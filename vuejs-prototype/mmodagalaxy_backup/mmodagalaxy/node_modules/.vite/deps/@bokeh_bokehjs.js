import "./chunk-RZNJG6VE.js";
import "./chunk-YOCUD4KP.js";
import "./chunk-K3GNAHK7.js";
import "./chunk-5DMLVHEF.js";
import "./chunk-UACPWR3H.js";
import "./chunk-UM25GOAD.js";
import "./chunk-4EIWIPC2.js";
import "./chunk-L5ZY3JC6.js";
import "./chunk-OF4ILSKF.js";
import "./chunk-FHV2DSGC.js";
import "./chunk-PAWQF2VP.js";
import "./chunk-XTBJCH7Z.js";
import "./chunk-AA4EBXVX.js";
import "./chunk-E2ECLAER.js";
import "./chunk-BOJUO2RS.js";
import {
  Align,
  AlternationPolicy,
  Anchor,
  AngleSpec,
  AngleUnits,
  Any,
  AnyRef,
  Arrayable,
  Auto,
  BYTE_ORDER,
  BaseCoordinateSpec,
  BitSet,
  Bool,
  BoxOrigin,
  Buffer,
  BuiltinFormatter,
  ButtonType,
  Bytes,
  CalendarPosition,
  Clock,
  Cloner,
  Color,
  ColorArray,
  ColorSpec,
  Comparator,
  ContextWhich,
  CoordinateSeqSeqSeqSpec,
  CoordinateSeqSpec,
  CoordinateSpec,
  CoordinateUnits,
  DataSpec,
  Dict,
  Dimension,
  Dimensions,
  Direction,
  DistanceSpec,
  Distribution,
  Enum,
  EqNotImplemented,
  Face,
  Fill,
  FillScalar,
  FillVector,
  Float,
  FlowMode,
  FontStyle,
  FontStyleSpec,
  GeneratorFunction,
  HAlign,
  HTTPMethod,
  Hatch,
  HatchPatternType,
  HatchScalar,
  HatchVector,
  HexTileOrientation,
  HoverMode,
  Image as Image2,
  ImageOrigin,
  ImageScalar,
  ImageVector,
  Int,
  Kind,
  LabelOrientation,
  LatLon,
  LegendClickPolicy,
  LegendLocation,
  Line,
  Line2,
  LinePolicy,
  LineScalar,
  LineScalar2,
  LineVector,
  LineVector2,
  List,
  Location,
  Logo,
  MapType,
  Mapping,
  MarkerSpec,
  MarkerType,
  MutedPolicy,
  NDArraySpec,
  NonNegative,
  Null,
  NullDistanceSpec,
  NullStringSpec,
  Nullable,
  NumberSpec,
  Opt,
  Or,
  Orientation,
  OutputBackend,
  PaddingUnits,
  PanDirection,
  PartialStruct,
  Percent,
  PointPolicy,
  PrimitiveProperty,
  Property,
  PropertyAlias,
  RGBAArray,
  RadiusDimension,
  Ref,
  Regex,
  RegionSelectionMode,
  RenderLevel,
  ResetPolicy,
  ResolutionType,
  RoundingFunction,
  ScalarSpec,
  ScreenArray,
  ScreenSizeSpec,
  ScrollbarPolicy,
  SelectionMode,
  Serializer,
  Signal,
  Signal0,
  Signalable,
  SimilarComparator,
  SizingMode,
  Sort,
  StartEnd,
  StepMode,
  Str,
  StringSpec,
  Struct,
  TapBehavior,
  TapGesture,
  Text,
  TextAlign,
  TextAlignSpec,
  TextBaseline,
  TextScalar,
  TextVector,
  TextureRepetition,
  ToolIcon,
  TooltipAttachment,
  Tuple,
  UniformScalar,
  UniformVector,
  UnitsSpec,
  Unknown,
  UpdateMode,
  VAlign,
  VectorSpec,
  VerticalAlign,
  VisualProperties,
  VisualUniforms,
  XCoordinateSeqSeqSeqSpec,
  XCoordinateSeqSpec,
  XCoordinateSpec,
  YCoordinateSeqSeqSeqSpec,
  YCoordinateSeqSpec,
  YCoordinateSpec,
  attrs_of,
  base64_to_buffer,
  clone as clone2,
  defer,
  diagnostics,
  enumerate,
  equals,
  flat_map,
  infer_type,
  interleave,
  isExpr,
  isField,
  isValue,
  isVectorized,
  is_NDArray,
  is_equal,
  is_ref,
  is_similar,
  is_structurally_equal,
  iterator_exports,
  join,
  kinds_exports,
  map as map2,
  max as max2,
  may_have_refs,
  ndarray,
  receivers_for_sender,
  serialize,
  settings,
  some as some2,
  swap,
  take,
  to_big_endian,
  to_screen,
  unset,
  wildcard
} from "./chunk-XNJJC3C4.js";
import "./chunk-SOVVRRFY.js";
import "./chunk-VBPJHA4C.js";
import "./chunk-PAH7BMFW.js";
import "./chunk-CSC5DGUD.js";
import "./chunk-TK2VIX64.js";
import {
  PI,
  _union,
  angle_between,
  argmax,
  argmin,
  argsort,
  assert,
  atan2,
  bin_counts,
  bisect_right,
  bisect_right_by,
  byte,
  clamp,
  clear,
  clone,
  color2css,
  color2hex,
  color2hexrgb,
  color2rgba,
  compute_angle,
  concat,
  contains,
  copy,
  css4_parse,
  cumsum,
  cycle,
  decode_rgba,
  dict,
  difference,
  elementwise,
  encode_rgba,
  entries,
  eval_poly,
  every,
  extend,
  factorial,
  filter,
  find,
  find_index,
  find_last,
  find_last_index,
  float,
  float32_epsilon,
  get_pattern,
  head,
  hermite,
  includes,
  index_of,
  inplace_map,
  interpolate,
  intersection,
  invert_angle,
  isArray,
  isArrayOf,
  isArrayable,
  isArrayableOf,
  isBasicObject,
  isBoolean,
  isDict,
  isFunction,
  isInteger,
  isIterable,
  isNumber,
  isObject,
  isPlainObject,
  isPrimitive,
  isString,
  isSymbol,
  isTypedArray,
  is_Floating,
  is_dark,
  is_defined,
  is_empty,
  is_empty2,
  is_nullish,
  is_undefined,
  keys,
  last,
  left_edge_index,
  linspace,
  log,
  logger,
  map,
  max,
  max_by,
  merge,
  min,
  min_by,
  minmax,
  minmax2,
  nth,
  pairwise,
  prepend,
  range,
  reduce,
  remove as remove2,
  remove_at,
  remove_by,
  repeat,
  resize,
  reversed,
  rgba2css,
  set_log_level,
  shuffle,
  size,
  some,
  sort_by,
  sorted_index,
  split,
  sqrt,
  sum,
  symmetric_difference,
  to_object,
  transparent,
  transpose,
  typed_entries,
  typed_keys,
  union,
  uniq,
  uniq_by,
  unreachable,
  unzip,
  values,
  version,
  zip
} from "./chunk-FHOMUG4O.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@bokeh/numbro/numbro.js
var require_numbro = __commonJS({
  "node_modules/@bokeh/numbro/numbro.js"(exports4, module2) {
    var numbro4;
    var VERSION2 = "1.6.2";
    var cultures = {};
    var languages = cultures;
    var currentCulture = "en-US";
    var zeroFormat = null;
    var defaultFormat = "0,0";
    var defaultCurrencyFormat = "0$";
    var hasModule = typeof module2 !== "undefined" && module2.exports;
    var enUS = {
      delimiters: {
        thousands: ",",
        decimal: "."
      },
      abbreviations: {
        thousand: "k",
        million: "m",
        billion: "b",
        trillion: "t"
      },
      ordinal: function(number2) {
        var b2 = number2 % 10;
        return ~~(number2 % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
      },
      currency: {
        symbol: "$",
        position: "prefix"
      },
      defaults: {
        currencyFormat: ",0000 a"
      },
      formats: {
        fourDigits: "0000 a",
        fullWithTwoDecimals: "$ ,0.00",
        fullWithTwoDecimalsNoCurrency: ",0.00"
      }
    };
    function Numbro4(number2) {
      this._value = number2;
    }
    function zeroes(count) {
      var i2, ret = "";
      for (i2 = 0; i2 < count; i2++) {
        ret += "0";
      }
      return ret;
    }
    function toFixedLarge(value2, precision) {
      var mantissa, beforeDec, afterDec, exponent, str;
      str = value2.toString();
      mantissa = str.split("e")[0];
      exponent = str.split("e")[1];
      beforeDec = mantissa.split(".")[0];
      afterDec = mantissa.split(".")[1] || "";
      str = beforeDec + afterDec + zeroes(exponent - afterDec.length);
      if (precision > 0) {
        str += "." + zeroes(precision);
      }
      return str;
    }
    function toFixed(value2, precision, roundingFunction, optionals) {
      var power = Math.pow(10, precision), optionalsRegExp, output2;
      if (value2.toFixed(0).search("e") > -1) {
        output2 = toFixedLarge(value2, precision);
      } else {
        output2 = (roundingFunction(value2 * power) / power).toFixed(precision);
      }
      if (optionals) {
        optionalsRegExp = new RegExp("0{1," + optionals + "}$");
        output2 = output2.replace(optionalsRegExp, "");
      }
      return output2;
    }
    function formatNumbro(value2, format8, roundingFunction) {
      var output2;
      if (format8.indexOf("$") > -1) {
        output2 = formatCurrency(value2, format8, roundingFunction);
      } else if (format8.indexOf("%") > -1) {
        output2 = formatPercentage(value2, format8, roundingFunction);
      } else if (format8.indexOf(":") > -1) {
        output2 = formatTime(value2);
      } else {
        output2 = formatNumber(value2, format8, roundingFunction);
      }
      return output2;
    }
    function formatCurrency(value2, originalFormat, roundingFunction) {
      var format8 = originalFormat, symbolIndex = format8.indexOf("$"), openParenIndex = format8.indexOf("("), plusSignIndex = format8.indexOf("+"), minusSignIndex = format8.indexOf("-"), space = "", decimalSeparator = "", spliceIndex, output2;
      if (format8.indexOf("$") === -1) {
        if (cultures[currentCulture].currency.position === "infix") {
          decimalSeparator = cultures[currentCulture].currency.symbol;
          if (cultures[currentCulture].currency.spaceSeparated) {
            decimalSeparator = " " + decimalSeparator + " ";
          }
        } else if (cultures[currentCulture].currency.spaceSeparated) {
          space = " ";
        }
      } else {
        if (format8.indexOf(" $") > -1) {
          space = " ";
          format8 = format8.replace(" $", "");
        } else if (format8.indexOf("$ ") > -1) {
          space = " ";
          format8 = format8.replace("$ ", "");
        } else {
          format8 = format8.replace("$", "");
        }
      }
      output2 = formatNumber(value2, format8, roundingFunction, decimalSeparator);
      if (originalFormat.indexOf("$") === -1) {
        switch (cultures[currentCulture].currency.position) {
          case "postfix":
            if (output2.indexOf(")") > -1) {
              output2 = output2.split("");
              output2.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
              output2 = output2.join("");
            } else {
              output2 = output2 + space + cultures[currentCulture].currency.symbol;
            }
            break;
          case "infix":
            break;
          case "prefix":
            if (output2.indexOf("(") > -1 || output2.indexOf("-") > -1) {
              output2 = output2.split("");
              spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;
              output2.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
              output2 = output2.join("");
            } else {
              output2 = cultures[currentCulture].currency.symbol + space + output2;
            }
            break;
          default:
            throw Error('Currency position should be among ["prefix", "infix", "postfix"]');
        }
      } else {
        if (symbolIndex <= 1) {
          if (output2.indexOf("(") > -1 || output2.indexOf("+") > -1 || output2.indexOf("-") > -1) {
            output2 = output2.split("");
            spliceIndex = 1;
            if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {
              spliceIndex = 0;
            }
            output2.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);
            output2 = output2.join("");
          } else {
            output2 = cultures[currentCulture].currency.symbol + space + output2;
          }
        } else {
          if (output2.indexOf(")") > -1) {
            output2 = output2.split("");
            output2.splice(-1, 0, space + cultures[currentCulture].currency.symbol);
            output2 = output2.join("");
          } else {
            output2 = output2 + space + cultures[currentCulture].currency.symbol;
          }
        }
      }
      return output2;
    }
    function formatPercentage(value2, format8, roundingFunction) {
      var space = "", output2;
      value2 = value2 * 100;
      if (format8.indexOf(" %") > -1) {
        space = " ";
        format8 = format8.replace(" %", "");
      } else {
        format8 = format8.replace("%", "");
      }
      output2 = formatNumber(value2, format8, roundingFunction);
      if (output2.indexOf(")") > -1) {
        output2 = output2.split("");
        output2.splice(-1, 0, space + "%");
        output2 = output2.join("");
      } else {
        output2 = output2 + space + "%";
      }
      return output2;
    }
    function formatTime(value2) {
      var hours = Math.floor(value2 / 60 / 60), minutes = Math.floor((value2 - hours * 60 * 60) / 60), seconds = Math.round(value2 - hours * 60 * 60 - minutes * 60);
      return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
    }
    function formatNumber(value2, format8, roundingFunction, sep) {
      var negP = false, signed = false, optDec = false, abbr2 = "", i2, abbrK = false, abbrM = false, abbrB = false, abbrT = false, abbrForce = false, bytes = "", ord = "", abs11 = Math.abs(value2), binarySuffixes = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], decimalSuffixes = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], min10, max18, power, totalLength, length, minimumPrecision, pow, w, intPrecision, precision, prefix, postfix, thousands, d = "", forcedNeg = false, neg = false, indexOpenP, size2, indexMinus, paren = "", minlen;
      if (value2 === 0 && zeroFormat !== null) {
        return zeroFormat;
      }
      if (!isFinite(value2)) {
        return "" + value2;
      }
      if (format8.indexOf("{") === 0) {
        var end = format8.indexOf("}");
        if (end === -1) {
          throw Error('Format should also contain a "}"');
        }
        prefix = format8.slice(1, end);
        format8 = format8.slice(end + 1);
      } else {
        prefix = "";
      }
      if (format8.indexOf("}") === format8.length - 1) {
        var start2 = format8.indexOf("{");
        if (start2 === -1) {
          throw Error('Format should also contain a "{"');
        }
        postfix = format8.slice(start2 + 1, -1);
        format8 = format8.slice(0, start2 + 1);
      } else {
        postfix = "";
      }
      var info;
      if (format8.indexOf(".") === -1) {
        info = format8.match(/([0-9]+).*/);
      } else {
        info = format8.match(/([0-9]+)\..*/);
      }
      minlen = info === null ? -1 : info[1].length;
      if (format8.indexOf("-") !== -1) {
        forcedNeg = true;
      }
      if (format8.indexOf("(") > -1) {
        negP = true;
        format8 = format8.slice(1, -1);
      } else if (format8.indexOf("+") > -1) {
        signed = true;
        format8 = format8.replace(/\+/g, "");
      }
      if (format8.indexOf("a") > -1) {
        intPrecision = format8.split(".")[0].match(/[0-9]+/g) || ["0"];
        intPrecision = parseInt(intPrecision[0], 10);
        abbrK = format8.indexOf("aK") >= 0;
        abbrM = format8.indexOf("aM") >= 0;
        abbrB = format8.indexOf("aB") >= 0;
        abbrT = format8.indexOf("aT") >= 0;
        abbrForce = abbrK || abbrM || abbrB || abbrT;
        if (format8.indexOf(" a") > -1) {
          abbr2 = " ";
          format8 = format8.replace(" a", "");
        } else {
          format8 = format8.replace("a", "");
        }
        totalLength = Math.floor(Math.log(abs11) / Math.LN10) + 1;
        minimumPrecision = totalLength % 3;
        minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;
        if (intPrecision && abs11 !== 0) {
          length = Math.floor(Math.log(abs11) / Math.LN10) + 1 - intPrecision;
          pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);
          abs11 = abs11 / Math.pow(10, pow);
          if (format8.indexOf(".") === -1 && intPrecision > 3) {
            format8 += "[.]";
            size2 = length === 0 ? 0 : 3 * ~~(length / 3) - length;
            size2 = size2 < 0 ? size2 + 3 : size2;
            for (i2 = 0; i2 < size2; i2++) {
              format8 += "0";
            }
          }
        }
        if (Math.floor(Math.log(Math.abs(value2)) / Math.LN10) + 1 !== intPrecision) {
          if (abs11 >= Math.pow(10, 12) && !abbrForce || abbrT) {
            abbr2 = abbr2 + cultures[currentCulture].abbreviations.trillion;
            value2 = value2 / Math.pow(10, 12);
          } else if (abs11 < Math.pow(10, 12) && abs11 >= Math.pow(10, 9) && !abbrForce || abbrB) {
            abbr2 = abbr2 + cultures[currentCulture].abbreviations.billion;
            value2 = value2 / Math.pow(10, 9);
          } else if (abs11 < Math.pow(10, 9) && abs11 >= Math.pow(10, 6) && !abbrForce || abbrM) {
            abbr2 = abbr2 + cultures[currentCulture].abbreviations.million;
            value2 = value2 / Math.pow(10, 6);
          } else if (abs11 < Math.pow(10, 6) && abs11 >= Math.pow(10, 3) && !abbrForce || abbrK) {
            abbr2 = abbr2 + cultures[currentCulture].abbreviations.thousand;
            value2 = value2 / Math.pow(10, 3);
          }
        }
      }
      if (format8.indexOf("b") > -1) {
        if (format8.indexOf(" b") > -1) {
          bytes = " ";
          format8 = format8.replace(" b", "");
        } else {
          format8 = format8.replace("b", "");
        }
        for (power = 0; power <= binarySuffixes.length; power++) {
          min10 = Math.pow(1024, power);
          max18 = Math.pow(1024, power + 1);
          if (value2 >= min10 && value2 < max18) {
            bytes = bytes + binarySuffixes[power];
            if (min10 > 0) {
              value2 = value2 / min10;
            }
            break;
          }
        }
      }
      if (format8.indexOf("d") > -1) {
        if (format8.indexOf(" d") > -1) {
          bytes = " ";
          format8 = format8.replace(" d", "");
        } else {
          format8 = format8.replace("d", "");
        }
        for (power = 0; power <= decimalSuffixes.length; power++) {
          min10 = Math.pow(1e3, power);
          max18 = Math.pow(1e3, power + 1);
          if (value2 >= min10 && value2 < max18) {
            bytes = bytes + decimalSuffixes[power];
            if (min10 > 0) {
              value2 = value2 / min10;
            }
            break;
          }
        }
      }
      if (format8.indexOf("o") > -1) {
        if (format8.indexOf(" o") > -1) {
          ord = " ";
          format8 = format8.replace(" o", "");
        } else {
          format8 = format8.replace("o", "");
        }
        if (cultures[currentCulture].ordinal) {
          ord = ord + cultures[currentCulture].ordinal(value2);
        }
      }
      if (format8.indexOf("[.]") > -1) {
        optDec = true;
        format8 = format8.replace("[.]", ".");
      }
      w = value2.toString().split(".")[0];
      precision = format8.split(".")[1];
      thousands = format8.indexOf(",");
      if (precision) {
        if (precision.indexOf("*") !== -1) {
          d = toFixed(value2, value2.toString().split(".")[1].length, roundingFunction);
        } else {
          if (precision.indexOf("[") > -1) {
            precision = precision.replace("]", "");
            precision = precision.split("[");
            d = toFixed(
              value2,
              precision[0].length + precision[1].length,
              roundingFunction,
              precision[1].length
            );
          } else {
            d = toFixed(value2, precision.length, roundingFunction);
          }
        }
        w = d.split(".")[0];
        if (d.split(".")[1].length) {
          var p2 = sep ? abbr2 + sep : cultures[currentCulture].delimiters.decimal;
          d = p2 + d.split(".")[1];
        } else {
          d = "";
        }
        if (optDec && Number(d.slice(1)) === 0) {
          d = "";
        }
      } else {
        w = toFixed(value2, null, roundingFunction);
      }
      if (w.indexOf("-") > -1) {
        w = w.slice(1);
        neg = true;
      }
      if (w.length < minlen) {
        w = new Array(minlen - w.length + 1).join("0") + w;
      }
      if (thousands > -1) {
        w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + cultures[currentCulture].delimiters.thousands);
      }
      if (format8.indexOf(".") === 0) {
        w = "";
      }
      indexOpenP = format8.indexOf("(");
      indexMinus = format8.indexOf("-");
      if (indexOpenP < indexMinus) {
        paren = (negP && neg ? "(" : "") + (forcedNeg && neg || !negP && neg ? "-" : "");
      } else {
        paren = (forcedNeg && neg || !negP && neg ? "-" : "") + (negP && neg ? "(" : "");
      }
      return prefix + paren + (!neg && signed && value2 !== 0 ? "+" : "") + w + d + (ord ? ord : "") + (abbr2 && !sep ? abbr2 : "") + (bytes ? bytes : "") + (negP && neg ? ")" : "") + postfix;
    }
    numbro4 = function(input12) {
      if (numbro4.isNumbro(input12)) {
        input12 = input12.value();
      } else if (input12 === 0 || typeof input12 === "undefined") {
        input12 = 0;
      } else if (!Number(input12)) {
        input12 = numbro4.fn.unformat(input12);
      }
      return new Numbro4(Number(input12));
    };
    numbro4.version = VERSION2;
    numbro4.isNumbro = function(obj) {
      return obj instanceof Numbro4;
    };
    numbro4.setLanguage = function(newLanguage, fallbackLanguage) {
      console.warn("`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead");
      var key = newLanguage, prefix = newLanguage.split("-")[0], matchingLanguage = null;
      if (!languages[key]) {
        Object.keys(languages).forEach(function(language) {
          if (!matchingLanguage && language.split("-")[0] === prefix) {
            matchingLanguage = language;
          }
        });
        key = matchingLanguage || fallbackLanguage || "en-US";
      }
      chooseCulture(key);
    };
    numbro4.setCulture = function(newCulture, fallbackCulture) {
      var key = newCulture, suffix = newCulture.split("-")[1], matchingCulture = null;
      if (!cultures[key]) {
        if (suffix) {
          Object.keys(cultures).forEach(function(language) {
            if (!matchingCulture && language.split("-")[1] === suffix) {
              matchingCulture = language;
            }
          });
        }
        key = matchingCulture || fallbackCulture || "en-US";
      }
      chooseCulture(key);
    };
    numbro4.language = function(key, values2) {
      console.warn("`language` is deprecated since version 1.6.0. Use `culture` instead");
      if (!key) {
        return currentCulture;
      }
      if (key && !values2) {
        if (!languages[key]) {
          throw new Error("Unknown language : " + key);
        }
        chooseCulture(key);
      }
      if (values2 || !languages[key]) {
        setCulture(key, values2);
      }
      return numbro4;
    };
    numbro4.culture = function(code2, values2) {
      if (!code2) {
        return currentCulture;
      }
      if (code2 && !values2) {
        if (!cultures[code2]) {
          throw new Error("Unknown culture : " + code2);
        }
        chooseCulture(code2);
      }
      if (values2 || !cultures[code2]) {
        setCulture(code2, values2);
      }
      return numbro4;
    };
    numbro4.languageData = function(key) {
      console.warn("`languageData` is deprecated since version 1.6.0. Use `cultureData` instead");
      if (!key) {
        return languages[currentCulture];
      }
      if (!languages[key]) {
        throw new Error("Unknown language : " + key);
      }
      return languages[key];
    };
    numbro4.cultureData = function(code2) {
      if (!code2) {
        return cultures[currentCulture];
      }
      if (!cultures[code2]) {
        throw new Error("Unknown culture : " + code2);
      }
      return cultures[code2];
    };
    numbro4.culture("en-US", enUS);
    numbro4.languages = function() {
      console.warn("`languages` is deprecated since version 1.6.0. Use `cultures` instead");
      return languages;
    };
    numbro4.cultures = function() {
      return cultures;
    };
    numbro4.zeroFormat = function(format8) {
      zeroFormat = typeof format8 === "string" ? format8 : null;
    };
    numbro4.defaultFormat = function(format8) {
      defaultFormat = typeof format8 === "string" ? format8 : "0.0";
    };
    numbro4.defaultCurrencyFormat = function(format8) {
      defaultCurrencyFormat = typeof format8 === "string" ? format8 : "0$";
    };
    numbro4.validate = function(val, culture) {
      var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp;
      if (typeof val !== "string") {
        val += "";
        if (console.warn) {
          console.warn("Numbro.js: Value is not string. It has been co-erced to: ", val);
        }
      }
      val = val.trim();
      if (!!val.match(/^\d+$/)) {
        return true;
      }
      if (val === "") {
        return false;
      }
      try {
        cultureData = numbro4.cultureData(culture);
      } catch (e) {
        cultureData = numbro4.cultureData(numbro4.culture());
      }
      _currSymbol = cultureData.currency.symbol;
      _abbrObj = cultureData.abbreviations;
      _decimalSep = cultureData.delimiters.decimal;
      if (cultureData.delimiters.thousands === ".") {
        _thousandSep = "\\.";
      } else {
        _thousandSep = cultureData.delimiters.thousands;
      }
      temp = val.match(/^[^\d]+/);
      if (temp !== null) {
        val = val.substr(1);
        if (temp[0] !== _currSymbol) {
          return false;
        }
      }
      temp = val.match(/[^\d]+$/);
      if (temp !== null) {
        val = val.slice(0, -1);
        if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
          return false;
        }
      }
      _thousandRegEx = new RegExp(_thousandSep + "{2}");
      if (!val.match(/[^\d.,]/g)) {
        _valArray = val.split(_decimalSep);
        if (_valArray.length > 2) {
          return false;
        } else {
          if (_valArray.length < 2) {
            return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
          } else {
            if (_valArray[0].length === 1) {
              return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
            } else {
              return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
            }
          }
        }
      }
      return false;
    };
    function setCulture(code2, values2) {
      cultures[code2] = values2;
    }
    function chooseCulture(code2) {
      currentCulture = code2;
      var defaults3 = cultures[code2].defaults;
      if (defaults3 && defaults3.format) {
        numbro4.defaultFormat(defaults3.format);
      }
      if (defaults3 && defaults3.currencyFormat) {
        numbro4.defaultCurrencyFormat(defaults3.currencyFormat);
      }
    }
    function format7(input12, formatString, language, roundingFunction) {
      if (language != null && language !== numbro4.culture()) {
        numbro4.setCulture(language);
      }
      return formatNumbro(
        Number(input12),
        formatString != null ? formatString : defaultFormat,
        roundingFunction == null ? Math.round : roundingFunction
      );
    }
    module2.exports = { "format": format7 };
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports4) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf2(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf2.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output2 = "", i2, k, ph2, pad2, pad_character, pad_length, is_positive, sign;
        for (i2 = 0; i2 < tree_length; i2++) {
          if (typeof parse_tree[i2] === "string") {
            output2 += parse_tree[i2];
          } else if (typeof parse_tree[i2] === "object") {
            ph2 = parse_tree[i2];
            if (ph2.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph2.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph2.keys[k], ph2.keys[k - 1]));
                }
                arg = arg[ph2.keys[k]];
              }
            } else if (ph2.param_no) {
              arg = argv[ph2.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph2.type) && re.not_primitive.test(ph2.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph2.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph2.type)) {
              is_positive = arg >= 0;
            }
            switch (ph2.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph2.width ? parseInt(ph2.width) : 0);
                break;
              case "e":
                arg = ph2.precision ? parseFloat(arg).toExponential(ph2.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph2.precision ? parseFloat(arg).toFixed(ph2.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph2.precision ? String(Number(arg.toPrecision(ph2.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph2.type)) {
              output2 += arg;
            } else {
              if (re.number.test(ph2.type) && (!is_positive || ph2.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph2.pad_char ? ph2.pad_char === "0" ? "0" : ph2.pad_char.charAt(1) : " ";
              pad_length = ph2.width - (sign + arg).length;
              pad2 = ph2.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output2 += ph2.align ? sign + arg + pad2 : pad_character === "0" ? sign + pad2 + arg : pad2 + sign + arg;
            }
          }
        }
        return output2;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match2, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match2 = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match2[0]);
          } else if ((match2 = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match2 = re.placeholder.exec(_fmt)) !== null) {
            if (match2[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match2[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match2[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match2[0],
                param_no: match2[1],
                keys: match2[2],
                sign: match2[3],
                pad_char: match2[4],
                align: match2[5],
                width: match2[6],
                precision: match2[7],
                type: match2[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match2[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports4 !== "undefined") {
        exports4["sprintf"] = sprintf2;
        exports4["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf2;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf2,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/timezone/index.js
var require_timezone = __commonJS({
  "node_modules/timezone/index.js"(exports4, module2) {
    !function(definition) {
      if (typeof module2 == "object" && module2.exports) module2.exports = definition();
      else if (typeof define == "function") define(definition);
      else this.tz = definition();
    }(function() {
      function actualize(entry2, rule, year) {
        var actualized, date = rule.day[1];
        do {
          actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));
        } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0]);
        actualized = {
          clock: rule.clock,
          sort: actualized.getTime(),
          rule,
          save: rule.save * 6e4,
          offset: entry2.offset
        };
        actualized[actualized.clock] = actualized.sort + rule.time * 6e4;
        if (actualized.posix) {
          actualized.wallclock = actualized[actualized.clock] + (entry2.offset + rule.saved);
        } else {
          actualized.posix = actualized[actualized.clock] - (entry2.offset + rule.saved);
        }
        return actualized;
      }
      function find2(request, clock, time2) {
        var i2, I, entry2, found, zone = request[request.zone], actualized = [], abbrev, rules, j, year = new Date(time2).getUTCFullYear(), off = 1;
        for (i2 = 1, I = zone.length; i2 < I; i2++) if (zone[i2][clock] <= time2) break;
        entry2 = zone[i2];
        if (entry2.rules) {
          rules = request[entry2.rules];
          for (j = year + 1; j >= year - off; --j)
            for (i2 = 0, I = rules.length; i2 < I; i2++)
              if (rules[i2].from <= j && j <= rules[i2].to) actualized.push(actualize(entry2, rules[i2], j));
              else if (rules[i2].to < j && off == 1) off = j - rules[i2].to;
          actualized.sort(function(a2, b2) {
            return a2.sort - b2.sort;
          });
          for (i2 = 0, I = actualized.length; i2 < I; i2++) {
            if (time2 >= actualized[i2][clock] && actualized[i2][actualized[i2].clock] > entry2[actualized[i2].clock]) found = actualized[i2];
          }
        }
        if (found) {
          if (abbrev = /^(.*)\/(.*)$/.exec(entry2.format)) {
            found.abbrev = abbrev[found.save ? 2 : 1];
          } else {
            found.abbrev = entry2.format.replace(/%s/, found.rule.letter);
          }
        }
        return found || entry2;
      }
      function convertToWallclock(request, posix) {
        if (request.zone == "UTC") return posix;
        request.entry = find2(request, "posix", posix);
        return posix + request.entry.offset + request.entry.save;
      }
      function convertToPOSIX(request, wallclock) {
        if (request.zone == "UTC") return wallclock;
        var entry2, diff;
        request.entry = entry2 = find2(request, "wallclock", wallclock);
        diff = wallclock - entry2.wallclock;
        return 0 < diff && diff < entry2.save ? null : wallclock - entry2.offset - entry2.save;
      }
      function adjust(request, posix, match2) {
        var increment = +(match2[1] + 1), offset3 = match2[2] * increment, index2 = UNITS.indexOf(match2[3].toLowerCase()), date;
        if (index2 > 9) {
          posix += offset3 * TIME[index2 - 10];
        } else {
          date = new Date(convertToWallclock(request, posix));
          if (index2 < 7) {
            while (offset3) {
              date.setUTCDate(date.getUTCDate() + increment);
              if (date.getUTCDay() == index2) offset3 -= increment;
            }
          } else if (index2 == 7) {
            date.setUTCFullYear(date.getUTCFullYear() + offset3);
          } else if (index2 == 8) {
            date.setUTCMonth(date.getUTCMonth() + offset3);
          } else {
            date.setUTCDate(date.getUTCDate() + offset3);
          }
          if ((posix = convertToPOSIX(request, date.getTime())) == null) {
            posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;
          }
        }
        return posix;
      }
      function convert(vargs) {
        if (!vargs.length) return "1.0.23";
        var request = Object.create(this), adjustments = [], i2, I, $2, argument, date;
        for (i2 = 0; i2 < vargs.length; i2++) {
          argument = vargs[i2];
          if (Array.isArray(argument)) {
            if (!i2 && !isNaN(argument[1])) {
              date = argument;
            } else {
              argument.splice.apply(vargs, [i2--, 1].concat(argument));
            }
          } else if (isNaN(argument)) {
            $2 = typeof argument;
            if ($2 == "string") {
              if (~argument.indexOf("%")) {
                request.format = argument;
              } else if (!i2 && argument == "*") {
                date = argument;
              } else if (!i2 && ($2 = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
                date = [];
                date.push.apply(date, $2.slice(1, 8));
                if ($2[9]) {
                  date.push($2[10] + 1);
                  date.push.apply(date, $2[11].split(/:/));
                } else if ($2[8]) {
                  date.push(1);
                }
              } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
                request.locale = argument;
              } else if ($2 = UNIT_RE.exec(argument)) {
                adjustments.push($2);
              } else {
                request.zone = argument;
              }
            } else if ($2 == "function") {
              if ($2 = argument.call(request)) return $2;
            } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
              request[argument.name] = argument;
            } else if (argument.zones) {
              for ($2 in argument.zones) request[$2] = argument.zones[$2];
              for ($2 in argument.rules) request[$2] = argument.rules[$2];
            }
          } else if (!i2) {
            date = argument;
          }
        }
        if (!request[request.locale]) delete request.locale;
        if (!request[request.zone]) delete request.zone;
        if (date != null) {
          if (date == "*") {
            date = request.clock();
          } else if (Array.isArray(date)) {
            $2 = [];
            I = !date[7];
            for (i2 = 0; i2 < 11; i2++) $2[i2] = +(date[i2] || 0);
            --$2[1];
            date = Date.UTC.apply(Date.UTC, $2) + -$2[7] * ($2[8] * 36e5 + $2[9] * 6e4 + $2[10] * 1e3);
          } else {
            date = Math.floor(date);
          }
          if (!isNaN(date)) {
            if (I) date = convertToPOSIX(request, date);
            if (date == null) return date;
            for (i2 = 0, I = adjustments.length; i2 < I; i2++) {
              date = adjust(request, date, adjustments[i2]);
            }
            if (!request.format) return date;
            $2 = new Date(convertToWallclock(request, date));
            return request.format.replace(
              /%([-0_^]?)(:{0,3})(\d*)(.)/g,
              function(value2, flag, colons, padding2, specifier) {
                var f2, fill = "0", pad2;
                if (f2 = request[specifier]) {
                  value2 = String(f2.call(request, $2, date, flag, colons.length));
                  if ((flag || f2.style) == "_") fill = " ";
                  pad2 = flag == "-" ? 0 : f2.pad || 0;
                  while (value2.length < pad2) value2 = fill + value2;
                  pad2 = flag == "-" ? 0 : padding2 || f2.pad;
                  while (value2.length < pad2) value2 = fill + value2;
                  if (specifier == "N" && pad2 < value2.length) value2 = value2.slice(0, pad2);
                  if (flag == "^") value2 = value2.toUpperCase();
                }
                return value2;
              }
            );
          }
        }
        return function() {
          return request.convert(arguments);
        };
      }
      var context = {
        clock: function() {
          return +/* @__PURE__ */ new Date();
        },
        zone: "UTC",
        entry: { abbrev: "UTC", offset: 0, save: 0 },
        UTC: 1,
        z: function(date, posix, flag, delimiters2) {
          var offset3 = this.entry.offset + this.entry.save, seconds = Math.abs(offset3 / 1e3), parts = [], part = 3600, i2, z;
          for (i2 = 0; i2 < 3; i2++) {
            parts.push(("0" + Math.floor(seconds / part)).slice(-2));
            seconds %= part;
            part /= 60;
          }
          if (flag == "^" && !offset3) return "Z";
          if (flag == "^") delimiters2 = 3;
          if (delimiters2 == 3) {
            z = parts.join(":");
            z = z.replace(/:00$/, "");
            if (flag != "^") z = z.replace(/:00$/, "");
          } else if (delimiters2) {
            z = parts.slice(0, delimiters2 + 1).join(":");
            if (flag == "^") z = z.replace(/:00$/, "");
          } else {
            z = parts.slice(0, 2).join("");
          }
          z = (offset3 < 0 ? "-" : "+") + z;
          z = z.replace(/([-+])(0)/, { "_": " $1", "-": "$1" }[flag] || "$1$2");
          return z;
        },
        "%": function(date) {
          return "%";
        },
        n: function(date) {
          return "\n";
        },
        t: function(date) {
          return "	";
        },
        U: function(date) {
          return weekOfYear(date, 0);
        },
        W: function(date) {
          return weekOfYear(date, 1);
        },
        V: function(date) {
          return isoWeek(date)[0];
        },
        G: function(date) {
          return isoWeek(date)[1];
        },
        g: function(date) {
          return isoWeek(date)[1] % 100;
        },
        j: function(date) {
          return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1;
        },
        s: function(date) {
          return Math.floor(date.getTime() / 1e3);
        },
        C: function(date) {
          return Math.floor(date.getUTCFullYear() / 100);
        },
        N: function(date) {
          return date.getTime() % 1e3 * 1e6;
        },
        m: function(date) {
          return date.getUTCMonth() + 1;
        },
        Y: function(date) {
          return date.getUTCFullYear();
        },
        y: function(date) {
          return date.getUTCFullYear() % 100;
        },
        H: function(date) {
          return date.getUTCHours();
        },
        M: function(date) {
          return date.getUTCMinutes();
        },
        S: function(date) {
          return date.getUTCSeconds();
        },
        e: function(date) {
          return date.getUTCDate();
        },
        d: function(date) {
          return date.getUTCDate();
        },
        u: function(date) {
          return date.getUTCDay() || 7;
        },
        w: function(date) {
          return date.getUTCDay();
        },
        l: function(date) {
          return date.getUTCHours() % 12 || 12;
        },
        I: function(date) {
          return date.getUTCHours() % 12 || 12;
        },
        k: function(date) {
          return date.getUTCHours();
        },
        Z: function(date) {
          return this.entry.abbrev;
        },
        a: function(date) {
          return this[this.locale].day.abbrev[date.getUTCDay()];
        },
        A: function(date) {
          return this[this.locale].day.full[date.getUTCDay()];
        },
        h: function(date) {
          return this[this.locale].month.abbrev[date.getUTCMonth()];
        },
        b: function(date) {
          return this[this.locale].month.abbrev[date.getUTCMonth()];
        },
        B: function(date) {
          return this[this.locale].month.full[date.getUTCMonth()];
        },
        P: function(date) {
          return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase();
        },
        p: function(date) {
          return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)];
        },
        R: function(date, posix) {
          return this.convert([posix, "%H:%M"]);
        },
        T: function(date, posix) {
          return this.convert([posix, "%H:%M:%S"]);
        },
        D: function(date, posix) {
          return this.convert([posix, "%m/%d/%y"]);
        },
        F: function(date, posix) {
          return this.convert([posix, "%Y-%m-%d"]);
        },
        x: function(date, posix) {
          return this.convert([posix, this[this.locale].date]);
        },
        r: function(date, posix) {
          return this.convert([posix, this[this.locale].time12 || "%I:%M:%S"]);
        },
        X: function(date, posix) {
          return this.convert([posix, this[this.locale].time24]);
        },
        c: function(date, posix) {
          return this.convert([posix, this[this.locale].dateTime]);
        },
        convert,
        locale: "en_US",
        en_US: {
          date: "%m/%d/%Y",
          time24: "%I:%M:%S %p",
          time12: "%I:%M:%S %p",
          dateTime: "%a %d %b %Y %I:%M:%S %p %Z",
          meridiem: ["AM", "PM"],
          month: {
            abbrev: "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec".split("|"),
            full: "January|February|March|April|May|June|July|August|September|October|November|December".split("|")
          },
          day: {
            abbrev: "Sun|Mon|Tue|Wed|Thu|Fri|Sat".split("|"),
            full: "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday".split("|")
          }
        }
      };
      var UNITS = "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond", UNIT_RE = new RegExp("^\\s*([+-])(\\d+)\\s+(" + UNITS + ")s?\\s*$", "i"), TIME = [36e5, 6e4, 1e3, 1];
      UNITS = UNITS.toLowerCase().split("|");
      "delmHMSUWVgCIky".replace(/./g, function(e) {
        context[e].pad = 2;
      });
      context.N.pad = 9;
      context.j.pad = 3;
      context.k.style = "_";
      context.l.style = "_";
      context.e.style = "_";
      function weekOfYear(date, startOfWeek) {
        var diff, nyd, weekStart;
        nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
        diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);
        if (nyd.getUTCDay() == startOfWeek) {
          weekStart = 0;
        } else {
          weekStart = 7 - nyd.getUTCDay() + startOfWeek;
          if (weekStart == 8) {
            weekStart = 1;
          }
        }
        return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
      }
      function isoWeek(date) {
        var nyd, nyy, week;
        nyy = date.getUTCFullYear();
        nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
        week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
        if (!week) {
          nyy = date.getUTCFullYear() - 1;
          nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
          week = nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29 ? 53 : 52;
          return [week, date.getUTCFullYear() - 1];
        } else if (week == 53 && !(nyd == 4 || nyd == 3 && new Date(nyy, 1, 29).getDate() == 29)) {
          return [1, date.getUTCFullYear() + 1];
        } else {
          return [week, date.getUTCFullYear()];
        }
      }
      return function() {
        return context.convert(arguments);
      };
    });
  }
});

// node_modules/choices.js/public/assets/scripts/choices.js
var require_choices = __commonJS({
  "node_modules/choices.js/public/assets/scripts/choices.js"(exports4, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports4 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports4 === "object")
        exports4["Choices"] = factory();
      else
        root["Choices"] = factory();
    })(window, function() {
      return (
        /******/
        function() {
          "use strict";
          var __webpack_modules__ = {
            /***/
            282: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.clearChoices = exports5.activateChoices = exports5.filterChoices = exports5.addChoice = void 0;
                var constants_1 = __webpack_require__2(883);
                var addChoice = function(_a34) {
                  var value2 = _a34.value, label3 = _a34.label, id = _a34.id, groupId = _a34.groupId, disabled5 = _a34.disabled, elementId = _a34.elementId, customProperties = _a34.customProperties, placeholder = _a34.placeholder, keyCode = _a34.keyCode;
                  return {
                    type: constants_1.ACTION_TYPES.ADD_CHOICE,
                    value: value2,
                    label: label3,
                    id,
                    groupId,
                    disabled: disabled5,
                    elementId,
                    customProperties,
                    placeholder,
                    keyCode
                  };
                };
                exports5.addChoice = addChoice;
                var filterChoices = function(results) {
                  return {
                    type: constants_1.ACTION_TYPES.FILTER_CHOICES,
                    results
                  };
                };
                exports5.filterChoices = filterChoices;
                var activateChoices = function(active8) {
                  if (active8 === void 0) {
                    active8 = true;
                  }
                  return {
                    type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
                    active: active8
                  };
                };
                exports5.activateChoices = activateChoices;
                var clearChoices = function() {
                  return {
                    type: constants_1.ACTION_TYPES.CLEAR_CHOICES
                  };
                };
                exports5.clearChoices = clearChoices;
              }
            ),
            /***/
            783: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.addGroup = void 0;
                var constants_1 = __webpack_require__2(883);
                var addGroup = function(_a34) {
                  var value2 = _a34.value, id = _a34.id, active8 = _a34.active, disabled5 = _a34.disabled;
                  return {
                    type: constants_1.ACTION_TYPES.ADD_GROUP,
                    value: value2,
                    id,
                    active: active8,
                    disabled: disabled5
                  };
                };
                exports5.addGroup = addGroup;
              }
            ),
            /***/
            464: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.highlightItem = exports5.removeItem = exports5.addItem = void 0;
                var constants_1 = __webpack_require__2(883);
                var addItem = function(_a34) {
                  var value2 = _a34.value, label3 = _a34.label, id = _a34.id, choiceId = _a34.choiceId, groupId = _a34.groupId, customProperties = _a34.customProperties, placeholder = _a34.placeholder, keyCode = _a34.keyCode;
                  return {
                    type: constants_1.ACTION_TYPES.ADD_ITEM,
                    value: value2,
                    label: label3,
                    id,
                    choiceId,
                    groupId,
                    customProperties,
                    placeholder,
                    keyCode
                  };
                };
                exports5.addItem = addItem;
                var removeItem = function(id, choiceId) {
                  return {
                    type: constants_1.ACTION_TYPES.REMOVE_ITEM,
                    id,
                    choiceId
                  };
                };
                exports5.removeItem = removeItem;
                var highlightItem = function(id, highlighted) {
                  return {
                    type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
                    id,
                    highlighted
                  };
                };
                exports5.highlightItem = highlightItem;
              }
            ),
            /***/
            137: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.setIsLoading = exports5.resetTo = exports5.clearAll = void 0;
                var constants_1 = __webpack_require__2(883);
                var clearAll = function() {
                  return {
                    type: constants_1.ACTION_TYPES.CLEAR_ALL
                  };
                };
                exports5.clearAll = clearAll;
                var resetTo = function(state) {
                  return {
                    type: constants_1.ACTION_TYPES.RESET_TO,
                    state
                  };
                };
                exports5.resetTo = resetTo;
                var setIsLoading = function(isLoading) {
                  return {
                    type: constants_1.ACTION_TYPES.SET_IS_LOADING,
                    isLoading
                  };
                };
                exports5.setIsLoading = setIsLoading;
              }
            ),
            /***/
            373: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
                    if (ar || !(i2 in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                      ar[i2] = from[i2];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var deepmerge_1 = __importDefault2(__webpack_require__2(996));
                var fuse_js_1 = __importDefault2(__webpack_require__2(221));
                var choices_1 = __webpack_require__2(282);
                var groups_1 = __webpack_require__2(783);
                var items_1 = __webpack_require__2(464);
                var misc_1 = __webpack_require__2(137);
                var components_1 = __webpack_require__2(520);
                var constants_1 = __webpack_require__2(883);
                var defaults_1 = __webpack_require__2(789);
                var utils_1 = __webpack_require__2(799);
                var reducers_1 = __webpack_require__2(655);
                var store_1 = __importDefault2(__webpack_require__2(744));
                var templates_1 = __importDefault2(__webpack_require__2(686));
                var IS_IE11 = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
                var USER_DEFAULTS = {};
                var Choices2 = (
                  /** @class */
                  function() {
                    function Choices3(element, userConfig) {
                      if (element === void 0) {
                        element = "[data-choice]";
                      }
                      if (userConfig === void 0) {
                        userConfig = {};
                      }
                      var _this = this;
                      if (userConfig.allowHTML === void 0) {
                        console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.");
                      }
                      this.config = deepmerge_1.default.all(
                        [defaults_1.DEFAULT_CONFIG, Choices3.defaults.options, userConfig],
                        // When merging array configs, replace with a copy of the userConfig array,
                        // instead of concatenating with the default array
                        {
                          arrayMerge: function(_2, sourceArray) {
                            return __spreadArray([], sourceArray, true);
                          }
                        }
                      );
                      var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
                      if (invalidConfigOptions.length) {
                        console.warn("Unknown config option(s) passed", invalidConfigOptions.join(", "));
                      }
                      var passedElement = typeof element === "string" ? document.querySelector(element) : element;
                      if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
                        throw TypeError("Expected one of the following types text|select-one|select-multiple");
                      }
                      this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
                      this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
                      this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
                      this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
                      this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
                      if (!["auto", "always"].includes("".concat(this.config.renderSelectedChoices))) {
                        this.config.renderSelectedChoices = "auto";
                      }
                      if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== "function") {
                        var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
                        this.config.addItemFilter = re.test.bind(re);
                      }
                      if (this._isTextElement) {
                        this.passedElement = new components_1.WrappedInput({
                          element: passedElement,
                          classNames: this.config.classNames,
                          delimiter: this.config.delimiter
                        });
                      } else {
                        this.passedElement = new components_1.WrappedSelect({
                          element: passedElement,
                          classNames: this.config.classNames,
                          template: function(data3) {
                            return _this._templates.option(data3);
                          }
                        });
                      }
                      this.initialised = false;
                      this._store = new store_1.default();
                      this._initialState = reducers_1.defaultState;
                      this._currentState = reducers_1.defaultState;
                      this._prevState = reducers_1.defaultState;
                      this._currentValue = "";
                      this._canSearch = !!this.config.searchEnabled;
                      this._isScrollingOnIe = false;
                      this._highlightPosition = 0;
                      this._wasTap = true;
                      this._placeholderValue = this._generatePlaceholderValue();
                      this._baseId = (0, utils_1.generateId)(this.passedElement.element, "choices-");
                      this._direction = this.passedElement.dir;
                      if (!this._direction) {
                        var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
                        var documentDirection = window.getComputedStyle(document.documentElement).direction;
                        if (elementDirection !== documentDirection) {
                          this._direction = elementDirection;
                        }
                      }
                      this._idNames = {
                        itemChoice: "item-choice"
                      };
                      if (this._isSelectElement) {
                        this._presetGroups = this.passedElement.optionGroups;
                        this._presetOptions = this.passedElement.options;
                      }
                      this._presetChoices = this.config.choices;
                      this._presetItems = this.config.items;
                      if (this.passedElement.value && this._isTextElement) {
                        var splitValues = this.passedElement.value.split(this.config.delimiter);
                        this._presetItems = this._presetItems.concat(splitValues);
                      }
                      if (this.passedElement.options) {
                        this.passedElement.options.forEach(function(option2) {
                          _this._presetChoices.push({
                            value: option2.value,
                            label: option2.innerHTML,
                            selected: !!option2.selected,
                            disabled: option2.disabled || option2.parentNode.disabled,
                            placeholder: option2.value === "" || option2.hasAttribute("placeholder"),
                            customProperties: (0, utils_1.parseCustomProperties)(option2.dataset.customProperties)
                          });
                        });
                      }
                      this._render = this._render.bind(this);
                      this._onFocus = this._onFocus.bind(this);
                      this._onBlur = this._onBlur.bind(this);
                      this._onKeyUp = this._onKeyUp.bind(this);
                      this._onKeyDown = this._onKeyDown.bind(this);
                      this._onClick = this._onClick.bind(this);
                      this._onTouchMove = this._onTouchMove.bind(this);
                      this._onTouchEnd = this._onTouchEnd.bind(this);
                      this._onMouseDown = this._onMouseDown.bind(this);
                      this._onMouseOver = this._onMouseOver.bind(this);
                      this._onFormReset = this._onFormReset.bind(this);
                      this._onSelectKey = this._onSelectKey.bind(this);
                      this._onEnterKey = this._onEnterKey.bind(this);
                      this._onEscapeKey = this._onEscapeKey.bind(this);
                      this._onDirectionKey = this._onDirectionKey.bind(this);
                      this._onDeleteKey = this._onDeleteKey.bind(this);
                      if (this.passedElement.isActive) {
                        if (!this.config.silent) {
                          console.warn("Trying to initialise Choices on element already initialised", {
                            element
                          });
                        }
                        this.initialised = true;
                        return;
                      }
                      this.init();
                    }
                    Object.defineProperty(Choices3, "defaults", {
                      get: function() {
                        return Object.preventExtensions({
                          get options() {
                            return USER_DEFAULTS;
                          },
                          get templates() {
                            return templates_1.default;
                          }
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Choices3.prototype.init = function() {
                      if (this.initialised) {
                        return;
                      }
                      this._createTemplates();
                      this._createElements();
                      this._createStructure();
                      this._store.subscribe(this._render);
                      this._render();
                      this._addEventListeners();
                      var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
                      if (shouldDisable) {
                        this.disable();
                      }
                      this.initialised = true;
                      var callbackOnInit = this.config.callbackOnInit;
                      if (callbackOnInit && typeof callbackOnInit === "function") {
                        callbackOnInit.call(this);
                      }
                    };
                    Choices3.prototype.destroy = function() {
                      if (!this.initialised) {
                        return;
                      }
                      this._removeEventListeners();
                      this.passedElement.reveal();
                      this.containerOuter.unwrap(this.passedElement.element);
                      this.clearStore();
                      if (this._isSelectElement) {
                        this.passedElement.options = this._presetOptions;
                      }
                      this._templates = templates_1.default;
                      this.initialised = false;
                    };
                    Choices3.prototype.enable = function() {
                      if (this.passedElement.isDisabled) {
                        this.passedElement.enable();
                      }
                      if (this.containerOuter.isDisabled) {
                        this._addEventListeners();
                        this.input.enable();
                        this.containerOuter.enable();
                      }
                      return this;
                    };
                    Choices3.prototype.disable = function() {
                      if (!this.passedElement.isDisabled) {
                        this.passedElement.disable();
                      }
                      if (!this.containerOuter.isDisabled) {
                        this._removeEventListeners();
                        this.input.disable();
                        this.containerOuter.disable();
                      }
                      return this;
                    };
                    Choices3.prototype.highlightItem = function(item3, runEvent) {
                      if (runEvent === void 0) {
                        runEvent = true;
                      }
                      if (!item3 || !item3.id) {
                        return this;
                      }
                      var id = item3.id, _a34 = item3.groupId, groupId = _a34 === void 0 ? -1 : _a34, _b4 = item3.value, value2 = _b4 === void 0 ? "" : _b4, _c = item3.label, label3 = _c === void 0 ? "" : _c;
                      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                      this._store.dispatch((0, items_1.highlightItem)(id, true));
                      if (runEvent) {
                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                          id,
                          value: value2,
                          label: label3,
                          groupValue: group && group.value ? group.value : null
                        });
                      }
                      return this;
                    };
                    Choices3.prototype.unhighlightItem = function(item3) {
                      if (!item3 || !item3.id) {
                        return this;
                      }
                      var id = item3.id, _a34 = item3.groupId, groupId = _a34 === void 0 ? -1 : _a34, _b4 = item3.value, value2 = _b4 === void 0 ? "" : _b4, _c = item3.label, label3 = _c === void 0 ? "" : _c;
                      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                      this._store.dispatch((0, items_1.highlightItem)(id, false));
                      this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                        id,
                        value: value2,
                        label: label3,
                        groupValue: group && group.value ? group.value : null
                      });
                      return this;
                    };
                    Choices3.prototype.highlightAll = function() {
                      var _this = this;
                      this._store.items.forEach(function(item3) {
                        return _this.highlightItem(item3);
                      });
                      return this;
                    };
                    Choices3.prototype.unhighlightAll = function() {
                      var _this = this;
                      this._store.items.forEach(function(item3) {
                        return _this.unhighlightItem(item3);
                      });
                      return this;
                    };
                    Choices3.prototype.removeActiveItemsByValue = function(value2) {
                      var _this = this;
                      this._store.activeItems.filter(function(item3) {
                        return item3.value === value2;
                      }).forEach(function(item3) {
                        return _this._removeItem(item3);
                      });
                      return this;
                    };
                    Choices3.prototype.removeActiveItems = function(excludedId) {
                      var _this = this;
                      this._store.activeItems.filter(function(_a34) {
                        var id = _a34.id;
                        return id !== excludedId;
                      }).forEach(function(item3) {
                        return _this._removeItem(item3);
                      });
                      return this;
                    };
                    Choices3.prototype.removeHighlightedItems = function(runEvent) {
                      var _this = this;
                      if (runEvent === void 0) {
                        runEvent = false;
                      }
                      this._store.highlightedActiveItems.forEach(function(item3) {
                        _this._removeItem(item3);
                        if (runEvent) {
                          _this._triggerChange(item3.value);
                        }
                      });
                      return this;
                    };
                    Choices3.prototype.showDropdown = function(preventInputFocus) {
                      var _this = this;
                      if (this.dropdown.isActive) {
                        return this;
                      }
                      requestAnimationFrame(function() {
                        _this.dropdown.show();
                        _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
                        if (!preventInputFocus && _this._canSearch) {
                          _this.input.focus();
                        }
                        _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
                      });
                      return this;
                    };
                    Choices3.prototype.hideDropdown = function(preventInputBlur) {
                      var _this = this;
                      if (!this.dropdown.isActive) {
                        return this;
                      }
                      requestAnimationFrame(function() {
                        _this.dropdown.hide();
                        _this.containerOuter.close();
                        if (!preventInputBlur && _this._canSearch) {
                          _this.input.removeActiveDescendant();
                          _this.input.blur();
                        }
                        _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
                      });
                      return this;
                    };
                    Choices3.prototype.getValue = function(valueOnly) {
                      if (valueOnly === void 0) {
                        valueOnly = false;
                      }
                      var values2 = this._store.activeItems.reduce(function(selectedItems, item3) {
                        var itemValue = valueOnly ? item3.value : item3;
                        selectedItems.push(itemValue);
                        return selectedItems;
                      }, []);
                      return this._isSelectOneElement ? values2[0] : values2;
                    };
                    Choices3.prototype.setValue = function(items) {
                      var _this = this;
                      if (!this.initialised) {
                        return this;
                      }
                      items.forEach(function(value2) {
                        return _this._setChoiceOrItem(value2);
                      });
                      return this;
                    };
                    Choices3.prototype.setChoiceByValue = function(value2) {
                      var _this = this;
                      if (!this.initialised || this._isTextElement) {
                        return this;
                      }
                      var choiceValue = Array.isArray(value2) ? value2 : [value2];
                      choiceValue.forEach(function(val) {
                        return _this._findAndSelectChoiceByValue(val);
                      });
                      return this;
                    };
                    Choices3.prototype.setChoices = function(choicesArrayOrFetcher, value2, label3, replaceChoices) {
                      var _this = this;
                      if (choicesArrayOrFetcher === void 0) {
                        choicesArrayOrFetcher = [];
                      }
                      if (value2 === void 0) {
                        value2 = "value";
                      }
                      if (label3 === void 0) {
                        label3 = "label";
                      }
                      if (replaceChoices === void 0) {
                        replaceChoices = false;
                      }
                      if (!this.initialised) {
                        throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
                      }
                      if (!this._isSelectElement) {
                        throw new TypeError("setChoices can't be used with INPUT based Choices");
                      }
                      if (typeof value2 !== "string" || !value2) {
                        throw new TypeError("value parameter must be a name of 'value' field in passed objects");
                      }
                      if (replaceChoices) {
                        this.clearChoices();
                      }
                      if (typeof choicesArrayOrFetcher === "function") {
                        var fetcher_1 = choicesArrayOrFetcher(this);
                        if (typeof Promise === "function" && fetcher_1 instanceof Promise) {
                          return new Promise(function(resolve) {
                            return requestAnimationFrame(resolve);
                          }).then(function() {
                            return _this._handleLoadingState(true);
                          }).then(function() {
                            return fetcher_1;
                          }).then(function(data3) {
                            return _this.setChoices(data3, value2, label3, replaceChoices);
                          }).catch(function(err) {
                            if (!_this.config.silent) {
                              console.error(err);
                            }
                          }).then(function() {
                            return _this._handleLoadingState(false);
                          }).then(function() {
                            return _this;
                          });
                        }
                        if (!Array.isArray(fetcher_1)) {
                          throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
                        }
                        return this.setChoices(fetcher_1, value2, label3, false);
                      }
                      if (!Array.isArray(choicesArrayOrFetcher)) {
                        throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
                      }
                      this.containerOuter.removeLoadingState();
                      this._startLoading();
                      choicesArrayOrFetcher.forEach(function(groupOrChoice) {
                        if (groupOrChoice.choices) {
                          _this._addGroup({
                            id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
                            group: groupOrChoice,
                            valueKey: value2,
                            labelKey: label3
                          });
                        } else {
                          var choice = groupOrChoice;
                          _this._addChoice({
                            value: choice[value2],
                            label: choice[label3],
                            isSelected: !!choice.selected,
                            isDisabled: !!choice.disabled,
                            placeholder: !!choice.placeholder,
                            customProperties: choice.customProperties
                          });
                        }
                      });
                      this._stopLoading();
                      return this;
                    };
                    Choices3.prototype.clearChoices = function() {
                      this._store.dispatch((0, choices_1.clearChoices)());
                      return this;
                    };
                    Choices3.prototype.clearStore = function() {
                      this._store.dispatch((0, misc_1.clearAll)());
                      return this;
                    };
                    Choices3.prototype.clearInput = function() {
                      var shouldSetInputWidth = !this._isSelectOneElement;
                      this.input.clear(shouldSetInputWidth);
                      if (!this._isTextElement && this._canSearch) {
                        this._isSearching = false;
                        this._store.dispatch((0, choices_1.activateChoices)(true));
                      }
                      return this;
                    };
                    Choices3.prototype._render = function() {
                      if (this._store.isLoading()) {
                        return;
                      }
                      this._currentState = this._store.state;
                      var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
                      var shouldRenderChoices = this._isSelectElement;
                      var shouldRenderItems = this._currentState.items !== this._prevState.items;
                      if (!stateChanged) {
                        return;
                      }
                      if (shouldRenderChoices) {
                        this._renderChoices();
                      }
                      if (shouldRenderItems) {
                        this._renderItems();
                      }
                      this._prevState = this._currentState;
                    };
                    Choices3.prototype._renderChoices = function() {
                      var _this = this;
                      var _a34 = this._store, activeGroups = _a34.activeGroups, activeChoices = _a34.activeChoices;
                      var choiceListFragment = document.createDocumentFragment();
                      this.choiceList.clear();
                      if (this.config.resetScrollPosition) {
                        requestAnimationFrame(function() {
                          return _this.choiceList.scrollToTop();
                        });
                      }
                      if (activeGroups.length >= 1 && !this._isSearching) {
                        var activePlaceholders = activeChoices.filter(function(activeChoice) {
                          return activeChoice.placeholder === true && activeChoice.groupId === -1;
                        });
                        if (activePlaceholders.length >= 1) {
                          choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                        }
                        choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
                      } else if (activeChoices.length >= 1) {
                        choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
                      }
                      if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
                        var activeItems = this._store.activeItems;
                        var canAddItem = this._canAddItem(activeItems, this.input.value);
                        if (canAddItem.response) {
                          this.choiceList.append(choiceListFragment);
                          this._highlightChoice();
                        } else {
                          var notice = this._getTemplate("notice", canAddItem.notice);
                          this.choiceList.append(notice);
                        }
                      } else {
                        var dropdownItem = void 0;
                        var notice = void 0;
                        if (this._isSearching) {
                          notice = typeof this.config.noResultsText === "function" ? this.config.noResultsText() : this.config.noResultsText;
                          dropdownItem = this._getTemplate("notice", notice, "no-results");
                        } else {
                          notice = typeof this.config.noChoicesText === "function" ? this.config.noChoicesText() : this.config.noChoicesText;
                          dropdownItem = this._getTemplate("notice", notice, "no-choices");
                        }
                        this.choiceList.append(dropdownItem);
                      }
                    };
                    Choices3.prototype._renderItems = function() {
                      var activeItems = this._store.activeItems || [];
                      this.itemList.clear();
                      var itemListFragment = this._createItemsFragment(activeItems);
                      if (itemListFragment.childNodes) {
                        this.itemList.append(itemListFragment);
                      }
                    };
                    Choices3.prototype._createGroupsFragment = function(groups, choices, fragment) {
                      var _this = this;
                      if (fragment === void 0) {
                        fragment = document.createDocumentFragment();
                      }
                      var getGroupChoices = function(group) {
                        return choices.filter(function(choice) {
                          if (_this._isSelectOneElement) {
                            return choice.groupId === group.id;
                          }
                          return choice.groupId === group.id && (_this.config.renderSelectedChoices === "always" || !choice.selected);
                        });
                      };
                      if (this.config.shouldSort) {
                        groups.sort(this.config.sorter);
                      }
                      groups.forEach(function(group) {
                        var groupChoices = getGroupChoices(group);
                        if (groupChoices.length >= 1) {
                          var dropdownGroup = _this._getTemplate("choiceGroup", group);
                          fragment.appendChild(dropdownGroup);
                          _this._createChoicesFragment(groupChoices, fragment, true);
                        }
                      });
                      return fragment;
                    };
                    Choices3.prototype._createChoicesFragment = function(choices, fragment, withinGroup) {
                      var _this = this;
                      if (fragment === void 0) {
                        fragment = document.createDocumentFragment();
                      }
                      if (withinGroup === void 0) {
                        withinGroup = false;
                      }
                      var _a34 = this.config, renderSelectedChoices = _a34.renderSelectedChoices, searchResultLimit = _a34.searchResultLimit, renderChoiceLimit = _a34.renderChoiceLimit;
                      var filter2 = this._isSearching ? utils_1.sortByScore : this.config.sorter;
                      var appendChoice = function(choice) {
                        var shouldRender = renderSelectedChoices === "auto" ? _this._isSelectOneElement || !choice.selected : true;
                        if (shouldRender) {
                          var dropdownItem = _this._getTemplate("choice", choice, _this.config.itemSelectText);
                          fragment.appendChild(dropdownItem);
                        }
                      };
                      var rendererableChoices = choices;
                      if (renderSelectedChoices === "auto" && !this._isSelectOneElement) {
                        rendererableChoices = choices.filter(function(choice) {
                          return !choice.selected;
                        });
                      }
                      var _b4 = rendererableChoices.reduce(function(acc, choice) {
                        if (choice.placeholder) {
                          acc.placeholderChoices.push(choice);
                        } else {
                          acc.normalChoices.push(choice);
                        }
                        return acc;
                      }, {
                        placeholderChoices: [],
                        normalChoices: []
                      }), placeholderChoices = _b4.placeholderChoices, normalChoices = _b4.normalChoices;
                      if (this.config.shouldSort || this._isSearching) {
                        normalChoices.sort(filter2);
                      }
                      var choiceLimit = rendererableChoices.length;
                      var sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;
                      if (this._isSearching) {
                        choiceLimit = searchResultLimit;
                      } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                        choiceLimit = renderChoiceLimit;
                      }
                      for (var i2 = 0; i2 < choiceLimit; i2 += 1) {
                        if (sortedChoices[i2]) {
                          appendChoice(sortedChoices[i2]);
                        }
                      }
                      return fragment;
                    };
                    Choices3.prototype._createItemsFragment = function(items, fragment) {
                      var _this = this;
                      if (fragment === void 0) {
                        fragment = document.createDocumentFragment();
                      }
                      var _a34 = this.config, shouldSortItems = _a34.shouldSortItems, sorter = _a34.sorter, removeItemButton = _a34.removeItemButton;
                      if (shouldSortItems && !this._isSelectOneElement) {
                        items.sort(sorter);
                      }
                      if (this._isTextElement) {
                        this.passedElement.value = items.map(function(_a35) {
                          var value2 = _a35.value;
                          return value2;
                        }).join(this.config.delimiter);
                      } else {
                        this.passedElement.options = items;
                      }
                      var addItemToFragment = function(item3) {
                        var listItem = _this._getTemplate("item", item3, removeItemButton);
                        fragment.appendChild(listItem);
                      };
                      items.forEach(addItemToFragment);
                      return fragment;
                    };
                    Choices3.prototype._triggerChange = function(value2) {
                      if (value2 === void 0 || value2 === null) {
                        return;
                      }
                      this.passedElement.triggerEvent(constants_1.EVENTS.change, {
                        value: value2
                      });
                    };
                    Choices3.prototype._selectPlaceholderChoice = function(placeholderChoice) {
                      this._addItem({
                        value: placeholderChoice.value,
                        label: placeholderChoice.label,
                        choiceId: placeholderChoice.id,
                        groupId: placeholderChoice.groupId,
                        placeholder: placeholderChoice.placeholder
                      });
                      this._triggerChange(placeholderChoice.value);
                    };
                    Choices3.prototype._handleButtonAction = function(activeItems, element) {
                      if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
                        return;
                      }
                      var itemId = element.parentNode && element.parentNode.dataset.id;
                      var itemToRemove = itemId && activeItems.find(function(item3) {
                        return item3.id === parseInt(itemId, 10);
                      });
                      if (!itemToRemove) {
                        return;
                      }
                      this._removeItem(itemToRemove);
                      this._triggerChange(itemToRemove.value);
                      if (this._isSelectOneElement && this._store.placeholderChoice) {
                        this._selectPlaceholderChoice(this._store.placeholderChoice);
                      }
                    };
                    Choices3.prototype._handleItemAction = function(activeItems, element, hasShiftKey) {
                      var _this = this;
                      if (hasShiftKey === void 0) {
                        hasShiftKey = false;
                      }
                      if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
                        return;
                      }
                      var passedId = element.dataset.id;
                      activeItems.forEach(function(item3) {
                        if (item3.id === parseInt("".concat(passedId), 10) && !item3.highlighted) {
                          _this.highlightItem(item3);
                        } else if (!hasShiftKey && item3.highlighted) {
                          _this.unhighlightItem(item3);
                        }
                      });
                      this.input.focus();
                    };
                    Choices3.prototype._handleChoiceAction = function(activeItems, element) {
                      if (!activeItems || !element) {
                        return;
                      }
                      var id = element.dataset.id;
                      var choice = id && this._store.getChoiceById(id);
                      if (!choice) {
                        return;
                      }
                      var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : void 0;
                      var hasActiveDropdown = this.dropdown.isActive;
                      choice.keyCode = passedKeyCode;
                      this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
                        choice
                      });
                      if (!choice.selected && !choice.disabled) {
                        var canAddItem = this._canAddItem(activeItems, choice.value);
                        if (canAddItem.response) {
                          this._addItem({
                            value: choice.value,
                            label: choice.label,
                            choiceId: choice.id,
                            groupId: choice.groupId,
                            customProperties: choice.customProperties,
                            placeholder: choice.placeholder,
                            keyCode: choice.keyCode
                          });
                          this._triggerChange(choice.value);
                        }
                      }
                      this.clearInput();
                      if (hasActiveDropdown && this._isSelectOneElement) {
                        this.hideDropdown(true);
                        this.containerOuter.focus();
                      }
                    };
                    Choices3.prototype._handleBackspace = function(activeItems) {
                      if (!this.config.removeItems || !activeItems) {
                        return;
                      }
                      var lastItem = activeItems[activeItems.length - 1];
                      var hasHighlightedItems = activeItems.some(function(item3) {
                        return item3.highlighted;
                      });
                      if (this.config.editItems && !hasHighlightedItems && lastItem) {
                        this.input.value = lastItem.value;
                        this.input.setWidth();
                        this._removeItem(lastItem);
                        this._triggerChange(lastItem.value);
                      } else {
                        if (!hasHighlightedItems) {
                          this.highlightItem(lastItem, false);
                        }
                        this.removeHighlightedItems(true);
                      }
                    };
                    Choices3.prototype._startLoading = function() {
                      this._store.dispatch((0, misc_1.setIsLoading)(true));
                    };
                    Choices3.prototype._stopLoading = function() {
                      this._store.dispatch((0, misc_1.setIsLoading)(false));
                    };
                    Choices3.prototype._handleLoadingState = function(setLoading) {
                      if (setLoading === void 0) {
                        setLoading = true;
                      }
                      var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
                      if (setLoading) {
                        this.disable();
                        this.containerOuter.addLoadingState();
                        if (this._isSelectOneElement) {
                          if (!placeholderItem) {
                            placeholderItem = this._getTemplate("placeholder", this.config.loadingText);
                            if (placeholderItem) {
                              this.itemList.append(placeholderItem);
                            }
                          } else {
                            placeholderItem.innerHTML = this.config.loadingText;
                          }
                        } else {
                          this.input.placeholder = this.config.loadingText;
                        }
                      } else {
                        this.enable();
                        this.containerOuter.removeLoadingState();
                        if (this._isSelectOneElement) {
                          if (placeholderItem) {
                            placeholderItem.innerHTML = this._placeholderValue || "";
                          }
                        } else {
                          this.input.placeholder = this._placeholderValue || "";
                        }
                      }
                    };
                    Choices3.prototype._handleSearch = function(value2) {
                      if (!this.input.isFocussed) {
                        return;
                      }
                      var choices = this._store.choices;
                      var _a34 = this.config, searchFloor = _a34.searchFloor, searchChoices = _a34.searchChoices;
                      var hasUnactiveChoices = choices.some(function(option2) {
                        return !option2.active;
                      });
                      if (value2 !== null && typeof value2 !== "undefined" && value2.length >= searchFloor) {
                        var resultCount = searchChoices ? this._searchChoices(value2) : 0;
                        this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                          value: value2,
                          resultCount
                        });
                      } else if (hasUnactiveChoices) {
                        this._isSearching = false;
                        this._store.dispatch((0, choices_1.activateChoices)(true));
                      }
                    };
                    Choices3.prototype._canAddItem = function(activeItems, value2) {
                      var canAddItem = true;
                      var notice = typeof this.config.addItemText === "function" ? this.config.addItemText(value2) : this.config.addItemText;
                      if (!this._isSelectOneElement) {
                        var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value2);
                        if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                          canAddItem = false;
                          notice = typeof this.config.maxItemText === "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
                        }
                        if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                          canAddItem = false;
                          notice = typeof this.config.uniqueItemText === "function" ? this.config.uniqueItemText(value2) : this.config.uniqueItemText;
                        }
                        if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === "function" && !this.config.addItemFilter(value2)) {
                          canAddItem = false;
                          notice = typeof this.config.customAddItemText === "function" ? this.config.customAddItemText(value2) : this.config.customAddItemText;
                        }
                      }
                      return {
                        response: canAddItem,
                        notice
                      };
                    };
                    Choices3.prototype._searchChoices = function(value2) {
                      var newValue = typeof value2 === "string" ? value2.trim() : value2;
                      var currentValue = typeof this._currentValue === "string" ? this._currentValue.trim() : this._currentValue;
                      if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
                        return 0;
                      }
                      var haystack = this._store.searchableChoices;
                      var needle = newValue;
                      var options2 = Object.assign(this.config.fuseOptions, {
                        keys: __spreadArray([], this.config.searchFields, true),
                        includeMatches: true
                      });
                      var fuse = new fuse_js_1.default(haystack, options2);
                      var results = fuse.search(needle);
                      this._currentValue = newValue;
                      this._highlightPosition = 0;
                      this._isSearching = true;
                      this._store.dispatch((0, choices_1.filterChoices)(results));
                      return results.length;
                    };
                    Choices3.prototype._addEventListeners = function() {
                      var documentElement = document.documentElement;
                      documentElement.addEventListener("touchend", this._onTouchEnd, true);
                      this.containerOuter.element.addEventListener("keydown", this._onKeyDown, true);
                      this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, true);
                      documentElement.addEventListener("click", this._onClick, {
                        passive: true
                      });
                      documentElement.addEventListener("touchmove", this._onTouchMove, {
                        passive: true
                      });
                      this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                        passive: true
                      });
                      if (this._isSelectOneElement) {
                        this.containerOuter.element.addEventListener("focus", this._onFocus, {
                          passive: true
                        });
                        this.containerOuter.element.addEventListener("blur", this._onBlur, {
                          passive: true
                        });
                      }
                      this.input.element.addEventListener("keyup", this._onKeyUp, {
                        passive: true
                      });
                      this.input.element.addEventListener("focus", this._onFocus, {
                        passive: true
                      });
                      this.input.element.addEventListener("blur", this._onBlur, {
                        passive: true
                      });
                      if (this.input.element.form) {
                        this.input.element.form.addEventListener("reset", this._onFormReset, {
                          passive: true
                        });
                      }
                      this.input.addEventListeners();
                    };
                    Choices3.prototype._removeEventListeners = function() {
                      var documentElement = document.documentElement;
                      documentElement.removeEventListener("touchend", this._onTouchEnd, true);
                      this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, true);
                      this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, true);
                      documentElement.removeEventListener("click", this._onClick);
                      documentElement.removeEventListener("touchmove", this._onTouchMove);
                      this.dropdown.element.removeEventListener("mouseover", this._onMouseOver);
                      if (this._isSelectOneElement) {
                        this.containerOuter.element.removeEventListener("focus", this._onFocus);
                        this.containerOuter.element.removeEventListener("blur", this._onBlur);
                      }
                      this.input.element.removeEventListener("keyup", this._onKeyUp);
                      this.input.element.removeEventListener("focus", this._onFocus);
                      this.input.element.removeEventListener("blur", this._onBlur);
                      if (this.input.element.form) {
                        this.input.element.form.removeEventListener("reset", this._onFormReset);
                      }
                      this.input.removeEventListeners();
                    };
                    Choices3.prototype._onKeyDown = function(event2) {
                      var keyCode = event2.keyCode;
                      var activeItems = this._store.activeItems;
                      var hasFocusedInput = this.input.isFocussed;
                      var hasActiveDropdown = this.dropdown.isActive;
                      var hasItems = this.itemList.hasChildren();
                      var keyString = String.fromCharCode(keyCode);
                      var wasPrintableChar = /[^\x00-\x1F]/.test(keyString);
                      var BACK_KEY = constants_1.KEY_CODES.BACK_KEY, DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY, ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY, A_KEY = constants_1.KEY_CODES.A_KEY, ESC_KEY = constants_1.KEY_CODES.ESC_KEY, UP_KEY = constants_1.KEY_CODES.UP_KEY, DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY, PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY, PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                      if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {
                        this.showDropdown();
                        if (!this.input.isFocussed) {
                          this.input.value += event2.key.toLowerCase();
                        }
                      }
                      switch (keyCode) {
                        case A_KEY:
                          return this._onSelectKey(event2, hasItems);
                        case ENTER_KEY:
                          return this._onEnterKey(event2, activeItems, hasActiveDropdown);
                        case ESC_KEY:
                          return this._onEscapeKey(hasActiveDropdown);
                        case UP_KEY:
                        case PAGE_UP_KEY:
                        case DOWN_KEY:
                        case PAGE_DOWN_KEY:
                          return this._onDirectionKey(event2, hasActiveDropdown);
                        case DELETE_KEY:
                        case BACK_KEY:
                          return this._onDeleteKey(event2, activeItems, hasFocusedInput);
                        default:
                      }
                    };
                    Choices3.prototype._onKeyUp = function(_a34) {
                      var target = _a34.target, keyCode = _a34.keyCode;
                      var value2 = this.input.value;
                      var activeItems = this._store.activeItems;
                      var canAddItem = this._canAddItem(activeItems, value2);
                      var backKey = constants_1.KEY_CODES.BACK_KEY, deleteKey = constants_1.KEY_CODES.DELETE_KEY;
                      if (this._isTextElement) {
                        var canShowDropdownNotice = canAddItem.notice && value2;
                        if (canShowDropdownNotice) {
                          var dropdownItem = this._getTemplate("notice", canAddItem.notice);
                          this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                          this.showDropdown(true);
                        } else {
                          this.hideDropdown(true);
                        }
                      } else {
                        var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
                        var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                        var canReactivateChoices = !this._isTextElement && this._isSearching;
                        var canSearch = this._canSearch && canAddItem.response;
                        if (userHasRemovedValue && canReactivateChoices) {
                          this._isSearching = false;
                          this._store.dispatch((0, choices_1.activateChoices)(true));
                        } else if (canSearch) {
                          this._handleSearch(this.input.rawValue);
                        }
                      }
                      this._canSearch = this.config.searchEnabled;
                    };
                    Choices3.prototype._onSelectKey = function(event2, hasItems) {
                      var ctrlKey = event2.ctrlKey, metaKey = event2.metaKey;
                      var hasCtrlDownKeyPressed = ctrlKey || metaKey;
                      if (hasCtrlDownKeyPressed && hasItems) {
                        this._canSearch = false;
                        var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                        if (shouldHightlightAll) {
                          this.highlightAll();
                        }
                      }
                    };
                    Choices3.prototype._onEnterKey = function(event2, activeItems, hasActiveDropdown) {
                      var target = event2.target;
                      var enterKey = constants_1.KEY_CODES.ENTER_KEY;
                      var targetWasButton = target && target.hasAttribute("data-button");
                      if (this._isTextElement && target && target.value) {
                        var value2 = this.input.value;
                        var canAddItem = this._canAddItem(activeItems, value2);
                        if (canAddItem.response) {
                          this.hideDropdown(true);
                          this._addItem({
                            value: value2
                          });
                          this._triggerChange(value2);
                          this.clearInput();
                        }
                      }
                      if (targetWasButton) {
                        this._handleButtonAction(activeItems, target);
                        event2.preventDefault();
                      }
                      if (hasActiveDropdown) {
                        var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                        if (highlightedChoice) {
                          if (activeItems[0]) {
                            activeItems[0].keyCode = enterKey;
                          }
                          this._handleChoiceAction(activeItems, highlightedChoice);
                        }
                        event2.preventDefault();
                      } else if (this._isSelectOneElement) {
                        this.showDropdown();
                        event2.preventDefault();
                      }
                    };
                    Choices3.prototype._onEscapeKey = function(hasActiveDropdown) {
                      if (hasActiveDropdown) {
                        this.hideDropdown(true);
                        this.containerOuter.focus();
                      }
                    };
                    Choices3.prototype._onDirectionKey = function(event2, hasActiveDropdown) {
                      var keyCode = event2.keyCode, metaKey = event2.metaKey;
                      var downKey = constants_1.KEY_CODES.DOWN_KEY, pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY, pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                      if (hasActiveDropdown || this._isSelectOneElement) {
                        this.showDropdown();
                        this._canSearch = false;
                        var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                        var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                        var selectableChoiceIdentifier = "[data-choice-selectable]";
                        var nextEl = void 0;
                        if (skipKey) {
                          if (directionInt > 0) {
                            nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                          } else {
                            nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                          }
                        } else {
                          var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                          if (currentEl) {
                            nextEl = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
                          } else {
                            nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                          }
                        }
                        if (nextEl) {
                          if (!(0, utils_1.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {
                            this.choiceList.scrollToChildElement(nextEl, directionInt);
                          }
                          this._highlightChoice(nextEl);
                        }
                        event2.preventDefault();
                      }
                    };
                    Choices3.prototype._onDeleteKey = function(event2, activeItems, hasFocusedInput) {
                      var target = event2.target;
                      if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
                        this._handleBackspace(activeItems);
                        event2.preventDefault();
                      }
                    };
                    Choices3.prototype._onTouchMove = function() {
                      if (this._wasTap) {
                        this._wasTap = false;
                      }
                    };
                    Choices3.prototype._onTouchEnd = function(event2) {
                      var target = (event2 || event2.touches[0]).target;
                      var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
                      if (touchWasWithinContainer) {
                        var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
                        if (containerWasExactTarget) {
                          if (this._isTextElement) {
                            this.input.focus();
                          } else if (this._isSelectMultipleElement) {
                            this.showDropdown();
                          }
                        }
                        event2.stopPropagation();
                      }
                      this._wasTap = true;
                    };
                    Choices3.prototype._onMouseDown = function(event2) {
                      var target = event2.target;
                      if (!(target instanceof HTMLElement)) {
                        return;
                      }
                      if (IS_IE11 && this.choiceList.element.contains(target)) {
                        var firstChoice = this.choiceList.element.firstElementChild;
                        var isOnScrollbar = this._direction === "ltr" ? event2.offsetX >= firstChoice.offsetWidth : event2.offsetX < firstChoice.offsetLeft;
                        this._isScrollingOnIe = isOnScrollbar;
                      }
                      if (target === this.input.element) {
                        return;
                      }
                      var item3 = target.closest("[data-button],[data-item],[data-choice]");
                      if (item3 instanceof HTMLElement) {
                        var hasShiftKey = event2.shiftKey;
                        var activeItems = this._store.activeItems;
                        var dataset = item3.dataset;
                        if ("button" in dataset) {
                          this._handleButtonAction(activeItems, item3);
                        } else if ("item" in dataset) {
                          this._handleItemAction(activeItems, item3, hasShiftKey);
                        } else if ("choice" in dataset) {
                          this._handleChoiceAction(activeItems, item3);
                        }
                      }
                      event2.preventDefault();
                    };
                    Choices3.prototype._onMouseOver = function(_a34) {
                      var target = _a34.target;
                      if (target instanceof HTMLElement && "choice" in target.dataset) {
                        this._highlightChoice(target);
                      }
                    };
                    Choices3.prototype._onClick = function(_a34) {
                      var target = _a34.target;
                      var clickWasWithinContainer = this.containerOuter.element.contains(target);
                      if (clickWasWithinContainer) {
                        if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                          if (this._isTextElement) {
                            if (document.activeElement !== this.input.element) {
                              this.input.focus();
                            }
                          } else {
                            this.showDropdown();
                            this.containerOuter.focus();
                          }
                        } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                          this.hideDropdown();
                        }
                      } else {
                        var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                        if (hasHighlightedItems) {
                          this.unhighlightAll();
                        }
                        this.containerOuter.removeFocusState();
                        this.hideDropdown(true);
                      }
                    };
                    Choices3.prototype._onFocus = function(_a34) {
                      var _b4;
                      var _this = this;
                      var target = _a34.target;
                      var focusWasWithinContainer = target && this.containerOuter.element.contains(target);
                      if (!focusWasWithinContainer) {
                        return;
                      }
                      var focusActions = (_b4 = {}, _b4[constants_1.TEXT_TYPE] = function() {
                        if (target === _this.input.element) {
                          _this.containerOuter.addFocusState();
                        }
                      }, _b4[constants_1.SELECT_ONE_TYPE] = function() {
                        _this.containerOuter.addFocusState();
                        if (target === _this.input.element) {
                          _this.showDropdown(true);
                        }
                      }, _b4[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                        if (target === _this.input.element) {
                          _this.showDropdown(true);
                          _this.containerOuter.addFocusState();
                        }
                      }, _b4);
                      focusActions[this.passedElement.element.type]();
                    };
                    Choices3.prototype._onBlur = function(_a34) {
                      var _b4;
                      var _this = this;
                      var target = _a34.target;
                      var blurWasWithinContainer = target && this.containerOuter.element.contains(target);
                      if (blurWasWithinContainer && !this._isScrollingOnIe) {
                        var activeItems = this._store.activeItems;
                        var hasHighlightedItems_1 = activeItems.some(function(item3) {
                          return item3.highlighted;
                        });
                        var blurActions = (_b4 = {}, _b4[constants_1.TEXT_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.containerOuter.removeFocusState();
                            if (hasHighlightedItems_1) {
                              _this.unhighlightAll();
                            }
                            _this.hideDropdown(true);
                          }
                        }, _b4[constants_1.SELECT_ONE_TYPE] = function() {
                          _this.containerOuter.removeFocusState();
                          if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
                            _this.hideDropdown(true);
                          }
                        }, _b4[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.containerOuter.removeFocusState();
                            _this.hideDropdown(true);
                            if (hasHighlightedItems_1) {
                              _this.unhighlightAll();
                            }
                          }
                        }, _b4);
                        blurActions[this.passedElement.element.type]();
                      } else {
                        this._isScrollingOnIe = false;
                        this.input.element.focus();
                      }
                    };
                    Choices3.prototype._onFormReset = function() {
                      this._store.dispatch((0, misc_1.resetTo)(this._initialState));
                    };
                    Choices3.prototype._highlightChoice = function(el) {
                      var _this = this;
                      if (el === void 0) {
                        el = null;
                      }
                      var choices = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
                      if (!choices.length) {
                        return;
                      }
                      var passedEl = el;
                      var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
                      highlightedChoices.forEach(function(choice) {
                        choice.classList.remove(_this.config.classNames.highlightedState);
                        choice.setAttribute("aria-selected", "false");
                      });
                      if (passedEl) {
                        this._highlightPosition = choices.indexOf(passedEl);
                      } else {
                        if (choices.length > this._highlightPosition) {
                          passedEl = choices[this._highlightPosition];
                        } else {
                          passedEl = choices[choices.length - 1];
                        }
                        if (!passedEl) {
                          passedEl = choices[0];
                        }
                      }
                      passedEl.classList.add(this.config.classNames.highlightedState);
                      passedEl.setAttribute("aria-selected", "true");
                      this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
                        el: passedEl
                      });
                      if (this.dropdown.isActive) {
                        this.input.setActiveDescendant(passedEl.id);
                        this.containerOuter.setActiveDescendant(passedEl.id);
                      }
                    };
                    Choices3.prototype._addItem = function(_a34) {
                      var value2 = _a34.value, _b4 = _a34.label, label3 = _b4 === void 0 ? null : _b4, _c = _a34.choiceId, choiceId = _c === void 0 ? -1 : _c, _d = _a34.groupId, groupId = _d === void 0 ? -1 : _d, _e = _a34.customProperties, customProperties = _e === void 0 ? {} : _e, _f = _a34.placeholder, placeholder = _f === void 0 ? false : _f, _g = _a34.keyCode, keyCode = _g === void 0 ? -1 : _g;
                      var passedValue = typeof value2 === "string" ? value2.trim() : value2;
                      var items = this._store.items;
                      var passedLabel = label3 || passedValue;
                      var passedOptionId = choiceId || -1;
                      var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                      var id = items ? items.length + 1 : 1;
                      if (this.config.prependValue) {
                        passedValue = this.config.prependValue + passedValue.toString();
                      }
                      if (this.config.appendValue) {
                        passedValue += this.config.appendValue.toString();
                      }
                      this._store.dispatch((0, items_1.addItem)({
                        value: passedValue,
                        label: passedLabel,
                        id,
                        choiceId: passedOptionId,
                        groupId,
                        customProperties,
                        placeholder,
                        keyCode
                      }));
                      if (this._isSelectOneElement) {
                        this.removeActiveItems(id);
                      }
                      this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
                        id,
                        value: passedValue,
                        label: passedLabel,
                        customProperties,
                        groupValue: group && group.value ? group.value : null,
                        keyCode
                      });
                    };
                    Choices3.prototype._removeItem = function(item3) {
                      var id = item3.id, value2 = item3.value, label3 = item3.label, customProperties = item3.customProperties, choiceId = item3.choiceId, groupId = item3.groupId;
                      var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
                      if (!id || !choiceId) {
                        return;
                      }
                      this._store.dispatch((0, items_1.removeItem)(id, choiceId));
                      this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
                        id,
                        value: value2,
                        label: label3,
                        customProperties,
                        groupValue: group && group.value ? group.value : null
                      });
                    };
                    Choices3.prototype._addChoice = function(_a34) {
                      var value2 = _a34.value, _b4 = _a34.label, label3 = _b4 === void 0 ? null : _b4, _c = _a34.isSelected, isSelected = _c === void 0 ? false : _c, _d = _a34.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a34.groupId, groupId = _e === void 0 ? -1 : _e, _f = _a34.customProperties, customProperties = _f === void 0 ? {} : _f, _g = _a34.placeholder, placeholder = _g === void 0 ? false : _g, _h = _a34.keyCode, keyCode = _h === void 0 ? -1 : _h;
                      if (typeof value2 === "undefined" || value2 === null) {
                        return;
                      }
                      var choices = this._store.choices;
                      var choiceLabel = label3 || value2;
                      var choiceId = choices ? choices.length + 1 : 1;
                      var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
                      this._store.dispatch((0, choices_1.addChoice)({
                        id: choiceId,
                        groupId,
                        elementId: choiceElementId,
                        value: value2,
                        label: choiceLabel,
                        disabled: isDisabled,
                        customProperties,
                        placeholder,
                        keyCode
                      }));
                      if (isSelected) {
                        this._addItem({
                          value: value2,
                          label: choiceLabel,
                          choiceId,
                          customProperties,
                          placeholder,
                          keyCode
                        });
                      }
                    };
                    Choices3.prototype._addGroup = function(_a34) {
                      var _this = this;
                      var group = _a34.group, id = _a34.id, _b4 = _a34.valueKey, valueKey = _b4 === void 0 ? "value" : _b4, _c = _a34.labelKey, labelKey = _c === void 0 ? "label" : _c;
                      var groupChoices = (0, utils_1.isType)("Object", group) ? group.choices : Array.from(group.getElementsByTagName("OPTION"));
                      var groupId = id || Math.floor((/* @__PURE__ */ new Date()).valueOf() * Math.random());
                      var isDisabled = group.disabled ? group.disabled : false;
                      if (groupChoices) {
                        this._store.dispatch((0, groups_1.addGroup)({
                          value: group.label,
                          id: groupId,
                          active: true,
                          disabled: isDisabled
                        }));
                        var addGroupChoices = function(choice) {
                          var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;
                          _this._addChoice({
                            value: choice[valueKey],
                            label: (0, utils_1.isType)("Object", choice) ? choice[labelKey] : choice.innerHTML,
                            isSelected: choice.selected,
                            isDisabled: isOptDisabled,
                            groupId,
                            customProperties: choice.customProperties,
                            placeholder: choice.placeholder
                          });
                        };
                        groupChoices.forEach(addGroupChoices);
                      } else {
                        this._store.dispatch((0, groups_1.addGroup)({
                          value: group.label,
                          id: group.id,
                          active: false,
                          disabled: group.disabled
                        }));
                      }
                    };
                    Choices3.prototype._getTemplate = function(template2) {
                      var _a34;
                      var args = [];
                      for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                      }
                      return (_a34 = this._templates[template2]).call.apply(_a34, __spreadArray([this, this.config], args, false));
                    };
                    Choices3.prototype._createTemplates = function() {
                      var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
                      var userTemplates = {};
                      if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === "function") {
                        userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
                      }
                      this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
                    };
                    Choices3.prototype._createElements = function() {
                      this.containerOuter = new components_1.Container({
                        element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                        classNames: this.config.classNames,
                        type: this.passedElement.element.type,
                        position: this.config.position
                      });
                      this.containerInner = new components_1.Container({
                        element: this._getTemplate("containerInner"),
                        classNames: this.config.classNames,
                        type: this.passedElement.element.type,
                        position: this.config.position
                      });
                      this.input = new components_1.Input({
                        element: this._getTemplate("input", this._placeholderValue),
                        classNames: this.config.classNames,
                        type: this.passedElement.element.type,
                        preventPaste: !this.config.paste
                      });
                      this.choiceList = new components_1.List({
                        element: this._getTemplate("choiceList", this._isSelectOneElement)
                      });
                      this.itemList = new components_1.List({
                        element: this._getTemplate("itemList", this._isSelectOneElement)
                      });
                      this.dropdown = new components_1.Dropdown({
                        element: this._getTemplate("dropdown"),
                        classNames: this.config.classNames,
                        type: this.passedElement.element.type
                      });
                    };
                    Choices3.prototype._createStructure = function() {
                      this.passedElement.conceal();
                      this.containerInner.wrap(this.passedElement.element);
                      this.containerOuter.wrap(this.containerInner.element);
                      if (this._isSelectOneElement) {
                        this.input.placeholder = this.config.searchPlaceholderValue || "";
                      } else if (this._placeholderValue) {
                        this.input.placeholder = this._placeholderValue;
                        this.input.setWidth();
                      }
                      this.containerOuter.element.appendChild(this.containerInner.element);
                      this.containerOuter.element.appendChild(this.dropdown.element);
                      this.containerInner.element.appendChild(this.itemList.element);
                      if (!this._isTextElement) {
                        this.dropdown.element.appendChild(this.choiceList.element);
                      }
                      if (!this._isSelectOneElement) {
                        this.containerInner.element.appendChild(this.input.element);
                      } else if (this.config.searchEnabled) {
                        this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                      }
                      if (this._isSelectElement) {
                        this._highlightPosition = 0;
                        this._isSearching = false;
                        this._startLoading();
                        if (this._presetGroups.length) {
                          this._addPredefinedGroups(this._presetGroups);
                        } else {
                          this._addPredefinedChoices(this._presetChoices);
                        }
                        this._stopLoading();
                      }
                      if (this._isTextElement) {
                        this._addPredefinedItems(this._presetItems);
                      }
                    };
                    Choices3.prototype._addPredefinedGroups = function(groups) {
                      var _this = this;
                      var placeholderChoice = this.passedElement.placeholderOption;
                      if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === "SELECT") {
                        this._addChoice({
                          value: placeholderChoice.value,
                          label: placeholderChoice.innerHTML,
                          isSelected: placeholderChoice.selected,
                          isDisabled: placeholderChoice.disabled,
                          placeholder: true
                        });
                      }
                      groups.forEach(function(group) {
                        return _this._addGroup({
                          group,
                          id: group.id || null
                        });
                      });
                    };
                    Choices3.prototype._addPredefinedChoices = function(choices) {
                      var _this = this;
                      if (this.config.shouldSort) {
                        choices.sort(this.config.sorter);
                      }
                      var hasSelectedChoice = choices.some(function(choice) {
                        return choice.selected;
                      });
                      var firstEnabledChoiceIndex = choices.findIndex(function(choice) {
                        return choice.disabled === void 0 || !choice.disabled;
                      });
                      choices.forEach(function(choice, index2) {
                        var _a34 = choice.value, value2 = _a34 === void 0 ? "" : _a34, label3 = choice.label, customProperties = choice.customProperties, placeholder = choice.placeholder;
                        if (_this._isSelectElement) {
                          if (choice.choices) {
                            _this._addGroup({
                              group: choice,
                              id: choice.id || null
                            });
                          } else {
                            var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index2 === firstEnabledChoiceIndex;
                            var isSelected = shouldPreselect ? true : choice.selected;
                            var isDisabled = choice.disabled;
                            _this._addChoice({
                              value: value2,
                              label: label3,
                              isSelected: !!isSelected,
                              isDisabled: !!isDisabled,
                              placeholder: !!placeholder,
                              customProperties
                            });
                          }
                        } else {
                          _this._addChoice({
                            value: value2,
                            label: label3,
                            isSelected: !!choice.selected,
                            isDisabled: !!choice.disabled,
                            placeholder: !!choice.placeholder,
                            customProperties
                          });
                        }
                      });
                    };
                    Choices3.prototype._addPredefinedItems = function(items) {
                      var _this = this;
                      items.forEach(function(item3) {
                        if (typeof item3 === "object" && item3.value) {
                          _this._addItem({
                            value: item3.value,
                            label: item3.label,
                            choiceId: item3.id,
                            customProperties: item3.customProperties,
                            placeholder: item3.placeholder
                          });
                        }
                        if (typeof item3 === "string") {
                          _this._addItem({
                            value: item3
                          });
                        }
                      });
                    };
                    Choices3.prototype._setChoiceOrItem = function(item3) {
                      var _this = this;
                      var itemType = (0, utils_1.getType)(item3).toLowerCase();
                      var handleType = {
                        object: function() {
                          if (!item3.value) {
                            return;
                          }
                          if (!_this._isTextElement) {
                            _this._addChoice({
                              value: item3.value,
                              label: item3.label,
                              isSelected: true,
                              isDisabled: false,
                              customProperties: item3.customProperties,
                              placeholder: item3.placeholder
                            });
                          } else {
                            _this._addItem({
                              value: item3.value,
                              label: item3.label,
                              choiceId: item3.id,
                              customProperties: item3.customProperties,
                              placeholder: item3.placeholder
                            });
                          }
                        },
                        string: function() {
                          if (!_this._isTextElement) {
                            _this._addChoice({
                              value: item3,
                              label: item3,
                              isSelected: true,
                              isDisabled: false
                            });
                          } else {
                            _this._addItem({
                              value: item3
                            });
                          }
                        }
                      };
                      handleType[itemType]();
                    };
                    Choices3.prototype._findAndSelectChoiceByValue = function(value2) {
                      var _this = this;
                      var choices = this._store.choices;
                      var foundChoice = choices.find(function(choice) {
                        return _this.config.valueComparer(choice.value, value2);
                      });
                      if (foundChoice && !foundChoice.selected) {
                        this._addItem({
                          value: foundChoice.value,
                          label: foundChoice.label,
                          choiceId: foundChoice.id,
                          groupId: foundChoice.groupId,
                          customProperties: foundChoice.customProperties,
                          placeholder: foundChoice.placeholder,
                          keyCode: foundChoice.keyCode
                        });
                      }
                    };
                    Choices3.prototype._generatePlaceholderValue = function() {
                      if (this._isSelectElement && this.passedElement.placeholderOption) {
                        var placeholderOption = this.passedElement.placeholderOption;
                        return placeholderOption ? placeholderOption.text : null;
                      }
                      var _a34 = this.config, placeholder = _a34.placeholder, placeholderValue = _a34.placeholderValue;
                      var dataset = this.passedElement.element.dataset;
                      if (placeholder) {
                        if (placeholderValue) {
                          return placeholderValue;
                        }
                        if (dataset.placeholder) {
                          return dataset.placeholder;
                        }
                      }
                      return null;
                    };
                    return Choices3;
                  }()
                );
                exports5["default"] = Choices2;
              }
            ),
            /***/
            613: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var utils_1 = __webpack_require__2(799);
                var constants_1 = __webpack_require__2(883);
                var Container2 = (
                  /** @class */
                  function() {
                    function Container3(_a34) {
                      var element = _a34.element, type = _a34.type, classNames = _a34.classNames, position2 = _a34.position;
                      this.element = element;
                      this.classNames = classNames;
                      this.type = type;
                      this.position = position2;
                      this.isOpen = false;
                      this.isFlipped = false;
                      this.isFocussed = false;
                      this.isDisabled = false;
                      this.isLoading = false;
                      this._onFocus = this._onFocus.bind(this);
                      this._onBlur = this._onBlur.bind(this);
                    }
                    Container3.prototype.addEventListeners = function() {
                      this.element.addEventListener("focus", this._onFocus);
                      this.element.addEventListener("blur", this._onBlur);
                    };
                    Container3.prototype.removeEventListeners = function() {
                      this.element.removeEventListener("focus", this._onFocus);
                      this.element.removeEventListener("blur", this._onBlur);
                    };
                    Container3.prototype.shouldFlip = function(dropdownPos) {
                      if (typeof dropdownPos !== "number") {
                        return false;
                      }
                      var shouldFlip = false;
                      if (this.position === "auto") {
                        shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
                      } else if (this.position === "top") {
                        shouldFlip = true;
                      }
                      return shouldFlip;
                    };
                    Container3.prototype.setActiveDescendant = function(activeDescendantID) {
                      this.element.setAttribute("aria-activedescendant", activeDescendantID);
                    };
                    Container3.prototype.removeActiveDescendant = function() {
                      this.element.removeAttribute("aria-activedescendant");
                    };
                    Container3.prototype.open = function(dropdownPos) {
                      this.element.classList.add(this.classNames.openState);
                      this.element.setAttribute("aria-expanded", "true");
                      this.isOpen = true;
                      if (this.shouldFlip(dropdownPos)) {
                        this.element.classList.add(this.classNames.flippedState);
                        this.isFlipped = true;
                      }
                    };
                    Container3.prototype.close = function() {
                      this.element.classList.remove(this.classNames.openState);
                      this.element.setAttribute("aria-expanded", "false");
                      this.removeActiveDescendant();
                      this.isOpen = false;
                      if (this.isFlipped) {
                        this.element.classList.remove(this.classNames.flippedState);
                        this.isFlipped = false;
                      }
                    };
                    Container3.prototype.focus = function() {
                      if (!this.isFocussed) {
                        this.element.focus();
                      }
                    };
                    Container3.prototype.addFocusState = function() {
                      this.element.classList.add(this.classNames.focusState);
                    };
                    Container3.prototype.removeFocusState = function() {
                      this.element.classList.remove(this.classNames.focusState);
                    };
                    Container3.prototype.enable = function() {
                      this.element.classList.remove(this.classNames.disabledState);
                      this.element.removeAttribute("aria-disabled");
                      if (this.type === constants_1.SELECT_ONE_TYPE) {
                        this.element.setAttribute("tabindex", "0");
                      }
                      this.isDisabled = false;
                    };
                    Container3.prototype.disable = function() {
                      this.element.classList.add(this.classNames.disabledState);
                      this.element.setAttribute("aria-disabled", "true");
                      if (this.type === constants_1.SELECT_ONE_TYPE) {
                        this.element.setAttribute("tabindex", "-1");
                      }
                      this.isDisabled = true;
                    };
                    Container3.prototype.wrap = function(element) {
                      (0, utils_1.wrap)(element, this.element);
                    };
                    Container3.prototype.unwrap = function(element) {
                      if (this.element.parentNode) {
                        this.element.parentNode.insertBefore(element, this.element);
                        this.element.parentNode.removeChild(this.element);
                      }
                    };
                    Container3.prototype.addLoadingState = function() {
                      this.element.classList.add(this.classNames.loadingState);
                      this.element.setAttribute("aria-busy", "true");
                      this.isLoading = true;
                    };
                    Container3.prototype.removeLoadingState = function() {
                      this.element.classList.remove(this.classNames.loadingState);
                      this.element.removeAttribute("aria-busy");
                      this.isLoading = false;
                    };
                    Container3.prototype._onFocus = function() {
                      this.isFocussed = true;
                    };
                    Container3.prototype._onBlur = function() {
                      this.isFocussed = false;
                    };
                    return Container3;
                  }()
                );
                exports5["default"] = Container2;
              }
            ),
            /***/
            217: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var Dropdown2 = (
                  /** @class */
                  function() {
                    function Dropdown3(_a34) {
                      var element = _a34.element, type = _a34.type, classNames = _a34.classNames;
                      this.element = element;
                      this.classNames = classNames;
                      this.type = type;
                      this.isActive = false;
                    }
                    Object.defineProperty(Dropdown3.prototype, "distanceFromTopWindow", {
                      /**
                       * Bottom position of dropdown in viewport coordinates
                       */
                      get: function() {
                        return this.element.getBoundingClientRect().bottom;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Dropdown3.prototype.getChild = function(selector) {
                      return this.element.querySelector(selector);
                    };
                    Dropdown3.prototype.show = function() {
                      this.element.classList.add(this.classNames.activeState);
                      this.element.setAttribute("aria-expanded", "true");
                      this.isActive = true;
                      return this;
                    };
                    Dropdown3.prototype.hide = function() {
                      this.element.classList.remove(this.classNames.activeState);
                      this.element.setAttribute("aria-expanded", "false");
                      this.isActive = false;
                      return this;
                    };
                    return Dropdown3;
                  }()
                );
                exports5["default"] = Dropdown2;
              }
            ),
            /***/
            520: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.WrappedSelect = exports5.WrappedInput = exports5.List = exports5.Input = exports5.Container = exports5.Dropdown = void 0;
                var dropdown_1 = __importDefault2(__webpack_require__2(217));
                exports5.Dropdown = dropdown_1.default;
                var container_1 = __importDefault2(__webpack_require__2(613));
                exports5.Container = container_1.default;
                var input_1 = __importDefault2(__webpack_require__2(11));
                exports5.Input = input_1.default;
                var list_1 = __importDefault2(__webpack_require__2(624));
                exports5.List = list_1.default;
                var wrapped_input_1 = __importDefault2(__webpack_require__2(541));
                exports5.WrappedInput = wrapped_input_1.default;
                var wrapped_select_1 = __importDefault2(__webpack_require__2(982));
                exports5.WrappedSelect = wrapped_select_1.default;
              }
            ),
            /***/
            11: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var utils_1 = __webpack_require__2(799);
                var constants_1 = __webpack_require__2(883);
                var Input = (
                  /** @class */
                  function() {
                    function Input2(_a34) {
                      var element = _a34.element, type = _a34.type, classNames = _a34.classNames, preventPaste = _a34.preventPaste;
                      this.element = element;
                      this.type = type;
                      this.classNames = classNames;
                      this.preventPaste = preventPaste;
                      this.isFocussed = this.element.isEqualNode(document.activeElement);
                      this.isDisabled = element.disabled;
                      this._onPaste = this._onPaste.bind(this);
                      this._onInput = this._onInput.bind(this);
                      this._onFocus = this._onFocus.bind(this);
                      this._onBlur = this._onBlur.bind(this);
                    }
                    Object.defineProperty(Input2.prototype, "placeholder", {
                      set: function(placeholder) {
                        this.element.placeholder = placeholder;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Input2.prototype, "value", {
                      get: function() {
                        return (0, utils_1.sanitise)(this.element.value);
                      },
                      set: function(value2) {
                        this.element.value = value2;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Input2.prototype, "rawValue", {
                      get: function() {
                        return this.element.value;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Input2.prototype.addEventListeners = function() {
                      this.element.addEventListener("paste", this._onPaste);
                      this.element.addEventListener("input", this._onInput, {
                        passive: true
                      });
                      this.element.addEventListener("focus", this._onFocus, {
                        passive: true
                      });
                      this.element.addEventListener("blur", this._onBlur, {
                        passive: true
                      });
                    };
                    Input2.prototype.removeEventListeners = function() {
                      this.element.removeEventListener("input", this._onInput);
                      this.element.removeEventListener("paste", this._onPaste);
                      this.element.removeEventListener("focus", this._onFocus);
                      this.element.removeEventListener("blur", this._onBlur);
                    };
                    Input2.prototype.enable = function() {
                      this.element.removeAttribute("disabled");
                      this.isDisabled = false;
                    };
                    Input2.prototype.disable = function() {
                      this.element.setAttribute("disabled", "");
                      this.isDisabled = true;
                    };
                    Input2.prototype.focus = function() {
                      if (!this.isFocussed) {
                        this.element.focus();
                      }
                    };
                    Input2.prototype.blur = function() {
                      if (this.isFocussed) {
                        this.element.blur();
                      }
                    };
                    Input2.prototype.clear = function(setWidth) {
                      if (setWidth === void 0) {
                        setWidth = true;
                      }
                      if (this.element.value) {
                        this.element.value = "";
                      }
                      if (setWidth) {
                        this.setWidth();
                      }
                      return this;
                    };
                    Input2.prototype.setWidth = function() {
                      var _a34 = this.element, style2 = _a34.style, value2 = _a34.value, placeholder = _a34.placeholder;
                      style2.minWidth = "".concat(placeholder.length + 1, "ch");
                      style2.width = "".concat(value2.length + 1, "ch");
                    };
                    Input2.prototype.setActiveDescendant = function(activeDescendantID) {
                      this.element.setAttribute("aria-activedescendant", activeDescendantID);
                    };
                    Input2.prototype.removeActiveDescendant = function() {
                      this.element.removeAttribute("aria-activedescendant");
                    };
                    Input2.prototype._onInput = function() {
                      if (this.type !== constants_1.SELECT_ONE_TYPE) {
                        this.setWidth();
                      }
                    };
                    Input2.prototype._onPaste = function(event2) {
                      if (this.preventPaste) {
                        event2.preventDefault();
                      }
                    };
                    Input2.prototype._onFocus = function() {
                      this.isFocussed = true;
                    };
                    Input2.prototype._onBlur = function() {
                      this.isFocussed = false;
                    };
                    return Input2;
                  }()
                );
                exports5["default"] = Input;
              }
            ),
            /***/
            624: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var constants_1 = __webpack_require__2(883);
                var List2 = (
                  /** @class */
                  function() {
                    function List3(_a34) {
                      var element = _a34.element;
                      this.element = element;
                      this.scrollPos = this.element.scrollTop;
                      this.height = this.element.offsetHeight;
                    }
                    List3.prototype.clear = function() {
                      this.element.innerHTML = "";
                    };
                    List3.prototype.append = function(node) {
                      this.element.appendChild(node);
                    };
                    List3.prototype.getChild = function(selector) {
                      return this.element.querySelector(selector);
                    };
                    List3.prototype.hasChildren = function() {
                      return this.element.hasChildNodes();
                    };
                    List3.prototype.scrollToTop = function() {
                      this.element.scrollTop = 0;
                    };
                    List3.prototype.scrollToChildElement = function(element, direction) {
                      var _this = this;
                      if (!element) {
                        return;
                      }
                      var listHeight = this.element.offsetHeight;
                      var listScrollPosition = this.element.scrollTop + listHeight;
                      var elementHeight = element.offsetHeight;
                      var elementPos = element.offsetTop + elementHeight;
                      var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
                      requestAnimationFrame(function() {
                        _this._animateScroll(destination, direction);
                      });
                    };
                    List3.prototype._scrollDown = function(scrollPos, strength, destination) {
                      var easing = (destination - scrollPos) / strength;
                      var distance = easing > 1 ? easing : 1;
                      this.element.scrollTop = scrollPos + distance;
                    };
                    List3.prototype._scrollUp = function(scrollPos, strength, destination) {
                      var easing = (scrollPos - destination) / strength;
                      var distance = easing > 1 ? easing : 1;
                      this.element.scrollTop = scrollPos - distance;
                    };
                    List3.prototype._animateScroll = function(destination, direction) {
                      var _this = this;
                      var strength = constants_1.SCROLLING_SPEED;
                      var choiceListScrollTop = this.element.scrollTop;
                      var continueAnimation = false;
                      if (direction > 0) {
                        this._scrollDown(choiceListScrollTop, strength, destination);
                        if (choiceListScrollTop < destination) {
                          continueAnimation = true;
                        }
                      } else {
                        this._scrollUp(choiceListScrollTop, strength, destination);
                        if (choiceListScrollTop > destination) {
                          continueAnimation = true;
                        }
                      }
                      if (continueAnimation) {
                        requestAnimationFrame(function() {
                          _this._animateScroll(destination, direction);
                        });
                      }
                    };
                    return List3;
                  }()
                );
                exports5["default"] = List2;
              }
            ),
            /***/
            730: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var utils_1 = __webpack_require__2(799);
                var WrappedElement = (
                  /** @class */
                  function() {
                    function WrappedElement2(_a34) {
                      var element = _a34.element, classNames = _a34.classNames;
                      this.element = element;
                      this.classNames = classNames;
                      if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
                        throw new TypeError("Invalid element passed");
                      }
                      this.isDisabled = false;
                    }
                    Object.defineProperty(WrappedElement2.prototype, "isActive", {
                      get: function() {
                        return this.element.dataset.choice === "active";
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(WrappedElement2.prototype, "dir", {
                      get: function() {
                        return this.element.dir;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(WrappedElement2.prototype, "value", {
                      get: function() {
                        return this.element.value;
                      },
                      set: function(value2) {
                        this.element.value = value2;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    WrappedElement2.prototype.conceal = function() {
                      this.element.classList.add(this.classNames.input);
                      this.element.hidden = true;
                      this.element.tabIndex = -1;
                      var origStyle = this.element.getAttribute("style");
                      if (origStyle) {
                        this.element.setAttribute("data-choice-orig-style", origStyle);
                      }
                      this.element.setAttribute("data-choice", "active");
                    };
                    WrappedElement2.prototype.reveal = function() {
                      this.element.classList.remove(this.classNames.input);
                      this.element.hidden = false;
                      this.element.removeAttribute("tabindex");
                      var origStyle = this.element.getAttribute("data-choice-orig-style");
                      if (origStyle) {
                        this.element.removeAttribute("data-choice-orig-style");
                        this.element.setAttribute("style", origStyle);
                      } else {
                        this.element.removeAttribute("style");
                      }
                      this.element.removeAttribute("data-choice");
                      this.element.value = this.element.value;
                    };
                    WrappedElement2.prototype.enable = function() {
                      this.element.removeAttribute("disabled");
                      this.element.disabled = false;
                      this.isDisabled = false;
                    };
                    WrappedElement2.prototype.disable = function() {
                      this.element.setAttribute("disabled", "");
                      this.element.disabled = true;
                      this.isDisabled = true;
                    };
                    WrappedElement2.prototype.triggerEvent = function(eventType, data3) {
                      (0, utils_1.dispatchEvent)(this.element, eventType, data3);
                    };
                    return WrappedElement2;
                  }()
                );
                exports5["default"] = WrappedElement;
              }
            ),
            /***/
            541: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                  var extendStatics2 = function(d, b2) {
                    extendStatics2 = Object.setPrototypeOf || {
                      __proto__: []
                    } instanceof Array && function(d2, b3) {
                      d2.__proto__ = b3;
                    } || function(d2, b3) {
                      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d2[p2] = b3[p2];
                    };
                    return extendStatics2(d, b2);
                  };
                  return function(d, b2) {
                    if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                    extendStatics2(d, b2);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                  };
                }();
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var wrapped_element_1 = __importDefault2(__webpack_require__2(730));
                var WrappedInput = (
                  /** @class */
                  function(_super) {
                    __extends2(WrappedInput2, _super);
                    function WrappedInput2(_a34) {
                      var element = _a34.element, classNames = _a34.classNames, delimiter = _a34.delimiter;
                      var _this = _super.call(this, {
                        element,
                        classNames
                      }) || this;
                      _this.delimiter = delimiter;
                      return _this;
                    }
                    Object.defineProperty(WrappedInput2.prototype, "value", {
                      get: function() {
                        return this.element.value;
                      },
                      set: function(value2) {
                        this.element.setAttribute("value", value2);
                        this.element.value = value2;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    return WrappedInput2;
                  }(wrapped_element_1.default)
                );
                exports5["default"] = WrappedInput;
              }
            ),
            /***/
            982: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                  var extendStatics2 = function(d, b2) {
                    extendStatics2 = Object.setPrototypeOf || {
                      __proto__: []
                    } instanceof Array && function(d2, b3) {
                      d2.__proto__ = b3;
                    } || function(d2, b3) {
                      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d2[p2] = b3[p2];
                    };
                    return extendStatics2(d, b2);
                  };
                  return function(d, b2) {
                    if (typeof b2 !== "function" && b2 !== null) throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                    extendStatics2(d, b2);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                  };
                }();
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var wrapped_element_1 = __importDefault2(__webpack_require__2(730));
                var WrappedSelect = (
                  /** @class */
                  function(_super) {
                    __extends2(WrappedSelect2, _super);
                    function WrappedSelect2(_a34) {
                      var element = _a34.element, classNames = _a34.classNames, template2 = _a34.template;
                      var _this = _super.call(this, {
                        element,
                        classNames
                      }) || this;
                      _this.template = template2;
                      return _this;
                    }
                    Object.defineProperty(WrappedSelect2.prototype, "placeholderOption", {
                      get: function() {
                        return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                        this.element.querySelector("option[placeholder]");
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(WrappedSelect2.prototype, "optionGroups", {
                      get: function() {
                        return Array.from(this.element.getElementsByTagName("OPTGROUP"));
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(WrappedSelect2.prototype, "options", {
                      get: function() {
                        return Array.from(this.element.options);
                      },
                      set: function(options2) {
                        var _this = this;
                        var fragment = document.createDocumentFragment();
                        var addOptionToFragment = function(data3) {
                          var option2 = _this.template(data3);
                          fragment.appendChild(option2);
                        };
                        options2.forEach(function(optionData) {
                          return addOptionToFragment(optionData);
                        });
                        this.appendDocFragment(fragment);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    WrappedSelect2.prototype.appendDocFragment = function(fragment) {
                      this.element.innerHTML = "";
                      this.element.appendChild(fragment);
                    };
                    return WrappedSelect2;
                  }(wrapped_element_1.default)
                );
                exports5["default"] = WrappedSelect;
              }
            ),
            /***/
            883: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.SCROLLING_SPEED = exports5.SELECT_MULTIPLE_TYPE = exports5.SELECT_ONE_TYPE = exports5.TEXT_TYPE = exports5.KEY_CODES = exports5.ACTION_TYPES = exports5.EVENTS = void 0;
                exports5.EVENTS = {
                  showDropdown: "showDropdown",
                  hideDropdown: "hideDropdown",
                  change: "change",
                  choice: "choice",
                  search: "search",
                  addItem: "addItem",
                  removeItem: "removeItem",
                  highlightItem: "highlightItem",
                  highlightChoice: "highlightChoice",
                  unhighlightItem: "unhighlightItem"
                };
                exports5.ACTION_TYPES = {
                  ADD_CHOICE: "ADD_CHOICE",
                  FILTER_CHOICES: "FILTER_CHOICES",
                  ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
                  CLEAR_CHOICES: "CLEAR_CHOICES",
                  ADD_GROUP: "ADD_GROUP",
                  ADD_ITEM: "ADD_ITEM",
                  REMOVE_ITEM: "REMOVE_ITEM",
                  HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
                  CLEAR_ALL: "CLEAR_ALL",
                  RESET_TO: "RESET_TO",
                  SET_IS_LOADING: "SET_IS_LOADING"
                };
                exports5.KEY_CODES = {
                  BACK_KEY: 46,
                  DELETE_KEY: 8,
                  ENTER_KEY: 13,
                  A_KEY: 65,
                  ESC_KEY: 27,
                  UP_KEY: 38,
                  DOWN_KEY: 40,
                  PAGE_UP_KEY: 33,
                  PAGE_DOWN_KEY: 34
                };
                exports5.TEXT_TYPE = "text";
                exports5.SELECT_ONE_TYPE = "select-one";
                exports5.SELECT_MULTIPLE_TYPE = "select-multiple";
                exports5.SCROLLING_SPEED = 4;
              }
            ),
            /***/
            789: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.DEFAULT_CONFIG = exports5.DEFAULT_CLASSNAMES = void 0;
                var utils_1 = __webpack_require__2(799);
                exports5.DEFAULT_CLASSNAMES = {
                  containerOuter: "choices",
                  containerInner: "choices__inner",
                  input: "choices__input",
                  inputCloned: "choices__input--cloned",
                  list: "choices__list",
                  listItems: "choices__list--multiple",
                  listSingle: "choices__list--single",
                  listDropdown: "choices__list--dropdown",
                  item: "choices__item",
                  itemSelectable: "choices__item--selectable",
                  itemDisabled: "choices__item--disabled",
                  itemChoice: "choices__item--choice",
                  placeholder: "choices__placeholder",
                  group: "choices__group",
                  groupHeading: "choices__heading",
                  button: "choices__button",
                  activeState: "is-active",
                  focusState: "is-focused",
                  openState: "is-open",
                  disabledState: "is-disabled",
                  highlightedState: "is-highlighted",
                  selectedState: "is-selected",
                  flippedState: "is-flipped",
                  loadingState: "is-loading",
                  noResults: "has-no-results",
                  noChoices: "has-no-choices"
                };
                exports5.DEFAULT_CONFIG = {
                  items: [],
                  choices: [],
                  silent: false,
                  renderChoiceLimit: -1,
                  maxItemCount: -1,
                  addItems: true,
                  addItemFilter: null,
                  removeItems: true,
                  removeItemButton: false,
                  editItems: false,
                  allowHTML: true,
                  duplicateItemsAllowed: true,
                  delimiter: ",",
                  paste: true,
                  searchEnabled: true,
                  searchChoices: true,
                  searchFloor: 1,
                  searchResultLimit: 4,
                  searchFields: ["label", "value"],
                  position: "auto",
                  resetScrollPosition: true,
                  shouldSort: true,
                  shouldSortItems: false,
                  sorter: utils_1.sortByAlpha,
                  placeholder: true,
                  placeholderValue: null,
                  searchPlaceholderValue: null,
                  prependValue: null,
                  appendValue: null,
                  renderSelectedChoices: "auto",
                  loadingText: "Loading...",
                  noResultsText: "No results found",
                  noChoicesText: "No choices to choose from",
                  itemSelectText: "Press to select",
                  uniqueItemText: "Only unique values can be added",
                  customAddItemText: "Only values matching specific conditions can be added",
                  addItemText: function(value2) {
                    return 'Press Enter to add <b>"'.concat((0, utils_1.sanitise)(value2), '"</b>');
                  },
                  maxItemText: function(maxItemCount) {
                    return "Only ".concat(maxItemCount, " values can be added");
                  },
                  valueComparer: function(value1, value2) {
                    return value1 === value2;
                  },
                  fuseOptions: {
                    includeScore: true
                  },
                  labelId: "",
                  callbackOnInit: null,
                  callbackOnCreateTemplates: null,
                  classNames: exports5.DEFAULT_CLASSNAMES
                };
              }
            ),
            /***/
            18: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            978: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            948: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            359: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            285: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            533: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            187: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __createBinding2 = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                  if (k2 === void 0) k2 = k;
                  var desc = Object.getOwnPropertyDescriptor(m, k);
                  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = {
                      enumerable: true,
                      get: function() {
                        return m[k];
                      }
                    };
                  }
                  Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                  if (k2 === void 0) k2 = k;
                  o[k2] = m[k];
                });
                var __exportStar2 = this && this.__exportStar || function(m, exports6) {
                  for (var p2 in m) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports6, p2)) __createBinding2(exports6, m, p2);
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                __exportStar2(__webpack_require__2(18), exports5);
                __exportStar2(__webpack_require__2(978), exports5);
                __exportStar2(__webpack_require__2(948), exports5);
                __exportStar2(__webpack_require__2(359), exports5);
                __exportStar2(__webpack_require__2(285), exports5);
                __exportStar2(__webpack_require__2(533), exports5);
                __exportStar2(__webpack_require__2(287), exports5);
                __exportStar2(__webpack_require__2(132), exports5);
                __exportStar2(__webpack_require__2(837), exports5);
                __exportStar2(__webpack_require__2(598), exports5);
                __exportStar2(__webpack_require__2(369), exports5);
                __exportStar2(__webpack_require__2(37), exports5);
                __exportStar2(__webpack_require__2(47), exports5);
                __exportStar2(__webpack_require__2(923), exports5);
                __exportStar2(__webpack_require__2(876), exports5);
              }
            ),
            /***/
            287: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            132: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            837: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            598: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            37: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            369: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            47: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            923: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            876: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
              }
            ),
            /***/
            799: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.parseCustomProperties = exports5.diff = exports5.cloneObject = exports5.existsInArray = exports5.dispatchEvent = exports5.sortByScore = exports5.sortByAlpha = exports5.strToEl = exports5.sanitise = exports5.isScrolledIntoView = exports5.getAdjacentEl = exports5.wrap = exports5.isType = exports5.getType = exports5.generateId = exports5.generateChars = exports5.getRandomNumber = void 0;
                var getRandomNumber = function(min10, max18) {
                  return Math.floor(Math.random() * (max18 - min10) + min10);
                };
                exports5.getRandomNumber = getRandomNumber;
                var generateChars = function(length) {
                  return Array.from({
                    length
                  }, function() {
                    return (0, exports5.getRandomNumber)(0, 36).toString(36);
                  }).join("");
                };
                exports5.generateChars = generateChars;
                var generateId = function(element, prefix) {
                  var id = element.id || element.name && "".concat(element.name, "-").concat((0, exports5.generateChars)(2)) || (0, exports5.generateChars)(4);
                  id = id.replace(/(:|\.|\[|\]|,)/g, "");
                  id = "".concat(prefix, "-").concat(id);
                  return id;
                };
                exports5.generateId = generateId;
                var getType = function(obj) {
                  return Object.prototype.toString.call(obj).slice(8, -1);
                };
                exports5.getType = getType;
                var isType = function(type, obj) {
                  return obj !== void 0 && obj !== null && (0, exports5.getType)(obj) === type;
                };
                exports5.isType = isType;
                var wrap = function(element, wrapper) {
                  if (wrapper === void 0) {
                    wrapper = document.createElement("div");
                  }
                  if (element.parentNode) {
                    if (element.nextSibling) {
                      element.parentNode.insertBefore(wrapper, element.nextSibling);
                    } else {
                      element.parentNode.appendChild(wrapper);
                    }
                  }
                  return wrapper.appendChild(element);
                };
                exports5.wrap = wrap;
                var getAdjacentEl = function(startEl, selector, direction) {
                  if (direction === void 0) {
                    direction = 1;
                  }
                  var prop = "".concat(direction > 0 ? "next" : "previous", "ElementSibling");
                  var sibling = startEl[prop];
                  while (sibling) {
                    if (sibling.matches(selector)) {
                      return sibling;
                    }
                    sibling = sibling[prop];
                  }
                  return sibling;
                };
                exports5.getAdjacentEl = getAdjacentEl;
                var isScrolledIntoView = function(element, parent, direction) {
                  if (direction === void 0) {
                    direction = 1;
                  }
                  if (!element) {
                    return false;
                  }
                  var isVisible;
                  if (direction > 0) {
                    isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
                  } else {
                    isVisible = element.offsetTop >= parent.scrollTop;
                  }
                  return isVisible;
                };
                exports5.isScrolledIntoView = isScrolledIntoView;
                var sanitise = function(value2) {
                  if (typeof value2 !== "string") {
                    return value2;
                  }
                  return value2.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
                };
                exports5.sanitise = sanitise;
                exports5.strToEl = function() {
                  var tmpEl = document.createElement("div");
                  return function(str) {
                    var cleanedInput = str.trim();
                    tmpEl.innerHTML = cleanedInput;
                    var firldChild = tmpEl.children[0];
                    while (tmpEl.firstChild) {
                      tmpEl.removeChild(tmpEl.firstChild);
                    }
                    return firldChild;
                  };
                }();
                var sortByAlpha = function(_a34, _b4) {
                  var value2 = _a34.value, _c = _a34.label, label3 = _c === void 0 ? value2 : _c;
                  var value22 = _b4.value, _d = _b4.label, label22 = _d === void 0 ? value22 : _d;
                  return label3.localeCompare(label22, [], {
                    sensitivity: "base",
                    ignorePunctuation: true,
                    numeric: true
                  });
                };
                exports5.sortByAlpha = sortByAlpha;
                var sortByScore = function(a2, b2) {
                  var _a34 = a2.score, scoreA = _a34 === void 0 ? 0 : _a34;
                  var _b4 = b2.score, scoreB = _b4 === void 0 ? 0 : _b4;
                  return scoreA - scoreB;
                };
                exports5.sortByScore = sortByScore;
                var dispatchEvent = function(element, type, customArgs) {
                  if (customArgs === void 0) {
                    customArgs = null;
                  }
                  var event2 = new CustomEvent(type, {
                    detail: customArgs,
                    bubbles: true,
                    cancelable: true
                  });
                  return element.dispatchEvent(event2);
                };
                exports5.dispatchEvent = dispatchEvent;
                var existsInArray = function(array2, value2, key) {
                  if (key === void 0) {
                    key = "value";
                  }
                  return array2.some(function(item3) {
                    if (typeof value2 === "string") {
                      return item3[key] === value2.trim();
                    }
                    return item3[key] === value2;
                  });
                };
                exports5.existsInArray = existsInArray;
                var cloneObject = function(obj) {
                  return JSON.parse(JSON.stringify(obj));
                };
                exports5.cloneObject = cloneObject;
                var diff = function(a2, b2) {
                  var aKeys = Object.keys(a2).sort();
                  var bKeys = Object.keys(b2).sort();
                  return aKeys.filter(function(i2) {
                    return bKeys.indexOf(i2) < 0;
                  });
                };
                exports5.diff = diff;
                var parseCustomProperties = function(customProperties) {
                  if (typeof customProperties !== "undefined") {
                    try {
                      return JSON.parse(customProperties);
                    } catch (e) {
                      return customProperties;
                    }
                  }
                  return {};
                };
                exports5.parseCustomProperties = parseCustomProperties;
              }
            ),
            /***/
            273: (
              /***/
              function(__unused_webpack_module, exports5) {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
                    if (ar || !(i2 in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                      ar[i2] = from[i2];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.defaultState = void 0;
                exports5.defaultState = [];
                function choices(state, action) {
                  if (state === void 0) {
                    state = exports5.defaultState;
                  }
                  if (action === void 0) {
                    action = {};
                  }
                  switch (action.type) {
                    case "ADD_CHOICE": {
                      var addChoiceAction = action;
                      var choice = {
                        id: addChoiceAction.id,
                        elementId: addChoiceAction.elementId,
                        groupId: addChoiceAction.groupId,
                        value: addChoiceAction.value,
                        label: addChoiceAction.label || addChoiceAction.value,
                        disabled: addChoiceAction.disabled || false,
                        selected: false,
                        active: true,
                        score: 9999,
                        customProperties: addChoiceAction.customProperties,
                        placeholder: addChoiceAction.placeholder || false
                      };
                      return __spreadArray(__spreadArray([], state, true), [choice], false);
                    }
                    case "ADD_ITEM": {
                      var addItemAction_1 = action;
                      if (addItemAction_1.choiceId > -1) {
                        return state.map(function(obj) {
                          var choice2 = obj;
                          if (choice2.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
                            choice2.selected = true;
                          }
                          return choice2;
                        });
                      }
                      return state;
                    }
                    case "REMOVE_ITEM": {
                      var removeItemAction_1 = action;
                      if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                        return state.map(function(obj) {
                          var choice2 = obj;
                          if (choice2.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
                            choice2.selected = false;
                          }
                          return choice2;
                        });
                      }
                      return state;
                    }
                    case "FILTER_CHOICES": {
                      var filterChoicesAction_1 = action;
                      return state.map(function(obj) {
                        var choice2 = obj;
                        choice2.active = filterChoicesAction_1.results.some(function(_a34) {
                          var item3 = _a34.item, score = _a34.score;
                          if (item3.id === choice2.id) {
                            choice2.score = score;
                            return true;
                          }
                          return false;
                        });
                        return choice2;
                      });
                    }
                    case "ACTIVATE_CHOICES": {
                      var activateChoicesAction_1 = action;
                      return state.map(function(obj) {
                        var choice2 = obj;
                        choice2.active = activateChoicesAction_1.active;
                        return choice2;
                      });
                    }
                    case "CLEAR_CHOICES": {
                      return exports5.defaultState;
                    }
                    default: {
                      return state;
                    }
                  }
                }
                exports5["default"] = choices;
              }
            ),
            /***/
            871: (
              /***/
              function(__unused_webpack_module, exports5) {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
                    if (ar || !(i2 in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                      ar[i2] = from[i2];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.defaultState = void 0;
                exports5.defaultState = [];
                function groups(state, action) {
                  if (state === void 0) {
                    state = exports5.defaultState;
                  }
                  if (action === void 0) {
                    action = {};
                  }
                  switch (action.type) {
                    case "ADD_GROUP": {
                      var addGroupAction = action;
                      return __spreadArray(__spreadArray([], state, true), [{
                        id: addGroupAction.id,
                        value: addGroupAction.value,
                        active: addGroupAction.active,
                        disabled: addGroupAction.disabled
                      }], false);
                    }
                    case "CLEAR_CHOICES": {
                      return [];
                    }
                    default: {
                      return state;
                    }
                  }
                }
                exports5["default"] = groups;
              }
            ),
            /***/
            655: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.defaultState = void 0;
                var redux_1 = __webpack_require__2(791);
                var items_1 = __importDefault2(__webpack_require__2(52));
                var groups_1 = __importDefault2(__webpack_require__2(871));
                var choices_1 = __importDefault2(__webpack_require__2(273));
                var loading_1 = __importDefault2(__webpack_require__2(502));
                var utils_1 = __webpack_require__2(799);
                exports5.defaultState = {
                  groups: [],
                  items: [],
                  choices: [],
                  loading: false
                };
                var appReducer = (0, redux_1.combineReducers)({
                  items: items_1.default,
                  groups: groups_1.default,
                  choices: choices_1.default,
                  loading: loading_1.default
                });
                var rootReducer = function(passedState, action) {
                  var state = passedState;
                  if (action.type === "CLEAR_ALL") {
                    state = exports5.defaultState;
                  } else if (action.type === "RESET_TO") {
                    return (0, utils_1.cloneObject)(action.state);
                  }
                  return appReducer(state, action);
                };
                exports5["default"] = rootReducer;
              }
            ),
            /***/
            52: (
              /***/
              function(__unused_webpack_module, exports5) {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
                    if (ar || !(i2 in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                      ar[i2] = from[i2];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.defaultState = void 0;
                exports5.defaultState = [];
                function items(state, action) {
                  if (state === void 0) {
                    state = exports5.defaultState;
                  }
                  if (action === void 0) {
                    action = {};
                  }
                  switch (action.type) {
                    case "ADD_ITEM": {
                      var addItemAction = action;
                      var newState = __spreadArray(__spreadArray([], state, true), [{
                        id: addItemAction.id,
                        choiceId: addItemAction.choiceId,
                        groupId: addItemAction.groupId,
                        value: addItemAction.value,
                        label: addItemAction.label,
                        active: true,
                        highlighted: false,
                        customProperties: addItemAction.customProperties,
                        placeholder: addItemAction.placeholder || false,
                        keyCode: null
                      }], false);
                      return newState.map(function(obj) {
                        var item3 = obj;
                        item3.highlighted = false;
                        return item3;
                      });
                    }
                    case "REMOVE_ITEM": {
                      return state.map(function(obj) {
                        var item3 = obj;
                        if (item3.id === action.id) {
                          item3.active = false;
                        }
                        return item3;
                      });
                    }
                    case "HIGHLIGHT_ITEM": {
                      var highlightItemAction_1 = action;
                      return state.map(function(obj) {
                        var item3 = obj;
                        if (item3.id === highlightItemAction_1.id) {
                          item3.highlighted = highlightItemAction_1.highlighted;
                        }
                        return item3;
                      });
                    }
                    default: {
                      return state;
                    }
                  }
                }
                exports5["default"] = items;
              }
            ),
            /***/
            502: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                exports5.defaultState = void 0;
                exports5.defaultState = false;
                var general = function(state, action) {
                  if (state === void 0) {
                    state = exports5.defaultState;
                  }
                  if (action === void 0) {
                    action = {};
                  }
                  switch (action.type) {
                    case "SET_IS_LOADING": {
                      return action.isLoading;
                    }
                    default: {
                      return state;
                    }
                  }
                };
                exports5["default"] = general;
              }
            ),
            /***/
            744: (
              /***/
              function(__unused_webpack_module, exports5, __webpack_require__2) {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
                    if (ar || !(i2 in from)) {
                      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                      ar[i2] = from[i2];
                    }
                  }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
                var __importDefault2 = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : {
                    "default": mod
                  };
                };
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var redux_1 = __webpack_require__2(791);
                var index_1 = __importDefault2(__webpack_require__2(655));
                var Store = (
                  /** @class */
                  function() {
                    function Store2() {
                      this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
                    }
                    Store2.prototype.subscribe = function(onChange) {
                      this._store.subscribe(onChange);
                    };
                    Store2.prototype.dispatch = function(action) {
                      this._store.dispatch(action);
                    };
                    Object.defineProperty(Store2.prototype, "state", {
                      /**
                       * Get store object (wrapping Redux method)
                       */
                      get: function() {
                        return this._store.getState();
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "items", {
                      /**
                       * Get items from store
                       */
                      get: function() {
                        return this.state.items;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "activeItems", {
                      /**
                       * Get active items from store
                       */
                      get: function() {
                        return this.items.filter(function(item3) {
                          return item3.active === true;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "highlightedActiveItems", {
                      /**
                       * Get highlighted items from store
                       */
                      get: function() {
                        return this.items.filter(function(item3) {
                          return item3.active && item3.highlighted;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "choices", {
                      /**
                       * Get choices from store
                       */
                      get: function() {
                        return this.state.choices;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "activeChoices", {
                      /**
                       * Get active choices from store
                       */
                      get: function() {
                        return this.choices.filter(function(choice) {
                          return choice.active === true;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "selectableChoices", {
                      /**
                       * Get selectable choices from store
                       */
                      get: function() {
                        return this.choices.filter(function(choice) {
                          return choice.disabled !== true;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "searchableChoices", {
                      /**
                       * Get choices that can be searched (excluding placeholders)
                       */
                      get: function() {
                        return this.selectableChoices.filter(function(choice) {
                          return choice.placeholder !== true;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "placeholderChoice", {
                      /**
                       * Get placeholder choice from store
                       */
                      get: function() {
                        return __spreadArray([], this.choices, true).reverse().find(function(choice) {
                          return choice.placeholder === true;
                        });
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "groups", {
                      /**
                       * Get groups from store
                       */
                      get: function() {
                        return this.state.groups;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(Store2.prototype, "activeGroups", {
                      /**
                       * Get active groups from store
                       */
                      get: function() {
                        var _a34 = this, groups = _a34.groups, choices = _a34.choices;
                        return groups.filter(function(group) {
                          var isActive = group.active === true && group.disabled === false;
                          var hasActiveOptions = choices.some(function(choice) {
                            return choice.active === true && choice.disabled === false;
                          });
                          return isActive && hasActiveOptions;
                        }, []);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Store2.prototype.isLoading = function() {
                      return this.state.loading;
                    };
                    Store2.prototype.getChoiceById = function(id) {
                      return this.activeChoices.find(function(choice) {
                        return choice.id === parseInt(id, 10);
                      });
                    };
                    Store2.prototype.getGroupById = function(id) {
                      return this.groups.find(function(group) {
                        return group.id === id;
                      });
                    };
                    return Store2;
                  }()
                );
                exports5["default"] = Store;
              }
            ),
            /***/
            686: (
              /***/
              function(__unused_webpack_module, exports5) {
                Object.defineProperty(exports5, "__esModule", {
                  value: true
                });
                var templates = {
                  containerOuter: function(_a34, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
                    var containerOuter = _a34.classNames.containerOuter;
                    var div2 = Object.assign(document.createElement("div"), {
                      className: containerOuter
                    });
                    div2.dataset.type = passedElementType;
                    if (dir) {
                      div2.dir = dir;
                    }
                    if (isSelectOneElement) {
                      div2.tabIndex = 0;
                    }
                    if (isSelectElement) {
                      div2.setAttribute("role", searchEnabled ? "combobox" : "listbox");
                      if (searchEnabled) {
                        div2.setAttribute("aria-autocomplete", "list");
                      }
                    }
                    div2.setAttribute("aria-haspopup", "true");
                    div2.setAttribute("aria-expanded", "false");
                    if (labelId) {
                      div2.setAttribute("aria-labelledby", labelId);
                    }
                    return div2;
                  },
                  containerInner: function(_a34) {
                    var containerInner = _a34.classNames.containerInner;
                    return Object.assign(document.createElement("div"), {
                      className: containerInner
                    });
                  },
                  itemList: function(_a34, isSelectOneElement) {
                    var _b4 = _a34.classNames, list = _b4.list, listSingle = _b4.listSingle, listItems = _b4.listItems;
                    return Object.assign(document.createElement("div"), {
                      className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems)
                    });
                  },
                  placeholder: function(_a34, value2) {
                    var _b4;
                    var allowHTML = _a34.allowHTML, placeholder = _a34.classNames.placeholder;
                    return Object.assign(document.createElement("div"), (_b4 = {
                      className: placeholder
                    }, _b4[allowHTML ? "innerHTML" : "innerText"] = value2, _b4));
                  },
                  item: function(_a34, _b4, removeItemButton) {
                    var _c, _d;
                    var allowHTML = _a34.allowHTML, _e = _a34.classNames, item3 = _e.item, button2 = _e.button, highlightedState = _e.highlightedState, itemSelectable = _e.itemSelectable, placeholder = _e.placeholder;
                    var id = _b4.id, value2 = _b4.value, label3 = _b4.label, customProperties = _b4.customProperties, active8 = _b4.active, disabled5 = _b4.disabled, highlighted = _b4.highlighted, isPlaceholder = _b4.placeholder;
                    var div2 = Object.assign(document.createElement("div"), (_c = {
                      className: item3
                    }, _c[allowHTML ? "innerHTML" : "innerText"] = label3, _c));
                    Object.assign(div2.dataset, {
                      item: "",
                      id,
                      value: value2,
                      customProperties
                    });
                    if (active8) {
                      div2.setAttribute("aria-selected", "true");
                    }
                    if (disabled5) {
                      div2.setAttribute("aria-disabled", "true");
                    }
                    if (isPlaceholder) {
                      div2.classList.add(placeholder);
                    }
                    div2.classList.add(highlighted ? highlightedState : itemSelectable);
                    if (removeItemButton) {
                      if (disabled5) {
                        div2.classList.remove(itemSelectable);
                      }
                      div2.dataset.deletable = "";
                      var REMOVE_ITEM_TEXT = "Remove item";
                      var removeButton = Object.assign(document.createElement("button"), (_d = {
                        type: "button",
                        className: button2
                      }, _d[allowHTML ? "innerHTML" : "innerText"] = REMOVE_ITEM_TEXT, _d));
                      removeButton.setAttribute("aria-label", "".concat(REMOVE_ITEM_TEXT, ": '").concat(value2, "'"));
                      removeButton.dataset.button = "";
                      div2.appendChild(removeButton);
                    }
                    return div2;
                  },
                  choiceList: function(_a34, isSelectOneElement) {
                    var list = _a34.classNames.list;
                    var div2 = Object.assign(document.createElement("div"), {
                      className: list
                    });
                    if (!isSelectOneElement) {
                      div2.setAttribute("aria-multiselectable", "true");
                    }
                    div2.setAttribute("role", "listbox");
                    return div2;
                  },
                  choiceGroup: function(_a34, _b4) {
                    var _c;
                    var allowHTML = _a34.allowHTML, _d = _a34.classNames, group = _d.group, groupHeading = _d.groupHeading, itemDisabled = _d.itemDisabled;
                    var id = _b4.id, value2 = _b4.value, disabled5 = _b4.disabled;
                    var div2 = Object.assign(document.createElement("div"), {
                      className: "".concat(group, " ").concat(disabled5 ? itemDisabled : "")
                    });
                    div2.setAttribute("role", "group");
                    Object.assign(div2.dataset, {
                      group: "",
                      id,
                      value: value2
                    });
                    if (disabled5) {
                      div2.setAttribute("aria-disabled", "true");
                    }
                    div2.appendChild(Object.assign(document.createElement("div"), (_c = {
                      className: groupHeading
                    }, _c[allowHTML ? "innerHTML" : "innerText"] = value2, _c)));
                    return div2;
                  },
                  choice: function(_a34, _b4, selectText) {
                    var _c;
                    var allowHTML = _a34.allowHTML, _d = _a34.classNames, item3 = _d.item, itemChoice = _d.itemChoice, itemSelectable = _d.itemSelectable, selectedState = _d.selectedState, itemDisabled = _d.itemDisabled, placeholder = _d.placeholder;
                    var id = _b4.id, value2 = _b4.value, label3 = _b4.label, groupId = _b4.groupId, elementId = _b4.elementId, isDisabled = _b4.disabled, isSelected = _b4.selected, isPlaceholder = _b4.placeholder;
                    var div2 = Object.assign(document.createElement("div"), (_c = {
                      id: elementId
                    }, _c[allowHTML ? "innerHTML" : "innerText"] = label3, _c.className = "".concat(item3, " ").concat(itemChoice), _c));
                    if (isSelected) {
                      div2.classList.add(selectedState);
                    }
                    if (isPlaceholder) {
                      div2.classList.add(placeholder);
                    }
                    div2.setAttribute("role", groupId && groupId > 0 ? "treeitem" : "option");
                    Object.assign(div2.dataset, {
                      choice: "",
                      id,
                      value: value2,
                      selectText
                    });
                    if (isDisabled) {
                      div2.classList.add(itemDisabled);
                      div2.dataset.choiceDisabled = "";
                      div2.setAttribute("aria-disabled", "true");
                    } else {
                      div2.classList.add(itemSelectable);
                      div2.dataset.choiceSelectable = "";
                    }
                    return div2;
                  },
                  input: function(_a34, placeholderValue) {
                    var _b4 = _a34.classNames, input12 = _b4.input, inputCloned = _b4.inputCloned;
                    var inp = Object.assign(document.createElement("input"), {
                      type: "search",
                      name: "search_terms",
                      className: "".concat(input12, " ").concat(inputCloned),
                      autocomplete: "off",
                      autocapitalize: "off",
                      spellcheck: false
                    });
                    inp.setAttribute("role", "textbox");
                    inp.setAttribute("aria-autocomplete", "list");
                    inp.setAttribute("aria-label", placeholderValue);
                    return inp;
                  },
                  dropdown: function(_a34) {
                    var _b4 = _a34.classNames, list = _b4.list, listDropdown = _b4.listDropdown;
                    var div2 = document.createElement("div");
                    div2.classList.add(list, listDropdown);
                    div2.setAttribute("aria-expanded", "false");
                    return div2;
                  },
                  notice: function(_a34, innerText, type) {
                    var _b4;
                    var allowHTML = _a34.allowHTML, _c = _a34.classNames, item3 = _c.item, itemChoice = _c.itemChoice, noResults = _c.noResults, noChoices = _c.noChoices;
                    if (type === void 0) {
                      type = "";
                    }
                    var classes = [item3, itemChoice];
                    if (type === "no-choices") {
                      classes.push(noChoices);
                    } else if (type === "no-results") {
                      classes.push(noResults);
                    }
                    return Object.assign(document.createElement("div"), (_b4 = {}, _b4[allowHTML ? "innerHTML" : "innerText"] = innerText, _b4.className = classes.join(" "), _b4));
                  },
                  option: function(_a34) {
                    var label3 = _a34.label, value2 = _a34.value, customProperties = _a34.customProperties, active8 = _a34.active, disabled5 = _a34.disabled;
                    var opt = new Option(label3, value2, false, active8);
                    if (customProperties) {
                      opt.dataset.customProperties = "".concat(customProperties);
                    }
                    opt.disabled = !!disabled5;
                    return opt;
                  }
                };
                exports5["default"] = templates;
              }
            ),
            /***/
            996: (
              /***/
              function(module3) {
                var isMergeableObject = function isMergeableObject2(value2) {
                  return isNonNullObject(value2) && !isSpecial(value2);
                };
                function isNonNullObject(value2) {
                  return !!value2 && typeof value2 === "object";
                }
                function isSpecial(value2) {
                  var stringValue = Object.prototype.toString.call(value2);
                  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value2);
                }
                var canUseSymbol = typeof Symbol === "function" && Symbol.for;
                var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
                function isReactElement(value2) {
                  return value2.$$typeof === REACT_ELEMENT_TYPE;
                }
                function emptyTarget(val) {
                  return Array.isArray(val) ? [] : {};
                }
                function cloneUnlessOtherwiseSpecified(value2, options2) {
                  return options2.clone !== false && options2.isMergeableObject(value2) ? deepmerge(emptyTarget(value2), value2, options2) : value2;
                }
                function defaultArrayMerge(target, source2, options2) {
                  return target.concat(source2).map(function(element) {
                    return cloneUnlessOtherwiseSpecified(element, options2);
                  });
                }
                function getMergeFunction(key, options2) {
                  if (!options2.customMerge) {
                    return deepmerge;
                  }
                  var customMerge = options2.customMerge(key);
                  return typeof customMerge === "function" ? customMerge : deepmerge;
                }
                function getEnumerableOwnPropertySymbols(target) {
                  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol2) {
                    return target.propertyIsEnumerable(symbol2);
                  }) : [];
                }
                function getKeys(target) {
                  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
                }
                function propertyIsOnObject(object3, property) {
                  try {
                    return property in object3;
                  } catch (_2) {
                    return false;
                  }
                }
                function propertyIsUnsafe(target, key) {
                  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
                }
                function mergeObject(target, source2, options2) {
                  var destination = {};
                  if (options2.isMergeableObject(target)) {
                    getKeys(target).forEach(function(key) {
                      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options2);
                    });
                  }
                  getKeys(source2).forEach(function(key) {
                    if (propertyIsUnsafe(target, key)) {
                      return;
                    }
                    if (propertyIsOnObject(target, key) && options2.isMergeableObject(source2[key])) {
                      destination[key] = getMergeFunction(key, options2)(target[key], source2[key], options2);
                    } else {
                      destination[key] = cloneUnlessOtherwiseSpecified(source2[key], options2);
                    }
                  });
                  return destination;
                }
                function deepmerge(target, source2, options2) {
                  options2 = options2 || {};
                  options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
                  options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
                  options2.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
                  var sourceIsArray = Array.isArray(source2);
                  var targetIsArray = Array.isArray(target);
                  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
                  if (!sourceAndTargetTypesMatch) {
                    return cloneUnlessOtherwiseSpecified(source2, options2);
                  } else if (sourceIsArray) {
                    return options2.arrayMerge(target, source2, options2);
                  } else {
                    return mergeObject(target, source2, options2);
                  }
                }
                deepmerge.all = function deepmergeAll(array2, options2) {
                  if (!Array.isArray(array2)) {
                    throw new Error("first argument should be an array");
                  }
                  return array2.reduce(function(prev, next) {
                    return deepmerge(prev, next, options2);
                  }, {});
                };
                var deepmerge_1 = deepmerge;
                module3.exports = deepmerge_1;
              }
            ),
            /***/
            221: (
              /***/
              function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  "default": function() {
                    return (
                      /* binding */
                      Fuse
                    );
                  }
                  /* harmony export */
                });
                function isArray2(value2) {
                  return !Array.isArray ? getTag(value2) === "[object Array]" : Array.isArray(value2);
                }
                const INFINITY = 1 / 0;
                function baseToString(value2) {
                  if (typeof value2 == "string") {
                    return value2;
                  }
                  let result = value2 + "";
                  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
                }
                function toString(value2) {
                  return value2 == null ? "" : baseToString(value2);
                }
                function isString2(value2) {
                  return typeof value2 === "string";
                }
                function isNumber2(value2) {
                  return typeof value2 === "number";
                }
                function isBoolean2(value2) {
                  return value2 === true || value2 === false || isObjectLike(value2) && getTag(value2) == "[object Boolean]";
                }
                function isObject2(value2) {
                  return typeof value2 === "object";
                }
                function isObjectLike(value2) {
                  return isObject2(value2) && value2 !== null;
                }
                function isDefined(value2) {
                  return value2 !== void 0 && value2 !== null;
                }
                function isBlank(value2) {
                  return !value2.trim().length;
                }
                function getTag(value2) {
                  return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
                }
                const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
                const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
                const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
                const PATTERN_LENGTH_TOO_LARGE = (max18) => `Pattern length exceeds max of ${max18}.`;
                const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
                const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
                const hasOwn = Object.prototype.hasOwnProperty;
                class KeyStore {
                  constructor(keys2) {
                    this._keys = [];
                    this._keyMap = {};
                    let totalWeight = 0;
                    keys2.forEach((key) => {
                      let obj = createKey(key);
                      totalWeight += obj.weight;
                      this._keys.push(obj);
                      this._keyMap[obj.id] = obj;
                      totalWeight += obj.weight;
                    });
                    this._keys.forEach((key) => {
                      key.weight /= totalWeight;
                    });
                  }
                  get(keyId) {
                    return this._keyMap[keyId];
                  }
                  keys() {
                    return this._keys;
                  }
                  toJSON() {
                    return JSON.stringify(this._keys);
                  }
                }
                function createKey(key) {
                  let path = null;
                  let id = null;
                  let src = null;
                  let weight = 1;
                  let getFn = null;
                  if (isString2(key) || isArray2(key)) {
                    src = key;
                    path = createKeyPath(key);
                    id = createKeyId(key);
                  } else {
                    if (!hasOwn.call(key, "name")) {
                      throw new Error(MISSING_KEY_PROPERTY("name"));
                    }
                    const name = key.name;
                    src = name;
                    if (hasOwn.call(key, "weight")) {
                      weight = key.weight;
                      if (weight <= 0) {
                        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
                      }
                    }
                    path = createKeyPath(name);
                    id = createKeyId(name);
                    getFn = key.getFn;
                  }
                  return { path, id, weight, src, getFn };
                }
                function createKeyPath(key) {
                  return isArray2(key) ? key : key.split(".");
                }
                function createKeyId(key) {
                  return isArray2(key) ? key.join(".") : key;
                }
                function get2(obj, path) {
                  let list = [];
                  let arr = false;
                  const deepGet = (obj2, path2, index2) => {
                    if (!isDefined(obj2)) {
                      return;
                    }
                    if (!path2[index2]) {
                      list.push(obj2);
                    } else {
                      let key = path2[index2];
                      const value2 = obj2[key];
                      if (!isDefined(value2)) {
                        return;
                      }
                      if (index2 === path2.length - 1 && (isString2(value2) || isNumber2(value2) || isBoolean2(value2))) {
                        list.push(toString(value2));
                      } else if (isArray2(value2)) {
                        arr = true;
                        for (let i2 = 0, len = value2.length; i2 < len; i2 += 1) {
                          deepGet(value2[i2], path2, index2 + 1);
                        }
                      } else if (path2.length) {
                        deepGet(value2, path2, index2 + 1);
                      }
                    }
                  };
                  deepGet(obj, isString2(path) ? path.split(".") : path, 0);
                  return arr ? list : list[0];
                }
                const MatchOptions = {
                  // Whether the matches should be included in the result set. When `true`, each record in the result
                  // set will include the indices of the matched characters.
                  // These can consequently be used for highlighting purposes.
                  includeMatches: false,
                  // When `true`, the matching function will continue to the end of a search pattern even if
                  // a perfect match has already been located in the string.
                  findAllMatches: false,
                  // Minimum number of characters that must be matched before a result is considered a match
                  minMatchCharLength: 1
                };
                const BasicOptions = {
                  // When `true`, the algorithm continues searching to the end of the input even if a perfect
                  // match is found before the end of the same input.
                  isCaseSensitive: false,
                  // When true, the matching function will continue to the end of a search pattern even if
                  includeScore: false,
                  // List of properties that will be searched. This also supports nested properties.
                  keys: [],
                  // Whether to sort the result list, by score
                  shouldSort: true,
                  // Default sort function: sort by ascending score, ascending index
                  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
                };
                const FuzzyOptions = {
                  // Approximately where in the text is the pattern expected to be found?
                  location: 0,
                  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
                  // (of both letters and location), a threshold of '1.0' would match anything.
                  threshold: 0.6,
                  // Determines how close the match must be to the fuzzy location (specified above).
                  // An exact letter match which is 'distance' characters away from the fuzzy location
                  // would score as a complete mismatch. A distance of '0' requires the match be at
                  // the exact location specified, a threshold of '1000' would require a perfect match
                  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
                  distance: 100
                };
                const AdvancedOptions = {
                  // When `true`, it enables the use of unix-like search commands
                  useExtendedSearch: false,
                  // The get function to use when fetching an object's properties.
                  // The default will search nested paths *ie foo.bar.baz*
                  getFn: get2,
                  // When `true`, search will ignore `location` and `distance`, so it won't matter
                  // where in the string the pattern appears.
                  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
                  ignoreLocation: false,
                  // When `true`, the calculation for the relevance score (used for sorting) will
                  // ignore the field-length norm.
                  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
                  ignoreFieldNorm: false,
                  // The weight to determine how much field length norm effects scoring.
                  fieldNormWeight: 1
                };
                var Config = {
                  ...BasicOptions,
                  ...MatchOptions,
                  ...FuzzyOptions,
                  ...AdvancedOptions
                };
                const SPACE = /[^ ]+/g;
                function norm(weight = 1, mantissa = 3) {
                  const cache = /* @__PURE__ */ new Map();
                  const m = Math.pow(10, mantissa);
                  return {
                    get(value2) {
                      const numTokens = value2.match(SPACE).length;
                      if (cache.has(numTokens)) {
                        return cache.get(numTokens);
                      }
                      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
                      const n2 = parseFloat(Math.round(norm2 * m) / m);
                      cache.set(numTokens, n2);
                      return n2;
                    },
                    clear() {
                      cache.clear();
                    }
                  };
                }
                class FuseIndex {
                  constructor({
                    getFn = Config.getFn,
                    fieldNormWeight = Config.fieldNormWeight
                  } = {}) {
                    this.norm = norm(fieldNormWeight, 3);
                    this.getFn = getFn;
                    this.isCreated = false;
                    this.setIndexRecords();
                  }
                  setSources(docs = []) {
                    this.docs = docs;
                  }
                  setIndexRecords(records = []) {
                    this.records = records;
                  }
                  setKeys(keys2 = []) {
                    this.keys = keys2;
                    this._keysMap = {};
                    keys2.forEach((key, idx) => {
                      this._keysMap[key.id] = idx;
                    });
                  }
                  create() {
                    if (this.isCreated || !this.docs.length) {
                      return;
                    }
                    this.isCreated = true;
                    if (isString2(this.docs[0])) {
                      this.docs.forEach((doc, docIndex) => {
                        this._addString(doc, docIndex);
                      });
                    } else {
                      this.docs.forEach((doc, docIndex) => {
                        this._addObject(doc, docIndex);
                      });
                    }
                    this.norm.clear();
                  }
                  // Adds a doc to the end of the index
                  add(doc) {
                    const idx = this.size();
                    if (isString2(doc)) {
                      this._addString(doc, idx);
                    } else {
                      this._addObject(doc, idx);
                    }
                  }
                  // Removes the doc at the specified index of the index
                  removeAt(idx) {
                    this.records.splice(idx, 1);
                    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
                      this.records[i2].i -= 1;
                    }
                  }
                  getValueForItemAtKeyId(item3, keyId) {
                    return item3[this._keysMap[keyId]];
                  }
                  size() {
                    return this.records.length;
                  }
                  _addString(doc, docIndex) {
                    if (!isDefined(doc) || isBlank(doc)) {
                      return;
                    }
                    let record = {
                      v: doc,
                      i: docIndex,
                      n: this.norm.get(doc)
                    };
                    this.records.push(record);
                  }
                  _addObject(doc, docIndex) {
                    let record = { i: docIndex, $: {} };
                    this.keys.forEach((key, keyIndex) => {
                      let value2 = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
                      if (!isDefined(value2)) {
                        return;
                      }
                      if (isArray2(value2)) {
                        let subRecords = [];
                        const stack = [{ nestedArrIndex: -1, value: value2 }];
                        while (stack.length) {
                          const { nestedArrIndex, value: value3 } = stack.pop();
                          if (!isDefined(value3)) {
                            continue;
                          }
                          if (isString2(value3) && !isBlank(value3)) {
                            let subRecord = {
                              v: value3,
                              i: nestedArrIndex,
                              n: this.norm.get(value3)
                            };
                            subRecords.push(subRecord);
                          } else if (isArray2(value3)) {
                            value3.forEach((item3, k) => {
                              stack.push({
                                nestedArrIndex: k,
                                value: item3
                              });
                            });
                          } else ;
                        }
                        record.$[keyIndex] = subRecords;
                      } else if (isString2(value2) && !isBlank(value2)) {
                        let subRecord = {
                          v: value2,
                          n: this.norm.get(value2)
                        };
                        record.$[keyIndex] = subRecord;
                      }
                    });
                    this.records.push(record);
                  }
                  toJSON() {
                    return {
                      keys: this.keys,
                      records: this.records
                    };
                  }
                }
                function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
                  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                  myIndex.setKeys(keys2.map(createKey));
                  myIndex.setSources(docs);
                  myIndex.create();
                  return myIndex;
                }
                function parseIndex(data3, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
                  const { keys: keys2, records } = data3;
                  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                  myIndex.setKeys(keys2);
                  myIndex.setIndexRecords(records);
                  return myIndex;
                }
                function computeScore$1(pattern, {
                  errors = 0,
                  currentLocation = 0,
                  expectedLocation = 0,
                  distance = Config.distance,
                  ignoreLocation = Config.ignoreLocation
                } = {}) {
                  const accuracy = errors / pattern.length;
                  if (ignoreLocation) {
                    return accuracy;
                  }
                  const proximity = Math.abs(expectedLocation - currentLocation);
                  if (!distance) {
                    return proximity ? 1 : accuracy;
                  }
                  return accuracy + proximity / distance;
                }
                function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
                  let indices = [];
                  let start2 = -1;
                  let end = -1;
                  let i2 = 0;
                  for (let len = matchmask.length; i2 < len; i2 += 1) {
                    let match2 = matchmask[i2];
                    if (match2 && start2 === -1) {
                      start2 = i2;
                    } else if (!match2 && start2 !== -1) {
                      end = i2 - 1;
                      if (end - start2 + 1 >= minMatchCharLength) {
                        indices.push([start2, end]);
                      }
                      start2 = -1;
                    }
                  }
                  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
                    indices.push([start2, i2 - 1]);
                  }
                  return indices;
                }
                const MAX_BITS = 32;
                function search2(text2, pattern, patternAlphabet, {
                  location = Config.location,
                  distance = Config.distance,
                  threshold = Config.threshold,
                  findAllMatches = Config.findAllMatches,
                  minMatchCharLength = Config.minMatchCharLength,
                  includeMatches = Config.includeMatches,
                  ignoreLocation = Config.ignoreLocation
                } = {}) {
                  if (pattern.length > MAX_BITS) {
                    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
                  }
                  const patternLen = pattern.length;
                  const textLen = text2.length;
                  const expectedLocation = Math.max(0, Math.min(location, textLen));
                  let currentThreshold = threshold;
                  let bestLocation = expectedLocation;
                  const computeMatches = minMatchCharLength > 1 || includeMatches;
                  const matchMask = computeMatches ? Array(textLen) : [];
                  let index2;
                  while ((index2 = text2.indexOf(pattern, bestLocation)) > -1) {
                    let score = computeScore$1(pattern, {
                      currentLocation: index2,
                      expectedLocation,
                      distance,
                      ignoreLocation
                    });
                    currentThreshold = Math.min(score, currentThreshold);
                    bestLocation = index2 + patternLen;
                    if (computeMatches) {
                      let i2 = 0;
                      while (i2 < patternLen) {
                        matchMask[index2 + i2] = 1;
                        i2 += 1;
                      }
                    }
                  }
                  bestLocation = -1;
                  let lastBitArr = [];
                  let finalScore = 1;
                  let binMax = patternLen + textLen;
                  const mask = 1 << patternLen - 1;
                  for (let i2 = 0; i2 < patternLen; i2 += 1) {
                    let binMin = 0;
                    let binMid = binMax;
                    while (binMin < binMid) {
                      const score2 = computeScore$1(pattern, {
                        errors: i2,
                        currentLocation: expectedLocation + binMid,
                        expectedLocation,
                        distance,
                        ignoreLocation
                      });
                      if (score2 <= currentThreshold) {
                        binMin = binMid;
                      } else {
                        binMax = binMid;
                      }
                      binMid = Math.floor((binMax - binMin) / 2 + binMin);
                    }
                    binMax = binMid;
                    let start2 = Math.max(1, expectedLocation - binMid + 1);
                    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
                    let bitArr = Array(finish + 2);
                    bitArr[finish + 1] = (1 << i2) - 1;
                    for (let j = finish; j >= start2; j -= 1) {
                      let currentLocation = j - 1;
                      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
                      if (computeMatches) {
                        matchMask[currentLocation] = +!!charMatch;
                      }
                      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
                      if (i2) {
                        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
                      }
                      if (bitArr[j] & mask) {
                        finalScore = computeScore$1(pattern, {
                          errors: i2,
                          currentLocation,
                          expectedLocation,
                          distance,
                          ignoreLocation
                        });
                        if (finalScore <= currentThreshold) {
                          currentThreshold = finalScore;
                          bestLocation = currentLocation;
                          if (bestLocation <= expectedLocation) {
                            break;
                          }
                          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
                        }
                      }
                    }
                    const score = computeScore$1(pattern, {
                      errors: i2 + 1,
                      currentLocation: expectedLocation,
                      expectedLocation,
                      distance,
                      ignoreLocation
                    });
                    if (score > currentThreshold) {
                      break;
                    }
                    lastBitArr = bitArr;
                  }
                  const result = {
                    isMatch: bestLocation >= 0,
                    // Count exact matches (those with a score of 0) to be "almost" exact
                    score: Math.max(1e-3, finalScore)
                  };
                  if (computeMatches) {
                    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
                    if (!indices.length) {
                      result.isMatch = false;
                    } else if (includeMatches) {
                      result.indices = indices;
                    }
                  }
                  return result;
                }
                function createPatternAlphabet(pattern) {
                  let mask = {};
                  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
                    const char = pattern.charAt(i2);
                    mask[char] = (mask[char] || 0) | 1 << len - i2 - 1;
                  }
                  return mask;
                }
                class BitapSearch {
                  constructor(pattern, {
                    location = Config.location,
                    threshold = Config.threshold,
                    distance = Config.distance,
                    includeMatches = Config.includeMatches,
                    findAllMatches = Config.findAllMatches,
                    minMatchCharLength = Config.minMatchCharLength,
                    isCaseSensitive = Config.isCaseSensitive,
                    ignoreLocation = Config.ignoreLocation
                  } = {}) {
                    this.options = {
                      location,
                      threshold,
                      distance,
                      includeMatches,
                      findAllMatches,
                      minMatchCharLength,
                      isCaseSensitive,
                      ignoreLocation
                    };
                    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                    this.chunks = [];
                    if (!this.pattern.length) {
                      return;
                    }
                    const addChunk = (pattern2, startIndex) => {
                      this.chunks.push({
                        pattern: pattern2,
                        alphabet: createPatternAlphabet(pattern2),
                        startIndex
                      });
                    };
                    const len = this.pattern.length;
                    if (len > MAX_BITS) {
                      let i2 = 0;
                      const remainder = len % MAX_BITS;
                      const end = len - remainder;
                      while (i2 < end) {
                        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
                        i2 += MAX_BITS;
                      }
                      if (remainder) {
                        const startIndex = len - MAX_BITS;
                        addChunk(this.pattern.substr(startIndex), startIndex);
                      }
                    } else {
                      addChunk(this.pattern, 0);
                    }
                  }
                  searchIn(text2) {
                    const { isCaseSensitive, includeMatches } = this.options;
                    if (!isCaseSensitive) {
                      text2 = text2.toLowerCase();
                    }
                    if (this.pattern === text2) {
                      let result2 = {
                        isMatch: true,
                        score: 0
                      };
                      if (includeMatches) {
                        result2.indices = [[0, text2.length - 1]];
                      }
                      return result2;
                    }
                    const {
                      location,
                      distance,
                      threshold,
                      findAllMatches,
                      minMatchCharLength,
                      ignoreLocation
                    } = this.options;
                    let allIndices = [];
                    let totalScore = 0;
                    let hasMatches = false;
                    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
                      const { isMatch, score, indices } = search2(text2, pattern, alphabet, {
                        location: location + startIndex,
                        distance,
                        threshold,
                        findAllMatches,
                        minMatchCharLength,
                        includeMatches,
                        ignoreLocation
                      });
                      if (isMatch) {
                        hasMatches = true;
                      }
                      totalScore += score;
                      if (isMatch && indices) {
                        allIndices = [...allIndices, ...indices];
                      }
                    });
                    let result = {
                      isMatch: hasMatches,
                      score: hasMatches ? totalScore / this.chunks.length : 1
                    };
                    if (hasMatches && includeMatches) {
                      result.indices = allIndices;
                    }
                    return result;
                  }
                }
                class BaseMatch {
                  constructor(pattern) {
                    this.pattern = pattern;
                  }
                  static isMultiMatch(pattern) {
                    return getMatch(pattern, this.multiRegex);
                  }
                  static isSingleMatch(pattern) {
                    return getMatch(pattern, this.singleRegex);
                  }
                  search() {
                  }
                }
                function getMatch(pattern, exp) {
                  const matches = pattern.match(exp);
                  return matches ? matches[1] : null;
                }
                class ExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "exact";
                  }
                  static get multiRegex() {
                    return /^="(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^=(.*)$/;
                  }
                  search(text2) {
                    const isMatch = text2 === this.pattern;
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [0, this.pattern.length - 1]
                    };
                  }
                }
                class InverseExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "inverse-exact";
                  }
                  static get multiRegex() {
                    return /^!"(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^!(.*)$/;
                  }
                  search(text2) {
                    const index2 = text2.indexOf(this.pattern);
                    const isMatch = index2 === -1;
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [0, text2.length - 1]
                    };
                  }
                }
                class PrefixExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "prefix-exact";
                  }
                  static get multiRegex() {
                    return /^\^"(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^\^(.*)$/;
                  }
                  search(text2) {
                    const isMatch = text2.startsWith(this.pattern);
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [0, this.pattern.length - 1]
                    };
                  }
                }
                class InversePrefixExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "inverse-prefix-exact";
                  }
                  static get multiRegex() {
                    return /^!\^"(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^!\^(.*)$/;
                  }
                  search(text2) {
                    const isMatch = !text2.startsWith(this.pattern);
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [0, text2.length - 1]
                    };
                  }
                }
                class SuffixExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "suffix-exact";
                  }
                  static get multiRegex() {
                    return /^"(.*)"\$$/;
                  }
                  static get singleRegex() {
                    return /^(.*)\$$/;
                  }
                  search(text2) {
                    const isMatch = text2.endsWith(this.pattern);
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [text2.length - this.pattern.length, text2.length - 1]
                    };
                  }
                }
                class InverseSuffixExactMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "inverse-suffix-exact";
                  }
                  static get multiRegex() {
                    return /^!"(.*)"\$$/;
                  }
                  static get singleRegex() {
                    return /^!(.*)\$$/;
                  }
                  search(text2) {
                    const isMatch = !text2.endsWith(this.pattern);
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices: [0, text2.length - 1]
                    };
                  }
                }
                class FuzzyMatch extends BaseMatch {
                  constructor(pattern, {
                    location = Config.location,
                    threshold = Config.threshold,
                    distance = Config.distance,
                    includeMatches = Config.includeMatches,
                    findAllMatches = Config.findAllMatches,
                    minMatchCharLength = Config.minMatchCharLength,
                    isCaseSensitive = Config.isCaseSensitive,
                    ignoreLocation = Config.ignoreLocation
                  } = {}) {
                    super(pattern);
                    this._bitapSearch = new BitapSearch(pattern, {
                      location,
                      threshold,
                      distance,
                      includeMatches,
                      findAllMatches,
                      minMatchCharLength,
                      isCaseSensitive,
                      ignoreLocation
                    });
                  }
                  static get type() {
                    return "fuzzy";
                  }
                  static get multiRegex() {
                    return /^"(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^(.*)$/;
                  }
                  search(text2) {
                    return this._bitapSearch.searchIn(text2);
                  }
                }
                class IncludeMatch extends BaseMatch {
                  constructor(pattern) {
                    super(pattern);
                  }
                  static get type() {
                    return "include";
                  }
                  static get multiRegex() {
                    return /^'"(.*)"$/;
                  }
                  static get singleRegex() {
                    return /^'(.*)$/;
                  }
                  search(text2) {
                    let location = 0;
                    let index2;
                    const indices = [];
                    const patternLen = this.pattern.length;
                    while ((index2 = text2.indexOf(this.pattern, location)) > -1) {
                      location = index2 + patternLen;
                      indices.push([index2, location - 1]);
                    }
                    const isMatch = !!indices.length;
                    return {
                      isMatch,
                      score: isMatch ? 0 : 1,
                      indices
                    };
                  }
                }
                const searchers = [
                  ExactMatch,
                  IncludeMatch,
                  PrefixExactMatch,
                  InversePrefixExactMatch,
                  InverseSuffixExactMatch,
                  SuffixExactMatch,
                  InverseExactMatch,
                  FuzzyMatch
                ];
                const searchersLen = searchers.length;
                const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
                const OR_TOKEN = "|";
                function parseQuery(pattern, options2 = {}) {
                  return pattern.split(OR_TOKEN).map((item3) => {
                    let query = item3.trim().split(SPACE_RE).filter((item4) => item4 && !!item4.trim());
                    let results = [];
                    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
                      const queryItem = query[i2];
                      let found = false;
                      let idx = -1;
                      while (!found && ++idx < searchersLen) {
                        const searcher = searchers[idx];
                        let token2 = searcher.isMultiMatch(queryItem);
                        if (token2) {
                          results.push(new searcher(token2, options2));
                          found = true;
                        }
                      }
                      if (found) {
                        continue;
                      }
                      idx = -1;
                      while (++idx < searchersLen) {
                        const searcher = searchers[idx];
                        let token2 = searcher.isSingleMatch(queryItem);
                        if (token2) {
                          results.push(new searcher(token2, options2));
                          break;
                        }
                      }
                    }
                    return results;
                  });
                }
                const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
                class ExtendedSearch {
                  constructor(pattern, {
                    isCaseSensitive = Config.isCaseSensitive,
                    includeMatches = Config.includeMatches,
                    minMatchCharLength = Config.minMatchCharLength,
                    ignoreLocation = Config.ignoreLocation,
                    findAllMatches = Config.findAllMatches,
                    location = Config.location,
                    threshold = Config.threshold,
                    distance = Config.distance
                  } = {}) {
                    this.query = null;
                    this.options = {
                      isCaseSensitive,
                      includeMatches,
                      minMatchCharLength,
                      findAllMatches,
                      ignoreLocation,
                      location,
                      threshold,
                      distance
                    };
                    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                    this.query = parseQuery(this.pattern, this.options);
                  }
                  static condition(_2, options2) {
                    return options2.useExtendedSearch;
                  }
                  searchIn(text2) {
                    const query = this.query;
                    if (!query) {
                      return {
                        isMatch: false,
                        score: 1
                      };
                    }
                    const { includeMatches, isCaseSensitive } = this.options;
                    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
                    let numMatches = 0;
                    let allIndices = [];
                    let totalScore = 0;
                    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
                      const searchers2 = query[i2];
                      allIndices.length = 0;
                      numMatches = 0;
                      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
                        const searcher = searchers2[j];
                        const { isMatch, indices, score } = searcher.search(text2);
                        if (isMatch) {
                          numMatches += 1;
                          totalScore += score;
                          if (includeMatches) {
                            const type = searcher.constructor.type;
                            if (MultiMatchSet.has(type)) {
                              allIndices = [...allIndices, ...indices];
                            } else {
                              allIndices.push(indices);
                            }
                          }
                        } else {
                          totalScore = 0;
                          numMatches = 0;
                          allIndices.length = 0;
                          break;
                        }
                      }
                      if (numMatches) {
                        let result = {
                          isMatch: true,
                          score: totalScore / numMatches
                        };
                        if (includeMatches) {
                          result.indices = allIndices;
                        }
                        return result;
                      }
                    }
                    return {
                      isMatch: false,
                      score: 1
                    };
                  }
                }
                const registeredSearchers = [];
                function register(...args) {
                  registeredSearchers.push(...args);
                }
                function createSearcher(pattern, options2) {
                  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
                    let searcherClass = registeredSearchers[i2];
                    if (searcherClass.condition(pattern, options2)) {
                      return new searcherClass(pattern, options2);
                    }
                  }
                  return new BitapSearch(pattern, options2);
                }
                const LogicalOperator = {
                  AND: "$and",
                  OR: "$or"
                };
                const KeyType = {
                  PATH: "$path",
                  PATTERN: "$val"
                };
                const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
                const isPath = (query) => !!query[KeyType.PATH];
                const isLeaf = (query) => !isArray2(query) && isObject2(query) && !isExpression(query);
                const convertToExplicit = (query) => ({
                  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
                    [key]: query[key]
                  }))
                });
                function parse2(query, options2, { auto = true } = {}) {
                  const next = (query2) => {
                    let keys2 = Object.keys(query2);
                    const isQueryPath = isPath(query2);
                    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
                      return next(convertToExplicit(query2));
                    }
                    if (isLeaf(query2)) {
                      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
                      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
                      if (!isString2(pattern)) {
                        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
                      }
                      const obj = {
                        keyId: createKeyId(key),
                        pattern
                      };
                      if (auto) {
                        obj.searcher = createSearcher(pattern, options2);
                      }
                      return obj;
                    }
                    let node = {
                      children: [],
                      operator: keys2[0]
                    };
                    keys2.forEach((key) => {
                      const value2 = query2[key];
                      if (isArray2(value2)) {
                        value2.forEach((item3) => {
                          node.children.push(next(item3));
                        });
                      }
                    });
                    return node;
                  };
                  if (!isExpression(query)) {
                    query = convertToExplicit(query);
                  }
                  return next(query);
                }
                function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
                  results.forEach((result) => {
                    let totalScore = 1;
                    result.matches.forEach(({ key, norm: norm2, score }) => {
                      const weight = key ? key.weight : null;
                      totalScore *= Math.pow(
                        score === 0 && weight ? Number.EPSILON : score,
                        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
                      );
                    });
                    result.score = totalScore;
                  });
                }
                function transformMatches(result, data3) {
                  const matches = result.matches;
                  data3.matches = [];
                  if (!isDefined(matches)) {
                    return;
                  }
                  matches.forEach((match2) => {
                    if (!isDefined(match2.indices) || !match2.indices.length) {
                      return;
                    }
                    const { indices, value: value2 } = match2;
                    let obj = {
                      indices,
                      value: value2
                    };
                    if (match2.key) {
                      obj.key = match2.key.src;
                    }
                    if (match2.idx > -1) {
                      obj.refIndex = match2.idx;
                    }
                    data3.matches.push(obj);
                  });
                }
                function transformScore(result, data3) {
                  data3.score = result.score;
                }
                function format7(results, docs, {
                  includeMatches = Config.includeMatches,
                  includeScore = Config.includeScore
                } = {}) {
                  const transformers = [];
                  if (includeMatches) transformers.push(transformMatches);
                  if (includeScore) transformers.push(transformScore);
                  return results.map((result) => {
                    const { idx } = result;
                    const data3 = {
                      item: docs[idx],
                      refIndex: idx
                    };
                    if (transformers.length) {
                      transformers.forEach((transformer2) => {
                        transformer2(result, data3);
                      });
                    }
                    return data3;
                  });
                }
                class Fuse {
                  constructor(docs, options2 = {}, index2) {
                    this.options = { ...Config, ...options2 };
                    if (this.options.useExtendedSearch && false) {
                    }
                    this._keyStore = new KeyStore(this.options.keys);
                    this.setCollection(docs, index2);
                  }
                  setCollection(docs, index2) {
                    this._docs = docs;
                    if (index2 && !(index2 instanceof FuseIndex)) {
                      throw new Error(INCORRECT_INDEX_TYPE);
                    }
                    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
                      getFn: this.options.getFn,
                      fieldNormWeight: this.options.fieldNormWeight
                    });
                  }
                  add(doc) {
                    if (!isDefined(doc)) {
                      return;
                    }
                    this._docs.push(doc);
                    this._myIndex.add(doc);
                  }
                  remove(predicate = () => false) {
                    const results = [];
                    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
                      const doc = this._docs[i2];
                      if (predicate(doc, i2)) {
                        this.removeAt(i2);
                        i2 -= 1;
                        len -= 1;
                        results.push(doc);
                      }
                    }
                    return results;
                  }
                  removeAt(idx) {
                    this._docs.splice(idx, 1);
                    this._myIndex.removeAt(idx);
                  }
                  getIndex() {
                    return this._myIndex;
                  }
                  search(query, { limit: limit2 = -1 } = {}) {
                    const {
                      includeMatches,
                      includeScore,
                      shouldSort,
                      sortFn,
                      ignoreFieldNorm
                    } = this.options;
                    let results = isString2(query) ? isString2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
                    computeScore(results, { ignoreFieldNorm });
                    if (shouldSort) {
                      results.sort(sortFn);
                    }
                    if (isNumber2(limit2) && limit2 > -1) {
                      results = results.slice(0, limit2);
                    }
                    return format7(results, this._docs, {
                      includeMatches,
                      includeScore
                    });
                  }
                  _searchStringList(query) {
                    const searcher = createSearcher(query, this.options);
                    const { records } = this._myIndex;
                    const results = [];
                    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
                      if (!isDefined(text2)) {
                        return;
                      }
                      const { isMatch, score, indices } = searcher.searchIn(text2);
                      if (isMatch) {
                        results.push({
                          item: text2,
                          idx,
                          matches: [{ score, value: text2, norm: norm2, indices }]
                        });
                      }
                    });
                    return results;
                  }
                  _searchLogical(query) {
                    const expression = parse2(query, this.options);
                    const evaluate2 = (node, item3, idx) => {
                      if (!node.children) {
                        const { keyId, searcher } = node;
                        const matches = this._findMatches({
                          key: this._keyStore.get(keyId),
                          value: this._myIndex.getValueForItemAtKeyId(item3, keyId),
                          searcher
                        });
                        if (matches && matches.length) {
                          return [
                            {
                              idx,
                              item: item3,
                              matches
                            }
                          ];
                        }
                        return [];
                      }
                      const res = [];
                      for (let i2 = 0, len = node.children.length; i2 < len; i2 += 1) {
                        const child = node.children[i2];
                        const result = evaluate2(child, item3, idx);
                        if (result.length) {
                          res.push(...result);
                        } else if (node.operator === LogicalOperator.AND) {
                          return [];
                        }
                      }
                      return res;
                    };
                    const records = this._myIndex.records;
                    const resultMap = {};
                    const results = [];
                    records.forEach(({ $: item3, i: idx }) => {
                      if (isDefined(item3)) {
                        let expResults = evaluate2(expression, item3, idx);
                        if (expResults.length) {
                          if (!resultMap[idx]) {
                            resultMap[idx] = { idx, item: item3, matches: [] };
                            results.push(resultMap[idx]);
                          }
                          expResults.forEach(({ matches }) => {
                            resultMap[idx].matches.push(...matches);
                          });
                        }
                      }
                    });
                    return results;
                  }
                  _searchObjectList(query) {
                    const searcher = createSearcher(query, this.options);
                    const { keys: keys2, records } = this._myIndex;
                    const results = [];
                    records.forEach(({ $: item3, i: idx }) => {
                      if (!isDefined(item3)) {
                        return;
                      }
                      let matches = [];
                      keys2.forEach((key, keyIndex) => {
                        matches.push(
                          ...this._findMatches({
                            key,
                            value: item3[keyIndex],
                            searcher
                          })
                        );
                      });
                      if (matches.length) {
                        results.push({
                          idx,
                          item: item3,
                          matches
                        });
                      }
                    });
                    return results;
                  }
                  _findMatches({ key, value: value2, searcher }) {
                    if (!isDefined(value2)) {
                      return [];
                    }
                    let matches = [];
                    if (isArray2(value2)) {
                      value2.forEach(({ v: text2, i: idx, n: norm2 }) => {
                        if (!isDefined(text2)) {
                          return;
                        }
                        const { isMatch, score, indices } = searcher.searchIn(text2);
                        if (isMatch) {
                          matches.push({
                            score,
                            key,
                            value: text2,
                            idx,
                            norm: norm2,
                            indices
                          });
                        }
                      });
                    } else {
                      const { v: text2, n: norm2 } = value2;
                      const { isMatch, score, indices } = searcher.searchIn(text2);
                      if (isMatch) {
                        matches.push({ score, key, value: text2, norm: norm2, indices });
                      }
                    }
                    return matches;
                  }
                }
                Fuse.version = "6.6.2";
                Fuse.createIndex = createIndex;
                Fuse.parseIndex = parseIndex;
                Fuse.config = Config;
                {
                  Fuse.parseQuery = parse2;
                }
                {
                  register(ExtendedSearch);
                }
              }
            ),
            /***/
            791: (
              /***/
              function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  "__DO_NOT_USE__ActionTypes": function() {
                    return (
                      /* binding */
                      ActionTypes
                    );
                  },
                  "applyMiddleware": function() {
                    return (
                      /* binding */
                      applyMiddleware
                    );
                  },
                  "bindActionCreators": function() {
                    return (
                      /* binding */
                      bindActionCreators
                    );
                  },
                  "combineReducers": function() {
                    return (
                      /* binding */
                      combineReducers
                    );
                  },
                  "compose": function() {
                    return (
                      /* binding */
                      compose
                    );
                  },
                  "createStore": function() {
                    return (
                      /* binding */
                      createStore
                    );
                  },
                  "legacy_createStore": function() {
                    return (
                      /* binding */
                      legacy_createStore
                    );
                  }
                });
                ;
                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                    return typeof obj2;
                  } : function(obj2) {
                    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                  }, _typeof(obj);
                }
                ;
                function _toPrimitive(input12, hint) {
                  if (_typeof(input12) !== "object" || input12 === null) return input12;
                  var prim = input12[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input12, hint || "default");
                    if (_typeof(res) !== "object") return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input12);
                }
                ;
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return _typeof(key) === "symbol" ? key : String(key);
                }
                ;
                function _defineProperty(obj, key, value2) {
                  key = _toPropertyKey(key);
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value: value2,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value2;
                  }
                  return obj;
                }
                ;
                function ownKeys(object3, enumerableOnly) {
                  var keys2 = Object.keys(object3);
                  if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object3);
                    enumerableOnly && (symbols = symbols.filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
                    })), keys2.push.apply(keys2, symbols);
                  }
                  return keys2;
                }
                function _objectSpread2(target) {
                  for (var i2 = 1; i2 < arguments.length; i2++) {
                    var source2 = null != arguments[i2] ? arguments[i2] : {};
                    i2 % 2 ? ownKeys(Object(source2), true).forEach(function(key) {
                      _defineProperty(target, key, source2[key]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
                    });
                  }
                  return target;
                }
                ;
                function formatProdErrorMessage(code2) {
                  return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
                }
                var $$observable = function() {
                  return typeof Symbol === "function" && Symbol.observable || "@@observable";
                }();
                var randomString = function randomString2() {
                  return Math.random().toString(36).substring(7).split("").join(".");
                };
                var ActionTypes = {
                  INIT: "@@redux/INIT" + randomString(),
                  REPLACE: "@@redux/REPLACE" + randomString(),
                  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
                  }
                };
                function isPlainObject2(obj) {
                  if (typeof obj !== "object" || obj === null) return false;
                  var proto = obj;
                  while (Object.getPrototypeOf(proto) !== null) {
                    proto = Object.getPrototypeOf(proto);
                  }
                  return Object.getPrototypeOf(obj) === proto;
                }
                function miniKindOf(val) {
                  if (val === void 0) return "undefined";
                  if (val === null) return "null";
                  var type = typeof val;
                  switch (type) {
                    case "boolean":
                    case "string":
                    case "number":
                    case "symbol":
                    case "function": {
                      return type;
                    }
                  }
                  if (Array.isArray(val)) return "array";
                  if (isDate(val)) return "date";
                  if (isError(val)) return "error";
                  var constructorName = ctorName(val);
                  switch (constructorName) {
                    case "Symbol":
                    case "Promise":
                    case "WeakMap":
                    case "WeakSet":
                    case "Map":
                    case "Set":
                      return constructorName;
                  }
                  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
                }
                function ctorName(val) {
                  return typeof val.constructor === "function" ? val.constructor.name : null;
                }
                function isError(val) {
                  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
                }
                function isDate(val) {
                  if (val instanceof Date) return true;
                  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
                }
                function kindOf(val) {
                  var typeOfVal = typeof val;
                  if (false) {
                  }
                  return typeOfVal;
                }
                function createStore(reducer, preloadedState, enhancer) {
                  var _ref2;
                  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
                    throw new Error(true ? formatProdErrorMessage(0) : 0);
                  }
                  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                    enhancer = preloadedState;
                    preloadedState = void 0;
                  }
                  if (typeof enhancer !== "undefined") {
                    if (typeof enhancer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(1) : 0);
                    }
                    return enhancer(createStore)(reducer, preloadedState);
                  }
                  if (typeof reducer !== "function") {
                    throw new Error(true ? formatProdErrorMessage(2) : 0);
                  }
                  var currentReducer = reducer;
                  var currentState = preloadedState;
                  var currentListeners = [];
                  var nextListeners = currentListeners;
                  var isDispatching = false;
                  function ensureCanMutateNextListeners() {
                    if (nextListeners === currentListeners) {
                      nextListeners = currentListeners.slice();
                    }
                  }
                  function getState() {
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(3) : 0);
                    }
                    return currentState;
                  }
                  function subscribe(listener) {
                    if (typeof listener !== "function") {
                      throw new Error(true ? formatProdErrorMessage(4) : 0);
                    }
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(5) : 0);
                    }
                    var isSubscribed = true;
                    ensureCanMutateNextListeners();
                    nextListeners.push(listener);
                    return function unsubscribe() {
                      if (!isSubscribed) {
                        return;
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(6) : 0);
                      }
                      isSubscribed = false;
                      ensureCanMutateNextListeners();
                      var index2 = nextListeners.indexOf(listener);
                      nextListeners.splice(index2, 1);
                      currentListeners = null;
                    };
                  }
                  function dispatch(action) {
                    if (!isPlainObject2(action)) {
                      throw new Error(true ? formatProdErrorMessage(7) : 0);
                    }
                    if (typeof action.type === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(8) : 0);
                    }
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(9) : 0);
                    }
                    try {
                      isDispatching = true;
                      currentState = currentReducer(currentState, action);
                    } finally {
                      isDispatching = false;
                    }
                    var listeners = currentListeners = nextListeners;
                    for (var i2 = 0; i2 < listeners.length; i2++) {
                      var listener = listeners[i2];
                      listener();
                    }
                    return action;
                  }
                  function replaceReducer(nextReducer) {
                    if (typeof nextReducer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(10) : 0);
                    }
                    currentReducer = nextReducer;
                    dispatch({
                      type: ActionTypes.REPLACE
                    });
                  }
                  function observable() {
                    var _ref;
                    var outerSubscribe = subscribe;
                    return _ref = {
                      /**
                       * The minimal observable subscription method.
                       * @param {Object} observer Any object that can be used as an observer.
                       * The observer object should have a `next` method.
                       * @returns {subscription} An object with an `unsubscribe` method that can
                       * be used to unsubscribe the observable from the store, and prevent further
                       * emission of values from the observable.
                       */
                      subscribe: function subscribe2(observer) {
                        if (typeof observer !== "object" || observer === null) {
                          throw new Error(true ? formatProdErrorMessage(11) : 0);
                        }
                        function observeState() {
                          if (observer.next) {
                            observer.next(getState());
                          }
                        }
                        observeState();
                        var unsubscribe = outerSubscribe(observeState);
                        return {
                          unsubscribe
                        };
                      }
                    }, _ref[$$observable] = function() {
                      return this;
                    }, _ref;
                  }
                  dispatch({
                    type: ActionTypes.INIT
                  });
                  return _ref2 = {
                    dispatch,
                    subscribe,
                    getState,
                    replaceReducer
                  }, _ref2[$$observable] = observable, _ref2;
                }
                var legacy_createStore = createStore;
                function warning(message) {
                  if (typeof console !== "undefined" && typeof console.error === "function") {
                    console.error(message);
                  }
                  try {
                    throw new Error(message);
                  } catch (e) {
                  }
                }
                function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
                  var reducerKeys = Object.keys(reducers);
                  var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
                  if (reducerKeys.length === 0) {
                    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
                  }
                  if (!isPlainObject2(inputState)) {
                    return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
                  }
                  var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
                  });
                  unexpectedKeys.forEach(function(key) {
                    unexpectedKeyCache[key] = true;
                  });
                  if (action && action.type === ActionTypes.REPLACE) return;
                  if (unexpectedKeys.length > 0) {
                    return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
                  }
                }
                function assertReducerShape(reducers) {
                  Object.keys(reducers).forEach(function(key) {
                    var reducer = reducers[key];
                    var initialState = reducer(void 0, {
                      type: ActionTypes.INIT
                    });
                    if (typeof initialState === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(12) : 0);
                    }
                    if (typeof reducer(void 0, {
                      type: ActionTypes.PROBE_UNKNOWN_ACTION()
                    }) === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(13) : 0);
                    }
                  });
                }
                function combineReducers(reducers) {
                  var reducerKeys = Object.keys(reducers);
                  var finalReducers = {};
                  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
                    var key = reducerKeys[i2];
                    if (false) {
                    }
                    if (typeof reducers[key] === "function") {
                      finalReducers[key] = reducers[key];
                    }
                  }
                  var finalReducerKeys = Object.keys(finalReducers);
                  var unexpectedKeyCache;
                  if (false) {
                  }
                  var shapeAssertionError;
                  try {
                    assertReducerShape(finalReducers);
                  } catch (e) {
                    shapeAssertionError = e;
                  }
                  return function combination(state, action) {
                    if (state === void 0) {
                      state = {};
                    }
                    if (shapeAssertionError) {
                      throw shapeAssertionError;
                    }
                    if (false) {
                      var warningMessage;
                    }
                    var hasChanged = false;
                    var nextState = {};
                    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                      var _key = finalReducerKeys[_i];
                      var reducer = finalReducers[_key];
                      var previousStateForKey = state[_key];
                      var nextStateForKey = reducer(previousStateForKey, action);
                      if (typeof nextStateForKey === "undefined") {
                        var actionType = action && action.type;
                        throw new Error(true ? formatProdErrorMessage(14) : 0);
                      }
                      nextState[_key] = nextStateForKey;
                      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                    }
                    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                    return hasChanged ? nextState : state;
                  };
                }
                function bindActionCreator(actionCreator, dispatch) {
                  return function() {
                    return dispatch(actionCreator.apply(this, arguments));
                  };
                }
                function bindActionCreators(actionCreators, dispatch) {
                  if (typeof actionCreators === "function") {
                    return bindActionCreator(actionCreators, dispatch);
                  }
                  if (typeof actionCreators !== "object" || actionCreators === null) {
                    throw new Error(true ? formatProdErrorMessage(16) : 0);
                  }
                  var boundActionCreators = {};
                  for (var key in actionCreators) {
                    var actionCreator = actionCreators[key];
                    if (typeof actionCreator === "function") {
                      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
                    }
                  }
                  return boundActionCreators;
                }
                function compose() {
                  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                    funcs[_key] = arguments[_key];
                  }
                  if (funcs.length === 0) {
                    return function(arg) {
                      return arg;
                    };
                  }
                  if (funcs.length === 1) {
                    return funcs[0];
                  }
                  return funcs.reduce(function(a2, b2) {
                    return function() {
                      return a2(b2.apply(void 0, arguments));
                    };
                  });
                }
                function applyMiddleware() {
                  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                    middlewares[_key] = arguments[_key];
                  }
                  return function(createStore2) {
                    return function() {
                      var store = createStore2.apply(void 0, arguments);
                      var _dispatch = function dispatch() {
                        throw new Error(true ? formatProdErrorMessage(15) : 0);
                      };
                      var middlewareAPI = {
                        getState: store.getState,
                        dispatch: function dispatch() {
                          return _dispatch.apply(void 0, arguments);
                        }
                      };
                      var chain = middlewares.map(function(middleware) {
                        return middleware(middlewareAPI);
                      });
                      _dispatch = compose.apply(void 0, chain)(store.dispatch);
                      return _objectSpread2(_objectSpread2({}, store), {}, {
                        dispatch: _dispatch
                      });
                    };
                  };
                }
                function isCrushed() {
                }
                if (false) {
                }
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module3 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            return module3.exports;
          }
          !function() {
            __webpack_require__.n = function(module3) {
              var getter = module3 && module3.__esModule ? (
                /******/
                function() {
                  return module3["default"];
                }
              ) : (
                /******/
                function() {
                  return module3;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports5, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports5, key)) {
                  Object.defineProperty(exports5, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          !function() {
            __webpack_require__.r = function(exports5) {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports5, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports5, "__esModule", { value: true });
            };
          }();
          var __webpack_exports__ = {};
          !function() {
            var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
            var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
            var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
            var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__);
            var _scripts_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(883);
            var _scripts_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(789);
            var _scripts_templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(686);
            __webpack_exports__["default"] = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();
          }();
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        }()
      );
    });
  }
});

// node_modules/underscore.template/lib/underscore.template.js
var require_underscore_template = __commonJS({
  "node_modules/underscore.template/lib/underscore.template.js"(exports4, module2) {
    "use strict";
    var breaker = {};
    var ArrayProto = Array.prototype;
    var ObjProto = Object.prototype;
    var slice2 = ArrayProto.slice;
    var toString = ObjProto.toString;
    var hasOwnProperty = ObjProto.hasOwnProperty;
    var nativeForEach = ArrayProto.forEach;
    var nativeKeys = Object.keys;
    var nativeIsArray = Array.isArray;
    var _2 = function() {
    };
    var each = _2.each = _2.forEach = function(obj, iterator, context) {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i2 = 0, length = obj.length; i2 < length; i2++) {
          if (iterator.call(context, obj[i2], i2, obj) === breaker) return;
        }
      } else {
        var keys2 = _2.keys(obj);
        for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
          if (iterator.call(context, obj[keys2[i2]], keys2[i2], obj) === breaker) return;
        }
      }
    };
    _2.keys = nativeKeys || function(obj) {
      if (obj !== Object(obj)) throw new TypeError("Invalid object");
      var keys2 = [];
      for (var key in obj) if (_2.has(obj, key)) keys2.push(key);
      return keys2;
    };
    _2.defaults = function(obj) {
      each(slice2.call(arguments, 1), function(source2) {
        if (source2) {
          for (var prop in source2) {
            if (obj[prop] === void 0) obj[prop] = source2[prop];
          }
        }
      });
      return obj;
    };
    _2.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === "[object Array]";
    };
    _2.has = function(obj, path) {
      if (!_2.isArray(path)) {
        return obj != null && hasOwnProperty.call(obj, path);
      }
      var length = path.length;
      for (var i2 = 0; i2 < length; i2++) {
        var key = path[i2];
        if (obj == null || !hasOwnProperty.call(obj, key)) {
          return false;
        }
        obj = obj[key];
      }
      return !!length;
    };
    var entityMap = {
      escape: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;"
      }
    };
    var entityRegexes = {
      escape: new RegExp("[" + _2.keys(entityMap.escape).join("") + "]", "g")
    };
    _2.each(["escape"], function(method) {
      _2[method] = function(string2) {
        if (string2 == null) return "";
        return ("" + string2).replace(entityRegexes[method], function(match2) {
          return entityMap[method][match2];
        });
      };
    });
    _2.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "	": "t",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    _2.template = function(text2, data3, settings2) {
      var render2;
      settings2 = _2.defaults({}, settings2, _2.templateSettings);
      var matcher = new RegExp([
        (settings2.escape || noMatch).source,
        (settings2.interpolate || noMatch).source,
        (settings2.evaluate || noMatch).source
      ].join("|") + "|$", "g");
      var index2 = 0;
      var source2 = "__p+='";
      text2.replace(matcher, function(match2, escape2, interpolate2, evaluate2, offset3) {
        source2 += text2.slice(index2, offset3).replace(escaper, function(match3) {
          return "\\" + escapes[match3];
        });
        if (escape2) {
          source2 += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate2) {
          source2 += "'+\n((__t=(" + interpolate2 + "))==null?'':__t)+\n'";
        }
        if (evaluate2) {
          source2 += "';\n" + evaluate2 + "\n__p+='";
        }
        index2 = offset3 + match2.length;
        return match2;
      });
      source2 += "';\n";
      if (!settings2.variable) source2 = "with(obj||{}){\n" + source2 + "}\n";
      source2 = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source2 + "return __p;\n";
      try {
        render2 = new Function(settings2.variable || "obj", "_", source2);
      } catch (e) {
        e.source = source2;
        throw e;
      }
      if (data3) return render2(data3, _2);
      var template2 = function(data4) {
        return render2.call(this, data4, _2);
      };
      template2.source = "function(" + (settings2.variable || "obj") + "){\n" + source2 + "}";
      return template2;
    };
    module2.exports = _2;
  }
});

// node_modules/underscore.template/lib/index.js
var require_lib = __commonJS({
  "node_modules/underscore.template/lib/index.js"(exports4, module2) {
    "use strict";
    var _2 = require_underscore_template();
    var UnderscoreTemplate = _2.template;
    function Template2(text2, data3, settings2) {
      return UnderscoreTemplate(text2, data3, settings2);
    }
    Template2._ = _2;
    module2.exports = Template2;
    if (typeof define === "function" && define.amd) {
      define(function() {
        return Template2;
      });
    } else if (typeof window !== "undefined" || typeof navigator !== "undefined") {
      window.UnderscoreTemplate = Template2;
    }
  }
});

// node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "node_modules/jquery/dist/jquery.js"(exports4, module2) {
    (function(global, factory) {
      "use strict";
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        module2.exports = global.document ? factory(global, true) : function(w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
      } else {
        factory(global);
      }
    })(typeof window !== "undefined" ? window : exports4, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice2 = arr.slice;
      var flat = arr.flat ? function(array2) {
        return arr.flat.call(array2);
      } : function(array2) {
        return arr.concat.apply([], array2);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction2 = function isFunction3(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code2, node, doc) {
        doc = doc || document2;
        var i2, val, script2 = doc.createElement("script");
        script2.text = code2;
        if (node) {
          for (i2 in preservedScriptAttributes) {
            val = node[i2] || node.getAttribute && node.getAttribute(i2);
            if (val) {
              script2.setAttribute(i2, val);
            }
          }
        }
        doc.head.appendChild(script2).parentNode.removeChild(script2);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
        return new jQuery2.fn.init(selector, context);
      };
      jQuery2.fn = jQuery2.prototype = {
        // The current version of jQuery being used
        jquery: version2,
        constructor: jQuery2,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice2.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice2.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery2.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery2.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery2.map(this, function(elem, i2) {
            return callback.call(elem, i2, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice2.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
            return (i2 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
            return i2 % 2;
          }));
        },
        eq: function(i2) {
          var len = this.length, j = +i2 + (i2 < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery2.extend = jQuery2.fn.extend = function() {
        var options2, name, src, copy2, copyIsArray, clone3, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i2] || {};
          i2++;
        }
        if (typeof target !== "object" && !isFunction2(target)) {
          target = {};
        }
        if (i2 === length) {
          target = this;
          i2--;
        }
        for (; i2 < length; i2++) {
          if ((options2 = arguments[i2]) != null) {
            for (name in options2) {
              copy2 = options2[name];
              if (name === "__proto__" || target === copy2) {
                continue;
              }
              if (deep && copy2 && (jQuery2.isPlainObject(copy2) || (copyIsArray = Array.isArray(copy2)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone3 = [];
                } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                  clone3 = {};
                } else {
                  clone3 = src;
                }
                copyIsArray = false;
                target[name] = jQuery2.extend(deep, clone3, copy2);
              } else if (copy2 !== void 0) {
                target[name] = copy2;
              }
            }
          }
        }
        return target;
      };
      jQuery2.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code2, options2, doc) {
          DOMEval(code2, { nonce: options2 && options2.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i2 = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i2 < length; i2++) {
              if (callback.call(obj[i2], i2, obj[i2]) === false) {
                break;
              }
            }
          } else {
            for (i2 in obj) {
              if (callback.call(obj[i2], i2, obj[i2]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += jQuery2.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery2.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i2) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i2);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
          var len = +second.length, j = 0, i2 = first.length;
          for (; j < len; j++) {
            first[i2++] = second[j];
          }
          first.length = i2;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
          for (; i2 < length; i2++) {
            callbackInverse = !callback(elems[i2], i2);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i2]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value2, i2 = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i2 < length; i2++) {
              value2 = callback(elems[i2], i2, arg);
              if (value2 != null) {
                ret.push(value2);
              }
            }
          } else {
            for (i2 in elems) {
              value2 = callback(elems[i2], i2, arg);
              if (value2 != null) {
                ret.push(value2);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery2.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction2(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var pop = arr.pop;
      var sort2 = arr.sort;
      var splice = arr.splice;
      var whitespace2 = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$",
        "g"
      );
      jQuery2.contains = function(a2, b2) {
        var bup = b2 && b2.parentNode;
        return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "�";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery2.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push;
      (function() {
        var i2, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
          if (a2 === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push2.apply(
            arr = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: function(target, els) {
              pushNative.apply(target, slice2.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice2.call(arguments, 1));
            }
          };
        }
        function find2(selector, context, results, seed) {
          var m, i3, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
                if (m = match2[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        push2.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && find2.contains(context, elem) && elem.id === m) {
                      push2.call(results, elem);
                      return results;
                    }
                  }
                } else if (match2[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match2[3]) && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery2.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i3 = groups.length;
                  while (i3--) {
                    groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select2(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys2 = [];
          function cache(key, value2) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache[keys2.shift()];
            }
            return cache[key + " "] = value2;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert2(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled5) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled5;
                  } else {
                    return elem.disabled === disabled5;
                  }
                }
                return elem.isDisabled === disabled5 || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled5 && inDisabledFieldset(elem) === disabled5;
              }
              return elem.disabled === disabled5;
            } else if ("label" in elem) {
              return elem.disabled === disabled5;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn([], seed.length, argument), i3 = matchIndexes.length;
              while (i3--) {
                if (seed[j = matchIndexes[i3]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery2.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert2(function(el) {
            documentElement2.appendChild(el).id = jQuery2.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
          });
          support.disconnectedMatch = assert2(function(el) {
            return matches.call(el, "*");
          });
          support.scope = assert2(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert2(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i3, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i3 = 0;
                  while (elem = elems[i3++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert2(function(el) {
            var input12;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input12 = document3.createElement("input");
            input12.setAttribute("type", "hidden");
            el.appendChild(input12).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input12 = document3.createElement("input");
            input12.setAttribute("name", "");
            el.appendChild(input12);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
              if (a2 === document3 || a2.ownerDocument == preferredDoc && find2.contains(preferredDoc, a2)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument == preferredDoc && find2.contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a2) - indexOf.call(sortInput, b2) : 0;
            }
            return compare & 4 ? -1 : 1;
          };
          return document3;
        }
        find2.matches = function(expr2, elements) {
          return find2(expr2, null, null, elements);
        };
        find2.matchesSelector = function(elem, expr2) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr2 + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr2))) {
            try {
              var ret = matches.call(elem, expr2);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr2, true);
            }
          }
          return find2(expr2, document3, null, [elem]).length > 0;
        };
        find2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery2.contains(context, elem);
        };
        find2.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name);
        };
        find2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i3 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice2.call(results, 0);
          sort2.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i3++]) {
              if (elem === results[i3]) {
                j = duplicates.push(i3);
              }
            }
            while (j--) {
              splice.call(results, duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery2.fn.uniqueSort = function() {
          return this.pushStack(jQuery2.uniqueSort(slice2.apply(this)));
        };
        Expr = jQuery2.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match2) {
              match2[1] = match2[1].replace(runescape, funescape);
              match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
              if (match2[2] === "~=") {
                match2[3] = " " + match2[3] + " ";
              }
              return match2.slice(0, 4);
            },
            CHILD: function(match2) {
              match2[1] = match2[1].toLowerCase();
              if (match2[1].slice(0, 3) === "nth") {
                if (!match2[3]) {
                  find2.error(match2[0]);
                }
                match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
              } else if (match2[3]) {
                find2.error(match2[0]);
              }
              return match2;
            },
            PSEUDO: function(match2) {
              var excess, unquoted = !match2[6] && match2[2];
              if (matchExpr.CHILD.test(match2[0])) {
                return null;
              }
              if (match2[3]) {
                match2[2] = match2[4] || match2[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match2[0] = match2[0].slice(0, excess);
                match2[2] = unquoted.slice(0, excess);
              }
              return match2.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name, operator, check2) {
              return function(elem) {
                var result = find2.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                if (operator === "=") {
                  return result === check2;
                }
                if (operator === "!=") {
                  return result !== check2;
                }
                if (operator === "^=") {
                  return check2 && result.indexOf(check2) === 0;
                }
                if (operator === "*=") {
                  return check2 && result.indexOf(check2) > -1;
                }
                if (operator === "$=") {
                  return check2 && result.slice(-check2.length) === check2;
                }
                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check2) > -1;
                }
                if (operator === "|=") {
                  return result === check2 || result.slice(0, check2.length + 1) === check2 + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first, last2) {
              var simple = type.slice(0, 3) !== "nth", forward2 = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last2 === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, outerCache, node, nodeIndex, start2, dir2 = simple !== forward2 ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward2 ? parent.firstChild : parent.lastChild];
                  if (forward2 && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start2.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last2;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i3 = matched.length;
                  while (i3--) {
                    idx = indexOf.call(seed, matched[i3]);
                    seed[idx] = !(matches2[idx] = matched[i3]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input12 = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                while (i3--) {
                  if (elem = unmatched[i3]) {
                    seed[i3] = !(matches2[i3] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input12[0] = elem;
                matcher(input12, null, xml, results);
                input12[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find2(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text2) {
              text2 = text2.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery2.text(elem)).indexOf(text2) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr2;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr2 = elem.getAttribute("type")) == null || attr2.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 0;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i3 = 1;
              for (; i3 < length; i3 += 2) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3;
              if (argument < 0) {
                i3 = argument + length;
              } else if (argument > length) {
                i3 = length;
              } else {
                i3 = argument;
              }
              for (; --i3 >= 0; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i3 = argument < 0 ? argument + length : argument;
              for (; ++i3 < length; ) {
                matchIndexes.push(i3);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i2] = createInputPseudo(i2);
        }
        for (i2 in { submit: true, reset: true }) {
          Expr.pseudos[i2] = createButtonPseudo(i2);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match2 = rcomma.exec(soFar))) {
              if (match2) {
                soFar = soFar.slice(match2[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match2 = rleadingCombinator.exec(soFar)) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match2[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
                matched = match2.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match2
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i3 = 0, len = tokens.length, selector = "";
          for (; i3 < len; i3++) {
            selector += tokens[i3].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base2) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base2 && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i3 = matchers.length;
            while (i3--) {
              if (!matchers[i3](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i3 = 0, len = contexts.length;
          for (; i3 < len; i3++) {
            find2(selector, contexts[i3], results);
          }
          return results;
        }
        function condense(unmatched, map4, filter2, context, xml) {
          var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map4 != null;
          for (; i3 < len; i3++) {
            if (elem = unmatched[i3]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map4.push(i3);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i3, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i3 = temp.length;
              while (i3--) {
                if (elem = temp[i3]) {
                  matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i3 = matcherOut.length;
                  while (i3--) {
                    if (elem = matcherOut[i3]) {
                      temp.push(matcherIn[i3] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i3 = matcherOut.length;
                while (i3--) {
                  if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i3]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i3 < len; i3++) {
            if (matcher = Expr.relative[tokens[i3].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
              if (matcher[expando]) {
                j = ++i3;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i3 > 1 && elementMatcher(matchers),
                  i3 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher,
                  i3 < j && matcherFromTokens(tokens.slice(i3, j)),
                  j < len && matcherFromTokens(tokens = tokens.slice(j)),
                  j < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    push2.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i3;
            if (bySet && i3 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i3--) {
                    if (!(unmatched[i3] || setMatched[i3])) {
                      setMatched[i3] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match2) {
          var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match2) {
              match2 = tokenize(selector);
            }
            i3 = match2.length;
            while (i3--) {
              cached = matcherFromTokens(match2[i3]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select2(selector, context, results, seed) {
          var i3, tokens, token2, type, find3, compiled = typeof selector === "function" && selector, match2 = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match2.length === 1) {
            tokens = match2[0] = match2[0].slice(0);
            if (tokens.length > 2 && (token2 = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token2.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i3 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i3--) {
              token2 = tokens[i3];
              if (Expr.relative[type = token2.type]) {
                break;
              }
              if (find3 = Expr.find[type]) {
                if (seed = find3(
                  token2.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i3, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match2))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert2(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery2.find = find2;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.unique = jQuery2.uniqueSort;
        find2.compile = compile;
        find2.select = select2;
        find2.setDocument = setDocument;
        find2.tokenize = tokenize;
        find2.escape = jQuery2.escapeSelector;
        find2.getText = jQuery2.text;
        find2.isXML = jQuery2.isXMLDoc;
        find2.selectors = jQuery2.expr;
        find2.support = jQuery2.support;
        find2.uniqueSort = jQuery2.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery2(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n2, elem) {
        var matched = [];
        for (; n2; n2 = n2.nextSibling) {
          if (n2.nodeType === 1 && n2 !== elem) {
            matched.push(n2);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery2.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction2(qualifier)) {
          return jQuery2.grep(elements, function(elem, i2) {
            return !!qualifier.call(elem, i2, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery2.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery2.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery2.filter(qualifier, elements, not);
      }
      jQuery2.filter = function(expr2, elems, not) {
        var elem = elems[0];
        if (not) {
          expr2 = ":not(" + expr2 + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery2.find.matchesSelector(elem, expr2) ? [elem] : [];
        }
        return jQuery2.find.matches(expr2, jQuery2.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery2.fn.extend({
        find: function(selector) {
          var i2, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery2(selector).filter(function() {
              for (i2 = 0; i2 < len; i2++) {
                if (jQuery2.contains(self2[i2], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i2 = 0; i2 < len; i2++) {
            jQuery2.find(selector, self2[i2], ret);
          }
          return len > 1 ? jQuery2.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init4 = jQuery2.fn.init = function(selector, context, root) {
        var match2, elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match2 = [null, selector, null];
          } else {
            match2 = rquickExpr.exec(selector);
          }
          if (match2 && (match2[1] || !context)) {
            if (match2[1]) {
              context = context instanceof jQuery2 ? context[0] : context;
              jQuery2.merge(this, jQuery2.parseHTML(
                match2[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match2[1]) && jQuery2.isPlainObject(context)) {
                for (match2 in context) {
                  if (isFunction2(this[match2])) {
                    this[match2](context[match2]);
                  } else {
                    this.attr(match2, context[match2]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match2[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction2(selector)) {
          return root.ready !== void 0 ? root.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery2)
          );
        }
        return jQuery2.makeArray(selector, this);
      };
      init4.prototype = jQuery2.fn;
      rootjQuery = jQuery2(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery2.fn.extend({
        has: function(target) {
          var targets = jQuery2(target, this), l = targets.length;
          return this.filter(function() {
            var i2 = 0;
            for (; i2 < l; i2++) {
              if (jQuery2.contains(this, targets[i2])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i2 = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i2 < l; i2++) {
              for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery2(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery2.uniqueSort(
              jQuery2.merge(this.get(), jQuery2(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery2.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery2.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery2.fn[name] = function(until, selector) {
          var matched = jQuery2.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery2.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery2.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options2) {
        var object3 = {};
        jQuery2.each(options2.match(rnothtmlwhite) || [], function(_2, flag) {
          object3[flag] = true;
        });
        return object3;
      }
      jQuery2.Callbacks = function(options2) {
        options2 = typeof options2 === "string" ? createOptions(options2) : jQuery2.extend({}, options2);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options2.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options2.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options2.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add2(args) {
                jQuery2.each(args, function(_2, arg) {
                  if (isFunction2(arg)) {
                    if (!options2.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add2(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery2.each(arguments, function(_2, arg) {
              var index2;
              while ((index2 = jQuery2.inArray(arg, list, index2)) > -1) {
                list.splice(index2, 1);
                if (index2 <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn) {
            return fn ? jQuery2.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v) {
        return v;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value2, resolve, reject, noValue) {
        var method;
        try {
          if (value2 && isFunction2(method = value2.promise)) {
            method.call(value2).done(resolve).fail(reject);
          } else if (value2 && isFunction2(method = value2.then)) {
            method.call(value2, resolve, reject);
          } else {
            resolve.apply(void 0, [value2].slice(noValue));
          }
        } catch (value3) {
          reject.apply(void 0, [value3]);
        }
      }
      jQuery2.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery2.Callbacks("memory"),
              jQuery2.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery2.Deferred(function(newDefer) {
                jQuery2.each(tuples, function(_i, tuple) {
                  var fn = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction2(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction2(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery2.Deferred.exceptionHook) {
                        jQuery2.Deferred.exceptionHook(
                          e,
                          process.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery2.Deferred.getErrorHook) {
                      process.error = jQuery2.Deferred.getErrorHook();
                    } else if (jQuery2.Deferred.getStackHook) {
                      process.error = jQuery2.Deferred.getStackHook();
                    }
                    window2.setTimeout(process);
                  }
                };
              }
              return jQuery2.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery2.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery2.each(tuples, function(i2, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i2][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i2][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice2.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i3) {
            return function(value2) {
              resolveContexts[i3] = this;
              resolveValues[i3] = arguments.length > 1 ? slice2.call(arguments) : value2;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i2)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction2(resolveValues[i2] && resolveValues[i2].then)) {
              return primary.then();
            }
          }
          while (i2--) {
            adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery2.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery2.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery2.Deferred();
      jQuery2.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery2.readyException(error);
        });
        return this;
      };
      jQuery2.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
            return;
          }
          jQuery2.isReady = true;
          if (wait !== true && --jQuery2.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery2]);
        }
      });
      jQuery2.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery2.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery2.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value2, chainable, emptyGet, raw) {
        var i2 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i2 in key) {
            access(elems, fn, i2, key[i2], true, emptyGet, raw);
          }
        } else if (value2 !== void 0) {
          chainable = true;
          if (!isFunction2(value2)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value2);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value3) {
                return bulk.call(jQuery2(elem), value3);
              };
            }
          }
          if (fn) {
            for (; i2 < len; i2++) {
              fn(
                elems[i2],
                key,
                raw ? value2 : value2.call(elems[i2], i2, fn(elems[i2], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string2) {
        return string2.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data2() {
        this.expando = jQuery2.expando + Data2.uid++;
      }
      Data2.uid = 1;
      Data2.prototype = {
        cache: function(owner) {
          var value2 = owner[this.expando];
          if (!value2) {
            value2 = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value2;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value: value2,
                  configurable: true
                });
              }
            }
          }
          return value2;
        },
        set: function(owner, data3, value2) {
          var prop, cache = this.cache(owner);
          if (typeof data3 === "string") {
            cache[camelCase(data3)] = value2;
          } else {
            for (prop in data3) {
              cache[camelCase(prop)] = data3[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value2) {
          if (key === void 0 || key && typeof key === "string" && value2 === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value2);
          return value2 !== void 0 ? value2 : key;
        },
        remove: function(owner, key) {
          var i2, cache = owner[this.expando];
          if (cache === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }
            i2 = key.length;
            while (i2--) {
              delete cache[key[i2]];
            }
          }
          if (key === void 0 || jQuery2.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== void 0 && !jQuery2.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data2();
      var dataUser = new Data2();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData2(data3) {
        if (data3 === "true") {
          return true;
        }
        if (data3 === "false") {
          return false;
        }
        if (data3 === "null") {
          return null;
        }
        if (data3 === +data3 + "") {
          return +data3;
        }
        if (rbrace.test(data3)) {
          return JSON.parse(data3);
        }
        return data3;
      }
      function dataAttr(elem, key, data3) {
        var name;
        if (data3 === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data3 = elem.getAttribute(name);
          if (typeof data3 === "string") {
            try {
              data3 = getData2(data3);
            } catch (e) {
            }
            dataUser.set(elem, key, data3);
          } else {
            data3 = void 0;
          }
        }
        return data3;
      }
      jQuery2.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data3) {
          return dataUser.access(elem, name, data3);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data3) {
          return dataPriv.access(elem, name, data3);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery2.fn.extend({
        data: function(key, value2) {
          var i2, name, data3, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data3 = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i2 = attrs.length;
                while (i2--) {
                  if (attrs[i2]) {
                    name = attrs[i2].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data3[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data3;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value3) {
            var data4;
            if (elem && value3 === void 0) {
              data4 = dataUser.get(elem, key);
              if (data4 !== void 0) {
                return data4;
              }
              data4 = dataAttr(elem, key);
              if (data4 !== void 0) {
                return data4;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value3);
            });
          }, null, value2, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery2.extend({
        queue: function(elem, type, data3) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data3) {
              if (!queue || Array.isArray(data3)) {
                queue = dataPriv.access(elem, type, jQuery2.makeArray(data3));
              } else {
                queue.push(data3);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery2.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
            jQuery2.dequeue(elem, type);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery2.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery2.fn.extend({
        queue: function(type, data3) {
          var setter = 2;
          if (typeof type !== "string") {
            data3 = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery2.queue(this[0], type);
          }
          return data3 === void 0 ? this : this.each(function() {
            var queue = jQuery2.queue(this, type, data3);
            jQuery2._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery2.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery2.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count = 1, defer2 = jQuery2.Deferred(), elements = this, i2 = this.length, resolve = function() {
            if (!--count) {
              defer2.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i2--) {
            tmp = dataPriv.get(elements[i2], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer2.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery2.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery2.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial = initial / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery2.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery2.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display2 = defaultDisplayMap[nodeName2];
        if (display2) {
          return display2;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display2 = jQuery2.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display2 === "none") {
          display2 = "block";
        }
        defaultDisplayMap[nodeName2] = display2;
        return display2;
      }
      function showHide(elements, show3) {
        var display2, elem, values2 = [], index2 = 0, length = elements.length;
        for (; index2 < length; index2++) {
          elem = elements[index2];
          if (!elem.style) {
            continue;
          }
          display2 = elem.style.display;
          if (show3) {
            if (display2 === "none") {
              values2[index2] = dataPriv.get(elem, "display") || null;
              if (!values2[index2]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values2[index2] = getDefaultDisplay(elem);
            }
          } else {
            if (display2 !== "none") {
              values2[index2] = "none";
              dataPriv.set(elem, "display", display2);
            }
          }
        }
        for (index2 = 0; index2 < length; index2++) {
          if (values2[index2] != null) {
            elements[index2].style.display = values2[index2];
          }
        }
        return elements;
      }
      jQuery2.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery2(this).show();
            } else {
              jQuery2(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div2 = fragment.appendChild(document2.createElement("div")), input12 = document2.createElement("input");
        input12.setAttribute("type", "radio");
        input12.setAttribute("checked", "checked");
        input12.setAttribute("name", "t");
        div2.appendChild(input12);
        support.checkClone = div2.cloneNode(true).cloneNode(true).lastChild.checked;
        div2.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div2.cloneNode(true).lastChild.defaultValue;
        div2.innerHTML = "<option></option>";
        support.option = !!div2.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery2.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i2 = 0, l = elems.length;
        for (; i2 < l; i2++) {
          dataPriv.set(
            elems[i2],
            "globalEval",
            !refElements || dataPriv.get(refElements[i2], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l = elems.length;
        for (; i2 < l; i2++) {
          elem = elems[i2];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
              j = wrap[0];
              while (j--) {
                tmp = tmp.lastChild;
              }
              jQuery2.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i2 = 0;
        while (elem = nodes[i2++]) {
          if (selection && jQuery2.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j = 0;
            while (elem = tmp[j++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on(elem, types, selector, data3, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data3 = data3 || selector;
            selector = void 0;
          }
          for (type in types) {
            on(elem, type, selector, data3, types[type], one);
          }
          return elem;
        }
        if (data3 == null && fn == null) {
          fn = selector;
          data3 = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data3;
            data3 = void 0;
          } else {
            fn = data3;
            data3 = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event2) {
            jQuery2().off(event2);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
        }
        return elem.each(function() {
          jQuery2.event.add(this, types, fn, data3, selector);
        });
      }
      jQuery2.event = {
        global: {},
        add: function(elem, types, handler, data3, selector) {
          var handleObjIn, eventHandle, tmp, events3, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery2.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery2.guid++;
          }
          if (!(events3 = elemData.events)) {
            events3 = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e) {
              return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery2.event.special[type] || {};
            handleObj = jQuery2.extend({
              type,
              origType,
              data: data3,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events3[type])) {
              handlers = events3[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data3, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery2.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j, origCount, tmp, events3, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events3 = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events3) {
                jQuery2.event.remove(elem, type + types[t], handler, selector, true);
              }
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events3[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j = handlers.length;
            while (j--) {
              handleObj = handlers[j];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery2.removeEvent(elem, type, elemData.handle);
              }
              delete events3[type];
            }
          }
          if (jQuery2.isEmptyObject(events3)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i2, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event2 = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event2.type] || [], special = jQuery2.event.special[event2.type] || {};
          args[0] = event2;
          for (i2 = 1; i2 < arguments.length; i2++) {
            args[i2] = arguments[i2];
          }
          event2.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event2) === false) {
            return;
          }
          handlerQueue = jQuery2.event.handlers.call(this, event2, handlers);
          i2 = 0;
          while ((matched = handlerQueue[i2++]) && !event2.isPropagationStopped()) {
            event2.currentTarget = matched.elem;
            j = 0;
            while ((handleObj = matched.handlers[j++]) && !event2.isImmediatePropagationStopped()) {
              if (!event2.rnamespace || handleObj.namespace === false || event2.rnamespace.test(handleObj.namespace)) {
                event2.handleObj = handleObj;
                event2.data = handleObj.data;
                ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event2.result = ret) === false) {
                    event2.preventDefault();
                    event2.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event2);
          }
          return event2.result;
        },
        handlers: function(event2, handlers) {
          var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event2.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event2.type === "click" && event2.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event2.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i2 = 0; i2 < delegateCount; i2++) {
                  handleObj = handlers[i2];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery2.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction2(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value2) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value2
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data3) {
              var el = this || data3;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data3) {
              var el = this || data3;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event2) {
              var target = event2.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event2) {
              if (event2.result !== void 0 && event2.originalEvent) {
                event2.originalEvent.returnValue = event2.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery2.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery2.event.add(el, type, {
          namespace: false,
          handler: function(event2) {
            var result, saved = dataPriv.get(this, type);
            if (event2.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice2.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result) {
                  event2.stopImmediatePropagation();
                  event2.preventDefault();
                  return result;
                }
              } else if ((jQuery2.event.special[type] || {}).delegateType) {
                event2.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery2.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event2.stopPropagation();
              event2.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery2.removeEvent = function(elem, type, handle2) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle2);
        }
      };
      jQuery2.Event = function(src, props) {
        if (!(this instanceof jQuery2.Event)) {
          return new jQuery2.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery2.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery2.expando] = true;
      };
      jQuery2.Event.prototype = {
        constructor: jQuery2.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e && !this.isSimulated) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery2.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery2.event.addProp);
      jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle2 = dataPriv.get(this, "handle"), event2 = jQuery2.event.fix(nativeEvent);
            event2.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event2.isSimulated = true;
            handle2(nativeEvent);
            if (event2.target === event2.currentTarget) {
              handle2(event2);
            }
          } else {
            jQuery2.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery2.event.fix(nativeEvent)
            );
          }
        }
        jQuery2.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event2) {
            return dataPriv.get(event2.target, type);
          },
          delegateType
        };
        jQuery2.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery2.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery2.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event2) {
            var ret, target = this, related = event2.relatedTarget, handleObj = event2.handleObj;
            if (!related || related !== target && !jQuery2.contains(target, related)) {
              event2.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event2.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery2.fn.extend({
        on: function(types, selector, data3, fn) {
          return on(this, types, selector, data3, fn);
        },
        one: function(types, selector, data3, fn) {
          return on(this, types, selector, data3, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery2(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery2.event.remove(this, types, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content2) {
        if (nodeName(elem, "table") && nodeName(content2.nodeType !== 11 ? content2 : content2.firstChild, "tr")) {
          return jQuery2(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i2, l, type, pdataOld, udataOld, udataCur, events3;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events3 = pdataOld.events;
          if (events3) {
            dataPriv.remove(dest, "handle events");
            for (type in events3) {
              for (i2 = 0, l = events3[type].length; i2 < l; i2++) {
                jQuery2.event.add(dest, type, events3[type][i2]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery2.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i2 = 0, l = collection.length, iNoClone = l - 1, value2 = args[0], valueIsFunction = isFunction2(value2);
        if (valueIsFunction || l > 1 && typeof value2 === "string" && !support.checkClone && rchecked.test(value2)) {
          return collection.each(function(index2) {
            var self2 = collection.eq(index2);
            if (valueIsFunction) {
              args[0] = value2.call(this, index2, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i2 < l; i2++) {
              node = fragment;
              if (i2 !== iNoClone) {
                node = jQuery2.clone(node, true, true);
                if (hasScripts) {
                  jQuery2.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i2], node, i2);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery2.map(scripts, restoreScript);
              for (i2 = 0; i2 < hasScripts; i2++) {
                node = scripts[i2];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery2._evalUrl && !node.noModule) {
                      jQuery2._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove3(elem, selector, keepData) {
        var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i2 = 0;
        for (; (node = nodes[i2]) != null; i2++) {
          if (!keepData && node.nodeType === 1) {
            jQuery2.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery2.extend({
        htmlPrefilter: function(html2) {
          return html2;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i2, l, srcElements, destElements, clone3 = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
            destElements = getAll(clone3);
            srcElements = getAll(elem);
            for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
              fixInput(srcElements[i2], destElements[i2]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone3);
              for (i2 = 0, l = srcElements.length; i2 < l; i2++) {
                cloneCopyEvent(srcElements[i2], destElements[i2]);
              }
            } else {
              cloneCopyEvent(elem, clone3);
            }
          }
          destElements = getAll(clone3, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone3;
        },
        cleanData: function(elems) {
          var data3, elem, type, special = jQuery2.event.special, i2 = 0;
          for (; (elem = elems[i2]) !== void 0; i2++) {
            if (acceptData(elem)) {
              if (data3 = elem[dataPriv.expando]) {
                if (data3.events) {
                  for (type in data3.events) {
                    if (special[type]) {
                      jQuery2.event.remove(elem, type);
                    } else {
                      jQuery2.removeEvent(elem, type, data3.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery2.fn.extend({
        detach: function(selector) {
          return remove3(this, selector, true);
        },
        remove: function(selector) {
          return remove3(this, selector);
        },
        text: function(value2) {
          return access(this, function(value3) {
            return value3 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value3;
              }
            });
          }, null, value2, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i2 = 0;
          for (; (elem = this[i2]) != null; i2++) {
            if (elem.nodeType === 1) {
              jQuery2.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value2) {
          return access(this, function(value3) {
            var elem = this[0] || {}, i2 = 0, l = this.length;
            if (value3 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value3 === "string" && !rnoInnerhtml.test(value3) && !wrapMap[(rtagName.exec(value3) || ["", ""])[1].toLowerCase()]) {
              value3 = jQuery2.htmlPrefilter(value3);
              try {
                for (; i2 < l; i2++) {
                  elem = this[i2] || {};
                  if (elem.nodeType === 1) {
                    jQuery2.cleanData(getAll(elem, false));
                    elem.innerHTML = value3;
                  }
                }
                elem = 0;
              } catch (e) {
              }
            }
            if (elem) {
              this.empty().append(value3);
            }
          }, null, value2, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery2.inArray(this, ignored) < 0) {
              jQuery2.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery2.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery2.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery2(selector), last2 = insert.length - 1, i2 = 0;
          for (; i2 <= last2; i2++) {
            elems = i2 === last2 ? this : this.clone(true);
            jQuery2(insert[i2])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap3 = function(elem, options2, callback) {
        var ret, name, old = {};
        for (name in options2) {
          old[name] = elem.style[name];
          elem.style[name] = options2[name];
        }
        ret = callback.call(elem);
        for (name in options2) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div2) {
            return;
          }
          container2.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container2).appendChild(div2);
          var divStyle = window2.getComputedStyle(div2);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div2.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div2.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div2.offsetWidth / 3) === 12;
          documentElement.removeChild(container2);
          div2 = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container2 = document2.createElement("div"), div2 = document2.createElement("div");
        if (!div2.style) {
          return;
        }
        div2.style.backgroundClip = "content-box";
        div2.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div2.style.backgroundClip === "content-box";
        jQuery2.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table2, tr2, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table2 = document2.createElement("table");
              tr2 = document2.createElement("tr");
              trChild = document2.createElement("div");
              table2.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr2.style.cssText = "box-sizing:content-box;border:1px solid";
              tr2.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table2).appendChild(tr2).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr2);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr2.offsetHeight;
              documentElement.removeChild(table2);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style2 = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery2.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width = style2.width;
            minWidth = style2.minWidth;
            maxWidth = style2.maxWidth;
            style2.minWidth = style2.maxWidth = style2.width = ret;
            ret = computed.width;
            style2.width = width;
            style2.minWidth = minWidth;
            style2.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
        while (i2--) {
          name = cssPrefixes[i2] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery2.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow2 = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value2, subtract) {
        var matches = rcssNum.exec(value2);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value2;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles3, computedVal) {
        var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i2 < 4; i2 += 2) {
          if (box === "margin") {
            marginDelta += jQuery2.css(elem, box + cssExpand[i2], true, styles3);
          }
          if (!isBorderBox) {
            delta += jQuery2.css(elem, "padding" + cssExpand[i2], true, styles3);
            if (box !== "padding") {
              delta += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles3);
            } else {
              extra += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles3);
            }
          } else {
            if (box === "content") {
              delta -= jQuery2.css(elem, "padding" + cssExpand[i2], true, styles3);
            }
            if (box !== "margin") {
              delta -= jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles3);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles3 = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles3) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles3), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery2.css(elem, "display", false, styles3) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery2.css(elem, "boxSizing", false, styles3) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles3,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery2.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value2, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style2 = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
          if (value2 !== void 0) {
            type = typeof value2;
            if (type === "string" && (ret = rcssNum.exec(value2)) && ret[1]) {
              value2 = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value2 == null || value2 !== value2) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value2 += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value2 === "" && name.indexOf("background") === 0) {
              style2[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value2 = hooks.set(elem, value2, extra)) !== void 0) {
              if (isCustomProp) {
                style2.setProperty(name, value2);
              } else {
                style2[name] = value2;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style2[name];
          }
        },
        css: function(elem, name, extra, styles3) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles3);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery2.each(["height", "width"], function(_i, dimension) {
        jQuery2.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap3(elem, cssShow2, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value2, extra) {
            var matches, styles3 = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles3.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles3) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles3
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles3[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles3) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value2)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value2;
              value2 = jQuery2.css(elem, dimension);
            }
            return setPositiveNumber(elem, value2, subtract);
          }
        };
      });
      jQuery2.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap3(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery2.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery2.cssHooks[prefix + suffix] = {
          expand: function(value2) {
            var i2 = 0, expanded = {}, parts = typeof value2 === "string" ? value2.split(" ") : [value2];
            for (; i2 < 4; i2++) {
              expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery2.fn.extend({
        css: function(name, value2) {
          return access(this, function(elem, name2, value3) {
            var styles3, len, map4 = {}, i2 = 0;
            if (Array.isArray(name2)) {
              styles3 = getStyles(elem);
              len = name2.length;
              for (; i2 < len; i2++) {
                map4[name2[i2]] = jQuery2.css(elem, name2[i2], false, styles3);
              }
              return map4;
            }
            return value3 !== void 0 ? jQuery2.style(elem, name2, value3) : jQuery2.css(elem, name2);
          }, name, value2, arguments.length > 1);
        }
      });
      function Tween(elem, options2, prop, end, easing) {
        return new Tween.prototype.init(elem, options2, prop, end, easing);
      }
      jQuery2.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options2, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery2.easing._default;
          this.options = options2;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery2.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery2.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery2.fx.step[tween.prop]) {
              jQuery2.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery2.easing = {
        linear: function(p2) {
          return p2;
        },
        swing: function(p2) {
          return 0.5 - Math.cos(p2 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery2.fx = Tween.prototype.init;
      jQuery2.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery2.fx.interval);
          }
          jQuery2.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i2 = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i2 < 4; i2 += 2 - includeWidth) {
          which = cssExpand[i2];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value2, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
        for (; index2 < length; index2++) {
          if (tween = collection[index2].call(animation, prop, value2)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value2, toggle, hooks, oldfire, propTween, restoreDisplay, display2, isBox = "width" in props || "height" in props, anim = this, orig = {}, style2 = elem.style, hidden2 = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery2._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery2.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value2 = props[prop];
          if (rfxtypes.test(value2)) {
            delete props[prop];
            toggle = toggle || value2 === "toggle";
            if (value2 === (hidden2 ? "hide" : "show")) {
              if (value2 === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden2 = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
          }
        }
        propTween = !jQuery2.isEmptyObject(props);
        if (!propTween && jQuery2.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style2.overflow, style2.overflowX, style2.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display2 = jQuery2.css(elem, "display");
          if (display2 === "none") {
            if (restoreDisplay) {
              display2 = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display2 = jQuery2.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display2 === "inline" || display2 === "inline-block" && restoreDisplay != null) {
            if (jQuery2.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style2.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display2 = style2.display;
                  restoreDisplay = display2 === "none" ? "" : display2;
                }
              }
              style2.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style2.overflow = "hidden";
          anim.always(function() {
            style2.overflow = opts.overflow[0];
            style2.overflowX = opts.overflow[1];
            style2.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden2 = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden2;
            }
            if (hidden2) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden2) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery2.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden2 ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden2) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index2, name, easing, value2, hooks;
        for (index2 in props) {
          name = camelCase(index2);
          easing = specialEasing[name];
          value2 = props[index2];
          if (Array.isArray(value2)) {
            easing = value2[1];
            value2 = props[index2] = value2[0];
          }
          if (index2 !== name) {
            props[name] = value2;
            delete props[index2];
          }
          hooks = jQuery2.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value2 = hooks.expand(value2);
            delete props[name];
            for (index2 in value2) {
              if (!(index2 in props)) {
                props[index2] = value2[index2];
                specialEasing[index2] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options2) {
        var result, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
          for (; index3 < length2; index3++) {
            animation.tweens[index3].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery2.extend({}, properties),
          opts: jQuery2.extend(true, {
            specialEasing: {},
            easing: jQuery2.easing._default
          }, options2),
          originalProperties: properties,
          originalOptions: options2,
          startTime: fxNow || createFxNow(),
          duration: options2.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery2.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index2 < length; index2++) {
          result = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction2(result.stop)) {
              jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery2.map(props, createTween, animation);
        if (isFunction2(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery2.fx.timer(
          jQuery2.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery2.Animation = jQuery2.extend(Animation, {
        tweeners: {
          "*": [function(prop, value2) {
            var tween = this.createTween(prop, value2);
            adjustCSS(tween.elem, prop, rcssNum.exec(value2), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction2(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index2 = 0, length = props.length;
          for (; index2 < length; index2++) {
            prop = props[index2];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend3) {
          if (prepend3) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery2.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction2(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction2(easing) && easing
        };
        if (jQuery2.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery2.fx.speeds) {
              opt.duration = jQuery2.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery2.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction2(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery2.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery2.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty3 = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery2.extend({}, prop), optall);
            if (empty3 || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty3 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index2 = type != null && type + "queueHooks", timers = jQuery2.timers, data3 = dataPriv.get(this);
            if (index2) {
              if (data3[index2] && data3[index2].stop) {
                stopQueue(data3[index2]);
              }
            } else {
              for (index2 in data3) {
                if (data3[index2] && data3[index2].stop && rrun.test(index2)) {
                  stopQueue(data3[index2]);
                }
              }
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && (type == null || timers[index2].queue === type)) {
                timers[index2].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index2, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery2.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index2, data3 = dataPriv.get(this), queue = data3[type + "queue"], hooks = data3[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
            data3.finish = true;
            jQuery2.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && timers[index2].queue === type) {
                timers[index2].anim.stop(true);
                timers.splice(index2, 1);
              }
            }
            for (index2 = 0; index2 < length; index2++) {
              if (queue[index2] && queue[index2].finish) {
                queue[index2].finish.call(this);
              }
            }
            delete data3.finish;
          });
        }
      });
      jQuery2.each(["toggle", "show", "hide"], function(_i, name) {
        var cssFn = jQuery2.fn[name];
        jQuery2.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery2.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery2.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery2.timers = [];
      jQuery2.fx.tick = function() {
        var timer, i2 = 0, timers = jQuery2.timers;
        fxNow = Date.now();
        for (; i2 < timers.length; i2++) {
          timer = timers[i2];
          if (!timer() && timers[i2] === timer) {
            timers.splice(i2--, 1);
          }
        }
        if (!timers.length) {
          jQuery2.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery2.fx.timer = function(timer) {
        jQuery2.timers.push(timer);
        jQuery2.fx.start();
      };
      jQuery2.fx.interval = 13;
      jQuery2.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery2.fx.stop = function() {
        inProgress = null;
      };
      jQuery2.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery2.fn.delay = function(time2, type) {
        time2 = jQuery2.fx ? jQuery2.fx.speeds[time2] || time2 : time2;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window2.setTimeout(next, time2);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input12 = document2.createElement("input"), select2 = document2.createElement("select"), opt = select2.appendChild(document2.createElement("option"));
        input12.type = "checkbox";
        support.checkOn = input12.value !== "";
        support.optSelected = opt.selected;
        input12 = document2.createElement("input");
        input12.value = "t";
        input12.type = "radio";
        support.radioValue = input12.value === "t";
      })();
      var boolHook, attrHandle = jQuery2.expr.attrHandle;
      jQuery2.fn.extend({
        attr: function(name, value2) {
          return access(this, jQuery2.attr, name, value2, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery2.removeAttr(this, name);
          });
        }
      });
      jQuery2.extend({
        attr: function(elem, name, value2) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery2.prop(elem, name, value2);
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value2 !== void 0) {
            if (value2 === null) {
              jQuery2.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value2, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value2 + "");
            return value2;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery2.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value2) {
              if (!support.radioValue && value2 === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value2);
                if (val) {
                  elem.value = val;
                }
                return value2;
              }
            }
          }
        },
        removeAttr: function(elem, value2) {
          var name, i2 = 0, attrNames = value2 && value2.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i2++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value2, name) {
          if (value2 === false) {
            jQuery2.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery2.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle2, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle2 = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle2;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery2.fn.extend({
        prop: function(name, value2) {
          return access(this, jQuery2.prop, name, value2, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery2.propFix[name] || name];
          });
        }
      });
      jQuery2.extend({
        prop: function(elem, name, value2) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            name = jQuery2.propFix[name] || name;
            hooks = jQuery2.propHooks[name];
          }
          if (value2 !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value2, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value2;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery2.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery2.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery2.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery2.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value2) {
        var tokens = value2.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value2) {
        if (Array.isArray(value2)) {
          return value2;
        }
        if (typeof value2 === "string") {
          return value2.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery2.fn.extend({
        addClass: function(value2) {
          var classNames, cur, curValue, className, i2, finalValue;
          if (isFunction2(value2)) {
            return this.each(function(j) {
              jQuery2(this).addClass(value2.call(this, j, getClass(this)));
            });
          }
          classNames = classesToArray(value2);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value2) {
          var classNames, cur, curValue, className, i2, finalValue;
          if (isFunction2(value2)) {
            return this.each(function(j) {
              jQuery2(this).removeClass(value2.call(this, j, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames = classesToArray(value2);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value2, stateVal) {
          var classNames, className, i2, self2, type = typeof value2, isValidValue = type === "string" || Array.isArray(value2);
          if (isFunction2(value2)) {
            return this.each(function(i3) {
              jQuery2(this).toggleClass(
                value2.call(this, i3, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value2) : this.removeClass(value2);
          }
          classNames = classesToArray(value2);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery2(this);
              for (i2 = 0; i2 < classNames.length; i2++) {
                className = classNames[i2];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value2 === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value2 === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i2 = 0;
          className = " " + selector + " ";
          while (elem = this[i2++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery2.fn.extend({
        val: function(value2) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction2(value2);
          return this.each(function(i2) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value2.call(this, i2, jQuery2(this).val());
            } else {
              val = value2;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery2.map(val, function(value3) {
                return value3 == null ? "" : value3 + "";
              });
            }
            hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery2.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery2.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery2.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value2, option2, i2, options2 = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max18 = one ? index2 + 1 : options2.length;
              if (index2 < 0) {
                i2 = max18;
              } else {
                i2 = one ? index2 : 0;
              }
              for (; i2 < max18; i2++) {
                option2 = options2[i2];
                if ((option2.selected || i2 === index2) && // Don't return options that are disabled or in a disabled optgroup
                !option2.disabled && (!option2.parentNode.disabled || !nodeName(option2.parentNode, "optgroup"))) {
                  value2 = jQuery2(option2).val();
                  if (one) {
                    return value2;
                  }
                  values2.push(value2);
                }
              }
              return values2;
            },
            set: function(elem, value2) {
              var optionSet, option2, options2 = elem.options, values2 = jQuery2.makeArray(value2), i2 = options2.length;
              while (i2--) {
                option2 = options2[i2];
                if (option2.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option2), values2) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values2;
            }
          }
        }
      });
      jQuery2.each(["radio", "checkbox"], function() {
        jQuery2.valHooks[this] = {
          set: function(elem, value2) {
            if (Array.isArray(value2)) {
              return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value2) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery2.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery2.parseXML = function(data3) {
        var xml, parserErrorElem;
        if (!data3 || typeof data3 !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data3, "text/xml");
        } catch (e) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
          }).join("\n") : data3));
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
      };
      jQuery2.extend(jQuery2.event, {
        trigger: function(event2, data3, elem, onlyHandlers) {
          var i2, cur, tmp, bubbleType, ontype, handle2, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event2, "type") ? event2.type : event2, namespaces = hasOwn.call(event2, "namespace") ? event2.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery2.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event2 = event2[jQuery2.expando] ? event2 : new jQuery2.Event(type, typeof event2 === "object" && event2);
          event2.isTrigger = onlyHandlers ? 2 : 3;
          event2.namespace = namespaces.join(".");
          event2.rnamespace = event2.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event2.result = void 0;
          if (!event2.target) {
            event2.target = elem;
          }
          data3 = data3 == null ? [event2] : jQuery2.makeArray(data3, [event2]);
          special = jQuery2.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data3) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i2 = 0;
          while ((cur = eventPath[i2++]) && !event2.isPropagationStopped()) {
            lastElement = cur;
            event2.type = i2 > 1 ? bubbleType : special.bindType || type;
            handle2 = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event2.type] && dataPriv.get(cur, "handle");
            if (handle2) {
              handle2.apply(cur, data3);
            }
            handle2 = ontype && cur[ontype];
            if (handle2 && handle2.apply && acceptData(cur)) {
              event2.result = handle2.apply(cur, data3);
              if (event2.result === false) {
                event2.preventDefault();
              }
            }
          }
          event2.type = type;
          if (!onlyHandlers && !event2.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data3) === false) && acceptData(elem)) {
              if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery2.event.triggered = type;
                if (event2.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event2.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery2.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event2.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event2) {
          var e = jQuery2.extend(
            new jQuery2.Event(),
            event2,
            {
              type,
              isSimulated: true
            }
          );
          jQuery2.event.trigger(e, null, elem);
        }
      });
      jQuery2.fn.extend({
        trigger: function(type, data3) {
          return this.each(function() {
            jQuery2.event.trigger(type, data3, this);
          });
        },
        triggerHandler: function(type, data3) {
          var elem = this[0];
          if (elem) {
            return jQuery2.event.trigger(type, data3, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add2) {
        var name;
        if (Array.isArray(obj)) {
          jQuery2.each(obj, function(i2, v) {
            if (traditional || rbracket.test(prefix)) {
              add2(prefix, v);
            } else {
              buildParams(
                prefix + "[" + (typeof v === "object" && v != null ? i2 : "") + "]",
                v,
                traditional,
                add2
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
          }
        } else {
          add2(prefix, obj);
        }
      }
      jQuery2.param = function(a2, traditional) {
        var prefix, s2 = [], add2 = function(key, valueOrFunction) {
          var value2 = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value2 == null ? "" : value2);
        };
        if (a2 == null) {
          return "";
        }
        if (Array.isArray(a2) || a2.jquery && !jQuery2.isPlainObject(a2)) {
          jQuery2.each(a2, function() {
            add2(this.name, this.value);
          });
        } else {
          for (prefix in a2) {
            buildParams(prefix, a2[prefix], traditional, add2);
          }
        }
        return s2.join("&");
      };
      jQuery2.fn.extend({
        serialize: function() {
          return jQuery2.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery2.prop(this, "elements");
            return elements ? jQuery2.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i, elem) {
            var val = jQuery2(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery2.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction2(func)) {
            while (dataType = dataTypes[i2++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options2, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options2, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options2.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options2.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery2.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s2, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s2, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s2.converters) {
            converters[conv.toLowerCase()] = s2.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s2.responseFields[current]) {
            jqXHR[s2.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s2.dataFilter) {
            response = s2.dataFilter(response, s2.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s2.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery2.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery2.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings2) {
          return settings2 ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings2)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery2.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url2, options2) {
          if (typeof url2 === "object") {
            options2 = url2;
            url2 = void 0;
          }
          options2 = options2 || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s2 = jQuery2.ajaxSetup({}, options2), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match2;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match2 = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                  }
                }
                match2 = responseHeaders[key.toLowerCase() + " "];
              }
              return match2 == null ? null : match2.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name, value2) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value2;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s2.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map4) {
              var code2;
              if (map4) {
                if (completed2) {
                  jqXHR.always(map4[jqXHR.status]);
                } else {
                  for (code2 in map4) {
                    statusCode[code2] = [statusCode[code2], map4[code2]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s2.url = ((url2 || s2.url || location.href) + "").replace(rprotocol, location.protocol + "//");
          s2.type = options2.method || options2.type || s2.method || s2.type;
          s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s2.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s2.url;
              urlAnchor.href = urlAnchor.href;
              s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              s2.crossDomain = true;
            }
          }
          if (s2.data && s2.processData && typeof s2.data !== "string") {
            s2.data = jQuery2.param(s2.data, s2.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s2, options2, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery2.event && s2.global;
          if (fireGlobals && jQuery2.active++ === 0) {
            jQuery2.event.trigger("ajaxStart");
          }
          s2.type = s2.type.toUpperCase();
          s2.hasContent = !rnoContent.test(s2.type);
          cacheURL = s2.url.replace(rhash, "");
          if (!s2.hasContent) {
            uncached = s2.url.slice(cacheURL.length);
            if (s2.data && (s2.processData || typeof s2.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
              delete s2.data;
            }
            if (s2.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s2.url = cacheURL + uncached;
          } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s2.data = s2.data.replace(r20, "+");
          }
          if (s2.ifModified) {
            if (jQuery2.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
            }
            if (jQuery2.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
            }
          }
          if (s2.data && s2.hasContent && s2.contentType !== false || options2.contentType) {
            jqXHR.setRequestHeader("Content-Type", s2.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
          );
          for (i2 in s2.headers) {
            jqXHR.setRequestHeader(i2, s2.headers[i2]);
          }
          if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s2.complete);
          jqXHR.done(s2.success);
          jqXHR.fail(s2.error);
          transport = inspectPrefiltersOrTransports(transports, s2, options2, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s2.async && s2.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s2.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e) {
              if (completed2) {
                throw e;
              }
              done(-1, e);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s2, jqXHR, responses);
            }
            if (!isSuccess && jQuery2.inArray("script", s2.dataTypes) > -1 && jQuery2.inArray("json", s2.dataTypes) < 0) {
              s2.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s2, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s2.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery2.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery2.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s2.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s2, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
              if (!--jQuery2.active) {
                jQuery2.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url2, data3, callback) {
          return jQuery2.get(url2, data3, callback, "json");
        },
        getScript: function(url2, callback) {
          return jQuery2.get(url2, void 0, callback, "script");
        }
      });
      jQuery2.each(["get", "post"], function(_i, method) {
        jQuery2[method] = function(url2, data3, callback, type) {
          if (isFunction2(data3)) {
            type = type || callback;
            callback = data3;
            data3 = void 0;
          }
          return jQuery2.ajax(jQuery2.extend({
            url: url2,
            type: method,
            dataType: type,
            data: data3,
            success: callback
          }, jQuery2.isPlainObject(url2) && url2));
        };
      });
      jQuery2.ajaxPrefilter(function(s2) {
        var i2;
        for (i2 in s2.headers) {
          if (i2.toLowerCase() === "content-type") {
            s2.contentType = s2.headers[i2] || "";
          }
        }
      });
      jQuery2._evalUrl = function(url2, options2, doc) {
        return jQuery2.ajax({
          url: url2,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery2.globalEval(response, options2, doc);
          }
        });
      };
      jQuery2.fn.extend({
        wrapAll: function(html2) {
          var wrap;
          if (this[0]) {
            if (isFunction2(html2)) {
              html2 = html2.call(this[0]);
            }
            wrap = jQuery2(html2, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html2) {
          if (isFunction2(html2)) {
            return this.each(function(i2) {
              jQuery2(this).wrapInner(html2.call(this, i2));
            });
          }
          return this.each(function() {
            var self2 = jQuery2(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html2);
            } else {
              self2.append(html2);
            }
          });
        },
        wrap: function(html2) {
          var htmlIsFunction = isFunction2(html2);
          return this.each(function(i2) {
            jQuery2(this).wrapAll(htmlIsFunction ? html2.call(this, i2) : html2);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery2(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery2.expr.pseudos.hidden = function(elem) {
        return !jQuery2.expr.pseudos.visible(elem);
      };
      jQuery2.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery2.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery2.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery2.ajaxTransport(function(options2) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options2.crossDomain) {
          return {
            send: function(headers, complete) {
              var i2, xhr = options2.xhr();
              xhr.open(
                options2.type,
                options2.url,
                options2.async,
                options2.username,
                options2.password
              );
              if (options2.xhrFields) {
                for (i2 in options2.xhrFields) {
                  xhr[i2] = options2.xhrFields[i2];
                }
              }
              if (options2.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options2.mimeType);
              }
              if (!options2.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i2 in headers) {
                xhr.setRequestHeader(i2, headers[i2]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options2.hasContent && options2.data || null);
              } catch (e) {
                if (callback) {
                  throw e;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery2.ajaxPrefilter(function(s2) {
        if (s2.crossDomain) {
          s2.contents.script = false;
        }
      });
      jQuery2.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text2) {
            jQuery2.globalEval(text2);
            return text2;
          }
        }
      });
      jQuery2.ajaxPrefilter("script", function(s2) {
        if (s2.cache === void 0) {
          s2.cache = false;
        }
        if (s2.crossDomain) {
          s2.type = "GET";
        }
      });
      jQuery2.ajaxTransport("script", function(s2) {
        if (s2.crossDomain || s2.scriptAttrs) {
          var script2, callback;
          return {
            send: function(_2, complete) {
              script2 = jQuery2("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                script2.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script2[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery2.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery2.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
        if (jsonProp || s2.dataTypes[0] === "jsonp") {
          callbackName = s2.jsonpCallback = isFunction2(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
          if (jsonProp) {
            s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s2.jsonp !== false) {
            s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
          }
          s2.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery2.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s2.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery2(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s2[callbackName]) {
              s2.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction2(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body2 = document2.implementation.createHTMLDocument("").body;
        body2.innerHTML = "<form></form><form></form>";
        return body2.childNodes.length === 2;
      }();
      jQuery2.parseHTML = function(data3, context, keepScripts) {
        if (typeof data3 !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base2, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base2 = context.createElement("base");
            base2.href = document2.location.href;
            context.head.appendChild(base2);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data3);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data3], context, scripts);
        if (scripts && scripts.length) {
          jQuery2(scripts).remove();
        }
        return jQuery2.merge([], parsed.childNodes);
      };
      jQuery2.fn.load = function(url2, params, callback) {
        var selector, type, response, self2 = this, off = url2.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url2.slice(off));
          url2 = url2.slice(0, off);
        }
        if (isFunction2(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery2.ajax({
            url: url2,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery2.expr.pseudos.animated = function(elem) {
        return jQuery2.grep(jQuery2.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery2.offset = {
        setOffset: function(elem, options2, i2) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position2 = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
          if (position2 === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery2.css(elem, "top");
          curCSSLeft = jQuery2.css(elem, "left");
          calculatePosition = (position2 === "absolute" || position2 === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction2(options2)) {
            options2 = options2.call(elem, i2, jQuery2.extend({}, curOffset));
          }
          if (options2.top != null) {
            props.top = options2.top - curOffset.top + curTop;
          }
          if (options2.left != null) {
            props.left = options2.left - curOffset.left + curLeft;
          }
          if ("using" in options2) {
            options2.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery2.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options2) {
          if (arguments.length) {
            return options2 === void 0 ? this : this.each(function(i2) {
              jQuery2.offset.setOffset(this, options2, i2);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset3, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery2.css(elem, "position") === "fixed") {
            offset3 = elem.getBoundingClientRect();
          } else {
            offset3 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery2(offsetParent).offset();
              parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset3.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
            left: offset3.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery2.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery2.each(["top", "left"], function(_i, prop) {
        jQuery2.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery2.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery2.fn[funcName] = function(margin, value2) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value2 === true ? "margin" : "border");
            return access(this, function(elem, type2, value3) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value3 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery2.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery2.style(elem, type2, value3, extra)
              );
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery2.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i, type) {
        jQuery2.fn[type] = function(fn) {
          return this.on(type, fn);
        };
      });
      jQuery2.fn.extend({
        bind: function(types, data3, fn) {
          return this.on(types, null, data3, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data3, fn) {
          return this.on(types, selector, data3, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery2.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i, name) {
          jQuery2.fn[name] = function(data3, fn) {
            return arguments.length > 0 ? this.on(name, null, data3, fn) : this.trigger(name);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery2.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction2(fn)) {
          return void 0;
        }
        args = slice2.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice2.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery2.guid++;
        return proxy;
      };
      jQuery2.holdReady = function(hold) {
        if (hold) {
          jQuery2.readyWait++;
        } else {
          jQuery2.ready(true);
        }
      };
      jQuery2.isArray = Array.isArray;
      jQuery2.parseJSON = JSON.parse;
      jQuery2.nodeName = nodeName;
      jQuery2.isFunction = isFunction2;
      jQuery2.isWindow = isWindow;
      jQuery2.camelCase = camelCase;
      jQuery2.type = toType;
      jQuery2.now = Date.now;
      jQuery2.isNumeric = function(obj) {
        var type = jQuery2.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery2.trim = function(text2) {
        return text2 == null ? "" : (text2 + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery2;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery2.noConflict = function(deep) {
        if (window2.$ === jQuery2) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery2) {
          window2.jQuery = _jQuery;
        }
        return jQuery2;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery2;
      }
      return jQuery2;
    });
  }
});

// node_modules/@bokeh/slickgrid/slick.jquery.js
var require_slick_jquery = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.jquery.js"(exports4, module2) {
    module2.exports = typeof $ !== "undefined" ? $ : require_jquery();
  }
});

// node_modules/@bokeh/slickgrid/slick.core.js
var require_slick_core = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.core.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    function EventData() {
      var isPropagationStopped = false;
      var isImmediatePropagationStopped = false;
      this.stopPropagation = function() {
        isPropagationStopped = true;
      };
      this.isPropagationStopped = function() {
        return isPropagationStopped;
      };
      this.stopImmediatePropagation = function() {
        isImmediatePropagationStopped = true;
      };
      this.isImmediatePropagationStopped = function() {
        return isImmediatePropagationStopped;
      };
    }
    function Event() {
      var handlers = [];
      this.subscribe = function(fn) {
        handlers.push(fn);
      };
      this.unsubscribe = function(fn) {
        for (var i2 = handlers.length - 1; i2 >= 0; i2--) {
          if (handlers[i2] === fn) {
            handlers.splice(i2, 1);
          }
        }
      };
      this.notify = function(args, e, scope2) {
        e = e || new EventData();
        scope2 = scope2 || this;
        var returnValue;
        for (var i2 = 0; i2 < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i2++) {
          returnValue = handlers[i2].call(scope2, e, args);
        }
        return returnValue;
      };
    }
    function EventHandler() {
      var handlers = [];
      this.subscribe = function(event2, handler) {
        handlers.push({
          event: event2,
          handler
        });
        event2.subscribe(handler);
        return this;
      };
      this.unsubscribe = function(event2, handler) {
        var i2 = handlers.length;
        while (i2--) {
          if (handlers[i2].event === event2 && handlers[i2].handler === handler) {
            handlers.splice(i2, 1);
            event2.unsubscribe(handler);
            return;
          }
        }
        return this;
      };
      this.unsubscribeAll = function() {
        var i2 = handlers.length;
        while (i2--) {
          handlers[i2].event.unsubscribe(handlers[i2].handler);
        }
        handlers = [];
        return this;
      };
    }
    function Range2(fromRow, fromCell, toRow, toCell) {
      if (toRow === void 0 && toCell === void 0) {
        toRow = fromRow;
        toCell = fromCell;
      }
      this.fromRow = Math.min(fromRow, toRow);
      this.fromCell = Math.min(fromCell, toCell);
      this.toRow = Math.max(fromRow, toRow);
      this.toCell = Math.max(fromCell, toCell);
      this.isSingleRow = function() {
        return this.fromRow == this.toRow;
      };
      this.isSingleCell = function() {
        return this.fromRow == this.toRow && this.fromCell == this.toCell;
      };
      this.contains = function(row2, cell) {
        return row2 >= this.fromRow && row2 <= this.toRow && cell >= this.fromCell && cell <= this.toCell;
      };
      this.toString = function() {
        if (this.isSingleCell()) {
          return "(" + this.fromRow + ":" + this.fromCell + ")";
        } else {
          return "(" + this.fromRow + ":" + this.fromCell + " - " + this.toRow + ":" + this.toCell + ")";
        }
      };
    }
    function NonDataItem() {
      this.__nonDataRow = true;
    }
    function Group2() {
      this.__group = true;
      this.level = 0;
      this.count = 0;
      this.value = null;
      this.title = null;
      this.collapsed = false;
      this.selectChecked = false;
      this.totals = null;
      this.rows = [];
      this.groups = null;
      this.groupingKey = null;
    }
    Group2.prototype = new NonDataItem();
    Group2.prototype.equals = function(group) {
      return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;
    };
    function GroupTotals() {
      this.__groupTotals = true;
      this.group = null;
      this.initialized = false;
    }
    GroupTotals.prototype = new NonDataItem();
    function EditorLock() {
      var activeEditController = null;
      this.isActive = function(editController2) {
        return editController2 ? activeEditController === editController2 : activeEditController !== null;
      };
      this.activate = function(editController2) {
        if (editController2 === activeEditController) {
          return;
        }
        if (activeEditController !== null) {
          throw new Error("SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController");
        }
        if (!editController2.commitCurrentEdit) {
          throw new Error("SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()");
        }
        if (!editController2.cancelCurrentEdit) {
          throw new Error("SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()");
        }
        activeEditController = editController2;
      };
      this.deactivate = function(editController2) {
        if (!activeEditController) {
          return;
        }
        if (activeEditController !== editController2) {
          throw new Error("SlickGrid.EditorLock.deactivate: specified editController is not the currently active one");
        }
        activeEditController = null;
      };
      this.commitCurrentEdit = function() {
        return activeEditController ? activeEditController.commitCurrentEdit() : true;
      };
      this.cancelCurrentEdit = function cancelCurrentEdit2() {
        return activeEditController ? activeEditController.cancelCurrentEdit() : true;
      };
    }
    function TreeColumns(treeColumns2) {
      var columnsById2 = {};
      function init4() {
        mapToId(treeColumns2);
      }
      function mapToId(columns2) {
        columns2.forEach(function(column) {
          columnsById2[column.id] = column;
          if (column.columns)
            mapToId(column.columns);
        });
      }
      function filter2(node, condition) {
        return node.filter(function(column) {
          var valid = condition.call(column);
          if (valid && column.columns)
            column.columns = filter2(column.columns, condition);
          return valid && (!column.columns || column.columns.length);
        });
      }
      function sort2(columns2, grid) {
        columns2.sort(function(a2, b2) {
          var indexA = getOrDefault(grid.getColumnIndex(a2.id)), indexB = getOrDefault(grid.getColumnIndex(b2.id));
          return indexA - indexB;
        }).forEach(function(column) {
          if (column.columns)
            sort2(column.columns, grid);
        });
      }
      function getOrDefault(value2) {
        return typeof value2 === "undefined" ? -1 : value2;
      }
      function getDepth(node) {
        if (node.length)
          for (var i2 in node)
            return getDepth(node[i2]);
        else if (node.columns)
          return 1 + getDepth(node.columns);
        else
          return 1;
      }
      function getColumnsInDepth(node, depth, current) {
        var columns2 = [];
        current = current || 0;
        if (depth == current) {
          if (node.length)
            node.forEach(function(n2) {
              if (n2.columns)
                n2.extractColumns = function() {
                  return extractColumns(n2);
                };
            });
          return node;
        } else
          for (var i2 in node)
            if (node[i2].columns) {
              columns2 = columns2.concat(getColumnsInDepth(node[i2].columns, depth, current + 1));
            }
        return columns2;
      }
      function extractColumns(node) {
        var result = [];
        if (node.hasOwnProperty("length")) {
          for (var i2 = 0; i2 < node.length; i2++)
            result = result.concat(extractColumns(node[i2]));
        } else {
          if (node.hasOwnProperty("columns"))
            result = result.concat(extractColumns(node.columns));
          else
            return node;
        }
        return result;
      }
      function cloneTreeColumns() {
        return $2.extend(true, [], treeColumns2);
      }
      init4();
      this.hasDepth = function() {
        for (var i2 in treeColumns2)
          if (treeColumns2[i2].hasOwnProperty("columns"))
            return true;
        return false;
      };
      this.getTreeColumns = function() {
        return treeColumns2;
      };
      this.extractColumns = function() {
        return this.hasDepth() ? extractColumns(treeColumns2) : treeColumns2;
      };
      this.getDepth = function() {
        return getDepth(treeColumns2);
      };
      this.getColumnsInDepth = function(depth) {
        return getColumnsInDepth(treeColumns2, depth);
      };
      this.getColumnsInGroup = function(groups) {
        return extractColumns(groups);
      };
      this.visibleColumns = function() {
        return filter2(cloneTreeColumns(), function() {
          return this.visible;
        });
      };
      this.filter = function(condition) {
        return filter2(cloneTreeColumns(), condition);
      };
      this.reOrder = function(grid) {
        return sort2(treeColumns2, grid);
      };
      this.getById = function(id) {
        return columnsById2[id];
      };
      this.getInIds = function(ids) {
        return ids.map(function(id) {
          return columnsById2[id];
        });
      };
    }
    var Map2 = "Map" in window ? window.Map : function Map3() {
      var data3 = {};
      this.get = function(key) {
        return data3[key];
      };
      this.set = function(key, value2) {
        data3[key] = value2;
      };
      this.has = function(key) {
        return key in data3;
      };
      this.delete = function(key) {
        delete data3[key];
      };
    };
    module2.exports = {
      "Event": Event,
      "EventData": EventData,
      "EventHandler": EventHandler,
      "Range": Range2,
      "Map": Map2,
      "NonDataRow": NonDataItem,
      "Group": Group2,
      "GroupTotals": GroupTotals,
      "EditorLock": EditorLock,
      /***
       * A global singleton editor lock.
       * @class GlobalEditorLock
       * @static
       * @constructor
       */
      "GlobalEditorLock": new EditorLock(),
      "TreeColumns": TreeColumns,
      "keyCode": {
        SPACE: 8,
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        ESC: 27,
        HOME: 36,
        INSERT: 45,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        RIGHT: 39,
        TAB: 9,
        UP: 38,
        A: 65,
        C: 67,
        V: 86
      },
      "preClickClassName": "slick-edit-preclick",
      "GridAutosizeColsMode": {
        None: "NOA",
        LegacyOff: "LOF",
        LegacyForceFit: "LFF",
        IgnoreViewport: "IGV",
        FitColsToViewport: "FCV",
        FitViewportToCols: "FVC"
      },
      "ColAutosizeMode": {
        Locked: "LCK",
        Guide: "GUI",
        Content: "CON",
        ContentIntelligent: "CTI"
      },
      "RowSelectionMode": {
        FirstRow: "FS1",
        FirstNRows: "FSN",
        AllRows: "ALL",
        LastRow: "LS1"
      },
      "ValueFilterMode": {
        None: "NONE",
        DeDuplicate: "DEDP",
        GetGreatestAndSub: "GR8T",
        GetLongestTextAndSub: "LNSB",
        GetLongestText: "LNSC"
      },
      "WidthEvalMode": {
        CanvasTextSize: "CANV",
        HTML: "HTML"
      }
    };
  }
});

// node_modules/@bokeh/slickgrid/plugins/slick.rowselectionmodel.js
var require_slick_rowselectionmodel = __commonJS({
  "node_modules/@bokeh/slickgrid/plugins/slick.rowselectionmodel.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function RowSelectionModel2(options2) {
      var _grid;
      var _ranges = [];
      var _self = this;
      var _handler = new Slick2.EventHandler();
      var _inHandler;
      var _options;
      var _defaults = {
        selectActiveRow: true
      };
      function init4(grid) {
        _options = $2.extend(true, {}, _defaults, options2);
        _grid = grid;
        _handler.subscribe(
          _grid.onActiveCellChanged,
          wrapHandler(handleActiveCellChange)
        );
        _handler.subscribe(
          _grid.onKeyDown,
          wrapHandler(handleKeyDown2)
        );
        _handler.subscribe(
          _grid.onClick,
          wrapHandler(handleClick2)
        );
      }
      function destroy2() {
        _handler.unsubscribeAll();
      }
      function wrapHandler(handler) {
        return function() {
          if (!_inHandler) {
            _inHandler = true;
            handler.apply(this, arguments);
            _inHandler = false;
          }
        };
      }
      function rangesToRows(ranges) {
        var rows = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          for (var j = ranges[i2].fromRow; j <= ranges[i2].toRow; j++) {
            rows.push(j);
          }
        }
        return rows;
      }
      function rowsToRanges2(rows) {
        var ranges = [];
        var lastCell = _grid.getColumns().length - 1;
        for (var i2 = 0; i2 < rows.length; i2++) {
          ranges.push(new Slick2.Range(rows[i2], 0, rows[i2], lastCell));
        }
        return ranges;
      }
      function getRowsRange(from, to) {
        var i2, rows = [];
        for (i2 = from; i2 <= to; i2++) {
          rows.push(i2);
        }
        for (i2 = to; i2 < from; i2++) {
          rows.push(i2);
        }
        return rows;
      }
      function getSelectedRows2() {
        return rangesToRows(_ranges);
      }
      function setSelectedRows2(rows) {
        setSelectedRanges(rowsToRanges2(rows));
      }
      function setSelectedRanges(ranges) {
        if ((!_ranges || _ranges.length === 0) && (!ranges || ranges.length === 0)) {
          return;
        }
        _ranges = ranges;
        _self.onSelectedRangesChanged.notify(_ranges);
      }
      function getSelectedRanges() {
        return _ranges;
      }
      function handleActiveCellChange(e, data3) {
        if (_options.selectActiveRow && data3.row != null) {
          setSelectedRanges([new Slick2.Range(data3.row, 0, data3.row, _grid.getColumns().length - 1)]);
        }
      }
      function handleKeyDown2(e) {
        var activeRow2 = _grid.getActiveCell();
        if (_grid.getOptions().multiSelect && activeRow2 && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (e.which == Slick2.keyCode.UP || e.which == Slick2.keyCode.DOWN)) {
          var selectedRows2 = getSelectedRows2();
          selectedRows2.sort(function(x2, y2) {
            return x2 - y2;
          });
          if (!selectedRows2.length) {
            selectedRows2 = [activeRow2.row];
          }
          var top = selectedRows2[0];
          var bottom = selectedRows2[selectedRows2.length - 1];
          var active8;
          if (e.which == Slick2.keyCode.DOWN) {
            active8 = activeRow2.row < bottom || top == bottom ? ++bottom : ++top;
          } else {
            active8 = activeRow2.row < bottom ? --bottom : --top;
          }
          if (active8 >= 0 && active8 < _grid.getDataLength()) {
            _grid.scrollRowIntoView(active8);
            var tempRanges = rowsToRanges2(getRowsRange(top, bottom));
            setSelectedRanges(tempRanges);
          }
          e.preventDefault();
          e.stopPropagation();
        }
      }
      function handleClick2(e) {
        var cell = _grid.getCellFromEvent(e);
        if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {
          return false;
        }
        if (!_grid.getOptions().multiSelect || !e.ctrlKey && !e.shiftKey && !e.metaKey) {
          return false;
        }
        var selection = rangesToRows(_ranges);
        var idx = $2.inArray(cell.row, selection);
        if (idx === -1 && (e.ctrlKey || e.metaKey)) {
          selection.push(cell.row);
          _grid.setActiveCell(cell.row, cell.cell);
        } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {
          selection = $2.grep(selection, function(o, i3) {
            return o !== cell.row;
          });
          _grid.setActiveCell(cell.row, cell.cell);
        } else if (selection.length && e.shiftKey) {
          var last2 = selection.pop();
          var from = Math.min(cell.row, last2);
          var to = Math.max(cell.row, last2);
          selection = [];
          for (var i2 = from; i2 <= to; i2++) {
            if (i2 !== last2) {
              selection.push(i2);
            }
          }
          selection.push(last2);
          _grid.setActiveCell(cell.row, cell.cell);
        }
        var tempRanges = rowsToRanges2(selection);
        setSelectedRanges(tempRanges);
        e.stopImmediatePropagation();
        return true;
      }
      $2.extend(this, {
        "getSelectedRows": getSelectedRows2,
        "setSelectedRows": setSelectedRows2,
        "getSelectedRanges": getSelectedRanges,
        "setSelectedRanges": setSelectedRanges,
        "init": init4,
        "destroy": destroy2,
        "pluginName": "RowSelectionModel",
        "onSelectedRangesChanged": new Slick2.Event()
      });
    }
    module2.exports = {
      "RowSelectionModel": RowSelectionModel2
    };
  }
});

// node_modules/@bokeh/slickgrid/plugins/slick.checkboxselectcolumn.js
var require_slick_checkboxselectcolumn = __commonJS({
  "node_modules/@bokeh/slickgrid/plugins/slick.checkboxselectcolumn.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function CheckboxSelectColumn2(options2) {
      var _grid;
      var _selectableOverride = null;
      var _selectAll_UID = createUID();
      var _handler = new Slick2.EventHandler();
      var _selectedRowsLookup = {};
      var _defaults = {
        columnId: "_checkbox_selector",
        cssClass: null,
        hideSelectAllCheckbox: false,
        toolTip: "Select/Deselect All",
        width: 30,
        hideInColumnTitleRow: false,
        hideInFilterHeaderRow: true
      };
      var _isSelectAllChecked = false;
      var _options = $2.extend(true, {}, _defaults, options2);
      if (typeof _options.selectableOverride === "function") {
        selectableOverride(_options.selectableOverride);
      }
      function init4(grid) {
        _grid = grid;
        _handler.subscribe(_grid.onSelectedRowsChanged, handleSelectedRowsChanged).subscribe(_grid.onClick, handleClick2).subscribe(_grid.onKeyDown, handleKeyDown2);
        if (!_options.hideInFilterHeaderRow) {
          addCheckboxToFilterHeaderRow(grid);
        }
        if (!_options.hideInColumnTitleRow) {
          _handler.subscribe(_grid.onHeaderClick, handleHeaderClick2);
        }
      }
      function destroy2() {
        _handler.unsubscribeAll();
      }
      function getOptions2() {
        return _options;
      }
      function setOptions2(options3) {
        _options = $2.extend(true, {}, _options, options3);
        if (_options.hideSelectAllCheckbox) {
          hideSelectAllFromColumnHeaderTitleRow();
          hideSelectAllFromColumnHeaderFilterRow();
        } else {
          if (!_options.hideInColumnTitleRow) {
            renderSelectAllCheckbox(_isSelectAllChecked);
            _handler.subscribe(_grid.onHeaderClick, handleHeaderClick2);
          } else {
            hideSelectAllFromColumnHeaderTitleRow();
          }
          if (!_options.hideInFilterHeaderRow) {
            var selectAllContainer = $2("#filter-checkbox-selectall-container");
            selectAllContainer.show();
            selectAllContainer.find('input[type="checkbox"]').prop("checked", _isSelectAllChecked);
          } else {
            hideSelectAllFromColumnHeaderFilterRow();
          }
        }
      }
      function hideSelectAllFromColumnHeaderTitleRow() {
        _grid.updateColumnHeader(_options.columnId, "", "");
      }
      function hideSelectAllFromColumnHeaderFilterRow() {
        $2("#filter-checkbox-selectall-container").hide();
      }
      function handleSelectedRowsChanged(e, args) {
        var selectedRows2 = _grid.getSelectedRows();
        var lookup = {}, row2, i2, k;
        var disabledCount = 0;
        if (typeof _selectableOverride === "function") {
          for (k = 0; k < _grid.getDataLength(); k++) {
            var dataItem = _grid.getDataItem(k);
            if (!checkSelectableOverride(i2, dataItem, _grid)) {
              disabledCount++;
            }
          }
        }
        var removeList = [];
        for (i2 = 0; i2 < selectedRows2.length; i2++) {
          row2 = selectedRows2[i2];
          var rowItem = _grid.getDataItem(row2);
          if (checkSelectableOverride(i2, rowItem, _grid)) {
            lookup[row2] = true;
            if (lookup[row2] !== _selectedRowsLookup[row2]) {
              _grid.invalidateRow(row2);
              delete _selectedRowsLookup[row2];
            }
          } else {
            removeList.push(row2);
          }
        }
        for (i2 in _selectedRowsLookup) {
          _grid.invalidateRow(i2);
        }
        _selectedRowsLookup = lookup;
        _grid.render();
        _isSelectAllChecked = selectedRows2.length && selectedRows2.length + disabledCount >= _grid.getDataLength();
        if (!_options.hideInColumnTitleRow && !_options.hideSelectAllCheckbox) {
          renderSelectAllCheckbox(_isSelectAllChecked);
        }
        if (!_options.hideInFilterHeaderRow) {
          var selectAllElm = $2("#header-filter-selector" + _selectAll_UID);
          selectAllElm.prop("checked", _isSelectAllChecked);
        }
        if (removeList.length > 0) {
          for (i2 = 0; i2 < removeList.length; i2++) {
            var remIdx = selectedRows2.indexOf(removeList[i2]);
            selectedRows2.splice(remIdx, 1);
          }
          _grid.setSelectedRows(selectedRows2);
        }
      }
      function handleKeyDown2(e, args) {
        if (e.which == 32) {
          if (_grid.getColumns()[args.cell].id === _options.columnId) {
            if (!_grid.getEditorLock().isActive() || _grid.getEditorLock().commitCurrentEdit()) {
              toggleRowSelection(args.row);
            }
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }
      }
      function handleClick2(e, args) {
        if (_grid.getColumns()[args.cell].id === _options.columnId && $2(e.target).is(":checkbox")) {
          if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return;
          }
          toggleRowSelection(args.row);
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
      function toggleRowSelection(row2) {
        var dataContext = _grid.getDataItem(row2);
        if (!checkSelectableOverride(row2, dataContext, _grid)) {
          return;
        }
        if (_selectedRowsLookup[row2]) {
          _grid.setSelectedRows($2.grep(_grid.getSelectedRows(), function(n2) {
            return n2 != row2;
          }));
        } else {
          _grid.setSelectedRows(_grid.getSelectedRows().concat(row2));
        }
        _grid.setActiveCell(row2, getCheckboxColumnCellIndex());
      }
      function selectRows(rowArray) {
        var i2, l = rowArray.length, addRows = [];
        for (i2 = 0; i2 < l; i2++) {
          if (!_selectedRowsLookup[rowArray[i2]]) {
            addRows[addRows.length] = rowArray[i2];
          }
        }
        _grid.setSelectedRows(_grid.getSelectedRows().concat(addRows));
      }
      function deSelectRows(rowArray) {
        var i2, l = rowArray.length, removeRows = [];
        for (i2 = 0; i2 < l; i2++) {
          if (_selectedRowsLookup[rowArray[i2]]) {
            removeRows[removeRows.length] = rowArray[i2];
          }
        }
        _grid.setSelectedRows($2.grep(_grid.getSelectedRows(), function(n2) {
          return removeRows.indexOf(n2) < 0;
        }));
      }
      function handleHeaderClick2(e, args) {
        if (args.column.id == _options.columnId && $2(e.target).is(":checkbox")) {
          if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return;
          }
          if ($2(e.target).is(":checked")) {
            var rows = [];
            for (var i2 = 0; i2 < _grid.getDataLength(); i2++) {
              var rowItem = _grid.getDataItem(i2);
              if (!rowItem.__group && !rowItem.__groupTotals && checkSelectableOverride(i2, rowItem, _grid)) {
                rows.push(i2);
              }
            }
            _grid.setSelectedRows(rows);
          } else {
            _grid.setSelectedRows([]);
          }
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
      var _checkboxColumnCellIndex = null;
      function getCheckboxColumnCellIndex() {
        if (_checkboxColumnCellIndex === null) {
          _checkboxColumnCellIndex = 0;
          var colArr = _grid.getColumns();
          for (var i2 = 0; i2 < colArr.length; i2++) {
            if (colArr[i2].id == _options.columnId) {
              _checkboxColumnCellIndex = i2;
            }
          }
        }
        return _checkboxColumnCellIndex;
      }
      function getColumnDefinition() {
        return {
          id: _options.columnId,
          name: _options.hideSelectAllCheckbox || _options.hideInColumnTitleRow ? "" : "<input id='header-selector" + _selectAll_UID + "' type='checkbox'><label for='header-selector" + _selectAll_UID + "'></label>",
          toolTip: _options.hideSelectAllCheckbox || _options.hideInColumnTitleRow ? "" : _options.toolTip,
          field: "sel",
          width: _options.width,
          resizable: false,
          sortable: false,
          cssClass: _options.cssClass,
          hideSelectAllCheckbox: _options.hideSelectAllCheckbox,
          formatter: checkboxSelectionFormatter
        };
      }
      function addCheckboxToFilterHeaderRow(grid) {
        _handler.subscribe(grid.onHeaderRowCellRendered, function(e, args) {
          if (args.column.field === "sel") {
            $2(args.node).empty();
            $2("<span id='filter-checkbox-selectall-container'><input id='header-filter-selector" + _selectAll_UID + "' type='checkbox'><label for='header-filter-selector" + _selectAll_UID + "'></label></span>").appendTo(args.node).on("click", function(evnt) {
              handleHeaderClick2(evnt, args);
            });
          }
        });
      }
      function createUID() {
        return Math.round(1e7 * Math.random());
      }
      function checkboxSelectionFormatter(row2, cell, value2, columnDef, dataContext, grid) {
        var UID = createUID() + row2;
        if (dataContext) {
          if (!checkSelectableOverride(row2, dataContext, grid)) {
            return null;
          } else {
            return _selectedRowsLookup[row2] ? "<input id='selector" + UID + "' type='checkbox' checked='checked'><label for='selector" + UID + "'></label>" : "<input id='selector" + UID + "' type='checkbox'><label for='selector" + UID + "'></label>";
          }
        }
        return null;
      }
      function checkSelectableOverride(row2, dataContext, grid) {
        if (typeof _selectableOverride === "function") {
          return _selectableOverride(row2, dataContext, grid);
        }
        return true;
      }
      function renderSelectAllCheckbox(isSelectAllChecked) {
        if (isSelectAllChecked) {
          _grid.updateColumnHeader(_options.columnId, "<input id='header-selector" + _selectAll_UID + "' type='checkbox' checked='checked'><label for='header-selector" + _selectAll_UID + "'></label>", _options.toolTip);
        } else {
          _grid.updateColumnHeader(_options.columnId, "<input id='header-selector" + _selectAll_UID + "' type='checkbox'><label for='header-selector" + _selectAll_UID + "'></label>", _options.toolTip);
        }
      }
      function selectableOverride(overrideFn) {
        _selectableOverride = overrideFn;
      }
      $2.extend(this, {
        "init": init4,
        "destroy": destroy2,
        "pluginName": "CheckboxSelectColumn",
        "deSelectRows": deSelectRows,
        "selectRows": selectRows,
        "getColumnDefinition": getColumnDefinition,
        "getOptions": getOptions2,
        "selectableOverride": selectableOverride,
        "setOptions": setOptions2
      });
    }
    module2.exports = {
      "CheckboxSelectColumn": CheckboxSelectColumn2
    };
  }
});

// node_modules/@bokeh/slickgrid/plugins/slick.cellexternalcopymanager.js
var require_slick_cellexternalcopymanager = __commonJS({
  "node_modules/@bokeh/slickgrid/plugins/slick.cellexternalcopymanager.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    var keyCodes = Slick2.keyCode;
    function CellExternalCopyManager2(options2) {
      var _grid;
      var _self = this;
      var _copiedRanges;
      var _options = options2 || {};
      var _copiedCellStyleLayerKey = _options.copiedCellStyleLayerKey || "copy-manager";
      var _copiedCellStyle = _options.copiedCellStyle || "copied";
      var _clearCopyTI = 0;
      var _bodyElement = _options.bodyElement || document.body;
      var _onCopyInit = _options.onCopyInit || null;
      var _onCopySuccess = _options.onCopySuccess || null;
      function init4(grid) {
        _grid = grid;
        _grid.onKeyDown.subscribe(handleKeyDown2);
        var cellSelectionModel = grid.getSelectionModel();
        if (!cellSelectionModel) {
          throw new Error("Selection model is mandatory for this plugin. Please set a selection model on the grid before adding this plugin: grid.setSelectionModel(new Slick.CellSelectionModel())");
        }
        cellSelectionModel.onSelectedRangesChanged.subscribe(function(e, args) {
          _grid.focus();
        });
      }
      function destroy2() {
        _grid.onKeyDown.unsubscribe(handleKeyDown2);
      }
      function getHeaderValueForColumn(columnDef) {
        if (_options.headerColumnValueExtractor) {
          var val = _options.headerColumnValueExtractor(columnDef);
          if (val) {
            return val;
          }
        }
        return columnDef.name;
      }
      function getDataItemValueForColumn2(item3, columnDef, e) {
        if (_options.dataItemColumnValueExtractor) {
          var val = _options.dataItemColumnValueExtractor(item3, columnDef);
          if (val) {
            return val;
          }
        }
        var retVal = "";
        if (columnDef.editor) {
          var editorArgs = {
            "container": $2("<p>"),
            // a dummy container
            "column": columnDef,
            "position": { "top": 0, "left": 0 },
            // a dummy position required by some editors
            "grid": _grid,
            "event": e
          };
          var editor = new columnDef.editor(editorArgs);
          editor.loadValue(item3);
          retVal = editor.serializeValue();
          editor.destroy();
        } else {
          retVal = item3[columnDef.field];
        }
        return retVal;
      }
      function setDataItemValueForColumn(item3, columnDef, value2) {
        if (columnDef.denyPaste) {
          return null;
        }
        if (_options.dataItemColumnValueSetter) {
          return _options.dataItemColumnValueSetter(item3, columnDef, value2);
        }
        if (columnDef.editor) {
          var editorArgs = {
            "container": $2("body"),
            // a dummy container
            "column": columnDef,
            "position": { "top": 0, "left": 0 },
            // a dummy position required by some editors
            "grid": _grid
          };
          var editor = new columnDef.editor(editorArgs);
          editor.loadValue(item3);
          editor.applyValue(item3, value2);
          editor.destroy();
        } else {
          item3[columnDef.field] = value2;
        }
      }
      function _createTextBox(innerText) {
        var ta = document.createElement("textarea");
        ta.style.position = "absolute";
        ta.style.left = "-1000px";
        ta.style.top = document.body.scrollTop + "px";
        ta.value = innerText;
        _bodyElement.appendChild(ta);
        ta.select();
        return ta;
      }
      function _decodeTabularData(_grid2, ta) {
        var columns2 = _grid2.getColumns();
        var clipText = ta.value;
        var clipRows = clipText.split(/[\n\f\r]/);
        if (clipRows[clipRows.length - 1] === "") {
          clipRows.pop();
        }
        var clippedRange = [];
        var j = 0;
        _bodyElement.removeChild(ta);
        for (var i2 = 0; i2 < clipRows.length; i2++) {
          if (clipRows[i2] !== "")
            clippedRange[j++] = clipRows[i2].split("	");
          else
            clippedRange[j++] = [""];
        }
        var selectedCell = _grid2.getActiveCell();
        var ranges = _grid2.getSelectionModel().getSelectedRanges();
        var selectedRange = ranges && ranges.length ? ranges[0] : null;
        var activeRow2 = null;
        var activeCell2 = null;
        if (selectedRange) {
          activeRow2 = selectedRange.fromRow;
          activeCell2 = selectedRange.fromCell;
        } else if (selectedCell) {
          activeRow2 = selectedCell.row;
          activeCell2 = selectedCell.cell;
        } else {
          return;
        }
        var oneCellToMultiple = false;
        var destH = clippedRange.length;
        var destW = clippedRange.length ? clippedRange[0].length : 0;
        if (clippedRange.length == 1 && clippedRange[0].length == 1 && selectedRange) {
          oneCellToMultiple = true;
          destH = selectedRange.toRow - selectedRange.fromRow + 1;
          destW = selectedRange.toCell - selectedRange.fromCell + 1;
        }
        var availableRows = _grid2.getData().length - activeRow2;
        var addRows = 0;
        if (availableRows < destH && _options.newRowCreator) {
          var d = _grid2.getData();
          for (addRows = 1; addRows <= destH - availableRows; addRows++)
            d.push({});
          _grid2.setData(d);
          _grid2.render();
        }
        var overflowsBottomOfGrid = activeRow2 + destH > _grid2.getDataLength();
        if (_options.newRowCreator && overflowsBottomOfGrid) {
          var newRowsNeeded = activeRow2 + destH - _grid2.getDataLength();
          _options.newRowCreator(newRowsNeeded);
        }
        var clipCommand = {
          isClipboardCommand: true,
          clippedRange,
          oldValues: [],
          cellExternalCopyManager: _self,
          _options,
          setDataItemValueForColumn,
          markCopySelection,
          oneCellToMultiple,
          activeRow: activeRow2,
          activeCell: activeCell2,
          destH,
          destW,
          maxDestY: _grid2.getDataLength(),
          maxDestX: _grid2.getColumns().length,
          h: 0,
          w: 0,
          execute: function() {
            this.h = 0;
            for (var y2 = 0; y2 < this.destH; y2++) {
              this.oldValues[y2] = [];
              this.w = 0;
              this.h++;
              for (var x2 = 0; x2 < this.destW; x2++) {
                this.w++;
                var desty = activeRow2 + y2;
                var destx = activeCell2 + x2;
                if (desty < this.maxDestY && destx < this.maxDestX) {
                  var nd = _grid2.getCellNode(desty, destx);
                  var dt2 = _grid2.getDataItem(desty);
                  this.oldValues[y2][x2] = dt2[columns2[destx]["field"]];
                  if (oneCellToMultiple)
                    this.setDataItemValueForColumn(dt2, columns2[destx], clippedRange[0][0]);
                  else
                    this.setDataItemValueForColumn(dt2, columns2[destx], clippedRange[y2] ? clippedRange[y2][x2] : "");
                  _grid2.updateCell(desty, destx);
                  _grid2.onCellChange.notify({
                    row: desty,
                    cell: destx,
                    item: dt2,
                    grid: _grid2
                  });
                }
              }
            }
            var bRange = {
              "fromCell": activeCell2,
              "fromRow": activeRow2,
              "toCell": activeCell2 + this.w - 1,
              "toRow": activeRow2 + this.h - 1
            };
            this.markCopySelection([bRange]);
            _grid2.getSelectionModel().setSelectedRanges([bRange]);
            this.cellExternalCopyManager.onPasteCells.notify({ ranges: [bRange] });
          },
          undo: function() {
            for (var y2 = 0; y2 < this.destH; y2++) {
              for (var x2 = 0; x2 < this.destW; x2++) {
                var desty = activeRow2 + y2;
                var destx = activeCell2 + x2;
                if (desty < this.maxDestY && destx < this.maxDestX) {
                  var nd = _grid2.getCellNode(desty, destx);
                  var dt2 = _grid2.getDataItem(desty);
                  if (oneCellToMultiple)
                    this.setDataItemValueForColumn(dt2, columns2[destx], this.oldValues[0][0]);
                  else
                    this.setDataItemValueForColumn(dt2, columns2[destx], this.oldValues[y2][x2]);
                  _grid2.updateCell(desty, destx);
                  _grid2.onCellChange.notify({
                    row: desty,
                    cell: destx,
                    item: dt2,
                    grid: _grid2
                  });
                }
              }
            }
            var bRange = {
              "fromCell": activeCell2,
              "fromRow": activeRow2,
              "toCell": activeCell2 + this.w - 1,
              "toRow": activeRow2 + this.h - 1
            };
            this.markCopySelection([bRange]);
            _grid2.getSelectionModel().setSelectedRanges([bRange]);
            this.cellExternalCopyManager.onPasteCells.notify({ ranges: [bRange] });
            if (addRows > 1) {
              var d2 = _grid2.getData();
              for (; addRows > 1; addRows--)
                d2.splice(d2.length - 1, 1);
              _grid2.setData(d2);
              _grid2.render();
            }
          }
        };
        if (_options.clipboardCommandHandler) {
          _options.clipboardCommandHandler(clipCommand);
        } else {
          clipCommand.execute();
        }
      }
      function handleKeyDown2(e, args) {
        var ranges;
        if (!_grid.getEditorLock().isActive() || _grid.getOptions().autoEdit) {
          if (e.which == keyCodes.ESC) {
            if (_copiedRanges) {
              e.preventDefault();
              clearCopySelection();
              _self.onCopyCancelled.notify({ ranges: _copiedRanges });
              _copiedRanges = null;
            }
          }
          if ((e.which === keyCodes.C || e.which === keyCodes.INSERT) && (e.ctrlKey || e.metaKey) && !e.shiftKey) {
            if (_onCopyInit) {
              _onCopyInit.call();
            }
            ranges = _grid.getSelectionModel().getSelectedRanges();
            if (ranges.length !== 0) {
              _copiedRanges = ranges;
              markCopySelection(ranges);
              _self.onCopyCells.notify({ ranges });
              var columns2 = _grid.getColumns();
              var clipText = "";
              for (var rg = 0; rg < ranges.length; rg++) {
                var range2 = ranges[rg];
                var clipTextRows = [];
                for (var i2 = range2.fromRow; i2 < range2.toRow + 1; i2++) {
                  var clipTextCells = [];
                  var dt2 = _grid.getDataItem(i2);
                  if (clipTextRows.length === 0 && _options.includeHeaderWhenCopying) {
                    var clipTextHeaders = [];
                    for (var j = range2.fromCell; j < range2.toCell + 1; j++) {
                      if (columns2[j].name.length > 0)
                        clipTextHeaders.push(getHeaderValueForColumn(columns2[j]));
                    }
                    clipTextRows.push(clipTextHeaders.join("	"));
                  }
                  for (var j = range2.fromCell; j < range2.toCell + 1; j++) {
                    clipTextCells.push(getDataItemValueForColumn2(dt2, columns2[j], e));
                  }
                  clipTextRows.push(clipTextCells.join("	"));
                }
                clipText += clipTextRows.join("\r\n") + "\r\n";
              }
              if (window.clipboardData) {
                window.clipboardData.setData("Text", clipText);
                return true;
              } else {
                var focusEl = document.activeElement;
                var ta = _createTextBox(clipText);
                ta.focus();
                setTimeout(function() {
                  _bodyElement.removeChild(ta);
                  if (focusEl)
                    focusEl.focus();
                  else
                    console.log("Not element to restore focus to after copy?");
                }, 100);
                if (_onCopySuccess) {
                  var rowCount = 0;
                  if (ranges.length === 1) {
                    rowCount = ranges[0].toRow + 1 - ranges[0].fromRow;
                  } else {
                    rowCount = ranges.length;
                  }
                  _onCopySuccess.call(this, rowCount);
                }
                return false;
              }
            }
          }
          if (!_options.readOnlyMode && (e.which === keyCodes.V && (e.ctrlKey || e.metaKey) && !e.shiftKey || e.which === keyCodes.INSERT && e.shiftKey && !e.ctrlKey)) {
            var ta = _createTextBox("");
            setTimeout(function() {
              _decodeTabularData(_grid, ta);
            }, 100);
            return false;
          }
        }
      }
      function markCopySelection(ranges) {
        clearCopySelection();
        var columns2 = _grid.getColumns();
        var hash = {};
        for (var i2 = 0; i2 < ranges.length; i2++) {
          for (var j = ranges[i2].fromRow; j <= ranges[i2].toRow; j++) {
            hash[j] = {};
            for (var k = ranges[i2].fromCell; k <= ranges[i2].toCell && k < columns2.length; k++) {
              hash[j][columns2[k].id] = _copiedCellStyle;
            }
          }
        }
        _grid.setCellCssStyles(_copiedCellStyleLayerKey, hash);
        clearTimeout(_clearCopyTI);
        _clearCopyTI = setTimeout(function() {
          _self.clearCopySelection();
        }, 2e3);
      }
      function clearCopySelection() {
        _grid.removeCellCssStyles(_copiedCellStyleLayerKey);
      }
      function setIncludeHeaderWhenCopying(includeHeaderWhenCopying) {
        _options.includeHeaderWhenCopying = includeHeaderWhenCopying;
      }
      $2.extend(this, {
        "init": init4,
        "destroy": destroy2,
        "pluginName": "CellExternalCopyManager",
        "clearCopySelection": clearCopySelection,
        "handleKeyDown": handleKeyDown2,
        "onCopyCells": new Slick2.Event(),
        "onCopyCancelled": new Slick2.Event(),
        "onPasteCells": new Slick2.Event(),
        "setIncludeHeaderWhenCopying": setIncludeHeaderWhenCopying
      });
    }
    module2.exports = {
      "CellExternalCopyManager": CellExternalCopyManager2
    };
  }
});

// node_modules/@bokeh/slickgrid/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate3,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values
});
function __extends(d, b2) {
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body2.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y2 = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports4) {
  for (var p2 in m) if (p2 !== "default" && !exports4.hasOwnProperty(p2)) exports4[p2] = m[p2];
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i2 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i2 >= o.length) o = void 0;
      return { value: o && o[i2++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i2.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays2() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r[k] = a2[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g[n2]) i2[n2] = function(v) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v, a2, b2]) > 1 || resume(n2, v);
      });
    };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f2, v) {
    if (f2(v), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o[n2] ? function(v) {
      return (p2 = !p2) ? { value: __await(o[n2](v)), done: n2 === "return" } : f2 ? f2(v) : v;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value2) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value2);
  return value2;
}
var extendStatics, __assign2;
var init_tslib_es6 = __esm({
  "node_modules/@bokeh/slickgrid/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p2 in b3) if (b3.hasOwnProperty(p2)) d2[p2] = b3[p2];
      };
      return extendStatics(d, b2);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// node_modules/@bokeh/slickgrid/lib/jquery.event.drag-2.3.0.js
var require_jquery_event_drag_2_3_0 = __commonJS({
  "node_modules/@bokeh/slickgrid/lib/jquery.event.drag-2.3.0.js"() {
    var $2 = require_slick_jquery();
    $2.fn.drag = function(str, arg, opts) {
      var type = typeof str == "string" ? str : "", fn = $2.isFunction(str) ? str : $2.isFunction(arg) ? arg : null;
      if (type.indexOf("drag") !== 0)
        type = "drag" + type;
      opts = (str == fn ? arg : opts) || {};
      return fn ? this.on(type, opts, fn) : this.trigger(type);
    };
    var $event = $2.event;
    var $special = $event.special;
    var drag = $special.drag = {
      // these are the default settings
      defaults: {
        which: 1,
        // mouse button pressed to start drag sequence
        distance: 0,
        // distance dragged before dragstart
        not: ":input",
        // selector to suppress dragging on target elements
        handle: null,
        // selector to match handle target elements
        relative: false,
        // true to use "position", false to use "offset"
        drop: true,
        // false to suppress drop events, true or selector to allow
        click: false
        // false to suppress click events after dragend (no proxy)
      },
      // the key name for stored drag data
      datakey: "dragdata",
      // prevent bubbling for better performance
      noBubble: true,
      // count bound related events
      add: function(obj) {
        var data3 = $2.data(this, drag.datakey), opts = obj.data || {};
        data3.related += 1;
        $2.each(drag.defaults, function(key, def) {
          if (opts[key] !== void 0)
            data3[key] = opts[key];
        });
      },
      // forget unbound related events
      remove: function() {
        $2.data(this, drag.datakey).related -= 1;
      },
      // configure interaction, capture settings
      setup: function() {
        if ($2.data(this, drag.datakey))
          return;
        var data3 = $2.extend({ related: 0 }, drag.defaults);
        $2.data(this, drag.datakey, data3);
        $event.add(this, "touchstart mousedown", drag.init, data3);
        if (this.attachEvent)
          this.attachEvent("ondragstart", drag.dontstart);
      },
      // destroy configured interaction
      teardown: function() {
        var data3 = $2.data(this, drag.datakey) || {};
        if (data3.related)
          return;
        $2.removeData(this, drag.datakey);
        $event.remove(this, "touchstart mousedown", drag.init);
        drag.textselect(true);
        if (this.detachEvent)
          this.detachEvent("ondragstart", drag.dontstart);
      },
      // initialize the interaction
      init: function(event2) {
        if (drag.touched)
          return;
        var dd2 = event2.data, results;
        if (event2.which != 0 && dd2.which > 0 && event2.which != dd2.which)
          return;
        var targetClass = $2(event2.target).attr("class") || "";
        if ($2(event2.target).is(dd2.not) || (!targetClass || targetClass.toString().indexOf("slick") === -1))
          return;
        if (dd2.handle && !$2(event2.target).closest(dd2.handle, event2.currentTarget).length)
          return;
        drag.touched = event2.type == "touchstart" ? this : null;
        dd2.propagates = 1;
        dd2.mousedown = this;
        dd2.interactions = [drag.interaction(this, dd2)];
        dd2.target = event2.target;
        dd2.pageX = event2.pageX;
        dd2.pageY = event2.pageY;
        dd2.dragging = null;
        results = drag.hijack(event2, "draginit", dd2);
        if (!dd2.propagates)
          return;
        results = drag.flatten(results);
        if (results && results.length) {
          dd2.interactions = [];
          $2.each(results, function() {
            dd2.interactions.push(drag.interaction(this, dd2));
          });
        }
        dd2.propagates = dd2.interactions.length;
        if (dd2.drop !== false && $special.drop)
          $special.drop.handler(event2, dd2);
        drag.textselect(false);
        if (drag.touched)
          $event.add(drag.touched, "touchmove touchend", drag.handler, dd2);
        else
          $event.add(document, "mousemove mouseup", drag.handler, dd2);
        if (!drag.touched || dd2.live)
          return false;
      },
      // returns an interaction object
      interaction: function(elem, dd2) {
        var offset3 = elem && elem.ownerDocument ? $2(elem)[dd2.relative ? "position" : "offset"]() || { top: 0, left: 0 } : { top: 0, left: 0 };
        return {
          drag: elem,
          callback: new drag.callback(),
          droppable: [],
          offset: offset3
        };
      },
      // handle drag-releatd DOM events
      handler: function(event2) {
        var dd2 = event2.data;
        switch (event2.type) {
          case (!dd2.dragging && "touchmove"):
            event2.preventDefault();
          case (!dd2.dragging && "mousemove"):
            if (Math.pow(event2.pageX - dd2.pageX, 2) + Math.pow(event2.pageY - dd2.pageY, 2) < Math.pow(dd2.distance, 2))
              break;
            event2.target = dd2.target;
            drag.hijack(event2, "dragstart", dd2);
            if (dd2.propagates)
              dd2.dragging = true;
          case "touchmove":
            event2.preventDefault();
          case "mousemove":
            if (dd2.dragging) {
              drag.hijack(event2, "drag", dd2);
              if (dd2.propagates) {
                if (dd2.drop !== false && $special.drop)
                  $special.drop.handler(event2, dd2);
                break;
              }
              event2.type = "mouseup";
            }
          case "touchend":
          case "mouseup":
          default:
            if (drag.touched)
              $event.remove(drag.touched, "touchmove touchend", drag.handler);
            else
              $event.remove(document, "mousemove mouseup", drag.handler);
            if (dd2.dragging) {
              if (dd2.drop !== false && $special.drop)
                $special.drop.handler(event2, dd2);
              drag.hijack(event2, "dragend", dd2);
            }
            drag.textselect(true);
            if (dd2.click === false && dd2.dragging)
              $2.data(dd2.mousedown, "suppress.click", (/* @__PURE__ */ new Date()).getTime() + 5);
            dd2.dragging = drag.touched = false;
            break;
        }
      },
      // re-use event object for custom events
      hijack: function(event2, type, dd2, x2, elem) {
        if (!dd2)
          return;
        var orig = { event: event2.originalEvent, type: event2.type }, mode = type.indexOf("drop") ? "drag" : "drop", result, i2 = x2 || 0, ia, $elems, callback, len = !isNaN(x2) ? x2 : dd2.interactions.length;
        event2.type = type;
        var noop = function() {
        };
        event2.originalEvent = new $2.Event(orig.event, {
          preventDefault: noop,
          stopPropagation: noop,
          stopImmediatePropagation: noop
        });
        dd2.results = [];
        do
          if (ia = dd2.interactions[i2]) {
            if (type !== "dragend" && ia.cancelled)
              continue;
            callback = drag.properties(event2, dd2, ia);
            ia.results = [];
            $2(elem || ia[mode] || dd2.droppable).each(function(p2, subject) {
              callback.target = subject;
              event2.isPropagationStopped = function() {
                return false;
              };
              result = subject ? $event.dispatch.call(subject, event2, callback) : null;
              if (result === false) {
                if (mode == "drag") {
                  ia.cancelled = true;
                  dd2.propagates -= 1;
                }
                if (type == "drop") {
                  ia[mode][p2] = null;
                }
              } else if (type == "dropinit")
                ia.droppable.push(drag.element(result) || subject);
              if (type == "dragstart")
                ia.proxy = $2(drag.element(result) || ia.drag)[0];
              ia.results.push(result);
              delete event2.result;
              if (type !== "dropinit")
                return result;
            });
            dd2.results[i2] = drag.flatten(ia.results);
            if (type == "dropinit")
              ia.droppable = drag.flatten(ia.droppable);
            if (type == "dragstart" && !ia.cancelled)
              callback.update();
          }
        while (++i2 < len);
        event2.type = orig.type;
        event2.originalEvent = orig.event;
        return drag.flatten(dd2.results);
      },
      // extend the callback object with drag/drop properties...
      properties: function(event2, dd2, ia) {
        var obj = ia.callback;
        obj.drag = ia.drag;
        obj.proxy = ia.proxy || ia.drag;
        obj.startX = dd2.pageX;
        obj.startY = dd2.pageY;
        obj.deltaX = event2.pageX - dd2.pageX;
        obj.deltaY = event2.pageY - dd2.pageY;
        obj.originalX = ia.offset.left;
        obj.originalY = ia.offset.top;
        obj.offsetX = obj.originalX + obj.deltaX;
        obj.offsetY = obj.originalY + obj.deltaY;
        obj.drop = drag.flatten((ia.drop || []).slice());
        obj.available = drag.flatten((ia.droppable || []).slice());
        return obj;
      },
      // determine is the argument is an element or jquery instance
      element: function(arg) {
        if (arg && (arg.jquery || arg.nodeType == 1))
          return arg;
      },
      // flatten nested jquery objects and arrays into a single dimension array
      flatten: function(arr) {
        return $2.map(arr, function(member) {
          return member && member.jquery ? $2.makeArray(member) : member && member.length ? drag.flatten(member) : member;
        });
      },
      // toggles text selection attributes ON (true) or OFF (false)
      textselect: function(bool) {
        $2(document)[bool ? "off" : "on"]("selectstart", drag.dontstart).css("MozUserSelect", bool ? "" : "none");
        document.unselectable = bool ? "off" : "on";
      },
      // suppress "selectstart" and "ondragstart" events
      dontstart: function() {
        return false;
      },
      // a callback instance contructor
      callback: function() {
      }
    };
    drag.callback.prototype = {
      update: function() {
        if ($special.drop && this.available.length)
          $2.each(this.available, function(i2) {
            $special.drop.locate(this, i2);
          });
      }
    };
    var $dispatch = $event.dispatch;
    $event.dispatch = function(event2) {
      if ($2.data(this, "suppress." + event2.type) - (/* @__PURE__ */ new Date()).getTime() > 0) {
        $2.removeData(this, "suppress." + event2.type);
        return;
      }
      return $dispatch.apply(this, arguments);
    };
    $special.draginit = $special.dragstart = $special.dragend = drag;
  }
});

// node_modules/@bokeh/slickgrid/lib/jquery.event.drop-2.3.0.js
var require_jquery_event_drop_2_3_0 = __commonJS({
  "node_modules/@bokeh/slickgrid/lib/jquery.event.drop-2.3.0.js"() {
    var $2 = require_slick_jquery();
    $2.fn.drop = function(str, arg, opts) {
      var type = typeof str == "string" ? str : "", fn = $2.isFunction(str) ? str : $2.isFunction(arg) ? arg : null;
      if (type.indexOf("drop") !== 0)
        type = "drop" + type;
      opts = (str == fn ? arg : opts) || {};
      return fn ? this.on(type, opts, fn) : this.trigger(type);
    };
    $2.drop = function(opts) {
      opts = opts || {};
      drop.multi = opts.multi === true ? Infinity : opts.multi === false ? 1 : !isNaN(opts.multi) ? opts.multi : drop.multi;
      drop.delay = opts.delay || drop.delay;
      drop.tolerance = $2.isFunction(opts.tolerance) ? opts.tolerance : opts.tolerance === null ? null : drop.tolerance;
      drop.mode = opts.mode || drop.mode || "intersect";
    };
    var $event = $2.event;
    var $special = $event.special;
    var drop = $2.event.special.drop = {
      // these are the default settings
      multi: 1,
      // allow multiple drop winners per dragged element
      delay: 20,
      // async timeout delay
      mode: "overlap",
      // drop tolerance mode
      // internal cache
      targets: [],
      // the key name for stored drop data
      datakey: "dropdata",
      // prevent bubbling for better performance
      noBubble: true,
      // count bound related events
      add: function(obj) {
        var data3 = $2.data(this, drop.datakey);
        data3.related += 1;
      },
      // forget unbound related events
      remove: function() {
        $2.data(this, drop.datakey).related -= 1;
      },
      // configure the interactions
      setup: function() {
        if ($2.data(this, drop.datakey))
          return;
        var data3 = {
          related: 0,
          active: [],
          anyactive: 0,
          winner: 0,
          location: {}
        };
        $2.data(this, drop.datakey, data3);
        drop.targets.push(this);
      },
      // destroy the configure interaction
      teardown: function() {
        var data3 = $2.data(this, drop.datakey) || {};
        if (data3.related)
          return;
        $2.removeData(this, drop.datakey);
        var element = this;
        drop.targets = $2.grep(drop.targets, function(target) {
          return target !== element;
        });
      },
      // shared event handler
      handler: function(event2, dd2) {
        var results, $targets;
        if (!dd2)
          return;
        switch (event2.type) {
          case "mousedown":
          case "touchstart":
            $targets = $2(drop.targets);
            if (typeof dd2.drop == "string")
              $targets = $targets.filter(dd2.drop);
            $targets.each(function() {
              var data3 = $2.data(this, drop.datakey);
              data3.active = [];
              data3.anyactive = 0;
              data3.winner = 0;
            });
            dd2.droppable = $targets;
            $special.drag.hijack(event2, "dropinit", dd2);
            break;
          case "mousemove":
          case "touchmove":
            drop.event = event2;
            if (!drop.timer)
              drop.tolerate(dd2);
            break;
          case "mouseup":
          case "touchend":
            drop.timer = clearTimeout(drop.timer);
            if (dd2.propagates) {
              $special.drag.hijack(event2, "drop", dd2);
              $special.drag.hijack(event2, "dropend", dd2);
            }
            break;
        }
      },
      // returns the location positions of an element
      locate: function(elem, index2) {
        var data3 = $2.data(elem, drop.datakey), $elem = $2(elem), posi = $elem.length && !$elem.is(document) ? $elem.offset() : {}, height = $elem.outerHeight(), width = $elem.outerWidth(), location = {
          elem,
          width,
          height,
          top: posi.top,
          left: posi.left,
          right: posi.left + width,
          bottom: posi.top + height
        };
        if (data3) {
          data3.location = location;
          data3.index = index2;
          data3.elem = elem;
        }
        return location;
      },
      // test the location positions of an element against another OR an X,Y coord
      contains: function(target, test) {
        return (test[0] || test.left) >= target.left && (test[0] || test.right) <= target.right && (test[1] || test.top) >= target.top && (test[1] || test.bottom) <= target.bottom;
      },
      // stored tolerance modes
      modes: {
        // fn scope: "$.event.special.drop" object
        // target with mouse wins, else target with most overlap wins
        "intersect": function(event2, proxy, target) {
          return this.contains(target, [event2.pageX, event2.pageY]) ? (
            // check cursor
            1e9
          ) : this.modes.overlap.apply(this, arguments);
        },
        // target with most overlap wins
        "overlap": function(event2, proxy, target) {
          return Math.max(0, Math.min(target.bottom, proxy.bottom) - Math.max(target.top, proxy.top)) * Math.max(0, Math.min(target.right, proxy.right) - Math.max(target.left, proxy.left));
        },
        // proxy is completely contained within target bounds
        "fit": function(event2, proxy, target) {
          return this.contains(target, proxy) ? 1 : 0;
        },
        // center of the proxy is contained within target bounds
        "middle": function(event2, proxy, target) {
          return this.contains(target, [proxy.left + proxy.width * 0.5, proxy.top + proxy.height * 0.5]) ? 1 : 0;
        }
      },
      // sort drop target cache by by winner (dsc), then index (asc)
      sort: function(a2, b2) {
        return b2.winner - a2.winner || a2.index - b2.index;
      },
      // async, recursive tolerance execution
      tolerate: function(dd2) {
        var i2, drp, drg, data3, arr, len, elem, x2 = 0, ia, end = dd2.interactions.length, xy2 = [drop.event.pageX, drop.event.pageY], tolerance = drop.tolerance || drop.modes[drop.mode];
        do
          if (ia = dd2.interactions[x2]) {
            if (!ia)
              return;
            ia.drop = [];
            arr = [];
            len = ia.droppable.length;
            if (tolerance)
              drg = drop.locate(ia.proxy);
            i2 = 0;
            do
              if (elem = ia.droppable[i2]) {
                data3 = $2.data(elem, drop.datakey);
                drp = data3.location;
                if (!drp) continue;
                data3.winner = tolerance ? tolerance.call(drop, drop.event, drg, drp) : drop.contains(drp, xy2) ? 1 : 0;
                arr.push(data3);
              }
            while (++i2 < len);
            arr.sort(drop.sort);
            i2 = 0;
            do
              if (data3 = arr[i2]) {
                if (data3.winner && ia.drop.length < drop.multi) {
                  if (!data3.active[x2] && !data3.anyactive) {
                    if ($special.drag.hijack(drop.event, "dropstart", dd2, x2, data3.elem)[0] !== false) {
                      data3.active[x2] = 1;
                      data3.anyactive += 1;
                    } else
                      data3.winner = 0;
                  }
                  if (data3.winner)
                    ia.drop.push(data3.elem);
                } else if (data3.active[x2] && data3.anyactive == 1) {
                  $special.drag.hijack(drop.event, "dropend", dd2, x2, data3.elem);
                  data3.active[x2] = 0;
                  data3.anyactive -= 1;
                }
              }
            while (++i2 < len);
          }
        while (++x2 < end);
        if (drop.last && xy2[0] == drop.last.pageX && xy2[1] == drop.last.pageY)
          delete drop.timer;
        else
          drop.timer = setTimeout(function() {
            drop.tolerate(dd2);
          }, drop.delay);
        drop.last = drop.event;
      }
    };
    $special.dropinit = $special.dropstart = $special.dropend = drop;
  }
});

// node_modules/@bokeh/slickgrid/slick.grid.js
var require_slick_grid = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.grid.js"(exports, module) {
    var jQuery = require_slick_jquery();
    var $ = jQuery;
    var Slick = require_slick_core();
    var scrollbarDimensions;
    var maxSupportedCssHeight;
    function SlickGrid(container, data, columns, options) {
      if (!$.fn.drag) {
        require_jquery_event_drag_2_3_0();
      }
      if (!$.fn.drop) {
        require_jquery_event_drop_2_3_0();
      }
      var defaults = {
        alwaysShowVerticalScroll: false,
        alwaysAllowHorizontalScroll: false,
        explicitInitialization: false,
        rowHeight: 25,
        defaultColumnWidth: 80,
        enableAddRow: false,
        leaveSpaceForNewRows: false,
        editable: false,
        autoEdit: true,
        suppressActiveCellChangeOnEdit: false,
        enableCellNavigation: true,
        enableColumnReorder: true,
        asyncEditorLoading: false,
        asyncEditorLoadDelay: 100,
        forceFitColumns: false,
        enableAsyncPostRender: false,
        asyncPostRenderDelay: 50,
        enableAsyncPostRenderCleanup: false,
        asyncPostRenderCleanupDelay: 40,
        autoHeight: false,
        editorLock: Slick.GlobalEditorLock,
        showColumnHeader: true,
        showHeaderRow: false,
        headerRowHeight: 25,
        createFooterRow: false,
        showFooterRow: false,
        footerRowHeight: 25,
        createPreHeaderPanel: false,
        showPreHeaderPanel: false,
        preHeaderPanelHeight: 25,
        showTopPanel: false,
        topPanelHeight: 25,
        formatterFactory: null,
        editorFactory: null,
        cellFlashingCssClass: "flashing",
        selectedCellCssClass: "selected",
        multiSelect: true,
        enableTextSelectionOnCells: false,
        dataItemColumnValueExtractor: null,
        frozenBottom: false,
        frozenColumn: -1,
        frozenRow: -1,
        frozenRightViewportMinWidth: 100,
        fullWidthRows: false,
        multiColumnSort: false,
        numberedMultiColumnSort: false,
        tristateMultiColumnSort: false,
        sortColNumberInSeparateSpan: false,
        defaultFormatter,
        forceSyncScrolling: false,
        addNewRowCssClass: "new-row",
        preserveCopiedSelectionOnPaste: false,
        showCellSelection: true,
        viewportClass: null,
        minRowBuffer: 3,
        emulatePagingWhenScrolling: true,
        // when scrolling off bottom of viewport, place new row at top of viewport
        editorCellNavOnLRKeys: false,
        enableMouseWheelScrollHandler: true,
        doPaging: true,
        autosizeColsMode: Slick.GridAutosizeColsMode.LegacyOff,
        autosizeColPaddingPx: 4,
        autosizeTextAvgToMWidthRatio: 0.75,
        viewportSwitchToScrollModeWidthPercent: void 0,
        viewportMinWidthPx: void 0,
        viewportMaxWidthPx: void 0,
        suppressCssChangesOnHiddenInit: false
      };
      var columnDefaults = {
        name: "",
        resizable: true,
        sortable: false,
        minWidth: 30,
        maxWidth: void 0,
        rerenderOnResize: false,
        headerCssClass: null,
        defaultSortAsc: true,
        focusable: true,
        selectable: true
      };
      var columnAutosizeDefaults = {
        ignoreHeaderText: false,
        colValueArray: void 0,
        allowAddlPercent: void 0,
        formatterOverride: void 0,
        autosizeMode: Slick.ColAutosizeMode.ContentIntelligent,
        rowSelectionModeOnInit: void 0,
        rowSelectionMode: Slick.RowSelectionMode.FirstNRows,
        rowSelectionCount: 100,
        valueFilterMode: Slick.ValueFilterMode.None,
        widthEvalMode: Slick.WidthEvalMode.CanvasTextSize,
        sizeToRemaining: void 0,
        widthPx: void 0,
        colDataTypeOf: void 0
      };
      var th;
      var h;
      var ph;
      var n;
      var cj;
      var page = 0;
      var offset = 0;
      var vScrollDir = 1;
      var initialized = false;
      var $container;
      var uid = "slickgrid_" + Math.round(1e6 * Math.random());
      var self = this;
      var $focusSink, $focusSink2;
      var $groupHeaders = $();
      var $headerScroller;
      var $headers;
      var $headerRow, $headerRowScroller, $headerRowSpacerL, $headerRowSpacerR;
      var $footerRow, $footerRowScroller, $footerRowSpacerL, $footerRowSpacerR;
      var $preHeaderPanel, $preHeaderPanelScroller, $preHeaderPanelSpacer;
      var $preHeaderPanelR, $preHeaderPanelScrollerR, $preHeaderPanelSpacerR;
      var $topPanelScroller;
      var $topPanel;
      var $viewport;
      var $canvas;
      var $style;
      var $boundAncestors;
      var treeColumns;
      var stylesheet, columnCssRulesL, columnCssRulesR;
      var viewportH, viewportW;
      var canvasWidth, canvasWidthL, canvasWidthR;
      var headersWidth, headersWidthL, headersWidthR;
      var viewportHasHScroll, viewportHasVScroll;
      var headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, cellWidthDiff = 0, cellHeightDiff = 0, jQueryNewWidthBehaviour = false;
      var absoluteColumnMinWidth;
      var hasFrozenRows = false;
      var frozenRowsHeight = 0;
      var actualFrozenRow = -1;
      var paneTopH = 0;
      var paneBottomH = 0;
      var viewportTopH = 0;
      var viewportBottomH = 0;
      var topPanelH = 0;
      var headerRowH = 0;
      var footerRowH = 0;
      var tabbingDirection = 1;
      var $activeCanvasNode;
      var $activeViewportNode;
      var activePosX;
      var activeRow, activeCell;
      var activeCellNode = null;
      var currentEditor = null;
      var serializedEditorValue;
      var editController;
      var rowsCache = {};
      var renderedRows = 0;
      var numVisibleRows = 0;
      var prevScrollTop = 0;
      var scrollTop = 0;
      var lastRenderedScrollTop = 0;
      var lastRenderedScrollLeft = 0;
      var prevScrollLeft = 0;
      var scrollLeft = 0;
      var selectionModel;
      var selectedRows = [];
      var plugins = [];
      var cellCssClasses = {};
      var columnsById = {};
      var sortColumns = [];
      var columnPosLeft = [];
      var columnPosRight = [];
      var pagingActive = false;
      var pagingIsLastPage = false;
      var scrollThrottle = ActionThrottle(render, 50);
      var h_editorLoader = null;
      var h_render = null;
      var h_postrender = null;
      var h_postrenderCleanup = null;
      var postProcessedRows = {};
      var postProcessToRow = null;
      var postProcessFromRow = null;
      var postProcessedCleanupQueue = [];
      var postProcessgroupId = 0;
      var counter_rows_rendered = 0;
      var counter_rows_removed = 0;
      var $paneHeaderL;
      var $paneHeaderR;
      var $paneTopL;
      var $paneTopR;
      var $paneBottomL;
      var $paneBottomR;
      var $headerScrollerL;
      var $headerScrollerR;
      var $headerL;
      var $headerR;
      var $groupHeadersL;
      var $groupHeadersR;
      var $headerRowScrollerL;
      var $headerRowScrollerR;
      var $footerRowScrollerL;
      var $footerRowScrollerR;
      var $headerRowL;
      var $headerRowR;
      var $footerRowL;
      var $footerRowR;
      var $topPanelScrollerL;
      var $topPanelScrollerR;
      var $topPanelL;
      var $topPanelR;
      var $viewportTopL;
      var $viewportTopR;
      var $viewportBottomL;
      var $viewportBottomR;
      var $canvasTopL;
      var $canvasTopR;
      var $canvasBottomL;
      var $canvasBottomR;
      var $viewportScrollContainerX;
      var $viewportScrollContainerY;
      var $headerScrollContainer;
      var $headerRowScrollContainer;
      var $footerRowScrollContainer;
      var cssShow = { position: "absolute", visibility: "hidden", display: "block" };
      var $hiddenParents;
      var oldProps = [];
      var columnResizeDragging = false;
      function init() {
        if (container instanceof $) {
          $container = container;
        } else {
          $container = $(container);
        }
        if ($container.length < 1) {
          throw new Error("SlickGrid requires a valid container, " + container + " does not exist in the DOM.");
        }
        maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();
        options = $.extend({}, defaults, options);
        validateAndEnforceOptions();
        columnDefaults.width = options.defaultColumnWidth;
        if (!options.suppressCssChangesOnHiddenInit) {
          cacheCssForHiddenInit();
        }
        treeColumns = new Slick.TreeColumns(columns);
        columns = treeColumns.extractColumns();
        updateColumnProps();
        if (options.enableColumnReorder && !$.fn.sortable) {
          throw new Error("SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded");
        }
        editController = {
          "commitCurrentEdit": commitCurrentEdit,
          "cancelCurrentEdit": cancelCurrentEdit
        };
        $container.empty().css("overflow", "hidden").css("outline", 0).addClass(uid).addClass("ui-widget");
        if (!/relative|absolute|fixed/.test($container.css("position"))) {
          $container.css("position", "relative");
        }
        $focusSink = $("<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>").appendTo($container);
        $paneHeaderL = $("<div class='slick-pane slick-pane-header slick-pane-left' tabIndex='0' />").appendTo($container);
        $paneHeaderR = $("<div class='slick-pane slick-pane-header slick-pane-right' tabIndex='0' />").appendTo($container);
        $paneTopL = $("<div class='slick-pane slick-pane-top slick-pane-left' tabIndex='0' />").appendTo($container);
        $paneTopR = $("<div class='slick-pane slick-pane-top slick-pane-right' tabIndex='0' />").appendTo($container);
        $paneBottomL = $("<div class='slick-pane slick-pane-bottom slick-pane-left' tabIndex='0' />").appendTo($container);
        $paneBottomR = $("<div class='slick-pane slick-pane-bottom slick-pane-right' tabIndex='0' />").appendTo($container);
        if (options.createPreHeaderPanel) {
          $preHeaderPanelScroller = $("<div class='slick-preheader-panel ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($paneHeaderL);
          $preHeaderPanel = $("<div />").appendTo($preHeaderPanelScroller);
          $preHeaderPanelSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($preHeaderPanelScroller);
          $preHeaderPanelScrollerR = $("<div class='slick-preheader-panel ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($paneHeaderR);
          $preHeaderPanelR = $("<div />").appendTo($preHeaderPanelScrollerR);
          $preHeaderPanelSpacerR = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($preHeaderPanelScrollerR);
          if (!options.showPreHeaderPanel) {
            $preHeaderPanelScroller.hide();
            $preHeaderPanelScrollerR.hide();
          }
        }
        $headerScrollerL = $("<div class='slick-header ui-state-default slick-header-left' />").appendTo($paneHeaderL);
        $headerScrollerR = $("<div class='slick-header ui-state-default slick-header-right' />").appendTo($paneHeaderR);
        $headerScroller = $().add($headerScrollerL).add($headerScrollerR);
        if (treeColumns.hasDepth()) {
          $groupHeadersL = [];
          $groupHeadersR = [];
          for (var index2 = 0; index2 < treeColumns.getDepth() - 1; index2++) {
            $groupHeadersL[index2] = $("<div class='slick-group-header-columns slick-group-header-columns-left' style='left:-1000px' />").appendTo($headerScrollerL);
            $groupHeadersR[index2] = $("<div class='slick-group-header-columns slick-group-header-columns-right' style='left:-1000px' />").appendTo($headerScrollerR);
          }
          $groupHeaders = $().add($groupHeadersL).add($groupHeadersR);
        }
        $headerL = $("<div class='slick-header-columns slick-header-columns-left' style='left:-1000px' />").appendTo($headerScrollerL);
        $headerR = $("<div class='slick-header-columns slick-header-columns-right' style='left:-1000px' />").appendTo($headerScrollerR);
        $headers = $().add($headerL).add($headerR);
        $headerRowScrollerL = $("<div class='slick-headerrow ui-state-default' />").appendTo($paneTopL);
        $headerRowScrollerR = $("<div class='slick-headerrow ui-state-default' />").appendTo($paneTopR);
        $headerRowScroller = $().add($headerRowScrollerL).add($headerRowScrollerR);
        $headerRowSpacerL = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($headerRowScrollerL);
        $headerRowSpacerR = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").appendTo($headerRowScrollerR);
        $headerRowL = $("<div class='slick-headerrow-columns slick-headerrow-columns-left' />").appendTo($headerRowScrollerL);
        $headerRowR = $("<div class='slick-headerrow-columns slick-headerrow-columns-right' />").appendTo($headerRowScrollerR);
        $headerRow = $().add($headerRowL).add($headerRowR);
        $topPanelScrollerL = $("<div class='slick-top-panel-scroller ui-state-default' />").appendTo($paneTopL);
        $topPanelScrollerR = $("<div class='slick-top-panel-scroller ui-state-default' />").appendTo($paneTopR);
        $topPanelScroller = $().add($topPanelScrollerL).add($topPanelScrollerR);
        $topPanelL = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScrollerL);
        $topPanelR = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScrollerR);
        $topPanel = $().add($topPanelL).add($topPanelR);
        if (!options.showColumnHeader) {
          $headerScroller.hide();
        }
        if (!options.showTopPanel) {
          $topPanelScroller.hide();
        }
        if (!options.showHeaderRow) {
          $headerRowScroller.hide();
        }
        $viewportTopL = $("<div class='slick-viewport slick-viewport-top slick-viewport-left' tabIndex='0' hideFocus />").appendTo($paneTopL);
        $viewportTopR = $("<div class='slick-viewport slick-viewport-top slick-viewport-right' tabIndex='0' hideFocus />").appendTo($paneTopR);
        $viewportBottomL = $("<div class='slick-viewport slick-viewport-bottom slick-viewport-left' tabIndex='0' hideFocus />").appendTo($paneBottomL);
        $viewportBottomR = $("<div class='slick-viewport slick-viewport-bottom slick-viewport-right' tabIndex='0' hideFocus />").appendTo($paneBottomR);
        $viewport = $().add($viewportTopL).add($viewportTopR).add($viewportBottomL).add($viewportBottomR);
        $activeViewportNode = $viewportTopL;
        $canvasTopL = $("<div class='grid-canvas grid-canvas-top grid-canvas-left' tabIndex='0' hideFocus />").appendTo($viewportTopL);
        $canvasTopR = $("<div class='grid-canvas grid-canvas-top grid-canvas-right' tabIndex='0' hideFocus />").appendTo($viewportTopR);
        $canvasBottomL = $("<div class='grid-canvas grid-canvas-bottom grid-canvas-left' tabIndex='0' hideFocus />").appendTo($viewportBottomL);
        $canvasBottomR = $("<div class='grid-canvas grid-canvas-bottom grid-canvas-right' tabIndex='0' hideFocus />").appendTo($viewportBottomR);
        if (options.viewportClass) $viewport.toggleClass(options.viewportClass, true);
        $canvas = $().add($canvasTopL).add($canvasTopR).add($canvasBottomL).add($canvasBottomR);
        scrollbarDimensions = scrollbarDimensions || measureScrollbar();
        $activeCanvasNode = $canvasTopL;
        if ($preHeaderPanelSpacer) $preHeaderPanelSpacer.css("width", getCanvasWidth() + scrollbarDimensions.width + "px");
        $headers.width(getHeadersWidth());
        $headerRowSpacerL.css("width", getCanvasWidth() + scrollbarDimensions.width + "px");
        $headerRowSpacerR.css("width", getCanvasWidth() + scrollbarDimensions.width + "px");
        if (options.createFooterRow) {
          $footerRowScrollerR = $("<div class='slick-footerrow ui-state-default' />").appendTo($paneTopR);
          $footerRowScrollerL = $("<div class='slick-footerrow ui-state-default' />").appendTo($paneTopL);
          $footerRowScroller = $().add($footerRowScrollerL).add($footerRowScrollerR);
          $footerRowSpacerL = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").css("width", getCanvasWidth() + scrollbarDimensions.width + "px").appendTo($footerRowScrollerL);
          $footerRowSpacerR = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").css("width", getCanvasWidth() + scrollbarDimensions.width + "px").appendTo($footerRowScrollerR);
          $footerRowL = $("<div class='slick-footerrow-columns slick-footerrow-columns-left' />").appendTo($footerRowScrollerL);
          $footerRowR = $("<div class='slick-footerrow-columns slick-footerrow-columns-right' />").appendTo($footerRowScrollerR);
          $footerRow = $().add($footerRowL).add($footerRowR);
          if (!options.showFooterRow) {
            $footerRowScroller.hide();
          }
        }
        $focusSink2 = $focusSink.clone().appendTo($container);
        if (!options.explicitInitialization) {
          finishInitialization();
        }
      }
      function finishInitialization() {
        if (!initialized) {
          initialized = true;
          getViewportWidth();
          getViewportHeight();
          measureCellPaddingAndBorder();
          disableSelection($headers);
          if (!options.enableTextSelectionOnCells) {
            $viewport.on("selectstart.ui", function(event2) {
              return $(event2.target).is("input,textarea");
            });
          }
          setFrozenOptions();
          setPaneVisibility();
          setScroller();
          setOverflow();
          updateColumnCaches();
          createColumnHeaders();
          createColumnGroupHeaders();
          createColumnFooter();
          setupColumnSort();
          createCssRules();
          resizeCanvas();
          bindAncestorScrollEvents();
          $container.on("resize.slickgrid", resizeCanvas);
          $viewport.on("scroll", handleScroll);
          if (jQuery.fn.mousewheel && options.enableMouseWheelScrollHandler) {
            $viewport.on("mousewheel", handleMouseWheel);
          }
          $headerScroller.on("contextmenu", handleHeaderContextMenu).on("click", handleHeaderClick).on("mouseenter", ".slick-header-column", handleHeaderMouseEnter).on("mouseleave", ".slick-header-column", handleHeaderMouseLeave);
          $headerRowScroller.on("scroll", handleHeaderRowScroll);
          if (options.createFooterRow) {
            $footerRow.on("contextmenu", handleFooterContextMenu).on("click", handleFooterClick);
            $footerRowScroller.on("scroll", handleFooterRowScroll);
          }
          if (options.createPreHeaderPanel) {
            $preHeaderPanelScroller.on("scroll", handlePreHeaderPanelScroll);
          }
          $focusSink.add($focusSink2).on("keydown", handleKeyDown);
          $canvas.on("keydown", handleKeyDown).on("click", handleClick).on("dblclick", handleDblClick).on("contextmenu", handleContextMenu).on("draginit", handleDragInit).on("dragstart", { distance: 3 }, handleDragStart).on("drag", handleDrag).on("dragend", handleDragEnd).on("mouseenter", ".slick-cell", handleMouseEnter).on("mouseleave", ".slick-cell", handleMouseLeave);
          if (!options.suppressCssChangesOnHiddenInit) {
            restoreCssFromHiddenInit();
          }
        }
      }
      function cacheCssForHiddenInit() {
        $hiddenParents = $container.parents().addBack().not(":visible");
        $hiddenParents.each(function() {
          var old = {};
          for (var name in cssShow) {
            old[name] = this.style[name];
            this.style[name] = cssShow[name];
          }
          oldProps.push(old);
        });
      }
      function restoreCssFromHiddenInit() {
        $hiddenParents.each(function(i2) {
          var old = oldProps[i2];
          for (var name in cssShow) {
            this.style[name] = old[name];
          }
        });
      }
      function hasFrozenColumns() {
        return options.frozenColumn > -1;
      }
      function registerPlugin(plugin) {
        plugins.unshift(plugin);
        plugin.init(self);
      }
      function unregisterPlugin(plugin) {
        for (var i2 = plugins.length; i2 >= 0; i2--) {
          if (plugins[i2] === plugin) {
            if (plugins[i2].destroy) {
              plugins[i2].destroy();
            }
            plugins.splice(i2, 1);
            break;
          }
        }
      }
      function getPluginByName(name) {
        for (var i2 = plugins.length - 1; i2 >= 0; i2--) {
          if (plugins[i2].pluginName === name) {
            return plugins[i2];
          }
        }
        return void 0;
      }
      function setSelectionModel(model2) {
        if (selectionModel) {
          selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);
          if (selectionModel.destroy) {
            selectionModel.destroy();
          }
        }
        selectionModel = model2;
        if (selectionModel) {
          selectionModel.init(self);
          selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);
        }
      }
      function getSelectionModel() {
        return selectionModel;
      }
      function getCanvasNode(columnIdOrIdx, rowIndex) {
        return _getContainerElement(getCanvases(), columnIdOrIdx, rowIndex);
      }
      function getActiveCanvasNode(element) {
        setActiveCanvasNode(element);
        return $activeCanvasNode[0];
      }
      function getCanvases() {
        return $canvas;
      }
      function setActiveCanvasNode(element) {
        if (element) {
          $activeCanvasNode = $(element.target).closest(".grid-canvas");
        }
      }
      function getViewportNode(columnIdOrIdx, rowIndex) {
        return _getContainerElement(getViewports(), columnIdOrIdx, rowIndex);
      }
      function getViewports() {
        return $viewport;
      }
      function getActiveViewportNode(element) {
        setActiveViewportNode(element);
        return $activeViewportNode[0];
      }
      function setActiveViewportNode(element) {
        if (element) {
          $activeViewportNode = $(element.target).closest(".slick-viewport");
        }
      }
      function _getContainerElement($targetContainers, columnIdOrIdx, rowIndex) {
        if (!$targetContainers) {
          return;
        }
        if (!columnIdOrIdx) {
          columnIdOrIdx = 0;
        }
        if (!rowIndex) {
          rowIndex = 0;
        }
        var idx = typeof columnIdOrIdx === "number" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);
        var isBottomSide = hasFrozenRows && rowIndex >= actualFrozenRow + (options.frozenBottom ? 0 : 1);
        var isRightSide = hasFrozenColumns() && idx > options.frozenColumn;
        return $targetContainers[(isBottomSide ? 2 : 0) + (isRightSide ? 1 : 0)];
      }
      function measureScrollbar() {
        var $outerdiv = $('<div class="' + $viewport.className + '" style="position:absolute; top:-10000px; left:-10000px; overflow:auto; width:100px; height:100px;"></div>').appendTo("body");
        var $innerdiv = $('<div style="width:200px; height:200px; overflow:auto;"></div>').appendTo($outerdiv);
        var dim = {
          width: $outerdiv[0].offsetWidth - $outerdiv[0].clientWidth,
          height: $outerdiv[0].offsetHeight - $outerdiv[0].clientHeight
        };
        $innerdiv.remove();
        $outerdiv.remove();
        return dim;
      }
      function getHeadersWidth() {
        headersWidth = headersWidthL = headersWidthR = 0;
        var includeScrollbar = !options.autoHeight;
        for (var i2 = 0, ii = columns.length; i2 < ii; i2++) {
          var width = columns[i2].width;
          if (options.frozenColumn > -1 && i2 > options.frozenColumn) {
            headersWidthR += width;
          } else {
            headersWidthL += width;
          }
        }
        if (includeScrollbar) {
          if (options.frozenColumn > -1 && i2 > options.frozenColumn) {
            headersWidthR += scrollbarDimensions.width;
          } else {
            headersWidthL += scrollbarDimensions.width;
          }
        }
        if (hasFrozenColumns()) {
          headersWidthL = headersWidthL + 1e3;
          headersWidthR = Math.max(headersWidthR, viewportW) + headersWidthL;
          headersWidthR += scrollbarDimensions.width;
        } else {
          headersWidthL += scrollbarDimensions.width;
          headersWidthL = Math.max(headersWidthL, viewportW) + 1e3;
        }
        headersWidth = headersWidthL + headersWidthR;
        return Math.max(headersWidth, viewportW) + 1e3;
      }
      function getHeadersWidthL() {
        headersWidthL = 0;
        columns.forEach(function(column, i2) {
          if (!(options.frozenColumn > -1 && i2 > options.frozenColumn))
            headersWidthL += column.width;
        });
        if (hasFrozenColumns()) {
          headersWidthL += 1e3;
        } else {
          headersWidthL += scrollbarDimensions.width;
          headersWidthL = Math.max(headersWidthL, viewportW) + 1e3;
        }
        return headersWidthL;
      }
      function getHeadersWidthR() {
        headersWidthR = 0;
        columns.forEach(function(column, i2) {
          if (options.frozenColumn > -1 && i2 > options.frozenColumn)
            headersWidthR += column.width;
        });
        if (hasFrozenColumns()) {
          headersWidthR = Math.max(headersWidthR, viewportW) + getHeadersWidthL();
          headersWidthR += scrollbarDimensions.width;
        }
        return headersWidthR;
      }
      function getCanvasWidth() {
        var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
        var i2 = columns.length;
        canvasWidthL = canvasWidthR = 0;
        while (i2--) {
          if (hasFrozenColumns() && i2 > options.frozenColumn) {
            canvasWidthR += columns[i2].width;
          } else {
            canvasWidthL += columns[i2].width;
          }
        }
        var totalRowWidth = canvasWidthL + canvasWidthR;
        return options.fullWidthRows ? Math.max(totalRowWidth, availableWidth) : totalRowWidth;
      }
      function updateCanvasWidth(forceColumnWidthsUpdate) {
        var oldCanvasWidth = canvasWidth;
        var oldCanvasWidthL = canvasWidthL;
        var oldCanvasWidthR = canvasWidthR;
        var widthChanged;
        canvasWidth = getCanvasWidth();
        widthChanged = canvasWidth !== oldCanvasWidth || canvasWidthL !== oldCanvasWidthL || canvasWidthR !== oldCanvasWidthR;
        if (widthChanged || hasFrozenColumns() || hasFrozenRows) {
          $canvasTopL.width(canvasWidthL);
          getHeadersWidth();
          $headerL.width(headersWidthL);
          $headerR.width(headersWidthR);
          if (hasFrozenColumns()) {
            $canvasTopR.width(canvasWidthR);
            $paneHeaderL.width(canvasWidthL);
            $paneHeaderR.css("left", canvasWidthL);
            $paneHeaderR.css("width", viewportW - canvasWidthL);
            $paneTopL.width(canvasWidthL);
            $paneTopR.css("left", canvasWidthL);
            $paneTopR.css("width", viewportW - canvasWidthL);
            $headerRowScrollerL.width(canvasWidthL);
            $headerRowScrollerR.width(viewportW - canvasWidthL);
            $headerRowL.width(canvasWidthL);
            $headerRowR.width(canvasWidthR);
            if (options.createFooterRow) {
              $footerRowScrollerL.width(canvasWidthL);
              $footerRowScrollerR.width(viewportW - canvasWidthL);
              $footerRowL.width(canvasWidthL);
              $footerRowR.width(canvasWidthR);
            }
            if (options.createPreHeaderPanel) {
              $preHeaderPanel.width(canvasWidth);
            }
            $viewportTopL.width(canvasWidthL);
            $viewportTopR.width(viewportW - canvasWidthL);
            if (hasFrozenRows) {
              $paneBottomL.width(canvasWidthL);
              $paneBottomR.css("left", canvasWidthL);
              $viewportBottomL.width(canvasWidthL);
              $viewportBottomR.width(viewportW - canvasWidthL);
              $canvasBottomL.width(canvasWidthL);
              $canvasBottomR.width(canvasWidthR);
            }
          } else {
            $paneHeaderL.width("100%");
            $paneTopL.width("100%");
            $headerRowScrollerL.width("100%");
            $headerRowL.width(canvasWidth);
            if (options.createFooterRow) {
              $footerRowScrollerL.width("100%");
              $footerRowL.width(canvasWidth);
            }
            if (options.createPreHeaderPanel) {
              $preHeaderPanel.width("100%");
              $preHeaderPanel.width(canvasWidth);
            }
            $viewportTopL.width("100%");
            if (hasFrozenRows) {
              $viewportBottomL.width("100%");
              $canvasBottomL.width(canvasWidthL);
            }
          }
          viewportHasHScroll = canvasWidth >= viewportW - scrollbarDimensions.width;
        }
        $headerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));
        $headerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));
        if (options.createFooterRow) {
          $footerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));
          $footerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));
        }
        if (widthChanged || forceColumnWidthsUpdate) {
          applyColumnWidths();
        }
      }
      function disableSelection($target) {
        if ($target && $target.jquery) {
          $target.attr("unselectable", "on").css("MozUserSelect", "none").on("selectstart.ui", function() {
            return false;
          });
        }
      }
      function getMaxSupportedCssHeight() {
        var supportedHeight = 1e6;
        var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9;
        var div2 = $("<div style='display:none' />").appendTo(document.body);
        while (true) {
          var test = supportedHeight * 2;
          div2.css("height", test);
          if (test > testUpTo || div2.height() !== test) {
            break;
          } else {
            supportedHeight = test;
          }
        }
        div2.remove();
        return supportedHeight;
      }
      function getUID() {
        return uid;
      }
      function getHeaderColumnWidthDiff() {
        return headerColumnWidthDiff;
      }
      function getScrollbarDimensions() {
        return scrollbarDimensions;
      }
      function bindAncestorScrollEvents() {
        var elem = hasFrozenRows && !options.frozenBottom ? $canvasBottomL[0] : $canvasTopL[0];
        while ((elem = elem.parentNode) != document.body && elem != null) {
          if (elem == $viewportTopL[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {
            var $elem = $(elem);
            if (!$boundAncestors) {
              $boundAncestors = $elem;
            } else {
              $boundAncestors = $boundAncestors.add($elem);
            }
            $elem.on("scroll." + uid, handleActiveCellPositionChange);
          }
        }
      }
      function unbindAncestorScrollEvents() {
        if (!$boundAncestors) {
          return;
        }
        $boundAncestors.off("scroll." + uid);
        $boundAncestors = null;
      }
      function updateColumnHeader(columnId, title3, toolTip) {
        if (!initialized) {
          return;
        }
        var idx = getColumnIndex(columnId);
        if (idx == null) {
          return;
        }
        var columnDef = columns[idx];
        var $header = $headers.children().eq(idx);
        if ($header) {
          if (title3 !== void 0) {
            columns[idx].name = title3;
          }
          if (toolTip !== void 0) {
            columns[idx].toolTip = toolTip;
          }
          trigger(self.onBeforeHeaderCellDestroy, {
            "node": $header[0],
            "column": columnDef,
            "grid": self
          });
          $header.attr("title", toolTip || "").children().eq(0).html(title3);
          trigger(self.onHeaderCellRendered, {
            "node": $header[0],
            "column": columnDef,
            "grid": self
          });
        }
      }
      function getHeader(columnDef) {
        if (!columnDef) {
          return hasFrozenColumns() ? $headers : $headerL;
        }
        var idx = getColumnIndex(columnDef.id);
        return hasFrozenColumns() ? idx <= options.frozenColumn ? $headerL : $headerR : $headerL;
      }
      function getHeaderColumn(columnIdOrIdx) {
        var idx = typeof columnIdOrIdx === "number" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);
        var targetHeader = hasFrozenColumns() ? idx <= options.frozenColumn ? $headerL : $headerR : $headerL;
        var targetIndex = hasFrozenColumns() ? idx <= options.frozenColumn ? idx : idx - options.frozenColumn - 1 : idx;
        var $rtn = targetHeader.children().eq(targetIndex);
        return $rtn && $rtn[0];
      }
      function getHeaderRow() {
        return hasFrozenColumns() ? $headerRow : $headerRow[0];
      }
      function getFooterRow() {
        return hasFrozenColumns() ? $footerRow : $footerRow[0];
      }
      function getPreHeaderPanel() {
        return $preHeaderPanel[0];
      }
      function getPreHeaderPanelRight() {
        return $preHeaderPanelR[0];
      }
      function getHeaderRowColumn(columnIdOrIdx) {
        var idx = typeof columnIdOrIdx === "number" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);
        var $headerRowTarget;
        if (hasFrozenColumns()) {
          if (idx <= options.frozenColumn) {
            $headerRowTarget = $headerRowL;
          } else {
            $headerRowTarget = $headerRowR;
            idx -= options.frozenColumn + 1;
          }
        } else {
          $headerRowTarget = $headerRowL;
        }
        var $header = $headerRowTarget.children().eq(idx);
        return $header && $header[0];
      }
      function getFooterRowColumn(columnIdOrIdx) {
        var idx = typeof columnIdOrIdx === "number" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);
        var $footerRowTarget;
        if (hasFrozenColumns()) {
          if (idx <= options.frozenColumn) {
            $footerRowTarget = $footerRowL;
          } else {
            $footerRowTarget = $footerRowR;
            idx -= options.frozenColumn + 1;
          }
        } else {
          $footerRowTarget = $footerRowL;
        }
        var $footer = $footerRowTarget && $footerRowTarget.children().eq(idx);
        return $footer && $footer[0];
      }
      function createColumnFooter() {
        if (options.createFooterRow) {
          $footerRow.find(".slick-footerrow-column").each(function() {
            var columnDef = $(this).data("column");
            if (columnDef) {
              trigger(self.onBeforeFooterRowCellDestroy, {
                "node": this,
                "column": columnDef,
                "grid": self
              });
            }
          });
          $footerRowL.empty();
          $footerRowR.empty();
          for (var i2 = 0; i2 < columns.length; i2++) {
            var m = columns[i2];
            var footerRowCell = $("<div class='ui-state-default slick-footerrow-column l" + i2 + " r" + i2 + "'></div>").data("column", m).addClass(hasFrozenColumns() && i2 <= options.frozenColumn ? "frozen" : "").appendTo(hasFrozenColumns() && i2 > options.frozenColumn ? $footerRowR : $footerRowL);
            trigger(self.onFooterRowCellRendered, {
              "node": footerRowCell[0],
              "column": m,
              "grid": self
            });
          }
        }
      }
      function createColumnGroupHeaders() {
        var columnsLength = 0;
        var frozenColumnsValid = false;
        if (!treeColumns.hasDepth())
          return;
        for (var index2 = 0; index2 < $groupHeadersL.length; index2++) {
          $groupHeadersL[index2].empty();
          $groupHeadersR[index2].empty();
          var groupColumns = treeColumns.getColumnsInDepth(index2);
          for (var indexGroup in groupColumns) {
            var m = groupColumns[indexGroup];
            columnsLength += m.extractColumns().length;
            if (hasFrozenColumns() && index2 === 0 && columnsLength - 1 === options.frozenColumn)
              frozenColumnsValid = true;
            $("<div class='ui-state-default slick-group-header-column' />").html("<span class='slick-column-name'>" + m.name + "</span>").attr("id", "" + uid + m.id).attr("title", m.toolTip || "").data("column", m).addClass(m.headerCssClass || "").addClass(hasFrozenColumns() && columnsLength - 1 > options.frozenColumn ? "frozen" : "").appendTo(hasFrozenColumns() && columnsLength - 1 > options.frozenColumn ? $groupHeadersR[index2] : $groupHeadersL[index2]);
          }
          if (hasFrozenColumns() && index2 === 0 && !frozenColumnsValid) {
            $groupHeadersL[index2].empty();
            $groupHeadersR[index2].empty();
            alert("All columns of group should to be grouped!");
            break;
          }
        }
        applyColumnGroupHeaderWidths();
      }
      function createColumnHeaders() {
        function onMouseEnter() {
          $(this).addClass("ui-state-hover");
        }
        function onMouseLeave() {
          $(this).removeClass("ui-state-hover");
        }
        $headers.find(".slick-header-column").each(function() {
          var columnDef = $(this).data("column");
          if (columnDef) {
            trigger(self.onBeforeHeaderCellDestroy, {
              "node": this,
              "column": columnDef,
              "grid": self
            });
          }
        });
        $headerL.empty();
        $headerR.empty();
        getHeadersWidth();
        $headerL.width(headersWidthL);
        $headerR.width(headersWidthR);
        $headerRow.find(".slick-headerrow-column").each(function() {
          var columnDef = $(this).data("column");
          if (columnDef) {
            trigger(self.onBeforeHeaderRowCellDestroy, {
              "node": this,
              "column": columnDef,
              "grid": self
            });
          }
        });
        $headerRowL.empty();
        $headerRowR.empty();
        if (options.createFooterRow) {
          $footerRowL.find(".slick-footerrow-column").each(function() {
            var columnDef = $(this).data("column");
            if (columnDef) {
              trigger(self.onBeforeFooterRowCellDestroy, {
                "node": this,
                "column": columnDef,
                "grid": self
              });
            }
          });
          $footerRowL.empty();
          if (hasFrozenColumns()) {
            $footerRowR.find(".slick-footerrow-column").each(function() {
              var columnDef = $(this).data("column");
              if (columnDef) {
                trigger(self.onBeforeFooterRowCellDestroy, {
                  "node": this,
                  "column": columnDef,
                  "grid": self
                });
              }
            });
            $footerRowR.empty();
          }
        }
        for (var i2 = 0; i2 < columns.length; i2++) {
          var m = columns[i2];
          var $headerTarget = hasFrozenColumns() ? i2 <= options.frozenColumn ? $headerL : $headerR : $headerL;
          var $headerRowTarget = hasFrozenColumns() ? i2 <= options.frozenColumn ? $headerRowL : $headerRowR : $headerRowL;
          var header4 = $("<div class='ui-state-default slick-header-column' />").html("<span class='slick-column-name'>" + m.name + "</span>").width(m.width - headerColumnWidthDiff).attr("id", "" + uid + m.id).attr("title", m.toolTip || "").data("column", m).addClass(m.headerCssClass || "").addClass(hasFrozenColumns() && i2 <= options.frozenColumn ? "frozen" : "").appendTo($headerTarget);
          if (options.enableColumnReorder || m.sortable) {
            header4.on("mouseenter", onMouseEnter).on("mouseleave", onMouseLeave);
          }
          if (m.hasOwnProperty("headerCellAttrs") && m.headerCellAttrs instanceof Object) {
            for (var key in m.headerCellAttrs) {
              if (m.headerCellAttrs.hasOwnProperty(key)) {
                header4.attr(key, m.headerCellAttrs[key]);
              }
            }
          }
          if (m.sortable) {
            header4.addClass("slick-header-sortable");
            header4.append("<span class='slick-sort-indicator" + (options.numberedMultiColumnSort && !options.sortColNumberInSeparateSpan ? " slick-sort-indicator-numbered" : "") + "' />");
            if (options.numberedMultiColumnSort && options.sortColNumberInSeparateSpan) {
              header4.append("<span class='slick-sort-indicator-numbered' />");
            }
          }
          trigger(self.onHeaderCellRendered, {
            "node": header4[0],
            "column": m,
            "grid": self
          });
          if (options.showHeaderRow) {
            var headerRowCell = $("<div class='ui-state-default slick-headerrow-column l" + i2 + " r" + i2 + "'></div>").data("column", m).addClass(hasFrozenColumns() && i2 <= options.frozenColumn ? "frozen" : "").appendTo($headerRowTarget);
            trigger(self.onHeaderRowCellRendered, {
              "node": headerRowCell[0],
              "column": m,
              "grid": self
            });
          }
          if (options.createFooterRow && options.showFooterRow) {
            var footerRowCell = $("<div class='ui-state-default slick-footerrow-column l" + i2 + " r" + i2 + "'></div>").data("column", m).appendTo($footerRow);
            trigger(self.onFooterRowCellRendered, {
              "node": footerRowCell[0],
              "column": m,
              "grid": self
            });
          }
        }
        setSortColumns(sortColumns);
        setupColumnResize();
        if (options.enableColumnReorder) {
          if (typeof options.enableColumnReorder == "function") {
            options.enableColumnReorder(self, $headers, headerColumnWidthDiff, setColumns, setupColumnResize, columns, getColumnIndex, uid, trigger);
          } else {
            setupColumnReorder();
          }
        }
      }
      function setupColumnSort() {
        $headers.click(function(e) {
          if (columnResizeDragging) return;
          e.metaKey = e.metaKey || e.ctrlKey;
          if ($(e.target).hasClass("slick-resizable-handle")) {
            return;
          }
          var $col = $(e.target).closest(".slick-header-column");
          if (!$col.length) {
            return;
          }
          var column = $col.data("column");
          if (column.sortable) {
            if (!getEditorLock().commitCurrentEdit()) {
              return;
            }
            var previousSortColumns = $.extend(true, [], sortColumns);
            var sortColumn = null;
            var i2 = 0;
            for (; i2 < sortColumns.length; i2++) {
              if (sortColumns[i2].columnId == column.id) {
                sortColumn = sortColumns[i2];
                sortColumn.sortAsc = !sortColumn.sortAsc;
                break;
              }
            }
            var hadSortCol = !!sortColumn;
            if (options.tristateMultiColumnSort) {
              if (!sortColumn) {
                sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };
              }
              if (hadSortCol && sortColumn.sortAsc) {
                sortColumns.splice(i2, 1);
                sortColumn = null;
              }
              if (!options.multiColumnSort) {
                sortColumns = [];
              }
              if (sortColumn && (!hadSortCol || !options.multiColumnSort)) {
                sortColumns.push(sortColumn);
              }
            } else {
              if (e.metaKey && options.multiColumnSort) {
                if (sortColumn) {
                  sortColumns.splice(i2, 1);
                }
              } else {
                if (!e.shiftKey && !e.metaKey || !options.multiColumnSort) {
                  sortColumns = [];
                }
                if (!sortColumn) {
                  sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };
                  sortColumns.push(sortColumn);
                } else if (sortColumns.length === 0) {
                  sortColumns.push(sortColumn);
                }
              }
            }
            var onSortArgs;
            if (!options.multiColumnSort) {
              onSortArgs = {
                multiColumnSort: false,
                previousSortColumns,
                columnId: sortColumns.length > 0 ? column.id : null,
                sortCol: sortColumns.length > 0 ? column : null,
                sortAsc: sortColumns.length > 0 ? sortColumns[0].sortAsc : true
              };
            } else {
              onSortArgs = {
                multiColumnSort: true,
                previousSortColumns,
                sortCols: $.map(sortColumns, function(col2) {
                  return { columnId: columns[getColumnIndex(col2.columnId)].id, sortCol: columns[getColumnIndex(col2.columnId)], sortAsc: col2.sortAsc };
                })
              };
            }
            if (trigger(self.onBeforeSort, onSortArgs, e) !== false) {
              setSortColumns(sortColumns);
              trigger(self.onSort, onSortArgs, e);
            }
          }
        });
      }
      function currentPositionInHeader(id) {
        var currentPosition = 0;
        $headers.find(".slick-header-column").each(function(i2) {
          if (this.id == id) {
            currentPosition = i2;
            return false;
          }
        });
        return currentPosition;
      }
      function limitPositionInGroup(idColumn) {
        var groupColumnOfPreviousPosition, startLimit = 0, endLimit = 0;
        treeColumns.getColumnsInDepth($groupHeadersL.length - 1).some(function(groupColumn) {
          startLimit = endLimit;
          endLimit += groupColumn.columns.length;
          groupColumn.columns.some(function(column) {
            if (column.id === idColumn)
              groupColumnOfPreviousPosition = groupColumn;
            return groupColumnOfPreviousPosition;
          });
          return groupColumnOfPreviousPosition;
        });
        endLimit--;
        return {
          start: startLimit,
          end: endLimit,
          group: groupColumnOfPreviousPosition
        };
      }
      function remove(arr, elem) {
        var index2 = arr.lastIndexOf(elem);
        if (index2 > -1) {
          arr.splice(index2, 1);
          remove(arr, elem);
        }
      }
      function columnPositionValidInGroup($item) {
        var currentPosition = currentPositionInHeader($item[0].id);
        var limit2 = limitPositionInGroup($item.data("column").id);
        var positionValid = limit2.start <= currentPosition && currentPosition <= limit2.end;
        return {
          limit: limit2,
          valid: positionValid,
          message: positionValid ? "" : 'Column "'.concat($item.text(), '" can be reordered only within the "', limit2.group.name, '" group!')
        };
      }
      function setupColumnReorder() {
        $headers.filter(":ui-sortable").sortable("destroy");
        var columnScrollTimer = null;
        function scrollColumnsRight() {
          $viewportScrollContainerX[0].scrollLeft = $viewportScrollContainerX[0].scrollLeft + 10;
        }
        function scrollColumnsLeft() {
          $viewportScrollContainerX[0].scrollLeft = $viewportScrollContainerX[0].scrollLeft - 10;
        }
        var canDragScroll;
        $headers.sortable({
          containment: "parent",
          distance: 3,
          axis: "x",
          cursor: "default",
          tolerance: "intersection",
          helper: "clone",
          placeholder: "slick-sortable-placeholder ui-state-default slick-header-column",
          start: function(e, ui) {
            ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);
            canDragScroll = !hasFrozenColumns() || ui.placeholder.offset().left + ui.placeholder.width() > $viewportScrollContainerX.offset().left;
            $(ui.helper).addClass("slick-header-column-active");
          },
          beforeStop: function(e, ui) {
            $(ui.helper).removeClass("slick-header-column-active");
          },
          sort: function(e, ui) {
            if (canDragScroll && e.originalEvent.pageX > $container[0].clientWidth) {
              if (!columnScrollTimer) {
                columnScrollTimer = setInterval(
                  scrollColumnsRight,
                  100
                );
              }
            } else if (canDragScroll && e.originalEvent.pageX < $viewportScrollContainerX.offset().left) {
              if (!columnScrollTimer) {
                columnScrollTimer = setInterval(
                  scrollColumnsLeft,
                  100
                );
              }
            } else {
              clearInterval(columnScrollTimer);
              columnScrollTimer = null;
            }
          },
          stop: function(e, ui) {
            var cancel = false;
            clearInterval(columnScrollTimer);
            columnScrollTimer = null;
            var limit2 = null;
            if (treeColumns.hasDepth()) {
              var validPositionInGroup = columnPositionValidInGroup(ui.item);
              limit2 = validPositionInGroup.limit;
              cancel = !validPositionInGroup.valid;
              if (cancel)
                alert(validPositionInGroup.message);
            }
            if (cancel || !getEditorLock().commitCurrentEdit()) {
              $(this).sortable("cancel");
              return;
            }
            var reorderedIds = $headerL.sortable("toArray");
            reorderedIds = reorderedIds.concat($headerR.sortable("toArray"));
            var reorderedColumns = [];
            for (var i2 = 0; i2 < reorderedIds.length; i2++) {
              reorderedColumns.push(columns[getColumnIndex(reorderedIds[i2].replace(uid, ""))]);
            }
            setColumns(reorderedColumns);
            trigger(self.onColumnsReordered, { impactedColumns: getImpactedColumns(limit2) });
            e.stopPropagation();
            setupColumnResize();
          }
        });
      }
      function getImpactedColumns(limit2) {
        var impactedColumns = [];
        if (limit2) {
          for (var i2 = limit2.start; i2 <= limit2.end; i2++) {
            impactedColumns.push(columns[i2]);
          }
        } else {
          impactedColumns = columns;
        }
        return impactedColumns;
      }
      function setupColumnResize() {
        var $col, j, k, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;
        var frozenLeftColMaxWidth = 0;
        columnElements = $headers.children();
        columnElements.find(".slick-resizable-handle").remove();
        columnElements.each(function(i2, e) {
          if (i2 >= columns.length) {
            return;
          }
          if (columns[i2].resizable) {
            if (firstResizable === void 0) {
              firstResizable = i2;
            }
            lastResizable = i2;
          }
        });
        if (firstResizable === void 0) {
          return;
        }
        columnElements.each(function(i2, e) {
          if (i2 >= columns.length) {
            return;
          }
          if (i2 < firstResizable || options.forceFitColumns && i2 >= lastResizable) {
            return;
          }
          $col = $(e);
          $("<div class='slick-resizable-handle' />").appendTo(e).on("dragstart", function(e2, dd2) {
            if (!getEditorLock().commitCurrentEdit()) {
              return false;
            }
            pageX = e2.pageX;
            frozenLeftColMaxWidth = 0;
            $(this).parent().addClass("slick-header-column-active");
            var shrinkLeewayOnRight = null, stretchLeewayOnRight = null;
            columnElements.each(function(i3, e3) {
              if (i3 >= columns.length) {
                return;
              }
              columns[i3].previousWidth = $(e3).outerWidth();
            });
            if (options.forceFitColumns) {
              shrinkLeewayOnRight = 0;
              stretchLeewayOnRight = 0;
              for (j = i2 + 1; j < columns.length; j++) {
                c = columns[j];
                if (c.resizable) {
                  if (stretchLeewayOnRight !== null) {
                    if (c.maxWidth) {
                      stretchLeewayOnRight += c.maxWidth - c.previousWidth;
                    } else {
                      stretchLeewayOnRight = null;
                    }
                  }
                  shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                }
              }
            }
            var shrinkLeewayOnLeft = 0, stretchLeewayOnLeft = 0;
            for (j = 0; j <= i2; j++) {
              c = columns[j];
              if (c.resizable) {
                if (stretchLeewayOnLeft !== null) {
                  if (c.maxWidth) {
                    stretchLeewayOnLeft += c.maxWidth - c.previousWidth;
                  } else {
                    stretchLeewayOnLeft = null;
                  }
                }
                shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
              }
            }
            if (shrinkLeewayOnRight === null) {
              shrinkLeewayOnRight = 1e5;
            }
            if (shrinkLeewayOnLeft === null) {
              shrinkLeewayOnLeft = 1e5;
            }
            if (stretchLeewayOnRight === null) {
              stretchLeewayOnRight = 1e5;
            }
            if (stretchLeewayOnLeft === null) {
              stretchLeewayOnLeft = 1e5;
            }
            maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);
            minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);
          }).on("drag", function(e2, dd2) {
            columnResizeDragging = true;
            var actualMinWidth, d = Math.min(maxPageX, Math.max(minPageX, e2.pageX)) - pageX, x2;
            var newCanvasWidthL = 0, newCanvasWidthR = 0;
            var viewportWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
            if (d < 0) {
              x2 = d;
              for (j = i2; j >= 0; j--) {
                c = columns[j];
                if (c.resizable) {
                  actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                  if (x2 && c.previousWidth + x2 < actualMinWidth) {
                    x2 += c.previousWidth - actualMinWidth;
                    c.width = actualMinWidth;
                  } else {
                    c.width = c.previousWidth + x2;
                    x2 = 0;
                  }
                }
              }
              for (k = 0; k <= i2; k++) {
                c = columns[k];
                if (hasFrozenColumns() && k > options.frozenColumn) {
                  newCanvasWidthR += c.width;
                } else {
                  newCanvasWidthL += c.width;
                }
              }
              if (options.forceFitColumns) {
                x2 = -d;
                for (j = i2 + 1; j < columns.length; j++) {
                  c = columns[j];
                  if (c.resizable) {
                    if (x2 && c.maxWidth && c.maxWidth - c.previousWidth < x2) {
                      x2 -= c.maxWidth - c.previousWidth;
                      c.width = c.maxWidth;
                    } else {
                      c.width = c.previousWidth + x2;
                      x2 = 0;
                    }
                    if (hasFrozenColumns() && j > options.frozenColumn) {
                      newCanvasWidthR += c.width;
                    } else {
                      newCanvasWidthL += c.width;
                    }
                  }
                }
              } else {
                for (j = i2 + 1; j < columns.length; j++) {
                  c = columns[j];
                  if (hasFrozenColumns() && j > options.frozenColumn) {
                    newCanvasWidthR += c.width;
                  } else {
                    newCanvasWidthL += c.width;
                  }
                }
              }
              if (options.forceFitColumns) {
                x2 = -d;
                for (j = i2 + 1; j < columns.length; j++) {
                  c = columns[j];
                  if (c.resizable) {
                    if (x2 && c.maxWidth && c.maxWidth - c.previousWidth < x2) {
                      x2 -= c.maxWidth - c.previousWidth;
                      c.width = c.maxWidth;
                    } else {
                      c.width = c.previousWidth + x2;
                      x2 = 0;
                    }
                  }
                }
              }
            } else {
              x2 = d;
              newCanvasWidthL = 0;
              newCanvasWidthR = 0;
              for (j = i2; j >= 0; j--) {
                c = columns[j];
                if (c.resizable) {
                  if (x2 && c.maxWidth && c.maxWidth - c.previousWidth < x2) {
                    x2 -= c.maxWidth - c.previousWidth;
                    c.width = c.maxWidth;
                  } else {
                    var newWidth = c.previousWidth + x2;
                    var resizedCanvasWidthL = canvasWidthL + x2;
                    if (hasFrozenColumns() && j <= options.frozenColumn) {
                      if (newWidth > frozenLeftColMaxWidth && resizedCanvasWidthL < viewportWidth - options.frozenRightViewportMinWidth) {
                        frozenLeftColMaxWidth = newWidth;
                      }
                      c.width = resizedCanvasWidthL + options.frozenRightViewportMinWidth > viewportWidth ? frozenLeftColMaxWidth : newWidth;
                    } else {
                      c.width = newWidth;
                    }
                    x2 = 0;
                  }
                }
              }
              for (k = 0; k <= i2; k++) {
                c = columns[k];
                if (hasFrozenColumns() && k > options.frozenColumn) {
                  newCanvasWidthR += c.width;
                } else {
                  newCanvasWidthL += c.width;
                }
              }
              if (options.forceFitColumns) {
                x2 = -d;
                for (j = i2 + 1; j < columns.length; j++) {
                  c = columns[j];
                  if (c.resizable) {
                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                    if (x2 && c.previousWidth + x2 < actualMinWidth) {
                      x2 += c.previousWidth - actualMinWidth;
                      c.width = actualMinWidth;
                    } else {
                      c.width = c.previousWidth + x2;
                      x2 = 0;
                    }
                    if (hasFrozenColumns() && j > options.frozenColumn) {
                      newCanvasWidthR += c.width;
                    } else {
                      newCanvasWidthL += c.width;
                    }
                  }
                }
              } else {
                for (j = i2 + 1; j < columns.length; j++) {
                  c = columns[j];
                  if (hasFrozenColumns() && j > options.frozenColumn) {
                    newCanvasWidthR += c.width;
                  } else {
                    newCanvasWidthL += c.width;
                  }
                }
              }
            }
            if (hasFrozenColumns() && newCanvasWidthL != canvasWidthL) {
              $headerL.width(newCanvasWidthL + 1e3);
              $paneHeaderR.css("left", newCanvasWidthL);
            }
            applyColumnHeaderWidths();
            applyColumnGroupHeaderWidths();
            if (options.syncColumnCellResize) {
              applyColumnWidths();
            }
            trigger(self.onColumnsDrag, {
              triggeredByColumn: $(this).parent().attr("id").replace(uid, ""),
              resizeHandle: $(this)
            });
          }).on("dragend", function(e2, dd2) {
            $(this).parent().removeClass("slick-header-column-active");
            var triggeredByColumn = $(this).parent().attr("id").replace(uid, "");
            if (trigger(self.onBeforeColumnsResize, { triggeredByColumn }) === true) {
              applyColumnHeaderWidths();
              applyColumnGroupHeaderWidths();
            }
            var newWidth;
            for (j = 0; j < columns.length; j++) {
              c = columns[j];
              newWidth = $(columnElements[j]).outerWidth();
              if (c.previousWidth !== newWidth && c.rerenderOnResize) {
                invalidateAllRows();
              }
            }
            updateCanvasWidth(true);
            render();
            trigger(self.onColumnsResized, { triggeredByColumn });
            setTimeout(function() {
              columnResizeDragging = false;
            }, 300);
          }).on("dblclick", function() {
            var triggeredByColumn = $(this).parent().attr("id").replace(uid, "");
            trigger(self.onColumnsResizeDblClick, { triggeredByColumn });
          });
        });
      }
      function getVBoxDelta($el) {
        var p2 = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
        var delta = 0;
        if ($el && typeof $el.css === "function") {
          $.each(p2, function(n2, val) {
            delta += parseFloat($el.css(val)) || 0;
          });
        }
        return delta;
      }
      function setFrozenOptions() {
        options.frozenColumn = options.frozenColumn >= 0 && options.frozenColumn < columns.length ? parseInt(options.frozenColumn) : -1;
        if (options.frozenRow > -1) {
          hasFrozenRows = true;
          frozenRowsHeight = options.frozenRow * options.rowHeight;
          var dataLength = getDataLength();
          actualFrozenRow = options.frozenBottom ? dataLength - options.frozenRow : options.frozenRow;
        } else {
          hasFrozenRows = false;
        }
      }
      function setPaneVisibility() {
        if (hasFrozenColumns()) {
          $paneHeaderR.show();
          $paneTopR.show();
          if (hasFrozenRows) {
            $paneBottomL.show();
            $paneBottomR.show();
          } else {
            $paneBottomR.hide();
            $paneBottomL.hide();
          }
        } else {
          $paneHeaderR.hide();
          $paneTopR.hide();
          $paneBottomR.hide();
          if (hasFrozenRows) {
            $paneBottomL.show();
          } else {
            $paneBottomR.hide();
            $paneBottomL.hide();
          }
        }
      }
      function setOverflow() {
        $viewportTopL.css({
          "overflow-x": hasFrozenColumns() ? hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "hidden" : "scroll" : hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "hidden" : "auto",
          "overflow-y": !hasFrozenColumns() && options.alwaysShowVerticalScroll ? "scroll" : hasFrozenColumns() ? hasFrozenRows ? "hidden" : "hidden" : hasFrozenRows ? "scroll" : "auto"
        });
        $viewportTopR.css({
          "overflow-x": hasFrozenColumns() ? hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "hidden" : "scroll" : hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "hidden" : "auto",
          "overflow-y": options.alwaysShowVerticalScroll ? "scroll" : hasFrozenColumns() ? hasFrozenRows ? "scroll" : "auto" : hasFrozenRows ? "scroll" : "auto"
        });
        $viewportBottomL.css({
          "overflow-x": hasFrozenColumns() ? hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "scroll" : "auto" : hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "auto" : "auto",
          "overflow-y": !hasFrozenColumns() && options.alwaysShowVerticalScroll ? "scroll" : hasFrozenColumns() ? hasFrozenRows ? "hidden" : "hidden" : hasFrozenRows ? "scroll" : "auto"
        });
        $viewportBottomR.css({
          "overflow-x": hasFrozenColumns() ? hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "scroll" : "auto" : hasFrozenRows && !options.alwaysAllowHorizontalScroll ? "auto" : "auto",
          "overflow-y": options.alwaysShowVerticalScroll ? "scroll" : hasFrozenColumns() ? hasFrozenRows ? "auto" : "auto" : hasFrozenRows ? "auto" : "auto"
        });
        if (options.viewportClass) {
          $viewportTopL.toggleClass(options.viewportClass, true);
          $viewportTopR.toggleClass(options.viewportClass, true);
          $viewportBottomL.toggleClass(options.viewportClass, true);
          $viewportBottomR.toggleClass(options.viewportClass, true);
        }
      }
      function setScroller() {
        if (hasFrozenColumns()) {
          $headerScrollContainer = $headerScrollerR;
          $headerRowScrollContainer = $headerRowScrollerR;
          $footerRowScrollContainer = $footerRowScrollerR;
          if (hasFrozenRows) {
            if (options.frozenBottom) {
              $viewportScrollContainerX = $viewportBottomR;
              $viewportScrollContainerY = $viewportTopR;
            } else {
              $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomR;
            }
          } else {
            $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopR;
          }
        } else {
          $headerScrollContainer = $headerScrollerL;
          $headerRowScrollContainer = $headerRowScrollerL;
          $footerRowScrollContainer = $footerRowScrollerL;
          if (hasFrozenRows) {
            if (options.frozenBottom) {
              $viewportScrollContainerX = $viewportBottomL;
              $viewportScrollContainerY = $viewportTopL;
            } else {
              $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomL;
            }
          } else {
            $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopL;
          }
        }
      }
      function measureCellPaddingAndBorder() {
        var el;
        var h7 = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"];
        var v = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
        var verArray = $.fn.jquery.split(".");
        jQueryNewWidthBehaviour = verArray[0] == 1 && verArray[1] >= 8 || verArray[0] >= 2;
        el = $("<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>").appendTo($headers);
        headerColumnWidthDiff = headerColumnHeightDiff = 0;
        if (el.css("box-sizing") != "border-box" && el.css("-moz-box-sizing") != "border-box" && el.css("-webkit-box-sizing") != "border-box") {
          $.each(h7, function(n2, val) {
            headerColumnWidthDiff += parseFloat(el.css(val)) || 0;
          });
          $.each(v, function(n2, val) {
            headerColumnHeightDiff += parseFloat(el.css(val)) || 0;
          });
        }
        el.remove();
        var r = $("<div class='slick-row' />").appendTo($canvas);
        el = $("<div class='slick-cell' id='' style='visibility:hidden'>-</div>").appendTo(r);
        cellWidthDiff = cellHeightDiff = 0;
        if (el.css("box-sizing") != "border-box" && el.css("-moz-box-sizing") != "border-box" && el.css("-webkit-box-sizing") != "border-box") {
          $.each(h7, function(n2, val) {
            cellWidthDiff += parseFloat(el.css(val)) || 0;
          });
          $.each(v, function(n2, val) {
            cellHeightDiff += parseFloat(el.css(val)) || 0;
          });
        }
        r.remove();
        absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);
      }
      function createCssRules() {
        $style = $("<style type='text/css' rel='stylesheet' />");
        if ($container[0].parentNode instanceof ShadowRoot)
          $container[0].parentNode.insertBefore($style[0], $container[0]);
        else
          $style.appendTo($("head"));
        var rowHeight = options.rowHeight - cellHeightDiff;
        var rules = [
          "." + uid + " .slick-group-header-column { left: 1000px; }",
          "." + uid + " .slick-header-column { left: 1000px; }",
          "." + uid + " .slick-top-panel { height:" + options.topPanelHeight + "px; }",
          "." + uid + " .slick-preheader-panel { height:" + options.preHeaderPanelHeight + "px; }",
          "." + uid + " .slick-headerrow-columns { height:" + options.headerRowHeight + "px; }",
          "." + uid + " .slick-footerrow-columns { height:" + options.footerRowHeight + "px; }",
          "." + uid + " .slick-cell { height:" + rowHeight + "px; }",
          "." + uid + " .slick-row { height:" + options.rowHeight + "px; }"
        ];
        for (var i2 = 0; i2 < columns.length; i2++) {
          rules.push("." + uid + " .l" + i2 + " { }");
          rules.push("." + uid + " .r" + i2 + " { }");
        }
        if ($style[0].styleSheet) {
          $style[0].styleSheet.cssText = rules.join(" ");
        } else {
          $style[0].appendChild(document.createTextNode(rules.join(" ")));
        }
      }
      function getColumnCssRules(idx) {
        var i2;
        if (!stylesheet) {
          var sheets;
          if ($container[0].parentNode instanceof ShadowRoot)
            sheets = $container[0].parentNode.styleSheets;
          else
            sheets = document.styleSheets;
          for (i2 = 0; i2 < sheets.length; i2++) {
            if ((sheets[i2].ownerNode || sheets[i2].owningElement) == $style[0]) {
              stylesheet = sheets[i2];
              break;
            }
          }
          if (!stylesheet) {
            throw new Error("SlickGrid Cannot find stylesheet.");
          }
          columnCssRulesL = [];
          columnCssRulesR = [];
          var cssRules = stylesheet.cssRules || stylesheet.rules;
          var matches, columnIdx;
          for (i2 = 0; i2 < cssRules.length; i2++) {
            var selector = cssRules[i2].selectorText;
            if (matches = /\.l\d+/.exec(selector)) {
              columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
              columnCssRulesL[columnIdx] = cssRules[i2];
            } else if (matches = /\.r\d+/.exec(selector)) {
              columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
              columnCssRulesR[columnIdx] = cssRules[i2];
            }
          }
        }
        return {
          "left": columnCssRulesL[idx],
          "right": columnCssRulesR[idx]
        };
      }
      function removeCssRules() {
        $style.remove();
        stylesheet = null;
      }
      function destroy(shouldDestroyAllElements) {
        getEditorLock().cancelCurrentEdit();
        trigger(self.onBeforeDestroy, {});
        var i2 = plugins.length;
        while (i2--) {
          unregisterPlugin(plugins[i2]);
        }
        if (options.enableColumnReorder) {
          $headers.filter(":ui-sortable").sortable("destroy");
        }
        unbindAncestorScrollEvents();
        $container.off(".slickgrid");
        removeCssRules();
        $canvas.off();
        $viewport.off();
        $headerScroller.off();
        $headerRowScroller.off();
        if ($footerRow) {
          $footerRow.off();
        }
        if ($footerRowScroller) {
          $footerRowScroller.off();
        }
        if ($preHeaderPanelScroller) {
          $preHeaderPanelScroller.off();
        }
        $focusSink.off();
        $(".slick-resizable-handle").off();
        $(".slick-header-column").off();
        $container.empty().removeClass(uid);
        if (shouldDestroyAllElements) {
          destroyAllElements();
        }
      }
      function destroyAllElements() {
        $activeCanvasNode = null;
        $activeViewportNode = null;
        $boundAncestors = null;
        $canvas = null;
        $canvasTopL = null;
        $canvasTopR = null;
        $canvasBottomL = null;
        $canvasBottomR = null;
        $container = null;
        $focusSink = null;
        $focusSink2 = null;
        $groupHeaders = null;
        $groupHeadersL = null;
        $groupHeadersR = null;
        $headerL = null;
        $headerR = null;
        $headers = null;
        $headerRow = null;
        $headerRowL = null;
        $headerRowR = null;
        $headerRowSpacerL = null;
        $headerRowSpacerR = null;
        $headerRowScrollContainer = null;
        $headerRowScroller = null;
        $headerRowScrollerL = null;
        $headerRowScrollerR = null;
        $headerScrollContainer = null;
        $headerScroller = null;
        $headerScrollerL = null;
        $headerScrollerR = null;
        $hiddenParents = null;
        $footerRow = null;
        $footerRowL = null;
        $footerRowR = null;
        $footerRowSpacerL = null;
        $footerRowSpacerR = null;
        $footerRowScroller = null;
        $footerRowScrollerL = null;
        $footerRowScrollerR = null;
        $footerRowScrollContainer = null;
        $preHeaderPanel = null;
        $preHeaderPanelR = null;
        $preHeaderPanelScroller = null;
        $preHeaderPanelScrollerR = null;
        $preHeaderPanelSpacer = null;
        $preHeaderPanelSpacerR = null;
        $topPanel = null;
        $topPanelScroller = null;
        $style = null;
        $topPanelScrollerL = null;
        $topPanelScrollerR = null;
        $topPanelL = null;
        $topPanelR = null;
        $paneHeaderL = null;
        $paneHeaderR = null;
        $paneTopL = null;
        $paneTopR = null;
        $paneBottomL = null;
        $paneBottomR = null;
        $viewport = null;
        $viewportTopL = null;
        $viewportTopR = null;
        $viewportBottomL = null;
        $viewportBottomR = null;
        $viewportScrollContainerX = null;
        $viewportScrollContainerY = null;
      }
      var canvas = null;
      var canvas_context = null;
      function autosizeColumn(columnOrIndexOrId, isInit) {
        var c = columnOrIndexOrId;
        if (typeof columnOrIndexOrId === "number") {
          c = columns[columnOrIndexOrId];
        } else if (typeof columnOrIndexOrId === "string") {
          for (var i2 = 0; i2 < columns.length; i2++) {
            if (columns[i2].Id === columnOrIndexOrId) {
              c = columns[i2];
            }
          }
        }
        var $gridCanvas = $(getCanvasNode(0, 0));
        getColAutosizeWidth(c, $gridCanvas, isInit);
      }
      function autosizeColumns(autosizeMode, isInit) {
        autosizeMode = autosizeMode || options.autosizeColsMode;
        if (autosizeMode === Slick.GridAutosizeColsMode.LegacyForceFit || autosizeMode === Slick.GridAutosizeColsMode.LegacyOff) {
          legacyAutosizeColumns();
          return;
        }
        if (autosizeMode === Slick.GridAutosizeColsMode.None) {
          return;
        }
        canvas = document.createElement("canvas");
        if (canvas && canvas.getContext) {
          canvas_context = canvas.getContext("2d");
        }
        var $gridCanvas = $(getCanvasNode(0, 0));
        var viewportWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
        var i2, c, colWidth, reRender, totalWidth = 0, totalWidthLessSTR = 0, strColsMinWidth = 0, totalMinWidth = 0, totalLockedColWidth = 0;
        for (i2 = 0; i2 < columns.length; i2++) {
          c = columns[i2];
          getColAutosizeWidth(c, $gridCanvas, isInit);
          totalLockedColWidth += c.autoSize.autosizeMode === Slick.ColAutosizeMode.Locked ? c.width : 0;
          totalMinWidth += c.autoSize.autosizeMode === Slick.ColAutosizeMode.Locked ? c.width : c.minWidth;
          totalWidth += c.autoSize.widthPx;
          totalWidthLessSTR += c.autoSize.sizeToRemaining ? 0 : c.autoSize.widthPx;
          strColsMinWidth += c.autoSize.sizeToRemaining ? c.minWidth || 0 : 0;
        }
        var strColTotalGuideWidth = totalWidth - totalWidthLessSTR;
        if (autosizeMode === Slick.GridAutosizeColsMode.FitViewportToCols) {
          var setWidth = totalWidth + scrollbarDimensions.width;
          autosizeMode = Slick.GridAutosizeColsMode.IgnoreViewport;
          if (options.viewportMaxWidthPx && setWidth > options.viewportMaxWidthPx) {
            setWidth = options.viewportMaxWidthPx;
            autosizeMode = Slick.GridAutosizeColsMode.FitColsToViewport;
          } else if (options.viewportMinWidthPx && setWidth < options.viewportMinWidthPx) {
            setWidth = options.viewportMinWidthPx;
            autosizeMode = Slick.GridAutosizeColsMode.FitColsToViewport;
          } else {
          }
          $container.width(setWidth);
        }
        if (autosizeMode === Slick.GridAutosizeColsMode.FitColsToViewport) {
          if (strColTotalGuideWidth > 0 && totalWidthLessSTR < viewportWidth - strColsMinWidth) {
            for (i2 = 0; i2 < columns.length; i2++) {
              c = columns[i2];
              var totalSTRViewportWidth = viewportWidth - totalWidthLessSTR;
              if (c.autoSize.sizeToRemaining) {
                colWidth = totalSTRViewportWidth * c.autoSize.widthPx / strColTotalGuideWidth;
              } else {
                colWidth = c.autoSize.widthPx;
              }
              if (c.rerenderOnResize && c.width != colWidth) {
                reRender = true;
              }
              c.width = colWidth;
            }
          } else if (options.viewportSwitchToScrollModeWidthPercent && totalWidthLessSTR + strColsMinWidth > viewportWidth * options.viewportSwitchToScrollModeWidthPercent / 100 || totalMinWidth > viewportWidth) {
            autosizeMode = Slick.GridAutosizeColsMode.IgnoreViewport;
          } else {
            var unallocatedColWidth = totalWidthLessSTR - totalLockedColWidth;
            var unallocatedViewportWidth = viewportWidth - totalLockedColWidth - strColsMinWidth;
            for (i2 = 0; i2 < columns.length; i2++) {
              c = columns[i2];
              colWidth = c.width;
              if (c.autoSize.autosizeMode !== Slick.ColAutosizeMode.Locked) {
                if (c.autoSize.sizeToRemaining) {
                  colWidth = c.minWidth;
                } else {
                  colWidth = unallocatedViewportWidth / unallocatedColWidth * c.autoSize.widthPx;
                  if (colWidth < c.minWidth) {
                    colWidth = c.minWidth;
                  }
                  unallocatedColWidth -= c.autoSize.widthPx;
                  unallocatedViewportWidth -= colWidth;
                }
              }
              if (c.rerenderOnResize && c.width != colWidth) {
                reRender = true;
              }
              c.width = colWidth;
            }
          }
        }
        if (autosizeMode === Slick.GridAutosizeColsMode.IgnoreViewport) {
          for (i2 = 0; i2 < columns.length; i2++) {
            colWidth = columns[i2].autoSize.widthPx;
            if (columns[i2].rerenderOnResize && columns[i2].width != colWidth) {
              reRender = true;
            }
            columns[i2].width = colWidth;
          }
        }
        reRenderColumns(reRender);
      }
      function LogColWidths() {
        var s2 = "Col Widths:";
        for (var i2 = 0; i2 < columns.length; i2++) {
          s2 += " " + columns[i2].width;
        }
        console.log(s2);
      }
      function getColAutosizeWidth(columnDef, $gridCanvas, isInit) {
        var autoSize = columnDef.autoSize;
        autoSize.widthPx = columnDef.width;
        if (autoSize.autosizeMode === Slick.ColAutosizeMode.Locked || autoSize.autosizeMode === Slick.ColAutosizeMode.Guide) {
          return;
        }
        var dl2 = getDataLength();
        if (autoSize.autosizeMode === Slick.ColAutosizeMode.ContentIntelligent) {
          var colDataTypeOf = autoSize.colDataTypeOf;
          var colDataItem;
          if (dl2 > 0) {
            var tempRow = getDataItem(0);
            if (tempRow) {
              colDataItem = tempRow[columnDef.field];
              colDataTypeOf = typeof colDataItem;
              if (colDataTypeOf === "object") {
                if (colDataItem instanceof Date) {
                  colDataTypeOf = "date";
                }
                if (typeof moment !== "undefined" && colDataItem instanceof moment) {
                  colDataTypeOf = "moment";
                }
              }
            }
          }
          if (colDataTypeOf === "boolean") {
            autoSize.colValueArray = [true, false];
          }
          if (colDataTypeOf === "number") {
            autoSize.valueFilterMode = Slick.ValueFilterMode.GetGreatestAndSub;
            autoSize.rowSelectionMode = Slick.RowSelectionMode.AllRows;
          }
          if (colDataTypeOf === "string") {
            autoSize.valueFilterMode = Slick.ValueFilterMode.GetLongestText;
            autoSize.rowSelectionMode = Slick.RowSelectionMode.AllRows;
            autoSize.allowAddlPercent = 5;
          }
          if (colDataTypeOf === "date") {
            autoSize.colValueArray = [new Date(2009, 8, 30, 12, 20, 20)];
          }
          if (colDataTypeOf === "moment" && typeof moment !== "undefined") {
            autoSize.colValueArray = [moment([2009, 8, 30, 12, 20, 20])];
          }
        }
        var colWidth = getColContentSize(columnDef, $gridCanvas, isInit);
        var addlPercentMultiplier = autoSize.allowAddlPercent ? 1 + autoSize.allowAddlPercent / 100 : 1;
        colWidth = colWidth * addlPercentMultiplier + options.autosizeColPaddingPx;
        if (columnDef.minWidth && colWidth < columnDef.minWidth) {
          colWidth = columnDef.minWidth;
        }
        if (columnDef.maxWidth && colWidth > columnDef.maxWidth) {
          colWidth = columnDef.maxWidth;
        }
        autoSize.widthPx = colWidth;
      }
      function getColContentSize(columnDef, $gridCanvas, isInit) {
        var autoSize = columnDef.autoSize;
        var widthAdjustRatio = 1;
        var i2, ii;
        var maxColWidth = 0;
        var headerWidth = 0;
        if (!autoSize.ignoreHeaderText) {
          headerWidth = getColHeaderWidth(columnDef);
        }
        if (autoSize.colValueArray) {
          maxColWidth = getColWidth(columnDef, $gridCanvas, autoSize.colValueArray);
          return Math.max(headerWidth, maxColWidth);
        }
        var rows = getData();
        if (rows.getItems) {
          rows = rows.getItems();
        }
        var rowSelectionMode = (isInit ? autoSize.rowSelectionModeOnInit : void 0) || autoSize.rowSelectionMode;
        if (rowSelectionMode === Slick.RowSelectionMode.FirstRow) {
          rows = rows.slice(0, 1);
        }
        if (rowSelectionMode === Slick.RowSelectionMode.LastRow) {
          rows = rows.slice(rows.length - 1, rows.length);
        }
        if (rowSelectionMode === Slick.RowSelectionMode.FirstNRows) {
          rows = rows.slice(0, autoSize.rowSelectionCount);
        }
        if (autoSize.valueFilterMode === Slick.ValueFilterMode.DeDuplicate) {
          var rowsDict = {};
          for (i2 = 0, ii = rows.length; i2 < ii; i2++) {
            rowsDict[rows[i2][columnDef.field]] = true;
          }
          if (Object.keys) {
            rows = Object.keys(rowsDict);
          } else {
            rows = [];
            for (var i2 in rowsDict) rows.push(i2);
          }
        }
        if (autoSize.valueFilterMode === Slick.ValueFilterMode.GetGreatestAndSub) {
          var tempVal, maxVal, maxAbsVal = 0;
          for (i2 = 0, ii = rows.length; i2 < ii; i2++) {
            tempVal = rows[i2][columnDef.field];
            if (Math.abs(tempVal) > maxAbsVal) {
              maxVal = tempVal;
              maxAbsVal = Math.abs(tempVal);
            }
          }
          maxVal = "" + maxVal;
          maxVal = Array(maxVal.length + 1).join("9");
          maxVal = +maxVal;
          rows = [maxVal];
        }
        if (autoSize.valueFilterMode === Slick.ValueFilterMode.GetLongestTextAndSub) {
          var tempVal, maxLen = 0;
          for (i2 = 0, ii = rows.length; i2 < ii; i2++) {
            tempVal = rows[i2][columnDef.field];
            if ((tempVal || "").length > maxLen) {
              maxLen = tempVal.length;
            }
          }
          tempVal = Array(maxLen + 1).join("m");
          widthAdjustRatio = options.autosizeTextAvgToMWidthRatio;
          rows = [tempVal];
        }
        if (autoSize.valueFilterMode === Slick.ValueFilterMode.GetLongestText) {
          var tempVal, maxLen = 0, maxIndex = 0;
          if (row.length) {
            for (i2 = 0, ii = rows.length; i2 < ii; i2++) {
              tempVal = rows[i2][columnDef.field];
              if ((tempVal || "").length > maxLen) {
                maxLen = tempVal.length;
                maxIndex = i2;
              }
            }
            tempVal = rows[maxIndex][columnDef.field];
          }
          rows = [tempVal];
        }
        maxColWidth = getColWidth(columnDef, $gridCanvas, rows) * widthAdjustRatio;
        return Math.max(headerWidth, maxColWidth);
      }
      function getColWidth(columnDef, $gridCanvas, data3) {
        var colIndex = getColumnIndex(columnDef.id);
        var $rowEl = $('<div class="slick-row ui-widget-content"></div>');
        var $cellEl = $('<div class="slick-cell"></div>');
        $cellEl.css({
          "position": "absolute",
          "visibility": "hidden",
          "text-overflow": "initial",
          "white-space": "nowrap"
        });
        $rowEl.append($cellEl);
        $gridCanvas.append($rowEl);
        var len, max18 = 0, text2, maxText, formatterResult, maxWidth = 0, val;
        if (canvas_context && columnDef.autoSize.widthEvalMode === Slick.WidthEvalMode.CanvasTextSize) {
          canvas_context.font = $cellEl.css("font-size") + " " + $cellEl.css("font-family");
          $(data3).each(function(index2, row2) {
            val = Array.isArray(row2) ? row2[columnDef.field] : row2;
            text2 = "" + val;
            len = text2 ? canvas_context.measureText(text2).width : 0;
            if (len > max18) {
              max18 = len;
              maxText = text2;
            }
          });
          $cellEl.html(maxText);
          len = $cellEl.outerWidth();
          $rowEl.remove();
          $cellEl = null;
          return len;
        }
        $(data3).each(function(index2, row2) {
          val = Array.isArray(row2) ? row2[columnDef.field] : row2;
          if (columnDef.formatterOverride) {
            formatterResult = columnDef.formatterOverride(index2, colIndex, val, columnDef, row2, self);
          } else if (columnDef.formatter) {
            formatterResult = columnDef.formatter(index2, colIndex, val, columnDef, row2, self);
          } else {
            formatterResult = "" + val;
          }
          applyFormatResultToCellNode(formatterResult, $cellEl[0]);
          len = $cellEl.outerWidth();
          if (len > max18) {
            max18 = len;
          }
        });
        $rowEl.remove();
        $cellEl = null;
        return max18;
      }
      function getColHeaderWidth(columnDef) {
        var width = 0;
        var headerColElId = getUID() + columnDef.id;
        var headerColEl = document.getElementById(headerColElId);
        var dummyHeaderColElId = headerColElId + "_";
        if (headerColEl) {
          var clone3 = headerColEl.cloneNode(true);
          clone3.id = dummyHeaderColElId;
          clone3.style.cssText = "position: absolute; visibility: hidden;right: auto;text-overflow: initial;white-space: nowrap;";
          headerColEl.parentNode.insertBefore(clone3, headerColEl);
          width = clone3.offsetWidth;
          clone3.parentNode.removeChild(clone3);
        } else {
          var header4 = getHeader(columnDef);
          headerColEl = $("<div class='ui-state-default slick-header-column' />").html("<span class='slick-column-name'>" + columnDef.name + "</span>").attr("id", dummyHeaderColElId).css({ "position": "absolute", "visibility": "hidden", "right": "auto", "text-overflow:": "initial", "white-space": "nowrap" }).addClass(columnDef.headerCssClass || "").appendTo(header4);
          width = headerColEl[0].offsetWidth;
          header4[0].removeChild(headerColEl[0]);
        }
        return width;
      }
      function legacyAutosizeColumns() {
        var i2, c, widths = [], shrinkLeeway = 0, total = 0, prevTotal, availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
        for (i2 = 0; i2 < columns.length; i2++) {
          c = columns[i2];
          widths.push(c.width);
          total += c.width;
          if (c.resizable) {
            shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);
          }
        }
        prevTotal = total;
        while (total > availWidth && shrinkLeeway) {
          var shrinkProportion = (total - availWidth) / shrinkLeeway;
          for (i2 = 0; i2 < columns.length && total > availWidth; i2++) {
            c = columns[i2];
            var width = widths[i2];
            if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {
              continue;
            }
            var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);
            var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;
            shrinkSize = Math.min(shrinkSize, width - absMinWidth);
            total -= shrinkSize;
            shrinkLeeway -= shrinkSize;
            widths[i2] -= shrinkSize;
          }
          if (prevTotal <= total) {
            break;
          }
          prevTotal = total;
        }
        prevTotal = total;
        while (total < availWidth) {
          var growProportion = availWidth / total;
          for (i2 = 0; i2 < columns.length && total < availWidth; i2++) {
            c = columns[i2];
            var currentWidth = widths[i2];
            var growSize;
            if (!c.resizable || c.maxWidth <= currentWidth) {
              growSize = 0;
            } else {
              growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, c.maxWidth - currentWidth || 1e6) || 1;
            }
            total += growSize;
            widths[i2] += total <= availWidth ? growSize : 0;
          }
          if (prevTotal >= total) {
            break;
          }
          prevTotal = total;
        }
        var reRender = false;
        for (i2 = 0; i2 < columns.length; i2++) {
          if (columns[i2].rerenderOnResize && columns[i2].width != widths[i2]) {
            reRender = true;
          }
          columns[i2].width = widths[i2];
        }
        reRenderColumns(reRender);
      }
      function reRenderColumns(reRender) {
        applyColumnHeaderWidths();
        applyColumnGroupHeaderWidths();
        updateCanvasWidth(true);
        trigger(self.onAutosizeColumns, { "columns": columns });
        if (reRender) {
          invalidateAllRows();
          render();
        }
      }
      function trigger(evt, args, e) {
        e = e || new Slick.EventData();
        args = args || {};
        args.grid = self;
        return evt.notify(args, e, self);
      }
      function getEditorLock() {
        return options.editorLock;
      }
      function getEditController() {
        return editController;
      }
      function getColumnIndex(id) {
        return columnsById[id];
      }
      function applyColumnGroupHeaderWidths() {
        if (!treeColumns.hasDepth())
          return;
        for (var depth = $groupHeadersL.length - 1; depth >= 0; depth--) {
          var groupColumns = treeColumns.getColumnsInDepth(depth);
          $().add($groupHeadersL[depth]).add($groupHeadersR[depth]).each(function(i2) {
            var $groupHeader = $(this), currentColumnIndex = 0;
            $groupHeader.width(i2 === 0 ? getHeadersWidthL() : getHeadersWidthR());
            $groupHeader.children().each(function() {
              var $groupHeaderColumn = $(this);
              var m = $(this).data("column");
              m.width = 0;
              m.columns.forEach(function() {
                var $headerColumn = $groupHeader.next().children(":eq(" + currentColumnIndex++ + ")");
                m.width += $headerColumn.outerWidth();
              });
              $groupHeaderColumn.width(m.width - headerColumnWidthDiff);
            });
          });
        }
      }
      function applyColumnHeaderWidths() {
        if (!initialized) {
          return;
        }
        var h7;
        for (var i2 = 0, headers = $headers.children(), ii = columns.length; i2 < ii; i2++) {
          h7 = $(headers[i2]);
          if (jQueryNewWidthBehaviour) {
            if (h7.outerWidth() !== columns[i2].width) {
              h7.outerWidth(columns[i2].width);
            }
          } else {
            if (h7.width() !== columns[i2].width - headerColumnWidthDiff) {
              h7.width(columns[i2].width - headerColumnWidthDiff);
            }
          }
        }
        updateColumnCaches();
      }
      function applyColumnWidths() {
        var x2 = 0, w, rule;
        for (var i2 = 0; i2 < columns.length; i2++) {
          w = columns[i2].width;
          rule = getColumnCssRules(i2);
          rule.left.style.left = x2 + "px";
          rule.right.style.right = (options.frozenColumn != -1 && i2 > options.frozenColumn ? canvasWidthR : canvasWidthL) - x2 - w + "px";
          if (options.frozenColumn == i2) {
            x2 = 0;
          } else {
            x2 += columns[i2].width;
          }
        }
      }
      function setSortColumn(columnId, ascending) {
        setSortColumns([{ columnId, sortAsc: ascending }]);
      }
      function setSortColumns(cols) {
        sortColumns = cols;
        var numberCols = options.numberedMultiColumnSort && sortColumns.length > 1;
        var headerColumnEls = $headers.children();
        headerColumnEls.removeClass("slick-header-column-sorted").find(".slick-sort-indicator").removeClass("slick-sort-indicator-asc slick-sort-indicator-desc");
        headerColumnEls.find(".slick-sort-indicator-numbered").text("");
        $.each(sortColumns, function(i2, col2) {
          if (col2.sortAsc == null) {
            col2.sortAsc = true;
          }
          var columnIndex = getColumnIndex(col2.columnId);
          if (columnIndex != null) {
            headerColumnEls.eq(columnIndex).addClass("slick-header-column-sorted").find(".slick-sort-indicator").addClass(col2.sortAsc ? "slick-sort-indicator-asc" : "slick-sort-indicator-desc");
            if (numberCols) {
              headerColumnEls.eq(columnIndex).find(".slick-sort-indicator-numbered").text(i2 + 1);
            }
          }
        });
      }
      function getSortColumns() {
        return sortColumns;
      }
      function handleSelectedRangesChanged(e, ranges) {
        var previousSelectedRows = selectedRows.slice(0);
        selectedRows = [];
        var hash = {};
        for (var i2 = 0; i2 < ranges.length; i2++) {
          for (var j = ranges[i2].fromRow; j <= ranges[i2].toRow; j++) {
            if (!hash[j]) {
              selectedRows.push(j);
              hash[j] = {};
            }
            for (var k = ranges[i2].fromCell; k <= ranges[i2].toCell; k++) {
              if (canCellBeSelected(j, k)) {
                hash[j][columns[k].id] = options.selectedCellCssClass;
              }
            }
          }
        }
        setCellCssStyles(options.selectedCellCssClass, hash);
        if (!simpleArrayEquals(previousSelectedRows, selectedRows)) {
          trigger(self.onSelectedRowsChanged, { rows: getSelectedRows(), previousSelectedRows }, e);
        }
      }
      function simpleArrayEquals(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2))
          return true;
        const s1 = new Set(arr1);
        const s2 = new Set(arr2);
        if (s1.size != s2.size)
          return false;
        for (const item3 of s1) {
          if (!s2.has(item3))
            return false;
        }
        return true;
      }
      function getColumns() {
        return columns;
      }
      function updateColumnCaches() {
        columnPosLeft = [];
        columnPosRight = [];
        var x2 = 0;
        for (var i2 = 0, ii = columns.length; i2 < ii; i2++) {
          columnPosLeft[i2] = x2;
          columnPosRight[i2] = x2 + columns[i2].width;
          if (options.frozenColumn == i2) {
            x2 = 0;
          } else {
            x2 += columns[i2].width;
          }
        }
      }
      function updateColumnProps() {
        columnsById = {};
        for (var i2 = 0; i2 < columns.length; i2++) {
          if (columns[i2].width) {
            columns[i2].widthRequest = columns[i2].width;
          }
          var m = columns[i2] = $.extend({}, columnDefaults, columns[i2]);
          m.autoSize = $.extend({}, columnAutosizeDefaults, m.autoSize);
          columnsById[m.id] = i2;
          if (m.minWidth && m.width < m.minWidth) {
            m.width = m.minWidth;
          }
          if (m.maxWidth && m.width > m.maxWidth) {
            m.width = m.maxWidth;
          }
          if (!m.resizable) {
          }
        }
      }
      function setColumns(columnDefinitions) {
        trigger(self.onBeforeSetColumns, { previousColumns: columns, newColumns: columnDefinitions, grid: self });
        var _treeColumns = new Slick.TreeColumns(columnDefinitions);
        if (_treeColumns.hasDepth()) {
          treeColumns = _treeColumns;
          columns = treeColumns.extractColumns();
        } else {
          columns = columnDefinitions;
        }
        updateColumnProps();
        updateColumnCaches();
        if (initialized) {
          setPaneVisibility();
          setOverflow();
          invalidateAllRows();
          createColumnHeaders();
          createColumnGroupHeaders();
          createColumnFooter();
          removeCssRules();
          createCssRules();
          resizeCanvas();
          updateCanvasWidth();
          applyColumnHeaderWidths();
          applyColumnWidths();
          handleScroll();
        }
      }
      function getOptions() {
        return options;
      }
      function setOptions(args, suppressRender, suppressColumnSet, suppressSetOverflow) {
        if (!getEditorLock().commitCurrentEdit()) {
          return;
        }
        makeActiveCellNormal();
        if (args.showColumnHeader !== void 0) {
          setColumnHeaderVisibility(args.showColumnHeader);
        }
        if (options.enableAddRow !== args.enableAddRow) {
          invalidateRow(getDataLength());
        }
        var originalOptions = $.extend(true, {}, options);
        options = $.extend(options, args);
        trigger(self.onSetOptions, { "optionsBefore": originalOptions, "optionsAfter": options });
        validateAndEnforceOptions();
        $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto");
        if (!suppressRender) {
          render();
        }
        setFrozenOptions();
        setScroller();
        if (!suppressSetOverflow) {
          setOverflow();
        }
        if (!suppressColumnSet) {
          setColumns(treeColumns.extractColumns());
        }
        if (options.enableMouseWheelScrollHandler && $viewport && jQuery.fn.mousewheel) {
          var viewportEvents = $._data($viewport[0], "events");
          if (!viewportEvents || !viewportEvents.mousewheel) {
            $viewport.on("mousewheel", handleMouseWheel);
          }
        } else if (options.enableMouseWheelScrollHandler === false) {
          $viewport.off("mousewheel");
        }
      }
      function validateAndEnforceOptions() {
        if (options.autoHeight) {
          options.leaveSpaceForNewRows = false;
        }
        if (options.forceFitColumns) {
          options.autosizeColsMode = Slick.GridAutosizeColsMode.LegacyForceFit;
          console.log("forceFitColumns option is deprecated - use autosizeColsMode");
        }
      }
      function setData(newData, scrollToTop) {
        data = newData;
        invalidateAllRows();
        updateRowCount();
        if (scrollToTop) {
          scrollTo(0);
        }
      }
      function getData() {
        return data;
      }
      function getDataLength() {
        if (data.getLength) {
          return data.getLength();
        } else {
          return data && data.length || 0;
        }
      }
      function getDataLengthIncludingAddNew() {
        return getDataLength() + (!options.enableAddRow ? 0 : !pagingActive || pagingIsLastPage ? 1 : 0);
      }
      function getDataItem(i2) {
        if (data.getItem) {
          return data.getItem(i2);
        } else {
          return data[i2];
        }
      }
      function getTopPanel() {
        return $topPanel[0];
      }
      function setTopPanelVisibility(visible, animate) {
        var animated = animate === false ? false : true;
        if (options.showTopPanel != visible) {
          options.showTopPanel = visible;
          if (visible) {
            if (animated) {
              $topPanelScroller.slideDown("fast", resizeCanvas);
            } else {
              $topPanelScroller.show();
              resizeCanvas();
            }
          } else {
            if (animated) {
              $topPanelScroller.slideUp("fast", resizeCanvas);
            } else {
              $topPanelScroller.hide();
              resizeCanvas();
            }
          }
        }
      }
      function setHeaderRowVisibility(visible, animate) {
        var animated = animate === false ? false : true;
        if (options.showHeaderRow != visible) {
          options.showHeaderRow = visible;
          if (visible) {
            if (animated) {
              $headerRowScroller.slideDown("fast", resizeCanvas);
            } else {
              $headerRowScroller.show();
              resizeCanvas();
            }
          } else {
            if (animated) {
              $headerRowScroller.slideUp("fast", resizeCanvas);
            } else {
              $headerRowScroller.hide();
              resizeCanvas();
            }
          }
        }
      }
      function setColumnHeaderVisibility(visible, animate) {
        if (options.showColumnHeader != visible) {
          options.showColumnHeader = visible;
          if (visible) {
            if (animate) {
              $headerScroller.slideDown("fast", resizeCanvas);
            } else {
              $headerScroller.show();
              resizeCanvas();
            }
          } else {
            if (animate) {
              $headerScroller.slideUp("fast", resizeCanvas);
            } else {
              $headerScroller.hide();
              resizeCanvas();
            }
          }
        }
      }
      function setFooterRowVisibility(visible, animate) {
        var animated = animate === false ? false : true;
        if (options.showFooterRow != visible) {
          options.showFooterRow = visible;
          if (visible) {
            if (animated) {
              $footerRowScroller.slideDown("fast", resizeCanvas);
            } else {
              $footerRowScroller.show();
              resizeCanvas();
            }
          } else {
            if (animated) {
              $footerRowScroller.slideUp("fast", resizeCanvas);
            } else {
              $footerRowScroller.hide();
              resizeCanvas();
            }
          }
        }
      }
      function setPreHeaderPanelVisibility(visible, animate) {
        var animated = animate === false ? false : true;
        if (options.showPreHeaderPanel != visible) {
          options.showPreHeaderPanel = visible;
          if (visible) {
            if (animated) {
              $preHeaderPanelScroller.slideDown("fast", resizeCanvas);
              $preHeaderPanelScrollerR.slideDown("fast", resizeCanvas);
            } else {
              $preHeaderPanelScroller.show();
              $preHeaderPanelScrollerR.show();
              resizeCanvas();
            }
          } else {
            if (animated) {
              $preHeaderPanelScroller.slideUp("fast", resizeCanvas);
              $preHeaderPanelScrollerR.slideUp("fast", resizeCanvas);
            } else {
              $preHeaderPanelScroller.hide();
              $preHeaderPanelScrollerR.hide();
              resizeCanvas();
            }
          }
        }
      }
      function getContainerNode() {
        return $container.get(0);
      }
      function getRowTop(row2) {
        return options.rowHeight * row2 - offset;
      }
      function getRowFromPosition(y2) {
        return Math.floor((y2 + offset) / options.rowHeight);
      }
      function scrollTo(y2) {
        y2 = Math.max(y2, 0);
        y2 = Math.min(y2, th - $viewportScrollContainerY.height() + (viewportHasHScroll || hasFrozenColumns() ? scrollbarDimensions.height : 0));
        var oldOffset = offset;
        page = Math.min(n - 1, Math.floor(y2 / ph));
        offset = Math.round(page * cj);
        var newScrollTop = y2 - offset;
        if (offset != oldOffset) {
          var range2 = getVisibleRange(newScrollTop);
          cleanupRows(range2);
          updateRowPositions();
        }
        if (prevScrollTop != newScrollTop) {
          vScrollDir = prevScrollTop + oldOffset < newScrollTop + offset ? 1 : -1;
          lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop;
          if (hasFrozenColumns()) {
            $viewportTopL[0].scrollTop = newScrollTop;
          }
          if (hasFrozenRows) {
            $viewportBottomL[0].scrollTop = $viewportBottomR[0].scrollTop = newScrollTop;
          }
          $viewportScrollContainerY[0].scrollTop = newScrollTop;
          trigger(self.onViewportChanged, {});
        }
      }
      function defaultFormatter(row2, cell, value2, columnDef, dataContext, grid) {
        if (value2 == null) {
          return "";
        } else {
          return (value2 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
      }
      function getFormatter(row2, column) {
        var rowMetadata = data.getItemMetadata && data.getItemMetadata(row2);
        var columnOverrides = rowMetadata && rowMetadata.columns && (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);
        return columnOverrides && columnOverrides.formatter || rowMetadata && rowMetadata.formatter || column.formatter || options.formatterFactory && options.formatterFactory.getFormatter(column) || options.defaultFormatter;
      }
      function getEditor(row2, cell) {
        var column = columns[cell];
        var rowMetadata = data.getItemMetadata && data.getItemMetadata(row2);
        var columnMetadata = rowMetadata && rowMetadata.columns;
        if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== void 0) {
          return columnMetadata[column.id].editor;
        }
        if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== void 0) {
          return columnMetadata[cell].editor;
        }
        return column.editor || options.editorFactory && options.editorFactory.getEditor(column);
      }
      function getDataItemValueForColumn(item3, columnDef) {
        if (options.dataItemColumnValueExtractor) {
          return options.dataItemColumnValueExtractor(item3, columnDef);
        }
        return item3[columnDef.field];
      }
      function appendRowHtml(stringArrayL, stringArrayR, row2, range2, dataLength) {
        var d = getDataItem(row2);
        var dataLoading = row2 < dataLength && !d;
        var rowCss = "slick-row" + (hasFrozenRows && row2 <= options.frozenRow ? " frozen" : "") + (dataLoading ? " loading" : "") + (row2 === activeRow && options.showCellSelection ? " active" : "") + (row2 % 2 == 1 ? " odd" : " even");
        if (!d) {
          rowCss += " " + options.addNewRowCssClass;
        }
        var metadata = data.getItemMetadata && data.getItemMetadata(row2);
        if (metadata && metadata.cssClasses) {
          rowCss += " " + metadata.cssClasses;
        }
        var frozenRowOffset = getFrozenRowOffset(row2);
        var rowHtml = "<div class='ui-widget-content " + rowCss + "' style='top:" + (getRowTop(row2) - frozenRowOffset) + "px'>";
        stringArrayL.push(rowHtml);
        if (hasFrozenColumns()) {
          stringArrayR.push(rowHtml);
        }
        var colspan, m;
        for (var i2 = 0, ii = columns.length; i2 < ii; i2++) {
          m = columns[i2];
          colspan = 1;
          if (metadata && metadata.columns) {
            var columnData = metadata.columns[m.id] || metadata.columns[i2];
            colspan = columnData && columnData.colspan || 1;
            if (colspan === "*") {
              colspan = ii - i2;
            }
          }
          if (columnPosRight[Math.min(ii - 1, i2 + colspan - 1)] > range2.leftPx) {
            if (!m.alwaysRenderColumn && columnPosLeft[i2] > range2.rightPx) {
              break;
            }
            if (hasFrozenColumns() && i2 > options.frozenColumn) {
              appendCellHtml(stringArrayR, row2, i2, colspan, d);
            } else {
              appendCellHtml(stringArrayL, row2, i2, colspan, d);
            }
          } else if (m.alwaysRenderColumn || hasFrozenColumns() && i2 <= options.frozenColumn) {
            appendCellHtml(stringArrayL, row2, i2, colspan, d);
          }
          if (colspan > 1) {
            i2 += colspan - 1;
          }
        }
        stringArrayL.push("</div>");
        if (hasFrozenColumns()) {
          stringArrayR.push("</div>");
        }
      }
      function appendCellHtml(stringArray, row2, cell, colspan, item3) {
        var m = columns[cell];
        var cellCss = "slick-cell l" + cell + " r" + Math.min(columns.length - 1, cell + colspan - 1) + (m.cssClass ? " " + m.cssClass : "");
        if (hasFrozenColumns() && cell <= options.frozenColumn) {
          cellCss += " frozen";
        }
        if (row2 === activeRow && cell === activeCell && options.showCellSelection) {
          cellCss += " active";
        }
        for (var key in cellCssClasses) {
          if (cellCssClasses[key][row2] && cellCssClasses[key][row2][m.id]) {
            cellCss += " " + cellCssClasses[key][row2][m.id];
          }
        }
        var value2 = null, formatterResult = "";
        if (item3) {
          value2 = getDataItemValueForColumn(item3, m);
          formatterResult = getFormatter(row2, m)(row2, cell, value2, m, item3, self);
          if (formatterResult === null || formatterResult === void 0) {
            formatterResult = "";
          }
        }
        var addlCssClasses = trigger(self.onBeforeAppendCell, { row: row2, cell, value: value2, dataContext: item3 }) || "";
        addlCssClasses += formatterResult && formatterResult.addClasses ? (addlCssClasses ? " " : "") + formatterResult.addClasses : "";
        var toolTip = formatterResult && formatterResult.toolTip ? "title='" + formatterResult.toolTip + "'" : "";
        var customAttrStr = "";
        if (m.hasOwnProperty("cellAttrs") && m.cellAttrs instanceof Object) {
          for (var key in m.cellAttrs) {
            if (m.cellAttrs.hasOwnProperty(key)) {
              customAttrStr += " " + key + '="' + m.cellAttrs[key] + '" ';
            }
          }
        }
        stringArray.push("<div class='" + cellCss + (addlCssClasses ? " " + addlCssClasses : "") + "' " + toolTip + customAttrStr + ">");
        if (item3) {
          stringArray.push(Object.prototype.toString.call(formatterResult) !== "[object Object]" ? formatterResult : formatterResult.text);
        }
        stringArray.push("</div>");
        rowsCache[row2].cellRenderQueue.push(cell);
        rowsCache[row2].cellColSpans[cell] = colspan;
      }
      function cleanupRows(rangeToKeep) {
        for (var i2 in rowsCache) {
          var removeFrozenRow = true;
          if (hasFrozenRows && (options.frozenBottom && i2 >= actualFrozenRow || !options.frozenBottom && i2 <= actualFrozenRow)) {
            removeFrozenRow = false;
          }
          if ((i2 = parseInt(i2, 10)) !== activeRow && (i2 < rangeToKeep.top || i2 > rangeToKeep.bottom) && removeFrozenRow) {
            removeRowFromCache(i2);
          }
        }
        if (options.enableAsyncPostRenderCleanup) {
          startPostProcessingCleanup();
        }
      }
      function invalidate() {
        updateRowCount();
        invalidateAllRows();
        render();
      }
      function invalidateAllRows() {
        if (currentEditor) {
          makeActiveCellNormal();
        }
        for (var row2 in rowsCache) {
          removeRowFromCache(row2);
        }
        if (options.enableAsyncPostRenderCleanup) {
          startPostProcessingCleanup();
        }
      }
      function queuePostProcessedRowForCleanup(cacheEntry, postProcessedRow, rowIdx) {
        postProcessgroupId++;
        for (var columnIdx in postProcessedRow) {
          if (postProcessedRow.hasOwnProperty(columnIdx)) {
            postProcessedCleanupQueue.push({
              actionType: "C",
              groupId: postProcessgroupId,
              node: cacheEntry.cellNodesByColumnIdx[columnIdx | 0],
              columnIdx: columnIdx | 0,
              rowIdx
            });
          }
        }
        postProcessedCleanupQueue.push({
          actionType: "R",
          groupId: postProcessgroupId,
          node: cacheEntry.rowNode
        });
        cacheEntry.rowNode.detach();
      }
      function queuePostProcessedCellForCleanup(cellnode, columnIdx, rowIdx) {
        postProcessedCleanupQueue.push({
          actionType: "C",
          groupId: postProcessgroupId,
          node: cellnode,
          columnIdx,
          rowIdx
        });
        $(cellnode).detach();
      }
      function removeRowFromCache(row2) {
        var cacheEntry = rowsCache[row2];
        if (!cacheEntry) {
          return;
        }
        if (options.enableAsyncPostRenderCleanup && postProcessedRows[row2]) {
          queuePostProcessedRowForCleanup(cacheEntry, postProcessedRows[row2], row2);
        } else {
          cacheEntry.rowNode.each(function() {
            this.parentElement.removeChild(this);
          });
        }
        delete rowsCache[row2];
        delete postProcessedRows[row2];
        renderedRows--;
        counter_rows_removed++;
      }
      function invalidateRows(rows) {
        var i2, rl;
        if (!rows || !rows.length) {
          return;
        }
        vScrollDir = 0;
        rl = rows.length;
        for (i2 = 0; i2 < rl; i2++) {
          if (currentEditor && activeRow === rows[i2]) {
            makeActiveCellNormal();
          }
          if (rowsCache[rows[i2]]) {
            removeRowFromCache(rows[i2]);
          }
        }
        if (options.enableAsyncPostRenderCleanup) {
          startPostProcessingCleanup();
        }
      }
      function invalidateRow(row2) {
        if (!row2 && row2 !== 0) {
          return;
        }
        invalidateRows([row2]);
      }
      function applyFormatResultToCellNode(formatterResult, cellNode, suppressRemove) {
        if (formatterResult === null || formatterResult === void 0) {
          formatterResult = "";
        }
        if (Object.prototype.toString.call(formatterResult) !== "[object Object]") {
          cellNode.innerHTML = formatterResult;
          return;
        }
        cellNode.innerHTML = formatterResult.text;
        if (formatterResult.removeClasses && !suppressRemove) {
          $(cellNode).removeClass(formatterResult.removeClasses);
        }
        if (formatterResult.addClasses) {
          $(cellNode).addClass(formatterResult.addClasses);
        }
        if (formatterResult.toolTip) {
          $(cellNode).attr("title", formatterResult.toolTip);
        }
      }
      function updateCell(row2, cell) {
        var cellNode = getCellNode(row2, cell);
        if (!cellNode) {
          return;
        }
        var m = columns[cell], d = getDataItem(row2);
        if (currentEditor && activeRow === row2 && activeCell === cell) {
          currentEditor.loadValue(d);
        } else {
          var formatterResult = d ? getFormatter(row2, m)(row2, cell, getDataItemValueForColumn(d, m), m, d, self) : "";
          applyFormatResultToCellNode(formatterResult, cellNode);
          invalidatePostProcessingResults(row2);
        }
      }
      function updateRow(row2) {
        var cacheEntry = rowsCache[row2];
        if (!cacheEntry) {
          return;
        }
        ensureCellNodesInRowsCache(row2);
        var formatterResult, d = getDataItem(row2);
        for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
          if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {
            continue;
          }
          columnIdx = columnIdx | 0;
          var m = columns[columnIdx], node = cacheEntry.cellNodesByColumnIdx[columnIdx][0];
          if (row2 === activeRow && columnIdx === activeCell && currentEditor) {
            currentEditor.loadValue(d);
          } else if (d) {
            formatterResult = getFormatter(row2, m)(row2, columnIdx, getDataItemValueForColumn(d, m), m, d, self);
            applyFormatResultToCellNode(formatterResult, node);
          } else {
            node.innerHTML = "";
          }
        }
        invalidatePostProcessingResults(row2);
      }
      function getViewportHeight() {
        if (!options.autoHeight || options.frozenColumn != -1) {
          topPanelH = options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0;
          headerRowH = options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0;
          footerRowH = options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0;
        }
        if (options.autoHeight) {
          var fullHeight = $paneHeaderL.outerHeight();
          fullHeight += options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0;
          fullHeight += options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0;
          fullHeight += getCanvasWidth() > viewportW ? scrollbarDimensions.height : 0;
          viewportH = options.rowHeight * getDataLengthIncludingAddNew() + (options.frozenColumn == -1 ? fullHeight : 0);
        } else {
          var columnNamesH = options.showColumnHeader ? parseFloat($.css($headerScroller[0], "height")) + getVBoxDelta($headerScroller) : 0;
          var preHeaderH = options.createPreHeaderPanel && options.showPreHeaderPanel ? options.preHeaderPanelHeight + getVBoxDelta($preHeaderPanelScroller) : 0;
          viewportH = parseFloat($.css($container[0], "height", true)) - parseFloat($.css($container[0], "paddingTop", true)) - parseFloat($.css($container[0], "paddingBottom", true)) - columnNamesH - topPanelH - headerRowH - footerRowH - preHeaderH;
        }
        numVisibleRows = Math.ceil(viewportH / options.rowHeight);
        return viewportH;
      }
      function getViewportWidth() {
        viewportW = parseFloat($container.width());
      }
      function resizeCanvas() {
        if (!initialized) {
          return;
        }
        paneTopH = 0;
        paneBottomH = 0;
        viewportTopH = 0;
        viewportBottomH = 0;
        getViewportWidth();
        getViewportHeight();
        if (hasFrozenRows) {
          if (options.frozenBottom) {
            paneTopH = viewportH - frozenRowsHeight - scrollbarDimensions.height;
            paneBottomH = frozenRowsHeight + scrollbarDimensions.height;
          } else {
            paneTopH = frozenRowsHeight;
            paneBottomH = viewportH - frozenRowsHeight;
          }
        } else {
          paneTopH = viewportH;
        }
        paneTopH += topPanelH + headerRowH + footerRowH;
        if (hasFrozenColumns() && options.autoHeight) {
          paneTopH += scrollbarDimensions.height;
        }
        viewportTopH = paneTopH - topPanelH - headerRowH - footerRowH;
        if (options.autoHeight) {
          if (hasFrozenColumns()) {
            $container.height(
              paneTopH + parseFloat($.css($headerScrollerL[0], "height"))
            );
          }
          $paneTopL.css("position", "relative");
        }
        $paneTopL.css({
          "top": $paneHeaderL.height() || (options.showHeaderRow ? options.headerRowHeight : 0) + (options.showPreHeaderPanel ? options.preHeaderPanelHeight : 0),
          "height": paneTopH
        });
        var paneBottomTop = $paneTopL.position().top + paneTopH;
        if (!options.autoHeight) {
          $viewportTopL.height(viewportTopH);
        }
        if (hasFrozenColumns()) {
          $paneTopR.css({
            "top": $paneHeaderL.height(),
            "height": paneTopH
          });
          $viewportTopR.height(viewportTopH);
          if (hasFrozenRows) {
            $paneBottomL.css({
              "top": paneBottomTop,
              "height": paneBottomH
            });
            $paneBottomR.css({
              "top": paneBottomTop,
              "height": paneBottomH
            });
            $viewportBottomR.height(paneBottomH);
          }
        } else {
          if (hasFrozenRows) {
            $paneBottomL.css({
              "width": "100%",
              "height": paneBottomH
            });
            $paneBottomL.css("top", paneBottomTop);
          }
        }
        if (hasFrozenRows) {
          $viewportBottomL.height(paneBottomH);
          if (options.frozenBottom) {
            $canvasBottomL.height(frozenRowsHeight);
            if (hasFrozenColumns()) {
              $canvasBottomR.height(frozenRowsHeight);
            }
          } else {
            $canvasTopL.height(frozenRowsHeight);
            if (hasFrozenColumns()) {
              $canvasTopR.height(frozenRowsHeight);
            }
          }
        } else {
          $viewportTopR.height(viewportTopH);
        }
        if (!scrollbarDimensions || !scrollbarDimensions.width) {
          scrollbarDimensions = measureScrollbar();
        }
        if (options.autosizeColsMode === Slick.GridAutosizeColsMode.LegacyForceFit) {
          autosizeColumns();
        }
        updateRowCount();
        handleScroll();
        lastRenderedScrollLeft = -1;
        render();
      }
      function updatePagingStatusFromView(pagingInfo) {
        pagingActive = pagingInfo.pageSize !== 0;
        pagingIsLastPage = pagingInfo.pageNum == pagingInfo.totalPages - 1;
      }
      function updateRowCount() {
        if (!initialized) {
          return;
        }
        var dataLength = getDataLength();
        var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
        var numberOfRows = 0;
        var oldH = hasFrozenRows && !options.frozenBottom ? $canvasBottomL.height() : $canvasTopL.height();
        if (hasFrozenRows) {
          var numberOfRows = getDataLength() - options.frozenRow;
        } else {
          var numberOfRows = dataLengthIncludingAddNew + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);
        }
        var tempViewportH = $viewportScrollContainerY.height();
        var oldViewportHasVScroll = viewportHasVScroll;
        viewportHasVScroll = options.alwaysShowVerticalScroll || !options.autoHeight && numberOfRows * options.rowHeight > tempViewportH;
        makeActiveCellNormal();
        var r1 = dataLength - 1;
        for (var i2 in rowsCache) {
          if (i2 > r1) {
            removeRowFromCache(i2);
          }
        }
        if (options.enableAsyncPostRenderCleanup) {
          startPostProcessingCleanup();
        }
        if (activeCellNode && activeRow > r1) {
          resetActiveCell();
        }
        var oldH = h;
        if (options.autoHeight) {
          h = options.rowHeight * numberOfRows;
        } else {
          th = Math.max(options.rowHeight * numberOfRows, tempViewportH - scrollbarDimensions.height);
          if (th < maxSupportedCssHeight) {
            h = ph = th;
            n = 1;
            cj = 0;
          } else {
            h = maxSupportedCssHeight;
            ph = h / 100;
            n = Math.floor(th / ph);
            cj = (th - h) / (n - 1);
          }
        }
        if (h !== oldH) {
          if (hasFrozenRows && !options.frozenBottom) {
            $canvasBottomL.css("height", h);
            if (hasFrozenColumns()) {
              $canvasBottomR.css("height", h);
            }
          } else {
            $canvasTopL.css("height", h);
            $canvasTopR.css("height", h);
          }
          scrollTop = $viewportScrollContainerY[0].scrollTop;
        }
        var oldScrollTopInRange = scrollTop + offset <= th - tempViewportH;
        if (th == 0 || scrollTop == 0) {
          page = offset = 0;
        } else if (oldScrollTopInRange) {
          scrollTo(scrollTop + offset);
        } else {
          scrollTo(th - tempViewportH);
        }
        if (h != oldH && options.autoHeight) {
          resizeCanvas();
        }
        if (options.autosizeColsMode === Slick.GridAutosizeColsMode.LegacyForceFit && oldViewportHasVScroll != viewportHasVScroll) {
          autosizeColumns();
        }
        updateCanvasWidth(false);
      }
      function getVisibleRange(viewportTop, viewportLeft) {
        if (viewportTop == null) {
          viewportTop = scrollTop;
        }
        if (viewportLeft == null) {
          viewportLeft = scrollLeft;
        }
        return {
          top: getRowFromPosition(viewportTop),
          bottom: getRowFromPosition(viewportTop + viewportH) + 1,
          leftPx: viewportLeft,
          rightPx: viewportLeft + viewportW
        };
      }
      function getRenderedRange(viewportTop, viewportLeft) {
        var range2 = getVisibleRange(viewportTop, viewportLeft);
        var buffer = Math.round(viewportH / options.rowHeight);
        var minBuffer = options.minRowBuffer;
        if (vScrollDir == -1) {
          range2.top -= buffer;
          range2.bottom += minBuffer;
        } else if (vScrollDir == 1) {
          range2.top -= minBuffer;
          range2.bottom += buffer;
        } else {
          range2.top -= minBuffer;
          range2.bottom += minBuffer;
        }
        range2.top = Math.max(0, range2.top);
        range2.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range2.bottom);
        range2.leftPx -= viewportW;
        range2.rightPx += viewportW;
        range2.leftPx = Math.max(0, range2.leftPx);
        range2.rightPx = Math.min(canvasWidth, range2.rightPx);
        return range2;
      }
      function ensureCellNodesInRowsCache(row2) {
        var cacheEntry = rowsCache[row2];
        if (cacheEntry) {
          if (cacheEntry.cellRenderQueue.length) {
            var $lastNode = cacheEntry.rowNode.children().last();
            while (cacheEntry.cellRenderQueue.length) {
              var columnIdx = cacheEntry.cellRenderQueue.pop();
              cacheEntry.cellNodesByColumnIdx[columnIdx] = $lastNode;
              $lastNode = $lastNode.prev();
              if ($lastNode.length === 0) {
                $lastNode = $(cacheEntry.rowNode[0]).children().last();
              }
            }
          }
        }
      }
      function cleanUpCells(range2, row2) {
        if (hasFrozenRows && (options.frozenBottom && row2 > actualFrozenRow || row2 <= actualFrozenRow)) {
          return;
        }
        var totalCellsRemoved = 0;
        var cacheEntry = rowsCache[row2];
        var cellsToRemove = [];
        for (var i2 in cacheEntry.cellNodesByColumnIdx) {
          if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i2)) {
            continue;
          }
          i2 = i2 | 0;
          if (i2 <= options.frozenColumn) {
            continue;
          }
          if (Array.isArray(columns) && columns[i2] && columns[i2].alwaysRenderColumn) {
            continue;
          }
          var colspan = cacheEntry.cellColSpans[i2];
          if (columnPosLeft[i2] > range2.rightPx || columnPosRight[Math.min(columns.length - 1, i2 + colspan - 1)] < range2.leftPx) {
            if (!(row2 == activeRow && i2 == activeCell)) {
              cellsToRemove.push(i2);
            }
          }
        }
        var cellToRemove, cellNode;
        while ((cellToRemove = cellsToRemove.pop()) != null) {
          cellNode = cacheEntry.cellNodesByColumnIdx[cellToRemove][0];
          if (options.enableAsyncPostRenderCleanup && postProcessedRows[row2] && postProcessedRows[row2][cellToRemove]) {
            queuePostProcessedCellForCleanup(cellNode, cellToRemove, row2);
          } else {
            cellNode.parentElement.removeChild(cellNode);
          }
          delete cacheEntry.cellColSpans[cellToRemove];
          delete cacheEntry.cellNodesByColumnIdx[cellToRemove];
          if (postProcessedRows[row2]) {
            delete postProcessedRows[row2][cellToRemove];
          }
          totalCellsRemoved++;
        }
      }
      function cleanUpAndRenderCells(range2) {
        var cacheEntry;
        var stringArray = [];
        var processedRows = [];
        var cellsAdded;
        var totalCellsAdded = 0;
        var colspan;
        for (var row2 = range2.top, btm = range2.bottom; row2 <= btm; row2++) {
          cacheEntry = rowsCache[row2];
          if (!cacheEntry) {
            continue;
          }
          ensureCellNodesInRowsCache(row2);
          cleanUpCells(range2, row2);
          cellsAdded = 0;
          var metadata = data.getItemMetadata && data.getItemMetadata(row2);
          metadata = metadata && metadata.columns;
          var d = getDataItem(row2);
          for (var i2 = 0, ii = columns.length; i2 < ii; i2++) {
            if (columnPosLeft[i2] > range2.rightPx) {
              break;
            }
            if ((colspan = cacheEntry.cellColSpans[i2]) != null) {
              i2 += colspan > 1 ? colspan - 1 : 0;
              continue;
            }
            colspan = 1;
            if (metadata) {
              var columnData = metadata[columns[i2].id] || metadata[i2];
              colspan = columnData && columnData.colspan || 1;
              if (colspan === "*") {
                colspan = ii - i2;
              }
            }
            if (columnPosRight[Math.min(ii - 1, i2 + colspan - 1)] > range2.leftPx) {
              appendCellHtml(stringArray, row2, i2, colspan, d);
              cellsAdded++;
            }
            i2 += colspan > 1 ? colspan - 1 : 0;
          }
          if (cellsAdded) {
            totalCellsAdded += cellsAdded;
            processedRows.push(row2);
          }
        }
        if (!stringArray.length) {
          return;
        }
        var x2 = document.createElement("div");
        x2.innerHTML = stringArray.join("");
        var processedRow;
        var node;
        while ((processedRow = processedRows.pop()) != null) {
          cacheEntry = rowsCache[processedRow];
          var columnIdx;
          while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {
            node = x2.lastChild;
            if (hasFrozenColumns() && columnIdx > options.frozenColumn) {
              cacheEntry.rowNode[1].appendChild(node);
            } else {
              cacheEntry.rowNode[0].appendChild(node);
            }
            cacheEntry.cellNodesByColumnIdx[columnIdx] = $(node);
          }
        }
      }
      function renderRows(range2) {
        var stringArrayL = [], stringArrayR = [], rows = [], needToReselectCell = false, dataLength = getDataLength();
        for (var i2 = range2.top, ii = range2.bottom; i2 <= ii; i2++) {
          if (rowsCache[i2] || hasFrozenRows && options.frozenBottom && i2 == getDataLength()) {
            continue;
          }
          renderedRows++;
          rows.push(i2);
          rowsCache[i2] = {
            "rowNode": null,
            // ColSpans of rendered cells (by column idx).
            // Can also be used for checking whether a cell has been rendered.
            "cellColSpans": [],
            // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().
            "cellNodesByColumnIdx": [],
            // Column indices of cell nodes that have been rendered, but not yet indexed in
            // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the
            // end of the row.
            "cellRenderQueue": []
          };
          appendRowHtml(stringArrayL, stringArrayR, i2, range2, dataLength);
          if (activeCellNode && activeRow === i2) {
            needToReselectCell = true;
          }
          counter_rows_rendered++;
        }
        if (!rows.length) {
          return;
        }
        var x2 = document.createElement("div"), xRight = document.createElement("div");
        x2.innerHTML = stringArrayL.join("");
        xRight.innerHTML = stringArrayR.join("");
        for (var i2 = 0, ii = rows.length; i2 < ii; i2++) {
          if (hasFrozenRows && rows[i2] >= actualFrozenRow) {
            if (hasFrozenColumns()) {
              rowsCache[rows[i2]].rowNode = $().add($(x2.firstChild)).add($(xRight.firstChild));
              $canvasBottomL[0].append(x2.firstChild);
              $canvasBottomR[0].append(xRight.firstChild);
            } else {
              rowsCache[rows[i2]].rowNode = $().add($(x2.firstChild));
              $canvasBottomL[0].append($(x2.firstChild));
            }
          } else if (hasFrozenColumns()) {
            rowsCache[rows[i2]].rowNode = $().add($(x2.firstChild)).add($(xRight.firstChild));
            $canvasTopL[0].append(x2.firstChild);
            $canvasTopR[0].append(xRight.firstChild);
          } else {
            rowsCache[rows[i2]].rowNode = $().add($(x2.firstChild));
            $canvasTopL[0].append(x2.firstChild);
          }
        }
        if (needToReselectCell) {
          activeCellNode = getCellNode(activeRow, activeCell);
        }
      }
      function startPostProcessing() {
        if (!options.enableAsyncPostRender) {
          return;
        }
        clearTimeout(h_postrender);
        h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
      }
      function startPostProcessingCleanup() {
        if (!options.enableAsyncPostRenderCleanup) {
          return;
        }
        clearTimeout(h_postrenderCleanup);
        h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);
      }
      function invalidatePostProcessingResults(row2) {
        for (var columnIdx in postProcessedRows[row2]) {
          if (postProcessedRows[row2].hasOwnProperty(columnIdx)) {
            postProcessedRows[row2][columnIdx] = "C";
          }
        }
        postProcessFromRow = Math.min(postProcessFromRow, row2);
        postProcessToRow = Math.max(postProcessToRow, row2);
        startPostProcessing();
      }
      function updateRowPositions() {
        for (var row2 in rowsCache) {
          var rowNumber = row2 ? parseInt(row2) : 0;
          rowsCache[rowNumber].rowNode[0].style.top = getRowTop(rowNumber) + "px";
        }
      }
      function render() {
        if (!initialized) {
          return;
        }
        scrollThrottle.dequeue();
        var visible = getVisibleRange();
        var rendered = getRenderedRange();
        cleanupRows(rendered);
        if (lastRenderedScrollLeft != scrollLeft) {
          if (hasFrozenRows) {
            var renderedFrozenRows = $.extend(true, {}, rendered);
            if (options.frozenBottom) {
              renderedFrozenRows.top = actualFrozenRow;
              renderedFrozenRows.bottom = getDataLength();
            } else {
              renderedFrozenRows.top = 0;
              renderedFrozenRows.bottom = options.frozenRow;
            }
            cleanUpAndRenderCells(renderedFrozenRows);
          }
          cleanUpAndRenderCells(rendered);
        }
        renderRows(rendered);
        if (hasFrozenRows) {
          if (options.frozenBottom) {
            renderRows({
              top: actualFrozenRow,
              bottom: getDataLength() - 1,
              leftPx: rendered.leftPx,
              rightPx: rendered.rightPx
            });
          } else {
            renderRows({
              top: 0,
              bottom: options.frozenRow - 1,
              leftPx: rendered.leftPx,
              rightPx: rendered.rightPx
            });
          }
        }
        postProcessFromRow = visible.top;
        postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);
        startPostProcessing();
        lastRenderedScrollTop = scrollTop;
        lastRenderedScrollLeft = scrollLeft;
        h_render = null;
        trigger(self.onRendered, { startRow: visible.top, endRow: visible.bottom, grid: self });
      }
      function handleHeaderScroll() {
        handleElementScroll($headerScrollContainer[0]);
      }
      function handleHeaderRowScroll() {
        var scrollLeft2 = $headerRowScrollContainer[0].scrollLeft;
        if (scrollLeft2 != $viewportScrollContainerX[0].scrollLeft) {
          $viewportScrollContainerX[0].scrollLeft = scrollLeft2;
        }
      }
      function handleFooterRowScroll() {
        var scrollLeft2 = $footerRowScrollContainer[0].scrollLeft;
        if (scrollLeft2 != $viewportScrollContainerX[0].scrollLeft) {
          $viewportScrollContainerX[0].scrollLeft = scrollLeft2;
        }
      }
      function handlePreHeaderPanelScroll() {
        handleElementScroll($preHeaderPanelScroller[0]);
      }
      function handleElementScroll(element) {
        var scrollLeft2 = element.scrollLeft;
        if (scrollLeft2 != $viewportScrollContainerX[0].scrollLeft) {
          $viewportScrollContainerX[0].scrollLeft = scrollLeft2;
        }
      }
      function handleScroll() {
        scrollTop = $viewportScrollContainerY[0].scrollTop;
        scrollLeft = $viewportScrollContainerX[0].scrollLeft;
        return _handleScroll(false);
      }
      function _handleScroll(isMouseWheel) {
        var maxScrollDistanceY = $viewportScrollContainerY[0].scrollHeight - $viewportScrollContainerY[0].clientHeight;
        var maxScrollDistanceX = $viewportScrollContainerY[0].scrollWidth - $viewportScrollContainerY[0].clientWidth;
        maxScrollDistanceY = Math.max(0, maxScrollDistanceY);
        maxScrollDistanceX = Math.max(0, maxScrollDistanceX);
        if (scrollTop > maxScrollDistanceY) {
          scrollTop = maxScrollDistanceY;
        }
        if (scrollLeft > maxScrollDistanceX) {
          scrollLeft = maxScrollDistanceX;
        }
        var vScrollDist = Math.abs(scrollTop - prevScrollTop);
        var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);
        if (hScrollDist) {
          prevScrollLeft = scrollLeft;
          $viewportScrollContainerX[0].scrollLeft = scrollLeft;
          $headerScrollContainer[0].scrollLeft = scrollLeft;
          $topPanelScroller[0].scrollLeft = scrollLeft;
          $headerRowScrollContainer[0].scrollLeft = scrollLeft;
          if (options.createFooterRow) {
            $footerRowScrollContainer[0].scrollLeft = scrollLeft;
          }
          if (options.createPreHeaderPanel) {
            if (hasFrozenColumns()) {
              $preHeaderPanelScrollerR[0].scrollLeft = scrollLeft;
            } else {
              $preHeaderPanelScroller[0].scrollLeft = scrollLeft;
            }
          }
          if (hasFrozenColumns()) {
            if (hasFrozenRows) {
              $viewportTopR[0].scrollLeft = scrollLeft;
            }
          } else {
            if (hasFrozenRows) {
              $viewportTopL[0].scrollLeft = scrollLeft;
            }
          }
        }
        if (vScrollDist) {
          vScrollDir = prevScrollTop < scrollTop ? 1 : -1;
          prevScrollTop = scrollTop;
          if (isMouseWheel) {
            $viewportScrollContainerY[0].scrollTop = scrollTop;
          }
          if (hasFrozenColumns()) {
            if (hasFrozenRows && !options.frozenBottom) {
              $viewportBottomL[0].scrollTop = scrollTop;
            } else {
              $viewportTopL[0].scrollTop = scrollTop;
            }
          }
          if (vScrollDist < viewportH) {
            scrollTo(scrollTop + offset);
          } else {
            var oldOffset = offset;
            if (h == viewportH) {
              page = 0;
            } else {
              page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));
            }
            offset = Math.round(page * cj);
            if (oldOffset != offset) {
              invalidateAllRows();
            }
          }
        }
        if (hScrollDist || vScrollDist) {
          var dx = Math.abs(lastRenderedScrollLeft - scrollLeft);
          var dy = Math.abs(lastRenderedScrollTop - scrollTop);
          if (dx > 20 || dy > 20) {
            if (options.forceSyncScrolling || dy < viewportH && dx < viewportW) {
              render();
            } else {
              scrollThrottle.enqueue();
            }
            trigger(self.onViewportChanged, {});
          }
        }
        trigger(self.onScroll, { scrollLeft, scrollTop });
        if (hScrollDist || vScrollDist) return true;
        return false;
      }
      function ActionThrottle(action, minPeriod_ms) {
        var blocked = false;
        var queued = false;
        function enqueue() {
          if (!blocked) {
            blockAndExecute();
          } else {
            queued = true;
          }
        }
        function dequeue() {
          queued = false;
        }
        function blockAndExecute() {
          blocked = true;
          setTimeout(unblock, minPeriod_ms);
          action();
        }
        function unblock() {
          if (queued) {
            dequeue();
            blockAndExecute();
          } else {
            blocked = false;
          }
        }
        return {
          enqueue,
          dequeue
        };
      }
      function asyncPostProcessRows() {
        var dataLength = getDataLength();
        while (postProcessFromRow <= postProcessToRow) {
          var row2 = vScrollDir >= 0 ? postProcessFromRow++ : postProcessToRow--;
          var cacheEntry = rowsCache[row2];
          if (!cacheEntry || row2 >= dataLength) {
            continue;
          }
          if (!postProcessedRows[row2]) {
            postProcessedRows[row2] = {};
          }
          ensureCellNodesInRowsCache(row2);
          for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
            if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {
              continue;
            }
            columnIdx = columnIdx | 0;
            var m = columns[columnIdx];
            var processedStatus = postProcessedRows[row2][columnIdx];
            if (m.asyncPostRender && processedStatus !== "R") {
              var node = cacheEntry.cellNodesByColumnIdx[columnIdx];
              if (node) {
                m.asyncPostRender(node, row2, getDataItem(row2), m, processedStatus === "C");
              }
              postProcessedRows[row2][columnIdx] = "R";
            }
          }
          h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
          return;
        }
      }
      function asyncPostProcessCleanupRows() {
        if (postProcessedCleanupQueue.length > 0) {
          var groupId = postProcessedCleanupQueue[0].groupId;
          while (postProcessedCleanupQueue.length > 0 && postProcessedCleanupQueue[0].groupId == groupId) {
            var entry2 = postProcessedCleanupQueue.shift();
            if (entry2.actionType == "R") {
              $(entry2.node).remove();
            }
            if (entry2.actionType == "C") {
              var column = columns[entry2.columnIdx];
              if (column.asyncPostRenderCleanup && entry2.node) {
                column.asyncPostRenderCleanup(entry2.node, entry2.rowIdx, column);
              }
            }
          }
          h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);
        }
      }
      function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {
        var node, columnId, addedRowHash, removedRowHash;
        for (var row2 in rowsCache) {
          removedRowHash = removedHash && removedHash[row2];
          addedRowHash = addedHash && addedHash[row2];
          if (removedRowHash) {
            for (columnId in removedRowHash) {
              if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
                node = getCellNode(row2, getColumnIndex(columnId));
                if (node) {
                  $(node).removeClass(removedRowHash[columnId]);
                }
              }
            }
          }
          if (addedRowHash) {
            for (columnId in addedRowHash) {
              if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
                node = getCellNode(row2, getColumnIndex(columnId));
                if (node) {
                  $(node).addClass(addedRowHash[columnId]);
                }
              }
            }
          }
        }
      }
      function addCellCssStyles(key, hash) {
        if (cellCssClasses[key]) {
          throw new Error("SlickGrid addCellCssStyles: cell CSS hash with key '" + key + "' already exists.");
        }
        cellCssClasses[key] = hash;
        updateCellCssStylesOnRenderedRows(hash, null);
        trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash, "grid": self });
      }
      function removeCellCssStyles(key) {
        if (!cellCssClasses[key]) {
          return;
        }
        updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);
        delete cellCssClasses[key];
        trigger(self.onCellCssStylesChanged, { "key": key, "hash": null, "grid": self });
      }
      function setCellCssStyles(key, hash) {
        var prevHash = cellCssClasses[key];
        cellCssClasses[key] = hash;
        updateCellCssStylesOnRenderedRows(hash, prevHash);
        trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash, "grid": self });
      }
      function getCellCssStyles(key) {
        return cellCssClasses[key];
      }
      function flashCell(row2, cell, speed) {
        speed = speed || 100;
        function toggleCellClass($cell2, times) {
          if (!times) {
            return;
          }
          setTimeout(function() {
            $cell2.queue(function() {
              $cell2.toggleClass(options.cellFlashingCssClass).dequeue();
              toggleCellClass($cell2, times - 1);
            });
          }, speed);
        }
        if (rowsCache[row2]) {
          var $cell = $(getCellNode(row2, cell));
          toggleCellClass($cell, 4);
        }
      }
      function handleMouseWheel(e, delta, deltaX, deltaY) {
        scrollTop = Math.max(0, $viewportScrollContainerY[0].scrollTop - deltaY * options.rowHeight);
        scrollLeft = $viewportScrollContainerX[0].scrollLeft + deltaX * 10;
        var handled = _handleScroll(true);
        if (handled) e.preventDefault();
      }
      function handleDragInit(e, dd2) {
        var cell = getCellFromEvent(e);
        if (!cell || !cellExists(cell.row, cell.cell)) {
          return false;
        }
        var retval = trigger(self.onDragInit, dd2, e);
        if (e.isImmediatePropagationStopped()) {
          return retval;
        }
        return false;
      }
      function handleDragStart(e, dd2) {
        var cell = getCellFromEvent(e);
        if (!cell || !cellExists(cell.row, cell.cell)) {
          return false;
        }
        var retval = trigger(self.onDragStart, dd2, e);
        if (e.isImmediatePropagationStopped()) {
          return retval;
        }
        return false;
      }
      function handleDrag(e, dd2) {
        return trigger(self.onDrag, dd2, e);
      }
      function handleDragEnd(e, dd2) {
        trigger(self.onDragEnd, dd2, e);
      }
      function handleKeyDown(e) {
        trigger(self.onKeyDown, { row: activeRow, cell: activeCell }, e);
        var handled = e.isImmediatePropagationStopped();
        var keyCode = Slick.keyCode;
        if (!handled) {
          if (!e.shiftKey && !e.altKey) {
            if (options.editable && currentEditor && currentEditor.keyCaptureList) {
              if (currentEditor.keyCaptureList.indexOf(e.which) > -1) {
                return;
              }
            }
            if (e.which == keyCode.HOME) {
              handled = e.ctrlKey ? navigateTop() : navigateRowStart();
            } else if (e.which == keyCode.END) {
              handled = e.ctrlKey ? navigateBottom() : navigateRowEnd();
            }
          }
        }
        if (!handled) {
          if (!e.shiftKey && !e.altKey && !e.ctrlKey) {
            if (options.editable && currentEditor && currentEditor.keyCaptureList) {
              if (currentEditor.keyCaptureList.indexOf(e.which) > -1) {
                return;
              }
            }
            if (e.which == keyCode.ESCAPE) {
              if (!getEditorLock().isActive()) {
                return;
              }
              cancelEditAndSetFocus();
            } else if (e.which == keyCode.PAGE_DOWN) {
              navigatePageDown();
              handled = true;
            } else if (e.which == keyCode.PAGE_UP) {
              navigatePageUp();
              handled = true;
            } else if (e.which == keyCode.LEFT) {
              handled = navigateLeft();
            } else if (e.which == keyCode.RIGHT) {
              handled = navigateRight();
            } else if (e.which == keyCode.UP) {
              handled = navigateUp();
            } else if (e.which == keyCode.DOWN) {
              handled = navigateDown();
            } else if (e.which == keyCode.TAB) {
              handled = navigateNext();
            } else if (e.which == keyCode.ENTER) {
              if (options.editable) {
                if (currentEditor) {
                  if (activeRow === getDataLength()) {
                    navigateDown();
                  } else {
                    commitEditAndSetFocus();
                  }
                } else {
                  if (getEditorLock().commitCurrentEdit()) {
                    makeActiveCellEditable(void 0, void 0, e);
                  }
                }
              }
              handled = true;
            }
          } else if (e.which == keyCode.TAB && e.shiftKey && !e.ctrlKey && !e.altKey) {
            handled = navigatePrev();
          }
        }
        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          try {
            e.originalEvent.keyCode = 0;
          } catch (error) {
          }
        }
      }
      function handleClick(e) {
        if (!currentEditor) {
          if (e.target != document.activeElement || $(e.target).hasClass("slick-cell")) {
            var selection = getTextSelection();
            setFocus();
            setTextSelection(selection);
          }
        }
        var cell = getCellFromEvent(e);
        if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {
          return;
        }
        trigger(self.onClick, { row: cell.row, cell: cell.cell }, e);
        if (e.isImmediatePropagationStopped()) {
          return;
        }
        if (canCellBeActive(cell.row, cell.cell)) {
          if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {
            scrollRowIntoView(cell.row, false);
            var preClickModeOn = e.target && e.target.className === Slick.preClickClassName;
            var column = columns[cell.cell];
            var suppressActiveCellChangedEvent = !!(options.editable && column && column.editor && options.suppressActiveCellChangeOnEdit);
            setActiveCellInternal(getCellNode(cell.row, cell.cell), null, preClickModeOn, suppressActiveCellChangedEvent, e);
          }
        }
      }
      function handleContextMenu(e) {
        var $cell = $(e.target).closest(".slick-cell", $canvas);
        if ($cell.length === 0) {
          return;
        }
        if (activeCellNode === $cell[0] && currentEditor !== null) {
          return;
        }
        trigger(self.onContextMenu, {}, e);
      }
      function handleDblClick(e) {
        var cell = getCellFromEvent(e);
        if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {
          return;
        }
        trigger(self.onDblClick, { row: cell.row, cell: cell.cell }, e);
        if (e.isImmediatePropagationStopped()) {
          return;
        }
        if (options.editable) {
          gotoCell(cell.row, cell.cell, true, e);
        }
      }
      function handleHeaderMouseEnter(e) {
        trigger(self.onHeaderMouseEnter, {
          "column": $(this).data("column"),
          "grid": self
        }, e);
      }
      function handleHeaderMouseLeave(e) {
        trigger(self.onHeaderMouseLeave, {
          "column": $(this).data("column"),
          "grid": self
        }, e);
      }
      function handleHeaderContextMenu(e) {
        var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
        var column = $header && $header.data("column");
        trigger(self.onHeaderContextMenu, { column }, e);
      }
      function handleHeaderClick(e) {
        if (columnResizeDragging) return;
        var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
        var column = $header && $header.data("column");
        if (column) {
          trigger(self.onHeaderClick, { column }, e);
        }
      }
      function handleFooterContextMenu(e) {
        var $footer = $(e.target).closest(".slick-footerrow-column", ".slick-footerrow-columns");
        var column = $footer && $footer.data("column");
        trigger(self.onFooterContextMenu, { column }, e);
      }
      function handleFooterClick(e) {
        var $footer = $(e.target).closest(".slick-footerrow-column", ".slick-footerrow-columns");
        var column = $footer && $footer.data("column");
        trigger(self.onFooterClick, { column }, e);
      }
      function handleMouseEnter(e) {
        trigger(self.onMouseEnter, {}, e);
      }
      function handleMouseLeave(e) {
        trigger(self.onMouseLeave, {}, e);
      }
      function cellExists(row2, cell) {
        return !(row2 < 0 || row2 >= getDataLength() || cell < 0 || cell >= columns.length);
      }
      function getCellFromPoint(x2, y2) {
        var row2 = getRowFromPosition(y2);
        var cell = 0;
        var w = 0;
        for (var i2 = 0; i2 < columns.length && w < x2; i2++) {
          w += columns[i2].width;
          cell++;
        }
        if (cell < 0) {
          cell = 0;
        }
        return { row: row2, cell: cell - 1 };
      }
      function getCellFromNode(cellNode) {
        var cls = /l\d+/.exec(cellNode.className);
        if (!cls) {
          throw new Error("SlickGrid getCellFromNode: cannot get cell - " + cellNode.className);
        }
        return parseInt(cls[0].substr(1, cls[0].length - 1), 10);
      }
      function getRowFromNode(rowNode) {
        for (var row2 in rowsCache) {
          for (var i2 in rowsCache[row2].rowNode) {
            if (rowsCache[row2].rowNode[i2] === rowNode)
              return row2 ? parseInt(row2) : 0;
          }
        }
        return null;
      }
      function getFrozenRowOffset(row2) {
        var offset3 = hasFrozenRows ? options.frozenBottom ? row2 >= actualFrozenRow ? h < viewportTopH ? actualFrozenRow * options.rowHeight : h : 0 : row2 >= actualFrozenRow ? frozenRowsHeight : 0 : 0;
        return offset3;
      }
      function getCellFromEvent(e) {
        var row2, cell;
        var $cell = $(e.target).closest(".slick-cell", $canvas);
        if (!$cell.length) {
          return null;
        }
        row2 = getRowFromNode($cell[0].parentNode);
        if (hasFrozenRows) {
          var c = $cell.parents(".grid-canvas").offset();
          var rowOffset = 0;
          var isBottom = $cell.parents(".grid-canvas-bottom").length;
          if (isBottom) {
            rowOffset = options.frozenBottom ? $canvasTopL.height() : frozenRowsHeight;
          }
          row2 = getCellFromPoint(e.clientX - c.left, e.clientY - c.top + rowOffset + $(document).scrollTop()).row;
        }
        cell = getCellFromNode($cell[0]);
        if (row2 == null || cell == null) {
          return null;
        } else {
          return {
            "row": row2,
            "cell": cell
          };
        }
      }
      function getCellNodeBox(row2, cell) {
        if (!cellExists(row2, cell)) {
          return null;
        }
        var frozenRowOffset = getFrozenRowOffset(row2);
        var y1 = getRowTop(row2) - frozenRowOffset;
        var y2 = y1 + options.rowHeight - 1;
        var x1 = 0;
        for (var i2 = 0; i2 < cell; i2++) {
          x1 += columns[i2].width;
          if (options.frozenColumn == i2) {
            x1 = 0;
          }
        }
        var x2 = x1 + columns[cell].width;
        return {
          top: y1,
          left: x1,
          bottom: y2,
          right: x2
        };
      }
      function resetActiveCell() {
        setActiveCellInternal(null, false);
      }
      function setFocus() {
        if (tabbingDirection == -1) {
          $focusSink[0].focus();
        } else {
          $focusSink2[0].focus();
        }
      }
      function scrollCellIntoView(row2, cell, doPaging) {
        scrollRowIntoView(row2, doPaging);
        if (cell <= options.frozenColumn) {
          return;
        }
        var colspan = getColspan(row2, cell);
        internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)]);
      }
      function internalScrollColumnIntoView(left2, right3) {
        var scrollRight = scrollLeft + $viewportScrollContainerX.width();
        if (left2 < scrollLeft) {
          $viewportScrollContainerX.scrollLeft(left2);
          handleScroll();
          render();
        } else if (right3 > scrollRight) {
          $viewportScrollContainerX.scrollLeft(Math.min(left2, right3 - $viewportScrollContainerX[0].clientWidth));
          handleScroll();
          render();
        }
      }
      function scrollColumnIntoView(cell) {
        internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell]);
      }
      function setActiveCellInternal(newCell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent, e) {
        if (activeCellNode !== null) {
          makeActiveCellNormal();
          $(activeCellNode).removeClass("active");
          if (rowsCache[activeRow]) {
            rowsCache[activeRow].rowNode.removeClass("active");
          }
        }
        var activeCellChanged = activeCellNode !== newCell;
        activeCellNode = newCell;
        if (activeCellNode != null) {
          var $activeCellNode = $(activeCellNode);
          var $activeCellOffset = $activeCellNode.offset();
          var rowOffset = Math.floor($activeCellNode.parents(".grid-canvas").offset().top);
          var isBottom = $activeCellNode.parents(".grid-canvas-bottom").length;
          if (hasFrozenRows && isBottom) {
            rowOffset -= options.frozenBottom ? $canvasTopL.height() : frozenRowsHeight;
          }
          var cell = getCellFromPoint($activeCellOffset.left, Math.ceil($activeCellOffset.top) - rowOffset);
          activeRow = cell.row;
          activeCell = activePosX = activeCell = activePosX = getCellFromNode(activeCellNode);
          if (opt_editMode == null) {
            opt_editMode = activeRow == getDataLength() || options.autoEdit;
          }
          if (options.showCellSelection) {
            $activeCellNode.addClass("active");
            if (rowsCache[activeRow]) {
              rowsCache[activeRow].rowNode.addClass("active");
            }
          }
          if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {
            clearTimeout(h_editorLoader);
            if (options.asyncEditorLoading) {
              h_editorLoader = setTimeout(function() {
                makeActiveCellEditable(void 0, preClickModeOn, e);
              }, options.asyncEditorLoadDelay);
            } else {
              makeActiveCellEditable(void 0, preClickModeOn, e);
            }
          }
        } else {
          activeRow = activeCell = null;
        }
        if (!suppressActiveCellChangedEvent) {
          trigger(self.onActiveCellChanged, getActiveCell());
        }
      }
      function clearTextSelection() {
        if (document.selection && document.selection.empty) {
          try {
            document.selection.empty();
          } catch (e) {
          }
        } else if (window.getSelection) {
          var sel = window.getSelection();
          if (sel && sel.removeAllRanges) {
            sel.removeAllRanges();
          }
        }
      }
      function isCellPotentiallyEditable(row2, cell) {
        var dataLength = getDataLength();
        if (row2 < dataLength && !getDataItem(row2)) {
          return false;
        }
        if (columns[cell].cannotTriggerInsert && row2 >= dataLength) {
          return false;
        }
        if (!getEditor(row2, cell)) {
          return false;
        }
        return true;
      }
      function makeActiveCellNormal() {
        if (!currentEditor) {
          return;
        }
        trigger(self.onBeforeCellEditorDestroy, { editor: currentEditor });
        currentEditor.destroy();
        currentEditor = null;
        if (activeCellNode) {
          var d = getDataItem(activeRow);
          $(activeCellNode).removeClass("editable invalid");
          if (d) {
            var column = columns[activeCell];
            var formatter = getFormatter(activeRow, column);
            var formatterResult = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d, self);
            applyFormatResultToCellNode(formatterResult, activeCellNode);
            invalidatePostProcessingResults(activeRow);
          }
        }
        if (navigator.userAgent.toLowerCase().match(/msie/)) {
          clearTextSelection();
        }
        getEditorLock().deactivate(editController);
      }
      function makeActiveCellEditable(editor, preClickModeOn, e) {
        if (!activeCellNode) {
          return;
        }
        if (!options.editable) {
          throw new Error("SlickGrid makeActiveCellEditable : should never get called when options.editable is false");
        }
        clearTimeout(h_editorLoader);
        if (!isCellPotentiallyEditable(activeRow, activeCell)) {
          return;
        }
        var columnDef = columns[activeCell];
        var item3 = getDataItem(activeRow);
        if (trigger(self.onBeforeEditCell, { row: activeRow, cell: activeCell, item: item3, column: columnDef, target: "grid" }) === false) {
          setFocus();
          return;
        }
        getEditorLock().activate(editController);
        $(activeCellNode).addClass("editable");
        var useEditor = editor || getEditor(activeRow, activeCell);
        if (!editor && !useEditor.suppressClearOnEdit) {
          activeCellNode.innerHTML = "";
        }
        var metadata = data.getItemMetadata && data.getItemMetadata(activeRow);
        metadata = metadata && metadata.columns;
        var columnMetaData = metadata && (metadata[columnDef.id] || metadata[activeCell]);
        currentEditor = new useEditor({
          grid: self,
          gridPosition: absBox($container[0]),
          position: absBox(activeCellNode),
          container: activeCellNode,
          column: columnDef,
          columnMetaData,
          item: item3 || {},
          event: e,
          commitChanges: commitEditAndSetFocus,
          cancelChanges: cancelEditAndSetFocus
        });
        if (item3) {
          currentEditor.loadValue(item3);
          if (preClickModeOn && currentEditor.preClick) {
            currentEditor.preClick();
          }
        }
        serializedEditorValue = currentEditor.serializeValue();
        if (currentEditor.position) {
          handleActiveCellPositionChange();
        }
      }
      function commitEditAndSetFocus() {
        if (getEditorLock().commitCurrentEdit()) {
          setFocus();
          if (options.autoEdit) {
            navigateDown();
          }
        }
      }
      function cancelEditAndSetFocus() {
        if (getEditorLock().cancelCurrentEdit()) {
          setFocus();
        }
      }
      function absBox(elem) {
        var box = {
          top: elem.offsetTop,
          left: elem.offsetLeft,
          bottom: 0,
          right: 0,
          width: $(elem).outerWidth(),
          height: $(elem).outerHeight(),
          visible: true
        };
        box.bottom = box.top + box.height;
        box.right = box.left + box.width;
        var offsetParent = elem.offsetParent;
        while ((elem = elem.parentNode) != document.body) {
          if (elem == null) break;
          if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css("overflowY") != "visible") {
            box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;
          }
          if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css("overflowX") != "visible") {
            box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;
          }
          box.left -= elem.scrollLeft;
          box.top -= elem.scrollTop;
          if (elem === offsetParent) {
            box.left += elem.offsetLeft;
            box.top += elem.offsetTop;
            offsetParent = elem.offsetParent;
          }
          box.bottom = box.top + box.height;
          box.right = box.left + box.width;
        }
        return box;
      }
      function getActiveCellPosition() {
        return absBox(activeCellNode);
      }
      function getGridPosition() {
        return absBox($container[0]);
      }
      function handleActiveCellPositionChange() {
        if (!activeCellNode) {
          return;
        }
        trigger(self.onActiveCellPositionChanged, {});
        if (currentEditor) {
          var cellBox = getActiveCellPosition();
          if (currentEditor.show && currentEditor.hide) {
            if (!cellBox.visible) {
              currentEditor.hide();
            } else {
              currentEditor.show();
            }
          }
          if (currentEditor.position) {
            currentEditor.position(cellBox);
          }
        }
      }
      function getCellEditor() {
        return currentEditor;
      }
      function getActiveCell() {
        if (!activeCellNode) {
          return null;
        } else {
          return { row: activeRow, cell: activeCell };
        }
      }
      function getActiveCellNode() {
        return activeCellNode;
      }
      function getTextSelection() {
        var textSelection = null;
        if (window.getSelection) {
          var selection = window.getSelection();
          if (selection.rangeCount > 0) {
            textSelection = selection.getRangeAt(0);
          }
        }
        return textSelection;
      }
      function setTextSelection(selection) {
        if (window.getSelection && selection) {
          var target = window.getSelection();
          target.removeAllRanges();
          target.addRange(selection);
        }
      }
      function scrollRowIntoView(row2, doPaging) {
        if (!hasFrozenRows || !options.frozenBottom && row2 > actualFrozenRow - 1 || options.frozenBottom && row2 < actualFrozenRow - 1) {
          var viewportScrollH = $viewportScrollContainerY.height();
          var rowNumber = hasFrozenRows && !options.frozenBottom ? row2 - options.frozenRow : row2;
          var rowAtTop = rowNumber * options.rowHeight;
          var rowAtBottom = (rowNumber + 1) * options.rowHeight - viewportScrollH + (viewportHasHScroll ? scrollbarDimensions.height : 0);
          if ((rowNumber + 1) * options.rowHeight > scrollTop + viewportScrollH + offset) {
            scrollTo(doPaging ? rowAtTop : rowAtBottom);
            render();
          } else if (rowNumber * options.rowHeight < scrollTop + offset) {
            scrollTo(doPaging ? rowAtBottom : rowAtTop);
            render();
          }
        }
      }
      function scrollRowToTop(row2) {
        scrollTo(row2 * options.rowHeight);
        render();
      }
      function scrollPage(dir) {
        var deltaRows = dir * numVisibleRows;
        var bottomOfTopmostFullyVisibleRow = scrollTop + options.rowHeight - 1;
        scrollTo((getRowFromPosition(bottomOfTopmostFullyVisibleRow) + deltaRows) * options.rowHeight);
        render();
        if (options.enableCellNavigation && activeRow != null) {
          var row2 = activeRow + deltaRows;
          var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
          if (row2 >= dataLengthIncludingAddNew) {
            row2 = dataLengthIncludingAddNew - 1;
          }
          if (row2 < 0) {
            row2 = 0;
          }
          var cell = 0, prevCell = null;
          var prevActivePosX = activePosX;
          while (cell <= activePosX) {
            if (canCellBeActive(row2, cell)) {
              prevCell = cell;
            }
            cell += getColspan(row2, cell);
          }
          if (prevCell !== null) {
            setActiveCellInternal(getCellNode(row2, prevCell));
            activePosX = prevActivePosX;
          } else {
            resetActiveCell();
          }
        }
      }
      function navigatePageDown() {
        scrollPage(1);
      }
      function navigatePageUp() {
        scrollPage(-1);
      }
      function navigateTop() {
        navigateToRow(0);
      }
      function navigateBottom() {
        navigateToRow(getDataLength() - 1);
      }
      function navigateToRow(row2) {
        var num_rows = getDataLength();
        if (!num_rows) return true;
        if (row2 < 0) row2 = 0;
        else if (row2 >= num_rows) row2 = num_rows - 1;
        scrollCellIntoView(row2, 0, true);
        if (options.enableCellNavigation && activeRow != null) {
          var cell = 0, prevCell = null;
          var prevActivePosX = activePosX;
          while (cell <= activePosX) {
            if (canCellBeActive(row2, cell)) {
              prevCell = cell;
            }
            cell += getColspan(row2, cell);
          }
          if (prevCell !== null) {
            setActiveCellInternal(getCellNode(row2, prevCell));
            activePosX = prevActivePosX;
          } else {
            resetActiveCell();
          }
        }
        return true;
      }
      function getColspan(row2, cell) {
        var metadata = data.getItemMetadata && data.getItemMetadata(row2);
        if (!metadata || !metadata.columns) {
          return 1;
        }
        var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];
        var colspan = columnData && columnData.colspan;
        if (colspan === "*") {
          colspan = columns.length - cell;
        } else {
          colspan = colspan || 1;
        }
        return colspan;
      }
      function findFirstFocusableCell(row2) {
        var cell = 0;
        while (cell < columns.length) {
          if (canCellBeActive(row2, cell)) {
            return cell;
          }
          cell += getColspan(row2, cell);
        }
        return null;
      }
      function findLastFocusableCell(row2) {
        var cell = 0;
        var lastFocusableCell = null;
        while (cell < columns.length) {
          if (canCellBeActive(row2, cell)) {
            lastFocusableCell = cell;
          }
          cell += getColspan(row2, cell);
        }
        return lastFocusableCell;
      }
      function gotoRight(row2, cell, posX) {
        if (cell >= columns.length) {
          return null;
        }
        do {
          cell += getColspan(row2, cell);
        } while (cell < columns.length && !canCellBeActive(row2, cell));
        if (cell < columns.length) {
          return {
            "row": row2,
            "cell": cell,
            "posX": cell
          };
        }
        return null;
      }
      function gotoLeft(row2, cell, posX) {
        if (cell <= 0) {
          return null;
        }
        var firstFocusableCell = findFirstFocusableCell(row2);
        if (firstFocusableCell === null || firstFocusableCell >= cell) {
          return null;
        }
        var prev = {
          "row": row2,
          "cell": firstFocusableCell,
          "posX": firstFocusableCell
        };
        var pos;
        while (true) {
          pos = gotoRight(prev.row, prev.cell, prev.posX);
          if (!pos) {
            return null;
          }
          if (pos.cell >= cell) {
            return prev;
          }
          prev = pos;
        }
      }
      function gotoDown(row2, cell, posX) {
        var prevCell;
        var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
        while (true) {
          if (++row2 >= dataLengthIncludingAddNew) {
            return null;
          }
          prevCell = cell = 0;
          while (cell <= posX) {
            prevCell = cell;
            cell += getColspan(row2, cell);
          }
          if (canCellBeActive(row2, prevCell)) {
            return {
              "row": row2,
              "cell": prevCell,
              "posX": posX
            };
          }
        }
      }
      function gotoUp(row2, cell, posX) {
        var prevCell;
        while (true) {
          if (--row2 < 0) {
            return null;
          }
          prevCell = cell = 0;
          while (cell <= posX) {
            prevCell = cell;
            cell += getColspan(row2, cell);
          }
          if (canCellBeActive(row2, prevCell)) {
            return {
              "row": row2,
              "cell": prevCell,
              "posX": posX
            };
          }
        }
      }
      function gotoNext(row2, cell, posX) {
        if (row2 == null && cell == null) {
          row2 = cell = posX = 0;
          if (canCellBeActive(row2, cell)) {
            return {
              "row": row2,
              "cell": cell,
              "posX": cell
            };
          }
        }
        var pos = gotoRight(row2, cell, posX);
        if (pos) {
          return pos;
        }
        var firstFocusableCell = null;
        var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();
        if (row2 === dataLengthIncludingAddNew - 1) {
          row2--;
        }
        while (++row2 < dataLengthIncludingAddNew) {
          firstFocusableCell = findFirstFocusableCell(row2);
          if (firstFocusableCell !== null) {
            return {
              "row": row2,
              "cell": firstFocusableCell,
              "posX": firstFocusableCell
            };
          }
        }
        return null;
      }
      function gotoPrev(row2, cell, posX) {
        if (row2 == null && cell == null) {
          row2 = getDataLengthIncludingAddNew() - 1;
          cell = posX = columns.length - 1;
          if (canCellBeActive(row2, cell)) {
            return {
              "row": row2,
              "cell": cell,
              "posX": cell
            };
          }
        }
        var pos;
        var lastSelectableCell;
        while (!pos) {
          pos = gotoLeft(row2, cell, posX);
          if (pos) {
            break;
          }
          if (--row2 < 0) {
            return null;
          }
          cell = 0;
          lastSelectableCell = findLastFocusableCell(row2);
          if (lastSelectableCell !== null) {
            pos = {
              "row": row2,
              "cell": lastSelectableCell,
              "posX": lastSelectableCell
            };
          }
        }
        return pos;
      }
      function gotoRowStart(row2, cell, posX) {
        var newCell = findFirstFocusableCell(row2);
        if (newCell === null) return null;
        return {
          "row": row2,
          "cell": newCell,
          "posX": newCell
        };
      }
      function gotoRowEnd(row2, cell, posX) {
        var newCell = findLastFocusableCell(row2);
        if (newCell === null) return null;
        return {
          "row": row2,
          "cell": newCell,
          "posX": newCell
        };
      }
      function navigateRight() {
        return navigate("right");
      }
      function navigateLeft() {
        return navigate("left");
      }
      function navigateDown() {
        return navigate("down");
      }
      function navigateUp() {
        return navigate("up");
      }
      function navigateNext() {
        return navigate("next");
      }
      function navigatePrev() {
        return navigate("prev");
      }
      function navigateRowStart() {
        return navigate("home");
      }
      function navigateRowEnd() {
        return navigate("end");
      }
      function navigate(dir) {
        if (!options.enableCellNavigation) {
          return false;
        }
        if (!activeCellNode && dir != "prev" && dir != "next") {
          return false;
        }
        if (!getEditorLock().commitCurrentEdit()) {
          return true;
        }
        setFocus();
        var tabbingDirections = {
          "up": -1,
          "down": 1,
          "left": -1,
          "right": 1,
          "prev": -1,
          "next": 1,
          "home": -1,
          "end": 1
        };
        tabbingDirection = tabbingDirections[dir];
        var stepFunctions = {
          "up": gotoUp,
          "down": gotoDown,
          "left": gotoLeft,
          "right": gotoRight,
          "prev": gotoPrev,
          "next": gotoNext,
          "home": gotoRowStart,
          "end": gotoRowEnd
        };
        var stepFn = stepFunctions[dir];
        var pos = stepFn(activeRow, activeCell, activePosX);
        if (pos) {
          if (hasFrozenRows && options.frozenBottom & pos.row == getDataLength()) {
            return;
          }
          var isAddNewRow = pos.row == getDataLength();
          if (!options.frozenBottom && pos.row >= actualFrozenRow || options.frozenBottom && pos.row < actualFrozenRow) {
            scrollCellIntoView(pos.row, pos.cell, !isAddNewRow && options.emulatePagingWhenScrolling);
          }
          setActiveCellInternal(getCellNode(pos.row, pos.cell));
          activePosX = pos.posX;
          return true;
        } else {
          setActiveCellInternal(getCellNode(activeRow, activeCell));
          return false;
        }
      }
      function getCellNode(row2, cell) {
        if (rowsCache[row2]) {
          ensureCellNodesInRowsCache(row2);
          try {
            if (rowsCache[row2].cellNodesByColumnIdx.length > cell) {
              return rowsCache[row2].cellNodesByColumnIdx[cell][0];
            } else {
              return null;
            }
          } catch (e) {
            return rowsCache[row2].cellNodesByColumnIdx[cell];
          }
        }
        return null;
      }
      function setActiveCell(row2, cell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent) {
        if (!initialized) {
          return;
        }
        if (row2 > getDataLength() || row2 < 0 || cell >= columns.length || cell < 0) {
          return;
        }
        if (!options.enableCellNavigation) {
          return;
        }
        scrollCellIntoView(row2, cell, false);
        setActiveCellInternal(getCellNode(row2, cell), opt_editMode, preClickModeOn, suppressActiveCellChangedEvent);
      }
      function setActiveRow(row2, cell, suppressScrollIntoView) {
        if (!initialized) {
          return;
        }
        if (row2 > getDataLength() || row2 < 0 || cell >= columns.length || cell < 0) {
          return;
        }
        activeRow = row2;
        if (!suppressScrollIntoView) {
          scrollCellIntoView(row2, cell || 0, false);
        }
      }
      function canCellBeActive(row2, cell) {
        if (!options.enableCellNavigation || row2 >= getDataLengthIncludingAddNew() || row2 < 0 || cell >= columns.length || cell < 0) {
          return false;
        }
        var rowMetadata = data.getItemMetadata && data.getItemMetadata(row2);
        if (rowMetadata && typeof rowMetadata.focusable !== "undefined") {
          return !!rowMetadata.focusable;
        }
        var columnMetadata = rowMetadata && rowMetadata.columns;
        if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable !== "undefined") {
          return !!columnMetadata[columns[cell].id].focusable;
        }
        if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable !== "undefined") {
          return !!columnMetadata[cell].focusable;
        }
        return !!columns[cell].focusable;
      }
      function canCellBeSelected(row2, cell) {
        if (row2 >= getDataLength() || row2 < 0 || cell >= columns.length || cell < 0) {
          return false;
        }
        var rowMetadata = data.getItemMetadata && data.getItemMetadata(row2);
        if (rowMetadata && typeof rowMetadata.selectable !== "undefined") {
          return !!rowMetadata.selectable;
        }
        var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);
        if (columnMetadata && typeof columnMetadata.selectable !== "undefined") {
          return !!columnMetadata.selectable;
        }
        return !!columns[cell].selectable;
      }
      function gotoCell(row2, cell, forceEdit, e) {
        if (!initialized) {
          return;
        }
        if (!canCellBeActive(row2, cell)) {
          return;
        }
        if (!getEditorLock().commitCurrentEdit()) {
          return;
        }
        scrollCellIntoView(row2, cell, false);
        var newCell = getCellNode(row2, cell);
        var column = columns[cell];
        var suppressActiveCellChangedEvent = !!(options.editable && column && column.editor && options.suppressActiveCellChangeOnEdit);
        setActiveCellInternal(newCell, forceEdit || row2 === getDataLength() || options.autoEdit, null, suppressActiveCellChangedEvent, e);
        if (!currentEditor) {
          setFocus();
        }
      }
      function commitCurrentEdit() {
        var item3 = getDataItem(activeRow);
        var column = columns[activeCell];
        if (currentEditor) {
          if (currentEditor.isValueChanged()) {
            var validationResults = currentEditor.validate();
            if (validationResults.valid) {
              if (activeRow < getDataLength()) {
                var editCommand = {
                  row: activeRow,
                  cell: activeCell,
                  editor: currentEditor,
                  serializedValue: currentEditor.serializeValue(),
                  prevSerializedValue: serializedEditorValue,
                  execute: function() {
                    this.editor.applyValue(item3, this.serializedValue);
                    updateRow(this.row);
                    trigger(self.onCellChange, {
                      command: "execute",
                      row: this.row,
                      cell: this.cell,
                      item: item3,
                      column
                    });
                  },
                  undo: function() {
                    this.editor.applyValue(item3, this.prevSerializedValue);
                    updateRow(this.row);
                    trigger(self.onCellChange, {
                      command: "undo",
                      row: this.row,
                      cell: this.cell,
                      item: item3,
                      column
                    });
                  }
                };
                if (options.editCommandHandler) {
                  makeActiveCellNormal();
                  options.editCommandHandler(item3, column, editCommand);
                } else {
                  editCommand.execute();
                  makeActiveCellNormal();
                }
              } else {
                var newItem = {};
                currentEditor.applyValue(newItem, currentEditor.serializeValue());
                makeActiveCellNormal();
                trigger(self.onAddNewRow, { item: newItem, column });
              }
              return !getEditorLock().isActive();
            } else {
              $(activeCellNode).removeClass("invalid");
              $(activeCellNode).width();
              $(activeCellNode).addClass("invalid");
              trigger(self.onValidationError, {
                editor: currentEditor,
                cellNode: activeCellNode,
                validationResults,
                row: activeRow,
                cell: activeCell,
                column
              });
              currentEditor.focus();
              return false;
            }
          }
          makeActiveCellNormal();
        }
        return true;
      }
      function cancelCurrentEdit() {
        makeActiveCellNormal();
        return true;
      }
      function rowsToRanges(rows) {
        var ranges = [];
        var lastCell = columns.length - 1;
        for (var i2 = 0; i2 < rows.length; i2++) {
          ranges.push(new Slick.Range(rows[i2], 0, rows[i2], lastCell));
        }
        return ranges;
      }
      function getSelectedRows() {
        if (!selectionModel) {
          throw new Error("SlickGrid Selection model is not set");
        }
        return selectedRows.slice(0);
      }
      function setSelectedRows(rows) {
        if (!selectionModel) {
          throw new Error("SlickGrid Selection model is not set");
        }
        if (self && self.getEditorLock && !self.getEditorLock().isActive()) {
          selectionModel.setSelectedRanges(rowsToRanges(rows));
        }
      }
      this.debug = function() {
        var s2 = "";
        s2 += "\ncounter_rows_rendered:  " + counter_rows_rendered;
        s2 += "\ncounter_rows_removed:  " + counter_rows_removed;
        s2 += "\nrenderedRows:  " + renderedRows;
        s2 += "\nnumVisibleRows:  " + numVisibleRows;
        s2 += "\nmaxSupportedCssHeight:  " + maxSupportedCssHeight;
        s2 += "\nn(umber of pages):  " + n;
        s2 += "\n(current) page:  " + page;
        s2 += "\npage height (ph):  " + ph;
        s2 += "\nvScrollDir:  " + vScrollDir;
        alert(s2);
      };
      this.eval = function(expr) {
        return eval(expr);
      };
      $.extend(this, {
        "slickGridVersion": "2.4.41",
        // Events
        "onScroll": new Slick.Event(),
        "onBeforeSort": new Slick.Event(),
        "onSort": new Slick.Event(),
        "onHeaderMouseEnter": new Slick.Event(),
        "onHeaderMouseLeave": new Slick.Event(),
        "onHeaderContextMenu": new Slick.Event(),
        "onHeaderClick": new Slick.Event(),
        "onHeaderCellRendered": new Slick.Event(),
        "onBeforeHeaderCellDestroy": new Slick.Event(),
        "onHeaderRowCellRendered": new Slick.Event(),
        "onFooterRowCellRendered": new Slick.Event(),
        "onFooterContextMenu": new Slick.Event(),
        "onFooterClick": new Slick.Event(),
        "onBeforeHeaderRowCellDestroy": new Slick.Event(),
        "onBeforeFooterRowCellDestroy": new Slick.Event(),
        "onMouseEnter": new Slick.Event(),
        "onMouseLeave": new Slick.Event(),
        "onClick": new Slick.Event(),
        "onDblClick": new Slick.Event(),
        "onContextMenu": new Slick.Event(),
        "onKeyDown": new Slick.Event(),
        "onAddNewRow": new Slick.Event(),
        "onBeforeAppendCell": new Slick.Event(),
        "onValidationError": new Slick.Event(),
        "onViewportChanged": new Slick.Event(),
        "onColumnsReordered": new Slick.Event(),
        "onColumnsDrag": new Slick.Event(),
        "onColumnsResized": new Slick.Event(),
        "onColumnsResizeDblClick": new Slick.Event(),
        "onBeforeColumnsResize": new Slick.Event(),
        "onCellChange": new Slick.Event(),
        "onCompositeEditorChange": new Slick.Event(),
        "onBeforeEditCell": new Slick.Event(),
        "onBeforeCellEditorDestroy": new Slick.Event(),
        "onBeforeDestroy": new Slick.Event(),
        "onActiveCellChanged": new Slick.Event(),
        "onActiveCellPositionChanged": new Slick.Event(),
        "onDragInit": new Slick.Event(),
        "onDragStart": new Slick.Event(),
        "onDrag": new Slick.Event(),
        "onDragEnd": new Slick.Event(),
        "onSelectedRowsChanged": new Slick.Event(),
        "onCellCssStylesChanged": new Slick.Event(),
        "onAutosizeColumns": new Slick.Event(),
        "onBeforeSetColumns": new Slick.Event(),
        "onRendered": new Slick.Event(),
        "onSetOptions": new Slick.Event(),
        // Methods
        "registerPlugin": registerPlugin,
        "unregisterPlugin": unregisterPlugin,
        "getPluginByName": getPluginByName,
        "getColumns": getColumns,
        "setColumns": setColumns,
        "getColumnIndex": getColumnIndex,
        "updateColumnHeader": updateColumnHeader,
        "setSortColumn": setSortColumn,
        "setSortColumns": setSortColumns,
        "getSortColumns": getSortColumns,
        "autosizeColumns": autosizeColumns,
        "autosizeColumn": autosizeColumn,
        "getOptions": getOptions,
        "setOptions": setOptions,
        "getData": getData,
        "getDataLength": getDataLength,
        "getDataItem": getDataItem,
        "setData": setData,
        "getSelectionModel": getSelectionModel,
        "setSelectionModel": setSelectionModel,
        "getSelectedRows": getSelectedRows,
        "setSelectedRows": setSelectedRows,
        "getContainerNode": getContainerNode,
        "updatePagingStatusFromView": updatePagingStatusFromView,
        "applyFormatResultToCellNode": applyFormatResultToCellNode,
        "render": render,
        "reRenderColumns": reRenderColumns,
        "invalidate": invalidate,
        "invalidateRow": invalidateRow,
        "invalidateRows": invalidateRows,
        "invalidateAllRows": invalidateAllRows,
        "updateCell": updateCell,
        "updateRow": updateRow,
        "getViewport": getVisibleRange,
        "getRenderedRange": getRenderedRange,
        "resizeCanvas": resizeCanvas,
        "updateRowCount": updateRowCount,
        "scrollRowIntoView": scrollRowIntoView,
        "scrollRowToTop": scrollRowToTop,
        "scrollCellIntoView": scrollCellIntoView,
        "scrollColumnIntoView": scrollColumnIntoView,
        "getCanvasNode": getCanvasNode,
        "getUID": getUID,
        "getHeaderColumnWidthDiff": getHeaderColumnWidthDiff,
        "getScrollbarDimensions": getScrollbarDimensions,
        "getHeadersWidth": getHeadersWidth,
        "getCanvasWidth": getCanvasWidth,
        "getCanvases": getCanvases,
        "getActiveCanvasNode": getActiveCanvasNode,
        "setActiveCanvasNode": setActiveCanvasNode,
        "getViewportNode": getViewportNode,
        "getViewports": getViewports,
        "getActiveViewportNode": getActiveViewportNode,
        "setActiveViewportNode": setActiveViewportNode,
        "focus": setFocus,
        "scrollTo": scrollTo,
        "cacheCssForHiddenInit": cacheCssForHiddenInit,
        "restoreCssFromHiddenInit": restoreCssFromHiddenInit,
        "getCellFromPoint": getCellFromPoint,
        "getCellFromEvent": getCellFromEvent,
        "getActiveCell": getActiveCell,
        "setActiveCell": setActiveCell,
        "setActiveRow": setActiveRow,
        "getActiveCellNode": getActiveCellNode,
        "getActiveCellPosition": getActiveCellPosition,
        "resetActiveCell": resetActiveCell,
        "editActiveCell": makeActiveCellEditable,
        "getCellEditor": getCellEditor,
        "getCellNode": getCellNode,
        "getCellNodeBox": getCellNodeBox,
        "canCellBeSelected": canCellBeSelected,
        "canCellBeActive": canCellBeActive,
        "navigatePrev": navigatePrev,
        "navigateNext": navigateNext,
        "navigateUp": navigateUp,
        "navigateDown": navigateDown,
        "navigateLeft": navigateLeft,
        "navigateRight": navigateRight,
        "navigatePageUp": navigatePageUp,
        "navigatePageDown": navigatePageDown,
        "navigateTop": navigateTop,
        "navigateBottom": navigateBottom,
        "navigateRowStart": navigateRowStart,
        "navigateRowEnd": navigateRowEnd,
        "gotoCell": gotoCell,
        "getTopPanel": getTopPanel,
        "setTopPanelVisibility": setTopPanelVisibility,
        "getPreHeaderPanel": getPreHeaderPanel,
        "getPreHeaderPanelLeft": getPreHeaderPanel,
        "getPreHeaderPanelRight": getPreHeaderPanelRight,
        "setPreHeaderPanelVisibility": setPreHeaderPanelVisibility,
        "getHeader": getHeader,
        "getHeaderColumn": getHeaderColumn,
        "setHeaderRowVisibility": setHeaderRowVisibility,
        "getHeaderRow": getHeaderRow,
        "getHeaderRowColumn": getHeaderRowColumn,
        "setFooterRowVisibility": setFooterRowVisibility,
        "getFooterRow": getFooterRow,
        "getFooterRowColumn": getFooterRowColumn,
        "getGridPosition": getGridPosition,
        "flashCell": flashCell,
        "addCellCssStyles": addCellCssStyles,
        "setCellCssStyles": setCellCssStyles,
        "removeCellCssStyles": removeCellCssStyles,
        "getCellCssStyles": getCellCssStyles,
        "getFrozenRowOffset": getFrozenRowOffset,
        "setColumnHeaderVisibility": setColumnHeaderVisibility,
        "init": finishInitialization,
        "destroy": destroy,
        // IEditor implementation
        "getEditorLock": getEditorLock,
        "getEditController": getEditController
      });
      init();
    }
    module.exports = {
      Grid: SlickGrid
    };
  }
});

// node_modules/@bokeh/slickgrid/slick.dataview.js
var require_slick_dataview = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.dataview.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function DataView2(options2) {
      var self2 = this;
      var defaults3 = {
        groupItemMetadataProvider: null,
        inlineFilters: false
      };
      var idProperty = "id";
      var items = [];
      var rows = [];
      var idxById = new Slick2.Map();
      var rowsById = null;
      var filter2 = null;
      var updated = null;
      var suspend = false;
      var isBulkSuspend = false;
      var bulkDeleteIds = new Slick2.Map();
      var sortAsc = true;
      var fastSortField;
      var sortComparer;
      var refreshHints = {};
      var prevRefreshHints = {};
      var filterArgs;
      var filteredItems = [];
      var compiledFilter;
      var compiledFilterWithCaching;
      var filterCache = [];
      var _grid = null;
      var groupingInfoDefaults = {
        getter: null,
        formatter: null,
        comparer: function(a2, b2) {
          return a2.value === b2.value ? 0 : a2.value > b2.value ? 1 : -1;
        },
        predefinedValues: [],
        aggregators: [],
        aggregateEmpty: false,
        aggregateCollapsed: false,
        aggregateChildGroups: false,
        collapsed: false,
        displayTotalsRow: true,
        lazyTotalsCalculation: false
      };
      var groupingInfos = [];
      var groups = [];
      var toggledGroupsByLevel = [];
      var groupingDelimiter = ":|:";
      var selectedRowIds = null;
      var pagesize = 0;
      var pagenum = 0;
      var totalRows = 0;
      var onSetItemsCalled = new Slick2.Event();
      var onRowCountChanged = new Slick2.Event();
      var onRowsChanged = new Slick2.Event();
      var onRowsOrCountChanged = new Slick2.Event();
      var onBeforePagingInfoChanged = new Slick2.Event();
      var onPagingInfoChanged = new Slick2.Event();
      var onGroupExpanded = new Slick2.Event();
      var onGroupCollapsed = new Slick2.Event();
      options2 = $2.extend(true, {}, defaults3, options2);
      function beginUpdate(bulkUpdate) {
        suspend = true;
        isBulkSuspend = bulkUpdate === true;
      }
      function endUpdate() {
        var wasBulkSuspend = isBulkSuspend;
        isBulkSuspend = false;
        suspend = false;
        if (wasBulkSuspend) {
          processBulkDelete();
          ensureIdUniqueness();
        }
        refresh();
      }
      function destroy2() {
        items = [];
        idxById = null;
        rowsById = null;
        filter2 = null;
        updated = null;
        sortComparer = null;
        filterCache = [];
        filteredItems = [];
        compiledFilter = null;
        compiledFilterWithCaching = null;
        if (_grid && _grid.onSelectedRowsChanged && _grid.onCellCssStylesChanged) {
          _grid.onSelectedRowsChanged.unsubscribe();
          _grid.onCellCssStylesChanged.unsubscribe();
        }
        if (self2.onRowsOrCountChanged) {
          self2.onRowsOrCountChanged.unsubscribe();
        }
      }
      function setRefreshHints(hints) {
        refreshHints = hints;
      }
      function setFilterArgs(args) {
        filterArgs = args;
      }
      function processBulkDelete() {
        var id, item3, newIdx = 0;
        for (var i2 = 0, l = items.length; i2 < l; i2++) {
          item3 = items[i2];
          id = item3[idProperty];
          if (id === void 0) {
            throw new Error("[SlickGrid DataView] Each data element must implement a unique 'id' property");
          }
          if (bulkDeleteIds.has(id)) {
            idxById.delete(id);
          } else {
            items[newIdx] = item3;
            idxById.set(id, newIdx);
            ++newIdx;
          }
        }
        items.length = newIdx;
        bulkDeleteIds = new Slick2.Map();
      }
      function updateIdxById(startingIndex) {
        if (isBulkSuspend) {
          return;
        }
        startingIndex = startingIndex || 0;
        var id;
        for (var i2 = startingIndex, l = items.length; i2 < l; i2++) {
          id = items[i2][idProperty];
          if (id === void 0) {
            throw new Error("[SlickGrid DataView] Each data element must implement a unique 'id' property");
          }
          idxById.set(id, i2);
        }
      }
      function ensureIdUniqueness() {
        if (isBulkSuspend) {
          return;
        }
        var id;
        for (var i2 = 0, l = items.length; i2 < l; i2++) {
          id = items[i2][idProperty];
          if (id === void 0 || idxById.get(id) !== i2) {
            throw new Error("[SlickGrid DataView] Each data element must implement a unique 'id' property");
          }
        }
      }
      function getItems() {
        return items;
      }
      function getIdPropertyName() {
        return idProperty;
      }
      function setItems(data3, objectIdProperty) {
        if (objectIdProperty !== void 0) {
          idProperty = objectIdProperty;
        }
        items = filteredItems = data3;
        onSetItemsCalled.notify({ idProperty: objectIdProperty, itemCount: items.length }, null, self2);
        idxById = new Slick2.Map();
        updateIdxById();
        ensureIdUniqueness();
        refresh();
      }
      function setPagingOptions(args) {
        if (onBeforePagingInfoChanged.notify(getPagingInfo(), null, self2) !== false) {
          if (args.pageSize != void 0) {
            pagesize = args.pageSize;
            pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;
          }
          if (args.pageNum != void 0) {
            pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));
          }
          onPagingInfoChanged.notify(getPagingInfo(), null, self2);
          refresh();
        }
      }
      function getPagingInfo() {
        var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;
        return { pageSize: pagesize, pageNum: pagenum, totalRows, totalPages, dataView: self2 };
      }
      function sort2(comparer, ascending) {
        sortAsc = ascending;
        sortComparer = comparer;
        fastSortField = null;
        if (ascending === false) {
          items.reverse();
        }
        items.sort(comparer);
        if (ascending === false) {
          items.reverse();
        }
        idxById = new Slick2.Map();
        updateIdxById();
        refresh();
      }
      function fastSort(field, ascending) {
        sortAsc = ascending;
        fastSortField = field;
        sortComparer = null;
        var oldToString = Object.prototype.toString;
        Object.prototype.toString = typeof field == "function" ? field : function() {
          return this[field];
        };
        if (ascending === false) {
          items.reverse();
        }
        items.sort();
        Object.prototype.toString = oldToString;
        if (ascending === false) {
          items.reverse();
        }
        idxById = new Slick2.Map();
        updateIdxById();
        refresh();
      }
      function reSort() {
        if (sortComparer) {
          sort2(sortComparer, sortAsc);
        } else if (fastSortField) {
          fastSort(fastSortField, sortAsc);
        }
      }
      function getFilteredItems() {
        return filteredItems;
      }
      function getFilteredItemCount() {
        return filteredItems.length;
      }
      function getFilter() {
        return filter2;
      }
      function setFilter(filterFn) {
        filter2 = filterFn;
        if (options2.inlineFilters) {
          compiledFilter = compileFilter();
          compiledFilterWithCaching = compileFilterWithCaching();
        }
        refresh();
      }
      function getGrouping() {
        return groupingInfos;
      }
      function setGrouping(groupingInfo) {
        if (!options2.groupItemMetadataProvider) {
          options2.groupItemMetadataProvider = new Slick2.Data.GroupItemMetadataProvider();
        }
        groups = [];
        toggledGroupsByLevel = [];
        groupingInfo = groupingInfo || [];
        groupingInfos = groupingInfo instanceof Array ? groupingInfo : [groupingInfo];
        for (var i2 = 0; i2 < groupingInfos.length; i2++) {
          var gi = groupingInfos[i2] = $2.extend(true, {}, groupingInfoDefaults, groupingInfos[i2]);
          gi.getterIsAFn = typeof gi.getter === "function";
          gi.compiledAccumulators = [];
          var idx = gi.aggregators.length;
          while (idx--) {
            gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);
          }
          toggledGroupsByLevel[i2] = {};
        }
        refresh();
      }
      function groupBy(valueGetter, valueFormatter, sortComparer2) {
        if (valueGetter == null) {
          setGrouping([]);
          return;
        }
        setGrouping({
          getter: valueGetter,
          formatter: valueFormatter,
          comparer: sortComparer2
        });
      }
      function setAggregators(groupAggregators, includeCollapsed) {
        if (!groupingInfos.length) {
          throw new Error("[SlickGrid DataView] At least one grouping must be specified before calling setAggregators().");
        }
        groupingInfos[0].aggregators = groupAggregators;
        groupingInfos[0].aggregateCollapsed = includeCollapsed;
        setGrouping(groupingInfos);
      }
      function getItemByIdx(i2) {
        return items[i2];
      }
      function getIdxById(id) {
        return idxById.get(id);
      }
      function ensureRowsByIdCache() {
        if (!rowsById) {
          rowsById = {};
          for (var i2 = 0, l = rows.length; i2 < l; i2++) {
            rowsById[rows[i2][idProperty]] = i2;
          }
        }
      }
      function getRowByItem(item3) {
        ensureRowsByIdCache();
        return rowsById[item3[idProperty]];
      }
      function getRowById(id) {
        ensureRowsByIdCache();
        return rowsById[id];
      }
      function getItemById(id) {
        return items[idxById.get(id)];
      }
      function mapItemsToRows(itemArray) {
        var rows2 = [];
        ensureRowsByIdCache();
        for (var i2 = 0, l = itemArray.length; i2 < l; i2++) {
          var row2 = rowsById[itemArray[i2][idProperty]];
          if (row2 != null) {
            rows2[rows2.length] = row2;
          }
        }
        return rows2;
      }
      function mapIdsToRows(idArray) {
        var rows2 = [];
        ensureRowsByIdCache();
        for (var i2 = 0, l = idArray.length; i2 < l; i2++) {
          var row2 = rowsById[idArray[i2]];
          if (row2 != null) {
            rows2[rows2.length] = row2;
          }
        }
        return rows2;
      }
      function mapRowsToIds(rowArray) {
        var ids = [];
        for (var i2 = 0, l = rowArray.length; i2 < l; i2++) {
          if (rowArray[i2] < rows.length) {
            ids[ids.length] = rows[rowArray[i2]][idProperty];
          }
        }
        return ids;
      }
      function updateSingleItem(id, item3) {
        if (!idxById.has(id)) {
          throw new Error("[SlickGrid DataView] Invalid id");
        }
        if (id !== item3[idProperty]) {
          var newId = item3[idProperty];
          if (newId == null) {
            throw new Error("[SlickGrid DataView] Cannot update item to associate with a null id");
          }
          if (idxById.has(newId)) {
            throw new Error("[SlickGrid DataView] Cannot update item to associate with a non-unique id");
          }
          idxById.set(newId, idxById.get(id));
          idxById.delete(id);
          if (updated && updated[id]) {
            delete updated[id];
          }
          id = newId;
        }
        items[idxById.get(id)] = item3;
        if (!updated) {
          updated = {};
        }
        updated[id] = true;
      }
      function updateItem(id, item3) {
        updateSingleItem(id, item3);
        refresh();
      }
      function updateItems(ids, newItems) {
        if (ids.length !== newItems.length) {
          throw new Error("[SlickGrid DataView] Mismatch on the length of ids and items provided to update");
        }
        for (var i2 = 0, l = newItems.length; i2 < l; i2++) {
          updateSingleItem(ids[i2], newItems[i2]);
        }
        refresh();
      }
      function insertItem(insertBefore, item3) {
        items.splice(insertBefore, 0, item3);
        updateIdxById(insertBefore);
        refresh();
      }
      function insertItems(insertBefore, newItems) {
        Array.prototype.splice.apply(items, [insertBefore, 0].concat(newItems));
        updateIdxById(insertBefore);
        refresh();
      }
      function addItem(item3) {
        items.push(item3);
        updateIdxById(items.length - 1);
        refresh();
      }
      function addItems(newItems) {
        items = items.concat(newItems);
        updateIdxById(items.length - newItems.length);
        refresh();
      }
      function deleteItem(id) {
        if (isBulkSuspend) {
          bulkDeleteIds.set(id, true);
        } else {
          var idx = idxById.get(id);
          if (idx === void 0) {
            throw new Error("[SlickGrid DataView] Invalid id");
          }
          idxById.delete(id);
          items.splice(idx, 1);
          updateIdxById(idx);
          refresh();
        }
      }
      function deleteItems(ids) {
        if (ids.length === 0) {
          return;
        }
        if (isBulkSuspend) {
          for (var i2 = 0, l = ids.length; i2 < l; i2++) {
            var id = ids[i2];
            var idx = idxById.get(id);
            if (idx === void 0) {
              throw new Error("[SlickGrid DataView] Invalid id");
            }
            bulkDeleteIds.set(id, true);
          }
        } else {
          var indexesToDelete = [];
          for (var i2 = 0, l = ids.length; i2 < l; i2++) {
            var id = ids[i2];
            var idx = idxById.get(id);
            if (idx === void 0) {
              throw new Error("[SlickGrid DataView] Invalid id");
            }
            idxById.delete(id);
            indexesToDelete.push(idx);
          }
          indexesToDelete.sort();
          for (var i2 = indexesToDelete.length - 1; i2 >= 0; --i2) {
            items.splice(indexesToDelete[i2], 1);
          }
          updateIdxById(indexesToDelete[0]);
          refresh();
        }
      }
      function sortedAddItem(item3) {
        if (!sortComparer) {
          throw new Error("[SlickGrid DataView] sortedAddItem() requires a sort comparer, use sort()");
        }
        insertItem(sortedIndex(item3), item3);
      }
      function sortedUpdateItem(id, item3) {
        if (!idxById.has(id) || id !== item3[idProperty]) {
          throw new Error("[SlickGrid DataView] Invalid or non-matching id " + idxById.get(id));
        }
        if (!sortComparer) {
          throw new Error("[SlickGrid DataView] sortedUpdateItem() requires a sort comparer, use sort()");
        }
        var oldItem = getItemById(id);
        if (sortComparer(oldItem, item3) !== 0) {
          deleteItem(id);
          sortedAddItem(item3);
        } else {
          updateItem(id, item3);
        }
      }
      function sortedIndex(searchItem) {
        var low = 0, high = items.length;
        while (low < high) {
          var mid = low + high >>> 1;
          if (sortComparer(items[mid], searchItem) === -1) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return low;
      }
      function getItemCount() {
        return items.length;
      }
      function getLength() {
        return rows.length;
      }
      function getItem(i2) {
        var item3 = rows[i2];
        if (item3 && item3.__group && item3.totals && !item3.totals.initialized) {
          var gi = groupingInfos[item3.level];
          if (!gi.displayTotalsRow) {
            calculateTotals(item3.totals);
            item3.title = gi.formatter ? gi.formatter(item3) : item3.value;
          }
        } else if (item3 && item3.__groupTotals && !item3.initialized) {
          calculateTotals(item3);
        }
        return item3;
      }
      function getItemMetadata(i2) {
        var item3 = rows[i2];
        if (item3 === void 0) {
          return null;
        }
        if (item3.__group) {
          return options2.groupItemMetadataProvider.getGroupRowMetadata(item3);
        }
        if (item3.__groupTotals) {
          return options2.groupItemMetadataProvider.getTotalsRowMetadata(item3);
        }
        return null;
      }
      function expandCollapseAllGroups(level, collapse2) {
        if (level == null) {
          for (var i2 = 0; i2 < groupingInfos.length; i2++) {
            toggledGroupsByLevel[i2] = {};
            groupingInfos[i2].collapsed = collapse2;
            if (collapse2 === true) {
              onGroupCollapsed.notify({ level: i2, groupingKey: null });
            } else {
              onGroupExpanded.notify({ level: i2, groupingKey: null });
            }
          }
        } else {
          toggledGroupsByLevel[level] = {};
          groupingInfos[level].collapsed = collapse2;
          if (collapse2 === true) {
            onGroupCollapsed.notify({ level, groupingKey: null });
          } else {
            onGroupExpanded.notify({ level, groupingKey: null });
          }
        }
        refresh();
      }
      function collapseAllGroups(level) {
        expandCollapseAllGroups(level, true);
      }
      function expandAllGroups(level) {
        expandCollapseAllGroups(level, false);
      }
      function expandCollapseGroup(level, groupingKey, collapse2) {
        toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse2;
        refresh();
      }
      function collapseGroup(varArgs) {
        var args = Array.prototype.slice.call(arguments);
        var arg0 = args[0];
        var groupingKey;
        var level;
        if (args.length === 1 && arg0.indexOf(groupingDelimiter) !== -1) {
          groupingKey = arg0;
          level = arg0.split(groupingDelimiter).length - 1;
        } else {
          groupingKey = args.join(groupingDelimiter);
          level = args.length - 1;
        }
        expandCollapseGroup(level, groupingKey, true);
        onGroupCollapsed.notify({ level, groupingKey });
      }
      function expandGroup(varArgs) {
        var args = Array.prototype.slice.call(arguments);
        var arg0 = args[0];
        var groupingKey;
        var level;
        if (args.length === 1 && arg0.indexOf(groupingDelimiter) !== -1) {
          level = arg0.split(groupingDelimiter).length - 1;
          groupingKey = arg0;
        } else {
          level = args.length - 1;
          groupingKey = args.join(groupingDelimiter);
        }
        expandCollapseGroup(level, groupingKey, false);
        onGroupExpanded.notify({ level, groupingKey });
      }
      function getGroups() {
        return groups;
      }
      function extractGroups(rows2, parentGroup) {
        var group;
        var val;
        var groups2 = [];
        var groupsByVal = {};
        var r;
        var level = parentGroup ? parentGroup.level + 1 : 0;
        var gi = groupingInfos[level];
        for (var i2 = 0, l = gi.predefinedValues.length; i2 < l; i2++) {
          val = gi.predefinedValues[i2];
          group = groupsByVal[val];
          if (!group) {
            group = new Slick2.Group();
            group.value = val;
            group.level = level;
            group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : "") + val;
            groups2[groups2.length] = group;
            groupsByVal[val] = group;
          }
        }
        for (var i2 = 0, l = rows2.length; i2 < l; i2++) {
          r = rows2[i2];
          val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];
          group = groupsByVal[val];
          if (!group) {
            group = new Slick2.Group();
            group.value = val;
            group.level = level;
            group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : "") + val;
            groups2[groups2.length] = group;
            groupsByVal[val] = group;
          }
          group.rows[group.count++] = r;
        }
        if (level < groupingInfos.length - 1) {
          for (var i2 = 0; i2 < groups2.length; i2++) {
            group = groups2[i2];
            group.groups = extractGroups(group.rows, group);
          }
        }
        if (groups2.length) {
          addTotals(groups2, level);
        }
        groups2.sort(groupingInfos[level].comparer);
        return groups2;
      }
      function calculateTotals(totals) {
        var group = totals.group;
        var gi = groupingInfos[group.level];
        var isLeafLevel = group.level == groupingInfos.length;
        var agg, idx = gi.aggregators.length;
        if (!isLeafLevel && gi.aggregateChildGroups) {
          var i2 = group.groups.length;
          while (i2--) {
            if (!group.groups[i2].totals.initialized) {
              calculateTotals(group.groups[i2].totals);
            }
          }
        }
        while (idx--) {
          agg = gi.aggregators[idx];
          agg.init();
          if (!isLeafLevel && gi.aggregateChildGroups) {
            gi.compiledAccumulators[idx].call(agg, group.groups);
          } else {
            gi.compiledAccumulators[idx].call(agg, group.rows);
          }
          agg.storeResult(totals);
        }
        totals.initialized = true;
      }
      function addGroupTotals(group) {
        var gi = groupingInfos[group.level];
        var totals = new Slick2.GroupTotals();
        totals.group = group;
        group.totals = totals;
        if (!gi.lazyTotalsCalculation) {
          calculateTotals(totals);
        }
      }
      function addTotals(groups2, level) {
        level = level || 0;
        var gi = groupingInfos[level];
        var groupCollapsed = gi.collapsed;
        var toggledGroups = toggledGroupsByLevel[level];
        var idx = groups2.length, g;
        while (idx--) {
          g = groups2[idx];
          if (g.collapsed && !gi.aggregateCollapsed) {
            continue;
          }
          if (g.groups) {
            addTotals(g.groups, level + 1);
          }
          if (gi.aggregators.length && (gi.aggregateEmpty || g.rows.length || g.groups && g.groups.length)) {
            addGroupTotals(g);
          }
          g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];
          g.title = gi.formatter ? gi.formatter(g) : g.value;
        }
      }
      function flattenGroupedRows(groups2, level) {
        level = level || 0;
        var gi = groupingInfos[level];
        var groupedRows = [], rows2, gl = 0, g;
        for (var i2 = 0, l = groups2.length; i2 < l; i2++) {
          g = groups2[i2];
          groupedRows[gl++] = g;
          if (!g.collapsed) {
            rows2 = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;
            for (var j = 0, jj = rows2.length; j < jj; j++) {
              groupedRows[gl++] = rows2[j];
            }
          }
          if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {
            groupedRows[gl++] = g.totals;
          }
        }
        return groupedRows;
      }
      function getFunctionInfo(fn) {
        var fnStr = fn.toString();
        var usingEs5 = fnStr.indexOf("function") >= 0;
        var fnRegex = usingEs5 ? /^function[^(]*\(([^)]*)\)\s*{([\s\S]*)}$/ : /^[^(]*\(([^)]*)\)\s*{([\s\S]*)}$/;
        var matches = fn.toString().match(fnRegex);
        return {
          params: matches[1].split(","),
          body: matches[2]
        };
      }
      function compileAccumulatorLoop(aggregator) {
        if (aggregator.accumulate) {
          var accumulatorInfo = getFunctionInfo(aggregator.accumulate);
          var fn = new Function(
            "_items",
            "for (var " + accumulatorInfo.params[0] + ", _i=0, _il=_items.length; _i<_il; _i++) {" + accumulatorInfo.params[0] + " = _items[_i]; " + accumulatorInfo.body + "}"
          );
          var fnName = "compiledAccumulatorLoop";
          fn.displayName = fnName;
          fn.name = setFunctionName(fn, fnName);
          return fn;
        } else {
          return function noAccumulator() {
          };
        }
      }
      function compileFilter() {
        var filterInfo = getFunctionInfo(filter2);
        var filterPath1 = "{ continue _coreloop; }$1";
        var filterPath2 = "{ _retval[_idx++] = $item$; continue _coreloop; }$1";
        var filterBody = filterInfo.body.replace(/return false\s*([;}]|\}|$)/gi, filterPath1).replace(/return!1([;}]|\}|$)/gi, filterPath1).replace(/return true\s*([;}]|\}|$)/gi, filterPath2).replace(/return!0([;}]|\}|$)/gi, filterPath2).replace(
          /return ([^;}]+?)\s*([;}]|$)/gi,
          "{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2"
        );
        var tpl = [
          //"function(_items, _args) { ",
          "var _retval = [], _idx = 0; ",
          "var $item$, $args$ = _args; ",
          "_coreloop: ",
          "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ",
          "$item$ = _items[_i]; ",
          "$filter$; ",
          "} ",
          "return _retval; "
          //"}"
        ].join("");
        tpl = tpl.replace(/\$filter\$/gi, filterBody);
        tpl = tpl.replace(/\$item\$/gi, filterInfo.params[0]);
        tpl = tpl.replace(/\$args\$/gi, filterInfo.params[1]);
        var fn = new Function("_items,_args", tpl);
        var fnName = "compiledFilter";
        fn.displayName = fnName;
        fn.name = setFunctionName(fn, fnName);
        return fn;
      }
      function compileFilterWithCaching() {
        var filterInfo = getFunctionInfo(filter2);
        var filterPath1 = "{ continue _coreloop; }$1";
        var filterPath2 = "{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1";
        var filterBody = filterInfo.body.replace(/return false\s*([;}]|\}|$)/gi, filterPath1).replace(/return!1([;}]|\}|$)/gi, filterPath1).replace(/return true\s*([;}]|\}|$)/gi, filterPath2).replace(/return!0([;}]|\}|$)/gi, filterPath2).replace(
          /return ([^;}]+?)\s*([;}]|$)/gi,
          "{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2"
        );
        var tpl = [
          //"function(_items, _args, _cache) { ",
          "var _retval = [], _idx = 0; ",
          "var $item$, $args$ = _args; ",
          "_coreloop: ",
          "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ",
          "$item$ = _items[_i]; ",
          "if (_cache[_i]) { ",
          "_retval[_idx++] = $item$; ",
          "continue _coreloop; ",
          "} ",
          "$filter$; ",
          "} ",
          "return _retval; "
          //"}"
        ].join("");
        tpl = tpl.replace(/\$filter\$/gi, filterBody);
        tpl = tpl.replace(/\$item\$/gi, filterInfo.params[0]);
        tpl = tpl.replace(/\$args\$/gi, filterInfo.params[1]);
        var fn = new Function("_items,_args,_cache", tpl);
        var fnName = "compiledFilterWithCaching";
        fn.displayName = fnName;
        fn.name = setFunctionName(fn, fnName);
        return fn;
      }
      function setFunctionName(fn, fnName) {
        try {
          Object.defineProperty(fn, "name", {
            writable: true,
            value: fnName
          });
        } catch (err) {
          fn.name = fnName;
        }
      }
      function uncompiledFilter(items2, args) {
        var retval = [], idx = 0;
        for (var i2 = 0, ii = items2.length; i2 < ii; i2++) {
          if (filter2(items2[i2], args)) {
            retval[idx++] = items2[i2];
          }
        }
        return retval;
      }
      function uncompiledFilterWithCaching(items2, args, cache) {
        var retval = [], idx = 0, item3;
        for (var i2 = 0, ii = items2.length; i2 < ii; i2++) {
          item3 = items2[i2];
          if (cache[i2]) {
            retval[idx++] = item3;
          } else if (filter2(item3, args)) {
            retval[idx++] = item3;
            cache[i2] = true;
          }
        }
        return retval;
      }
      function getFilteredAndPagedItems(items2) {
        if (filter2) {
          var batchFilter = options2.inlineFilters ? compiledFilter : uncompiledFilter;
          var batchFilterWithCaching = options2.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;
          if (refreshHints.isFilterNarrowing) {
            filteredItems = batchFilter(filteredItems, filterArgs);
          } else if (refreshHints.isFilterExpanding) {
            filteredItems = batchFilterWithCaching(items2, filterArgs, filterCache);
          } else if (!refreshHints.isFilterUnchanged) {
            filteredItems = batchFilter(items2, filterArgs);
          }
        } else {
          filteredItems = pagesize ? items2 : items2.concat();
        }
        var paged;
        if (pagesize) {
          if (filteredItems.length <= pagenum * pagesize) {
            if (filteredItems.length === 0) {
              pagenum = 0;
            } else {
              pagenum = Math.floor((filteredItems.length - 1) / pagesize);
            }
          }
          paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);
        } else {
          paged = filteredItems;
        }
        return { totalRows: filteredItems.length, rows: paged };
      }
      function getRowDiffs(rows2, newRows) {
        var item3, r, eitherIsNonData, diff = [];
        var from = 0, to = Math.max(newRows.length, rows2.length);
        if (refreshHints && refreshHints.ignoreDiffsBefore) {
          from = Math.max(
            0,
            Math.min(newRows.length, refreshHints.ignoreDiffsBefore)
          );
        }
        if (refreshHints && refreshHints.ignoreDiffsAfter) {
          to = Math.min(
            newRows.length,
            Math.max(0, refreshHints.ignoreDiffsAfter)
          );
        }
        for (var i2 = from, rl = rows2.length; i2 < to; i2++) {
          if (i2 >= rl) {
            diff[diff.length] = i2;
          } else {
            item3 = newRows[i2];
            r = rows2[i2];
            if (!item3 || (groupingInfos.length && (eitherIsNonData = item3.__nonDataRow || r.__nonDataRow) && item3.__group !== r.__group || item3.__group && !item3.equals(r)) || eitherIsNonData && // no good way to compare totals since they are arbitrary DTOs
            // deep object comparison is pretty expensive
            // always considering them 'dirty' seems easier for the time being
            (item3.__groupTotals || r.__groupTotals) || item3[idProperty] != r[idProperty] || updated && updated[item3[idProperty]]) {
              diff[diff.length] = i2;
            }
          }
        }
        return diff;
      }
      function recalc(_items) {
        rowsById = null;
        if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing || refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {
          filterCache = [];
        }
        var filteredItems2 = getFilteredAndPagedItems(_items);
        totalRows = filteredItems2.totalRows;
        var newRows = filteredItems2.rows;
        groups = [];
        if (groupingInfos.length) {
          groups = extractGroups(newRows);
          if (groups.length) {
            newRows = flattenGroupedRows(groups);
          }
        }
        var diff = getRowDiffs(rows, newRows);
        rows = newRows;
        return diff;
      }
      function refresh() {
        if (suspend) {
          return;
        }
        var previousPagingInfo = $2.extend(true, {}, getPagingInfo());
        var countBefore = rows.length;
        var totalRowsBefore = totalRows;
        var diff = recalc(items, filter2);
        if (pagesize && totalRows < pagenum * pagesize) {
          pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);
          diff = recalc(items, filter2);
        }
        updated = null;
        prevRefreshHints = refreshHints;
        refreshHints = {};
        if (totalRowsBefore !== totalRows) {
          if (onBeforePagingInfoChanged.notify(previousPagingInfo, null, self2) !== false) {
            onPagingInfoChanged.notify(getPagingInfo(), null, self2);
          }
        }
        if (countBefore !== rows.length) {
          onRowCountChanged.notify({ previous: countBefore, current: rows.length, itemCount: items.length, dataView: self2, callingOnRowsChanged: diff.length > 0 }, null, self2);
        }
        if (diff.length > 0) {
          onRowsChanged.notify({ rows: diff, itemCount: items.length, dataView: self2, calledOnRowCountChanged: countBefore !== rows.length }, null, self2);
        }
        if (countBefore !== rows.length || diff.length > 0) {
          onRowsOrCountChanged.notify({
            rowsDiff: diff,
            previousRowCount: countBefore,
            currentRowCount: rows.length,
            itemCount: items.length,
            rowCountChanged: countBefore !== rows.length,
            rowsChanged: diff.length > 0,
            dataView: self2
          }, null, self2);
        }
      }
      function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {
        var self3 = this;
        _grid = grid;
        var inHandler;
        selectedRowIds = self3.mapRowsToIds(grid.getSelectedRows());
        var onSelectedRowIdsChanged = new Slick2.Event();
        function setSelectedRowIds(rowIds) {
          if (selectedRowIds.join(",") == rowIds.join(",")) {
            return;
          }
          selectedRowIds = rowIds;
          onSelectedRowIdsChanged.notify({
            "grid": grid,
            "ids": selectedRowIds,
            "dataView": self3
          }, new Slick2.EventData(), self3);
        }
        function update() {
          if (selectedRowIds.length > 0) {
            inHandler = true;
            var selectedRows2 = self3.mapIdsToRows(selectedRowIds);
            if (!preserveHidden) {
              setSelectedRowIds(self3.mapRowsToIds(selectedRows2));
            }
            grid.setSelectedRows(selectedRows2);
            inHandler = false;
          }
        }
        grid.onSelectedRowsChanged.subscribe(function(e, args) {
          if (inHandler) {
            return;
          }
          var newSelectedRowIds = self3.mapRowsToIds(grid.getSelectedRows());
          if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {
            setSelectedRowIds(newSelectedRowIds);
          } else {
            var existing = $2.grep(selectedRowIds, function(id) {
              return self3.getRowById(id) === void 0;
            });
            setSelectedRowIds(existing.concat(newSelectedRowIds));
          }
        });
        this.onRowsOrCountChanged.subscribe(update);
        return onSelectedRowIdsChanged;
      }
      function getAllSelectedIds() {
        return selectedRowIds;
      }
      function getAllSelectedItems() {
        var selectedData = [];
        var selectedIds = getAllSelectedIds();
        selectedIds.forEach(function(id) {
          selectedData.push(self2.getItemById(id));
        });
        return selectedData;
      }
      function syncGridCellCssStyles(grid, key) {
        var hashById;
        var inHandler;
        storeCellCssStyles(grid.getCellCssStyles(key));
        function storeCellCssStyles(hash) {
          hashById = {};
          for (var row2 in hash) {
            var id = rows[row2][idProperty];
            hashById[id] = hash[row2];
          }
        }
        function update() {
          if (hashById) {
            inHandler = true;
            ensureRowsByIdCache();
            var newHash = {};
            for (var id in hashById) {
              var row2 = rowsById[id];
              if (row2 != void 0) {
                newHash[row2] = hashById[id];
              }
            }
            grid.setCellCssStyles(key, newHash);
            inHandler = false;
          }
        }
        grid.onCellCssStylesChanged.subscribe(function(e, args) {
          if (inHandler) {
            return;
          }
          if (key != args.key) {
            return;
          }
          if (args.hash) {
            storeCellCssStyles(args.hash);
          } else {
            grid.onCellCssStylesChanged.unsubscribe();
            self2.onRowsOrCountChanged.unsubscribe(update);
          }
        });
        this.onRowsOrCountChanged.subscribe(update);
      }
      $2.extend(this, {
        // methods
        "beginUpdate": beginUpdate,
        "endUpdate": endUpdate,
        "destroy": destroy2,
        "setPagingOptions": setPagingOptions,
        "getPagingInfo": getPagingInfo,
        "getIdPropertyName": getIdPropertyName,
        "getItems": getItems,
        "setItems": setItems,
        "setFilter": setFilter,
        "getFilter": getFilter,
        "getFilteredItems": getFilteredItems,
        "getFilteredItemCount": getFilteredItemCount,
        "sort": sort2,
        "fastSort": fastSort,
        "reSort": reSort,
        "setGrouping": setGrouping,
        "getGrouping": getGrouping,
        "groupBy": groupBy,
        "setAggregators": setAggregators,
        "collapseAllGroups": collapseAllGroups,
        "expandAllGroups": expandAllGroups,
        "collapseGroup": collapseGroup,
        "expandGroup": expandGroup,
        "getGroups": getGroups,
        "getAllSelectedIds": getAllSelectedIds,
        "getAllSelectedItems": getAllSelectedItems,
        "getIdxById": getIdxById,
        "getRowByItem": getRowByItem,
        "getRowById": getRowById,
        "getItemById": getItemById,
        "getItemByIdx": getItemByIdx,
        "mapItemsToRows": mapItemsToRows,
        "mapRowsToIds": mapRowsToIds,
        "mapIdsToRows": mapIdsToRows,
        "setRefreshHints": setRefreshHints,
        "setFilterArgs": setFilterArgs,
        "refresh": refresh,
        "updateItem": updateItem,
        "updateItems": updateItems,
        "insertItem": insertItem,
        "insertItems": insertItems,
        "addItem": addItem,
        "addItems": addItems,
        "deleteItem": deleteItem,
        "deleteItems": deleteItems,
        "sortedAddItem": sortedAddItem,
        "sortedUpdateItem": sortedUpdateItem,
        "syncGridSelection": syncGridSelection,
        "syncGridCellCssStyles": syncGridCellCssStyles,
        // data provider methods
        "getItemCount": getItemCount,
        "getLength": getLength,
        "getItem": getItem,
        "getItemMetadata": getItemMetadata,
        // events
        "onSetItemsCalled": onSetItemsCalled,
        "onRowCountChanged": onRowCountChanged,
        "onRowsChanged": onRowsChanged,
        "onRowsOrCountChanged": onRowsOrCountChanged,
        "onBeforePagingInfoChanged": onBeforePagingInfoChanged,
        "onPagingInfoChanged": onPagingInfoChanged,
        "onGroupExpanded": onGroupExpanded,
        "onGroupCollapsed": onGroupCollapsed
      });
    }
    function AvgAggregator2(field) {
      this.field_ = field;
      this.init = function() {
        this.count_ = 0;
        this.nonNullCount_ = 0;
        this.sum_ = 0;
      };
      this.accumulate = function(item3) {
        var val = item3[this.field_];
        this.count_++;
        if (val != null && val !== "" && !isNaN(val)) {
          this.nonNullCount_++;
          this.sum_ += parseFloat(val);
        }
      };
      this.storeResult = function(groupTotals) {
        if (!groupTotals.avg) {
          groupTotals.avg = {};
        }
        if (this.nonNullCount_ !== 0) {
          groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;
        }
      };
    }
    function MinAggregator2(field) {
      this.field_ = field;
      this.init = function() {
        this.min_ = null;
      };
      this.accumulate = function(item3) {
        var val = item3[this.field_];
        if (val != null && val !== "" && !isNaN(val)) {
          if (this.min_ == null || val < this.min_) {
            this.min_ = val;
          }
        }
      };
      this.storeResult = function(groupTotals) {
        if (!groupTotals.min) {
          groupTotals.min = {};
        }
        groupTotals.min[this.field_] = this.min_;
      };
    }
    function MaxAggregator2(field) {
      this.field_ = field;
      this.init = function() {
        this.max_ = null;
      };
      this.accumulate = function(item3) {
        var val = item3[this.field_];
        if (val != null && val !== "" && !isNaN(val)) {
          if (this.max_ == null || val > this.max_) {
            this.max_ = val;
          }
        }
      };
      this.storeResult = function(groupTotals) {
        if (!groupTotals.max) {
          groupTotals.max = {};
        }
        groupTotals.max[this.field_] = this.max_;
      };
    }
    function SumAggregator2(field) {
      this.field_ = field;
      this.init = function() {
        this.sum_ = null;
      };
      this.accumulate = function(item3) {
        var val = item3[this.field_];
        if (val != null && val !== "" && !isNaN(val)) {
          this.sum_ += parseFloat(val);
        }
      };
      this.storeResult = function(groupTotals) {
        if (!groupTotals.sum) {
          groupTotals.sum = {};
        }
        groupTotals.sum[this.field_] = this.sum_;
      };
    }
    function CountAggregator(field) {
      this.field_ = field;
      this.init = function() {
      };
      this.storeResult = function(groupTotals) {
        if (!groupTotals.count) {
          groupTotals.count = {};
        }
        groupTotals.count[this.field_] = groupTotals.group.rows.length;
      };
    }
    var Aggregators = {
      Avg: AvgAggregator2,
      Min: MinAggregator2,
      Max: MaxAggregator2,
      Sum: SumAggregator2,
      Count: CountAggregator
    };
    module2.exports = {
      DataView: DataView2,
      Aggregators,
      Data: { Aggregators }
    };
  }
});

// node_modules/@bokeh/slickgrid/slick.editors.js
var require_slick_editors = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.editors.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function TextEditor2(args) {
      var $input;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        var navOnLR = args.grid.getOptions().editorCellNavOnLRKeys;
        $input = $2("<INPUT type=text class='editor-text' />").appendTo(args.container).on("keydown.nav", navOnLR ? handleKeydownLRNav : handleKeydownLRNoNav).focus().select();
        if (args.compositeEditorOptions) {
          $input.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        }
      };
      this.destroy = function() {
        $input.remove();
      };
      this.focus = function() {
        $input.focus();
      };
      this.getValue = function() {
        return $input.val();
      };
      this.setValue = function(val) {
        $input.val(val);
      };
      this.loadValue = function(item3) {
        defaultValue = item3[args.column.field] || "";
        $input.val(defaultValue);
        $input[0].defaultValue = defaultValue;
        $input.select();
      };
      this.serializeValue = function() {
        return $input.val();
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && $input.val() != defaultValue;
      };
      this.validate = function() {
        if (args.column.validator) {
          var validationResults = args.column.validator($input.val(), args);
          if (!validationResults.valid) {
            return validationResults;
          }
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function IntegerEditor(args) {
      var $input;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        var navOnLR = args.grid.getOptions().editorCellNavOnLRKeys;
        $input = $2("<INPUT type=text class='editor-text' />").appendTo(args.container).on("keydown.nav", navOnLR ? handleKeydownLRNav : handleKeydownLRNoNav).focus().select();
        if (args.compositeEditorOptions) {
          $input.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        }
      };
      this.destroy = function() {
        $input.remove();
      };
      this.focus = function() {
        $input.focus();
      };
      this.loadValue = function(item3) {
        defaultValue = item3[args.column.field];
        $input.val(defaultValue);
        $input[0].defaultValue = defaultValue;
        $input.select();
      };
      this.serializeValue = function() {
        return parseInt($input.val(), 10) || 0;
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && $input.val() != defaultValue;
      };
      this.validate = function() {
        if (isNaN($input.val())) {
          return {
            valid: false,
            msg: "Please enter a valid integer"
          };
        }
        if (args.column.validator) {
          var validationResults = args.column.validator($input.val(), args);
          if (!validationResults.valid) {
            return validationResults;
          }
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function FloatEditor(args) {
      var $input;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        var navOnLR = args.grid.getOptions().editorCellNavOnLRKeys;
        $input = $2("<INPUT type=text class='editor-text' />").appendTo(args.container).on("keydown.nav", navOnLR ? handleKeydownLRNav : handleKeydownLRNoNav).focus().select();
        if (args.compositeEditorOptions) {
          $input.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        }
      };
      this.destroy = function() {
        $input.remove();
      };
      this.focus = function() {
        $input.focus();
      };
      function getDecimalPlaces() {
        var rtn = args.column.editorFixedDecimalPlaces;
        if (typeof rtn == "undefined") {
          rtn = FloatEditor.DefaultDecimalPlaces;
        }
        return !rtn && rtn !== 0 ? null : rtn;
      }
      this.loadValue = function(item3) {
        defaultValue = item3[args.column.field];
        var decPlaces = getDecimalPlaces();
        if (decPlaces !== null && (defaultValue || defaultValue === 0) && defaultValue.toFixed) {
          defaultValue = defaultValue.toFixed(decPlaces);
        }
        $input.val(defaultValue);
        $input[0].defaultValue = defaultValue;
        $input.select();
      };
      this.serializeValue = function() {
        var rtn = parseFloat($input.val());
        if (FloatEditor.AllowEmptyValue) {
          if (!rtn && rtn !== 0) {
            rtn = "";
          }
        } else {
          rtn = rtn || 0;
        }
        var decPlaces = getDecimalPlaces();
        if (decPlaces !== null && (rtn || rtn === 0) && rtn.toFixed) {
          rtn = parseFloat(rtn.toFixed(decPlaces));
        }
        return rtn;
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && $input.val() != defaultValue;
      };
      this.validate = function() {
        if (isNaN($input.val())) {
          return {
            valid: false,
            msg: "Please enter a valid number"
          };
        }
        if (args.column.validator) {
          var validationResults = args.column.validator($input.val(), args);
          if (!validationResults.valid) {
            return validationResults;
          }
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    FloatEditor.DefaultDecimalPlaces = null;
    FloatEditor.AllowEmptyValue = false;
    function DateEditor2(args) {
      var $input;
      var defaultValue;
      var scope2 = this;
      var calendarOpen = false;
      this.args = args;
      this.init = function() {
        $input = $2("<INPUT type=text class='editor-text' />");
        $input.appendTo(args.container);
        $input.focus().select();
        $input.datepicker({
          showOn: "button",
          buttonImageOnly: true,
          beforeShow: function() {
            calendarOpen = true;
          },
          onClose: function() {
            calendarOpen = false;
            if (args.compositeEditorOptions) {
              var activeCell2 = args.grid.getActiveCell();
              if (scope2.validate().valid) {
                scope2.applyValue(scope2.args.item, scope2.serializeValue());
              }
              scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
              args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
            }
          }
        });
        $input.width($input.width() - (!args.compositeEditorOptions ? 18 : 28));
      };
      this.destroy = function() {
        $2.datepicker.dpDiv.stop(true, true);
        $input.datepicker("hide");
        $input.datepicker("destroy");
        $input.remove();
      };
      this.show = function() {
        if (calendarOpen) {
          $2.datepicker.dpDiv.stop(true, true).show();
        }
      };
      this.hide = function() {
        if (calendarOpen) {
          $2.datepicker.dpDiv.stop(true, true).hide();
        }
      };
      this.position = function(position2) {
        if (!calendarOpen) {
          return;
        }
        $2.datepicker.dpDiv.css("top", position2.top + 30).css("left", position2.left);
      };
      this.focus = function() {
        $input.focus();
      };
      this.loadValue = function(item3) {
        defaultValue = item3[args.column.field];
        $input.val(defaultValue);
        $input[0].defaultValue = defaultValue;
        $input.select();
      };
      this.serializeValue = function() {
        return $input.val();
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && $input.val() != defaultValue;
      };
      this.validate = function() {
        if (args.column.validator) {
          var validationResults = args.column.validator($input.val(), args);
          if (!validationResults.valid) {
            return validationResults;
          }
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function YesNoSelectEditor(args) {
      var $select;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        $select = $2("<SELECT tabIndex='0' class='editor-yesno'><OPTION value='yes'>Yes</OPTION><OPTION value='no'>No</OPTION></SELECT>");
        $select.appendTo(args.container);
        $select.focus();
        if (args.compositeEditorOptions) {
          $select.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        }
      };
      this.destroy = function() {
        $select.remove();
      };
      this.focus = function() {
        $select.focus();
      };
      this.loadValue = function(item3) {
        $select.val((defaultValue = item3[args.column.field]) ? "yes" : "no");
        $select.select();
      };
      this.serializeValue = function() {
        return $select.val() == "yes";
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return $select.val() != defaultValue;
      };
      this.validate = function() {
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function CheckboxEditor2(args) {
      var $select;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        $select = $2("<INPUT type=checkbox value='true' class='editor-checkbox' hideFocus>");
        $select.appendTo(args.container);
        $select.focus();
        if (args.compositeEditorOptions) {
          $select.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        }
      };
      this.destroy = function() {
        $select.remove();
      };
      this.focus = function() {
        $select.focus();
      };
      this.loadValue = function(item3) {
        defaultValue = !!item3[args.column.field];
        if (defaultValue) {
          $select.prop("checked", true);
        } else {
          $select.prop("checked", false);
        }
      };
      this.preClick = function() {
        $select.prop("checked", !$select.prop("checked"));
      };
      this.serializeValue = function() {
        return $select.prop("checked");
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return this.serializeValue() !== defaultValue;
      };
      this.validate = function() {
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function PercentCompleteEditor(args) {
      var $input, $picker;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        $input = $2("<INPUT type=text class='editor-percentcomplete' />");
        $input.width($2(args.container).innerWidth() - 25);
        $input.appendTo(args.container);
        $picker = $2("<div class='editor-percentcomplete-picker' />").appendTo(args.container);
        $picker.append("<div class='editor-percentcomplete-helper'><div class='editor-percentcomplete-wrapper'><div class='editor-percentcomplete-slider' /><div class='editor-percentcomplete-buttons' /></div></div>");
        $picker.find(".editor-percentcomplete-buttons").append("<button val=0>Not started</button><br/><button val=50>In Progress</button><br/><button val=100>Complete</button>");
        $input.focus().select();
        $picker.find(".editor-percentcomplete-slider").slider({
          orientation: "vertical",
          range: "min",
          value: defaultValue,
          slide: function(event2, ui) {
            $input.val(ui.value);
          },
          stop: function(event2, ui) {
            if (args.compositeEditorOptions) {
              var activeCell2 = args.grid.getActiveCell();
              if (scope2.validate().valid) {
                scope2.applyValue(scope2.args.item, scope2.serializeValue());
              }
              scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
              args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
            }
          }
        });
        $picker.find(".editor-percentcomplete-buttons button").on("click", function(e) {
          $input.val($2(this).attr("val"));
          $picker.find(".editor-percentcomplete-slider").slider("value", $2(this).attr("val"));
        });
      };
      this.destroy = function() {
        $input.remove();
        $picker.remove();
      };
      this.focus = function() {
        $input.focus();
      };
      this.loadValue = function(item3) {
        $input.val(defaultValue = item3[args.column.field]);
        $input.select();
      };
      this.serializeValue = function() {
        return parseInt($input.val(), 10) || 0;
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && (parseInt($input.val(), 10) || 0) != defaultValue;
      };
      this.validate = function() {
        if (isNaN(parseInt($input.val(), 10))) {
          return {
            valid: false,
            msg: "Please enter a valid positive number"
          };
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function LongTextEditor(args) {
      var $input, $wrapper;
      var defaultValue;
      var scope2 = this;
      this.args = args;
      this.init = function() {
        var compositeEditorOptions = args.compositeEditorOptions;
        var navOnLR = args.grid.getOptions().editorCellNavOnLRKeys;
        var $container2 = compositeEditorOptions ? args.container : $2("body");
        $wrapper = $2("<DIV class='slick-large-editor-text' style='z-index:10000;background:white;padding:5px;border:3px solid gray; border-radius:10px;'/>").appendTo($container2);
        if (compositeEditorOptions) {
          $wrapper.css({ position: "relative", padding: 0, border: 0 });
        } else {
          $wrapper.css({ position: "absolute" });
        }
        $input = $2("<TEXTAREA hidefocus rows=5 style='background:white;width:250px;height:80px;border:0;outline:0'>").appendTo($wrapper);
        if (compositeEditorOptions) {
          $input.on("change", function() {
            var activeCell2 = args.grid.getActiveCell();
            if (scope2.validate().valid) {
              scope2.applyValue(scope2.args.item, scope2.serializeValue());
            }
            scope2.applyValue(scope2.args.compositeEditorOptions.formValues, scope2.serializeValue());
            args.grid.onCompositeEditorChange.notify({ row: activeCell2.row, cell: activeCell2.cell, item: scope2.args.item, column: scope2.args.column, formValues: scope2.args.compositeEditorOptions.formValues });
          });
        } else {
          $2("<DIV style='text-align:right'><BUTTON>Save</BUTTON><BUTTON>Cancel</BUTTON></DIV>").appendTo($wrapper);
          $wrapper.find("button:first").on("click", this.save);
          $wrapper.find("button:last").on("click", this.cancel);
          $input.on("keydown", this.handleKeyDown);
          scope2.position(args.position);
        }
        $input.focus().select();
      };
      this.handleKeyDown = function(e) {
        if (e.which == Slick2.keyCode.ENTER && e.ctrlKey) {
          scope2.save();
        } else if (e.which == Slick2.keyCode.ESCAPE) {
          e.preventDefault();
          scope2.cancel();
        } else if (e.which == Slick2.keyCode.TAB && e.shiftKey) {
          e.preventDefault();
          args.grid.navigatePrev();
        } else if (e.which == Slick2.keyCode.TAB) {
          e.preventDefault();
          args.grid.navigateNext();
        } else if (e.which == Slick2.keyCode.LEFT || e.which == Slick2.keyCode.RIGHT) {
          if (args.grid.getOptions().editorCellNavOnLRKeys) {
            var cursorPosition = this.selectionStart;
            var textLength = this.value.length;
            if (e.keyCode === Slick2.keyCode.LEFT && cursorPosition === 0) {
              args.grid.navigatePrev();
            }
            if (e.keyCode === Slick2.keyCode.RIGHT && cursorPosition >= textLength - 1) {
              args.grid.navigateNext();
            }
          }
        }
      };
      this.save = function() {
        args.commitChanges();
      };
      this.cancel = function() {
        $input.val(defaultValue);
        args.cancelChanges();
      };
      this.hide = function() {
        $wrapper.hide();
      };
      this.show = function() {
        $wrapper.show();
      };
      this.position = function(position2) {
        $wrapper.css("top", position2.top - 5).css("left", position2.left - 5);
      };
      this.destroy = function() {
        $wrapper.remove();
      };
      this.focus = function() {
        $input.focus();
      };
      this.loadValue = function(item3) {
        $input.val(defaultValue = item3[args.column.field]);
        $input.select();
      };
      this.serializeValue = function() {
        return $input.val();
      };
      this.applyValue = function(item3, state) {
        item3[args.column.field] = state;
      };
      this.isValueChanged = function() {
        return !($input.val() === "" && defaultValue == null) && $input.val() != defaultValue;
      };
      this.validate = function() {
        if (args.column.validator) {
          var validationResults = args.column.validator($input.val(), args);
          if (!validationResults.valid) {
            return validationResults;
          }
        }
        return {
          valid: true,
          msg: null
        };
      };
      this.init();
    }
    function handleKeydownLRNav(e) {
      var cursorPosition = this.selectionStart;
      var textLength = this.value.length;
      if (e.keyCode === Slick2.keyCode.LEFT && cursorPosition > 0 || e.keyCode === Slick2.keyCode.RIGHT && cursorPosition < textLength - 1) {
        e.stopImmediatePropagation();
      }
    }
    function handleKeydownLRNoNav(e) {
      if (e.keyCode === Slick2.keyCode.LEFT || e.keyCode === Slick2.keyCode.RIGHT) {
        e.stopImmediatePropagation();
      }
    }
    module2.exports = {
      Editors: {
        Text: TextEditor2,
        Integer: IntegerEditor,
        Float: FloatEditor,
        Date: DateEditor2,
        YesNoSelect: YesNoSelectEditor,
        Checkbox: CheckboxEditor2,
        PercentComplete: PercentCompleteEditor,
        LongText: LongTextEditor
      }
    };
  }
});

// node_modules/@bokeh/slickgrid/slick.formatters.js
var require_slick_formatters = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.formatters.js"(exports4, module2) {
    var Slick2 = require_slick_core();
    function PercentCompleteFormatter(row2, cell, value2, columnDef, dataContext) {
      if (value2 == null || value2 === "") {
        return "-";
      } else if (value2 < 50) {
        return "<span style='color:red;font-weight:bold;'>" + value2 + "%</span>";
      } else {
        return "<span style='color:green'>" + value2 + "%</span>";
      }
    }
    function PercentCompleteBarFormatter(row2, cell, value2, columnDef, dataContext) {
      if (value2 == null || value2 === "") {
        return "";
      }
      var color;
      if (value2 < 30) {
        color = "red";
      } else if (value2 < 70) {
        color = "silver";
      } else {
        color = "green";
      }
      return "<span class='percent-complete-bar' style='background:" + color + ";width:" + value2 + "%'></span>";
    }
    function YesNoFormatter(row2, cell, value2, columnDef, dataContext) {
      return value2 ? "Yes" : "No";
    }
    function CheckboxFormatter(row2, cell, value2, columnDef, dataContext) {
      return '<img class="slick-edit-preclick" src="../images/' + (value2 ? "CheckboxY" : "CheckboxN") + '.png">';
    }
    function CheckmarkFormatter(row2, cell, value2, columnDef, dataContext) {
      return value2 ? "<img src='../images/tick.png'>" : "";
    }
    module2.exports = {
      Formatters: {
        PercentComplete: PercentCompleteFormatter,
        PercentCompleteBar: PercentCompleteBarFormatter,
        YesNo: YesNoFormatter,
        Checkmark: CheckmarkFormatter,
        Checkbox: CheckboxFormatter
      }
    };
  }
});

// node_modules/@bokeh/slickgrid/slick.remotemodel.js
var require_slick_remotemodel = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.remotemodel.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function RemoteModel() {
      var PAGESIZE = 50;
      var data3 = { length: 0 };
      var searchstr = "";
      var sortcol = null;
      var sortdir = 1;
      var h_request = null;
      var req = null;
      var onDataLoading = new Slick2.Event();
      var onDataLoaded = new Slick2.Event();
      function init4() {
      }
      function isDataLoaded(from, to) {
        for (var i2 = from; i2 <= to; i2++) {
          if (data3[i2] == void 0 || data3[i2] == null) {
            return false;
          }
        }
        return true;
      }
      function clear2() {
        for (var key in data3) {
          delete data3[key];
        }
        data3.length = 0;
      }
      function ensureData(from, to) {
        if (req) {
          req.abort();
          for (var i2 = req.fromPage; i2 <= req.toPage; i2++)
            data3[i2 * PAGESIZE] = void 0;
        }
        if (from < 0) {
          from = 0;
        }
        if (data3.length > 0) {
          to = Math.min(to, data3.length - 1);
        }
        var fromPage = Math.floor(from / PAGESIZE);
        var toPage = Math.floor(to / PAGESIZE);
        while (data3[fromPage * PAGESIZE] !== void 0 && fromPage < toPage)
          fromPage++;
        while (data3[toPage * PAGESIZE] !== void 0 && fromPage < toPage)
          toPage--;
        if (fromPage > toPage || fromPage == toPage && data3[fromPage * PAGESIZE] !== void 0) {
          onDataLoaded.notify({ from, to });
          return;
        }
        var url2 = "http://octopart.com/api/v3/parts/search?apikey=68b25f31&include[]=short_description&show[]=uid&show[]=manufacturer&show[]=mpn&show[]=brand&show[]=octopart_url&show[]=short_description&q=" + searchstr + "&start=" + fromPage * PAGESIZE + "&limit=" + ((toPage - fromPage) * PAGESIZE + PAGESIZE);
        if (sortcol != null) {
          url2 += "&sortby=" + sortcol + (sortdir > 0 ? "+asc" : "+desc");
        }
        if (h_request != null) {
          clearTimeout(h_request);
        }
        h_request = setTimeout(function() {
          for (var i3 = fromPage; i3 <= toPage; i3++)
            data3[i3 * PAGESIZE] = null;
          onDataLoading.notify({ from, to });
          req = $2.jsonp({
            url: url2,
            callbackParameter: "callback",
            cache: true,
            success: onSuccess,
            error: function() {
              onError(fromPage, toPage);
            }
          });
          req.fromPage = fromPage;
          req.toPage = toPage;
        }, 50);
      }
      function onError(fromPage, toPage) {
        alert("error loading pages " + fromPage + " to " + toPage);
      }
      function onSuccess(resp) {
        var from = resp.request.start, to = from + resp.results.length;
        data3.length = Math.min(parseInt(resp.hits), 1e3);
        for (var i2 = 0; i2 < resp.results.length; i2++) {
          var item3 = resp.results[i2].item;
          data3[from + i2] = item3;
          data3[from + i2].index = from + i2;
        }
        req = null;
        onDataLoaded.notify({ from, to });
      }
      function reloadData(from, to) {
        for (var i2 = from; i2 <= to; i2++)
          delete data3[i2];
        ensureData(from, to);
      }
      function setSort(column, dir) {
        sortcol = column;
        sortdir = dir;
        clear2();
      }
      function setSearch(str) {
        searchstr = str;
        clear2();
      }
      init4();
      return {
        // properties
        "data": data3,
        // methods
        "clear": clear2,
        "isDataLoaded": isDataLoaded,
        "ensureData": ensureData,
        "reloadData": reloadData,
        "setSort": setSort,
        "setSearch": setSearch,
        // events
        "onDataLoading": onDataLoading,
        "onDataLoaded": onDataLoaded
      };
    }
    module2.exports = {
      RemoteModel
    };
  }
});

// node_modules/@bokeh/slickgrid/slick.groupitemmetadataprovider.js
var require_slick_groupitemmetadataprovider = __commonJS({
  "node_modules/@bokeh/slickgrid/slick.groupitemmetadataprovider.js"(exports4, module2) {
    var $2 = require_slick_jquery();
    var Slick2 = require_slick_core();
    function GroupItemMetadataProvider(inputOptions) {
      var _grid;
      var _defaults = {
        checkboxSelect: false,
        checkboxSelectCssClass: "slick-group-select-checkbox",
        checkboxSelectPlugin: null,
        groupCssClass: "slick-group",
        groupTitleCssClass: "slick-group-title",
        totalsCssClass: "slick-group-totals",
        groupFocusable: true,
        totalsFocusable: false,
        toggleCssClass: "slick-group-toggle",
        toggleExpandedCssClass: "expanded",
        toggleCollapsedCssClass: "collapsed",
        enableExpandCollapse: true,
        groupFormatter: defaultGroupCellFormatter,
        totalsFormatter: defaultTotalsCellFormatter,
        includeHeaderTotals: false
      };
      var options2 = $2.extend(true, {}, _defaults, inputOptions);
      function getOptions2() {
        return options2;
      }
      function setOptions2(inputOptions2) {
        $2.extend(true, options2, inputOptions2);
      }
      function defaultGroupCellFormatter(row2, cell, value2, columnDef, item3, grid) {
        if (!options2.enableExpandCollapse) {
          return item3.title;
        }
        var indentation = item3.level * 15 + "px";
        return (options2.checkboxSelect ? '<span class="' + options2.checkboxSelectCssClass + " " + (item3.selectChecked ? "checked" : "unchecked") + '"></span>' : "") + "<span class='" + options2.toggleCssClass + " " + (item3.collapsed ? options2.toggleCollapsedCssClass : options2.toggleExpandedCssClass) + "' style='margin-left:" + indentation + "'></span><span class='" + options2.groupTitleCssClass + "' level='" + item3.level + "'>" + item3.title + "</span>";
      }
      function defaultTotalsCellFormatter(row2, cell, value2, columnDef, item3, grid) {
        return columnDef.groupTotalsFormatter && columnDef.groupTotalsFormatter(item3, columnDef, grid) || "";
      }
      function init4(grid) {
        _grid = grid;
        _grid.onClick.subscribe(handleGridClick2);
        _grid.onKeyDown.subscribe(handleGridKeyDown);
      }
      function destroy2() {
        if (_grid) {
          _grid.onClick.unsubscribe(handleGridClick2);
          _grid.onKeyDown.unsubscribe(handleGridKeyDown);
        }
      }
      function handleGridClick2(e, args) {
        var $target = $2(e.target);
        var item3 = this.getDataItem(args.row);
        if (item3 && item3 instanceof Slick2.Group && $target.hasClass(options2.toggleCssClass)) {
          var range2 = _grid.getRenderedRange();
          this.getData().setRefreshHints({
            ignoreDiffsBefore: range2.top,
            ignoreDiffsAfter: range2.bottom + 1
          });
          if (item3.collapsed) {
            this.getData().expandGroup(item3.groupingKey);
          } else {
            this.getData().collapseGroup(item3.groupingKey);
          }
          e.stopImmediatePropagation();
          e.preventDefault();
        }
        if (item3 && item3 instanceof Slick2.Group && $target.hasClass(options2.checkboxSelectCssClass)) {
          item3.selectChecked = !item3.selectChecked;
          $target.removeClass(item3.selectChecked ? "unchecked" : "checked");
          $target.addClass(item3.selectChecked ? "checked" : "unchecked");
          var rowIndexes = _grid.getData().mapItemsToRows(item3.rows);
          (item3.selectChecked ? options2.checkboxSelectPlugin.selectRows : options2.checkboxSelectPlugin.deSelectRows)(rowIndexes);
        }
      }
      function handleGridKeyDown(e, args) {
        if (options2.enableExpandCollapse && e.which == Slick2.keyCode.SPACE) {
          var activeCell2 = this.getActiveCell();
          if (activeCell2) {
            var item3 = this.getDataItem(activeCell2.row);
            if (item3 && item3 instanceof Slick2.Group) {
              var range2 = _grid.getRenderedRange();
              this.getData().setRefreshHints({
                ignoreDiffsBefore: range2.top,
                ignoreDiffsAfter: range2.bottom + 1
              });
              if (item3.collapsed) {
                this.getData().expandGroup(item3.groupingKey);
              } else {
                this.getData().collapseGroup(item3.groupingKey);
              }
              e.stopImmediatePropagation();
              e.preventDefault();
            }
          }
        }
      }
      function getGroupRowMetadata(item3) {
        var groupLevel = item3 && item3.level;
        return {
          selectable: false,
          focusable: options2.groupFocusable,
          cssClasses: options2.groupCssClass + " slick-group-level-" + groupLevel,
          formatter: options2.includeHeaderTotals && options2.totalsFormatter,
          columns: {
            0: {
              colspan: options2.includeHeaderTotals ? "1" : "*",
              formatter: options2.groupFormatter,
              editor: null
            }
          }
        };
      }
      function getTotalsRowMetadata(item3) {
        var groupLevel = item3 && item3.group && item3.group.level;
        return {
          selectable: false,
          focusable: options2.totalsFocusable,
          cssClasses: options2.totalsCssClass + " slick-group-level-" + groupLevel,
          formatter: options2.totalsFormatter,
          editor: null
        };
      }
      return {
        "init": init4,
        "destroy": destroy2,
        "getGroupRowMetadata": getGroupRowMetadata,
        "getTotalsRowMetadata": getTotalsRowMetadata,
        "getOptions": getOptions2,
        "setOptions": setOptions2
      };
    }
    module2.exports = {
      GroupItemMetadataProvider
    };
  }
});

// node_modules/@bokeh/slickgrid/index.js
var require_slickgrid = __commonJS({
  "node_modules/@bokeh/slickgrid/index.js"(exports4, module2) {
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib.__exportStar(require_slick_core(), module2.exports);
    tslib.__exportStar(require_slick_grid(), module2.exports);
    tslib.__exportStar(require_slick_dataview(), module2.exports);
    tslib.__exportStar(require_slick_editors(), module2.exports);
    tslib.__exportStar(require_slick_formatters(), module2.exports);
    tslib.__exportStar(require_slick_remotemodel(), module2.exports);
    tslib.__exportStar(require_slick_groupitemmetadataprovider(), module2.exports);
  }
});

// node_modules/@bokeh/bokehjs/build/js/lib/embed/index.js
var embed_exports = {};
__export(embed_exports, {
  add_document_from_session: () => add_document_from_session,
  add_document_standalone: () => add_document_standalone,
  embed_item: () => embed_item,
  embed_items: () => embed_items,
  embed_items_notebook: () => embed_items_notebook,
  index: () => index,
  kernels: () => kernels
});

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/string.js
function uuid4() {
  const s2 = new Array(32);
  const hex_digits = "0123456789ABCDEF";
  for (let i2 = 0; i2 < 32; i2++) {
    s2[i2] = hex_digits[Math.floor(Math.random() * 16)];
  }
  s2[12] = "4";
  s2[16] = hex_digits[s2[16].charCodeAt(0) & 3 | 8];
  return s2.join("");
}
var counter = 1e3;
function unique_id(prefix) {
  const id = settings.dev ? `j${counter++}` : uuid4();
  if (prefix != null) {
    return `${prefix}-${id}`;
  } else {
    return id;
  }
}
function escape(s2) {
  return s2.replace(/(?:[&<>"'`])/g, (ch) => {
    switch (ch) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&#x27;";
      case "`":
        return "&#x60;";
      default:
        return ch;
    }
  });
}
function unescape(s2) {
  return s2.replace(/&(amp|lt|gt|quot|#x27|#x60);/g, (_2, entity) => {
    switch (entity) {
      case "amp":
        return "&";
      case "lt":
        return "<";
      case "gt":
        return ">";
      case "quot":
        return '"';
      case "#x27":
        return "'";
      case "#x60":
        return "`";
      default:
        return entity;
    }
  });
}
function use_strict(code2) {
  return `'use strict';
${code2}`;
}
function to_fixed(val, precision) {
  return val.toFixed(precision).replace(/(\.[0-9]*?)0+$/, "$1").replace(/\.$/, "");
}
function insert_text_on_position(destination, position2, text_to_be_inserted) {
  const result_text = [];
  result_text.push(destination.slice(0, position2));
  result_text.push(text_to_be_inserted);
  result_text.push(destination.slice(position2));
  return result_text.join("");
}

// node_modules/@bokeh/bokehjs/build/js/lib/document/events.js
var DocumentEvent = class {
  constructor(document2) {
    __publicField(this, "document");
    /**
     * Indicates whether this event should be emitted internally within bokehjs,
     * or whether it should also be synchronized with the server, if any session
     * is listening for such events.
     */
    __publicField(this, "sync", true);
    this.document = document2;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.__name__;
  }
  [equals](that, cmp) {
    return cmp.eq(this.document, that.document);
  }
};
__publicField(DocumentEvent, "__name__", "DocumentEvent");
var DocumentEventBatch = class extends DocumentEvent {
  constructor(document2, events3) {
    super(document2);
    __publicField(this, "events");
    this.events = events3;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.events, that.events);
  }
};
__publicField(DocumentEventBatch, "__name__", "DocumentEventBatch");
var DocumentChangedEvent = class extends DocumentEvent {
};
__publicField(DocumentChangedEvent, "__name__", "DocumentChangedEvent");
var MessageSentEvent = class extends DocumentChangedEvent {
  constructor(document2, msg_type, msg_data) {
    super(document2);
    __publicField(this, "msg_type");
    __publicField(this, "msg_data");
    __publicField(this, "kind", "MessageSent");
    this.msg_type = msg_type;
    this.msg_data = msg_data;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.msg_type, that.msg_type) && cmp.eq(this.msg_data, that.msg_data);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      msg_type: this.msg_type,
      msg_data: serializer.encode(this.msg_data)
    };
  }
};
__publicField(MessageSentEvent, "__name__", "MessageSentEvent");
var ModelChangedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2, attr2, value2) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "attr");
    __publicField(this, "value");
    __publicField(this, "kind", "ModelChanged");
    this.model = model2;
    this.attr = attr2;
    this.value = value2;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model) && cmp.eq(this.attr, that.attr) && cmp.eq(this.value, that.value);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      model: this.model.ref(),
      attr: this.attr,
      new: serializer.encode(this.value)
    };
  }
};
__publicField(ModelChangedEvent, "__name__", "ModelChangedEvent");
var ColumnDataChangedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2, attr2, data3, cols) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "attr");
    __publicField(this, "data");
    __publicField(this, "cols");
    __publicField(this, "kind", "ColumnDataChanged");
    this.model = model2;
    this.attr = attr2;
    this.data = data3;
    this.cols = cols;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model) && cmp.eq(this.attr, that.attr) && cmp.eq(this.data, that.data) && cmp.eq(this.cols, that.cols);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      model: this.model.ref(),
      attr: this.attr,
      data: serializer.encode(this.data),
      cols: this.cols
    };
  }
};
__publicField(ColumnDataChangedEvent, "__name__", "ColumnDataChangedEvent");
var ColumnsStreamedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2, attr2, data3, rollover) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "attr");
    __publicField(this, "data");
    __publicField(this, "rollover");
    __publicField(this, "kind", "ColumnsStreamed");
    this.model = model2;
    this.attr = attr2;
    this.data = data3;
    this.rollover = rollover;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model) && cmp.eq(this.attr, that.attr) && cmp.eq(this.data, that.data) && cmp.eq(this.rollover, that.rollover);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      model: this.model.ref(),
      attr: this.attr,
      data: serializer.encode(this.data),
      rollover: this.rollover
    };
  }
};
__publicField(ColumnsStreamedEvent, "__name__", "ColumnsStreamedEvent");
var ColumnsPatchedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2, attr2, patches) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "attr");
    __publicField(this, "patches");
    __publicField(this, "kind", "ColumnsPatched");
    this.model = model2;
    this.attr = attr2;
    this.patches = patches;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model) && cmp.eq(this.attr, that.attr) && cmp.eq(this.patches, that.patches);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      attr: this.attr,
      model: this.model.ref(),
      patches: serializer.encode(this.patches)
    };
  }
};
__publicField(ColumnsPatchedEvent, "__name__", "ColumnsPatchedEvent");
var TitleChangedEvent = class extends DocumentChangedEvent {
  constructor(document2, title3) {
    super(document2);
    __publicField(this, "title");
    __publicField(this, "kind", "TitleChanged");
    this.title = title3;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.title, that.title);
  }
  [serialize](_serializer) {
    return {
      kind: this.kind,
      title: this.title
    };
  }
};
__publicField(TitleChangedEvent, "__name__", "TitleChangedEvent");
var RootAddedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "kind", "RootAdded");
    this.model = model2;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model);
  }
  [serialize](serializer) {
    return {
      kind: this.kind,
      model: serializer.encode(this.model)
    };
  }
};
__publicField(RootAddedEvent, "__name__", "RootAddedEvent");
var RootRemovedEvent = class extends DocumentChangedEvent {
  constructor(document2, model2) {
    super(document2);
    __publicField(this, "model");
    __publicField(this, "kind", "RootRemoved");
    this.model = model2;
  }
  [equals](that, cmp) {
    return super[equals](that, cmp) && cmp.eq(this.model, that.model);
  }
  [serialize](_serializer) {
    return {
      kind: this.kind,
      model: this.model.ref()
    };
  }
};
__publicField(RootRemovedEvent, "__name__", "RootRemovedEvent");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/pretty.js
var pretty = Symbol("pretty");
function is_Printable(obj) {
  return isObject(obj) && pretty in obj;
}
var Printer = class {
  constructor(options2) {
    __publicField(this, "precision");
    __publicField(this, "visited", /* @__PURE__ */ new Set());
    this.precision = options2 == null ? void 0 : options2.precision;
  }
  to_string(obj) {
    if (isObject(obj)) {
      if (this.visited.has(obj)) {
        return "<circular>";
      } else {
        this.visited.add(obj);
      }
    }
    if (is_Printable(obj)) {
      return obj[pretty](this);
    } else if (isBoolean(obj)) {
      return this.boolean(obj);
    } else if (isNumber(obj)) {
      return this.number(obj);
    } else if (isString(obj)) {
      return this.string(obj);
    } else if (isArray(obj)) {
      return this.array(obj);
    } else if (isIterable(obj)) {
      return this.iterable(obj);
    } else if (isPlainObject(obj)) {
      return this.object(obj);
    } else if (isSymbol(obj)) {
      return this.symbol(obj);
    } else if (obj instanceof ArrayBuffer) {
      return this.array_buffer(obj);
    } else {
      return `${obj}`;
    }
  }
  token(val) {
    return val;
  }
  boolean(val) {
    return `${val}`;
  }
  number(val) {
    if (this.precision != null) {
      return val.toFixed(this.precision);
    } else {
      return `${val}`;
    }
  }
  string(val) {
    const sq = val.includes("'");
    const dq = val.includes('"');
    if (sq && dq) {
      return `\`${val.replace(/`/g, "\\`")}\``;
    } else if (dq) {
      return `'${val}'`;
    } else {
      return `"${val}"`;
    }
  }
  symbol(val) {
    return val.toString();
  }
  array(obj) {
    const T = this.token;
    const items = [];
    for (const entry2 of obj) {
      items.push(this.to_string(entry2));
    }
    return `${T("[")}${items.join(`${T(",")} `)}${T("]")}`;
  }
  iterable(obj) {
    const T = this.token;
    const tag = Object(obj)[Symbol.toStringTag] ?? "Object";
    const items = this.array(obj);
    return `${tag}${T("(")}${items}${T(")")}`;
  }
  object(obj) {
    const T = this.token;
    const items = [];
    for (const [key, val] of entries(obj)) {
      items.push(`${key}${T(":")} ${this.to_string(val)}`);
    }
    return `${T("{")}${items.join(`${T(",")} `)}${T("}")}`;
  }
  array_buffer(obj) {
    return `ArrayBuffer(#${obj.byteLength})`;
  }
};
__publicField(Printer, "__name__", "Printer");
function to_string(obj, options2) {
  const printer = new Printer(options2);
  return printer.to_string(obj);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/set.js
function union2(...sets) {
  const result = /* @__PURE__ */ new Set();
  for (const set of sets) {
    for (const item3 of set) {
      result.add(item3);
    }
  }
  return result;
}
function difference2(set, ...sets) {
  const result = new Set(set);
  for (const item3 of union2(...sets)) {
    result.delete(item3);
  }
  return result;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/typed_array.js
function concat2(array0, ...arrays) {
  let n2 = array0.length;
  for (const array2 of arrays) {
    n2 += array2.length;
  }
  const result = new array0.constructor(n2);
  result.set(array0, 0);
  let i2 = array0.length;
  for (const array2 of arrays) {
    result.set(array2, i2);
    i2 += array2.length;
  }
  return result;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/patching.js
function stream_to_column(col2, new_col, rollover) {
  if (isArray(col2) && isArray(new_col)) {
    const result = col2.concat(new_col);
    if (rollover != null && result.length > rollover) {
      return result.slice(-rollover);
    } else {
      return result;
    }
  }
  const total_len = col2.length + new_col.length;
  if (rollover != null && total_len > rollover) {
    const start2 = total_len - rollover;
    const end = col2.length;
    const result = (() => {
      if (col2.length < rollover) {
        const ctor = (() => {
          if (isTypedArray(col2)) {
            return col2.constructor;
          } else if (isTypedArray(new_col)) {
            return new_col.constructor;
          } else {
            throw new Error("unsupported array types");
          }
        })();
        const result2 = new ctor(rollover);
        result2.set(col2, 0);
        return result2;
      } else {
        return col2;
      }
    })();
    for (let i2 = start2, endi = end; i2 < endi; i2++) {
      result[i2 - start2] = result[i2];
    }
    for (let i2 = 0, endi = new_col.length; i2 < endi; i2++) {
      result[i2 + (end - start2)] = new_col[i2];
    }
    return result;
  } else {
    const col_ = (() => {
      if (isTypedArray(col2)) {
        return col2;
      } else if (isTypedArray(new_col)) {
        return new new_col.constructor(col2);
      } else {
        throw new Error("unsupported array types");
      }
    })();
    return concat2(col_, new_col);
  }
}
function slice(ind, length) {
  let start2, step, stop;
  if (isNumber(ind)) {
    start2 = ind;
    stop = ind + 1;
    step = 1;
  } else {
    start2 = ind.start != null ? ind.start : 0;
    stop = ind.stop != null ? ind.stop : length;
    step = ind.step != null ? ind.step : 1;
  }
  return [start2, stop, step];
}
function patch_to_column(col2, patch) {
  const patched = /* @__PURE__ */ new Set();
  let patched_range = false;
  for (const [ind, val] of patch) {
    let shape;
    let item3;
    let index2;
    let value2;
    if (isArray(ind)) {
      const [i2] = ind;
      patched.add(i2);
      shape = col2[i2].shape;
      item3 = col2[i2];
      value2 = val;
      if (ind.length === 2) {
        shape = [1, shape[0]];
        index2 = [ind[0], 0, ind[1]];
      } else {
        index2 = ind;
      }
    } else {
      if (isNumber(ind)) {
        value2 = [val];
        patched.add(ind);
      } else {
        value2 = val;
        patched_range = true;
      }
      index2 = [0, 0, ind];
      shape = [1, col2.length];
      item3 = col2;
    }
    let flat_index = 0;
    const [istart, istop, istep] = slice(index2[1], shape[0]);
    const [jstart, jstop, jstep] = slice(index2[2], shape[1]);
    for (let i2 = istart; i2 < istop; i2 += istep) {
      for (let j = jstart; j < jstop; j += jstep) {
        if (patched_range) {
          patched.add(j);
        }
        item3[i2 * shape[1] + j] = value2[flat_index];
        flat_index++;
      }
    }
  }
  return patched;
}
function stream_to_columns(old_data, new_data, rollover) {
  const data3 = dict(old_data);
  for (const [name, new_column] of dict(new_data)) {
    const old_column = data3.get(name) ?? [];
    data3.set(name, stream_to_column(old_column, new_column, rollover));
  }
}
function patch_to_columns(old_data, patches) {
  const data3 = dict(old_data);
  let patched = /* @__PURE__ */ new Set();
  for (const [name, patch] of dict(patches)) {
    const old_column = data3.get(name) ?? [];
    patched = union2(patched, patch_to_column(old_column, patch));
  }
  return patched;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/has_props.js
var _qualified_names = /* @__PURE__ */ new WeakMap();
var _HasProps = class _HasProps extends Signalable() {
  constructor(attrs = {}) {
    super();
    __publicField(this, "id");
    __publicField(this, "document", null);
    __publicField(this, "destroyed", new Signal0(this, "destroyed"));
    __publicField(this, "change", new Signal0(this, "change"));
    __publicField(this, "transformchange", new Signal0(this, "transformchange"));
    __publicField(this, "exprchange", new Signal0(this, "exprchange"));
    __publicField(this, "streaming", new Signal0(this, "streaming"));
    __publicField(this, "patching", new Signal(this, "patching"));
    __publicField(this, "properties", {});
    __publicField(this, "_watchers", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_pending", false);
    __publicField(this, "_changing", false);
    const deferred = isPlainObject(attrs) && "id" in attrs;
    this.id = deferred ? attrs.id : unique_id();
    for (const [name, { type, default_value, options: options2 }] of entries(this._props)) {
      let property;
      if (type instanceof PropertyAlias) {
        const property2 = this.properties[type.attr];
        if (typeof property2 === "undefined") {
          throw new Error(`can't resolve ${type.attr} before ${name} to create an alias`);
        }
        Object.defineProperty(this.properties, name, {
          get: () => property2,
          configurable: false,
          enumerable: false
        });
      } else {
        if (type instanceof Kind) {
          property = new PrimitiveProperty(this, name, type, default_value, options2);
        } else {
          property = new type(this, name, Any, default_value, options2);
        }
        this.properties[name] = property;
      }
    }
    if (deferred) {
      assert(keys(attrs).length == 1, "'id' cannot be used together with property initializers");
    } else {
      this.initialize_props(attrs);
      this.finalize();
      this.connect_signals();
    }
  }
  get is_syncable() {
    return true;
  }
  get type() {
    return this.constructor.__qualified__;
  }
  static get __qualified__() {
    let qualified = _qualified_names.get(this);
    if (qualified == null) {
      const { __module__, __name__ } = this;
      qualified = __module__ != null ? `${__module__}.${__name__}` : __name__;
      _qualified_names.set(this, qualified);
    }
    return qualified;
  }
  static set __qualified__(qualified) {
    _qualified_names.set(this, qualified);
  }
  get [Symbol.toStringTag]() {
    return this.constructor.__qualified__;
  }
  static _fix_default(default_value, _attr) {
    if (default_value === void 0 || default_value === unset) {
      return () => unset;
    } else if (isFunction(default_value)) {
      return default_value;
    } else if (isPrimitive(default_value)) {
      return () => default_value;
    } else {
      const cloner = new Cloner();
      return () => cloner.clone(default_value);
    }
  }
  // TODO: don't use Partial<>, but exclude inherited properties
  static define(obj) {
    for (const [name, prop] of entries(isFunction(obj) ? obj(kinds_exports) : obj)) {
      if (name in this.prototype._props) {
        throw new Error(`attempted to redefine property '${this.prototype.type}.${name}'`);
      }
      if (name in this.prototype) {
        throw new Error(`attempted to redefine attribute '${this.prototype.type}.${name}'`);
      }
      Object.defineProperty(this.prototype, name, {
        // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306
        get() {
          const value2 = this.properties[name].get_value();
          return value2;
        },
        set(value2) {
          this.setv({ [name]: value2 });
          return this;
        },
        configurable: false,
        enumerable: true
      });
      const [type, default_value, options2 = {}] = prop;
      const refined_prop = {
        type,
        default_value: this._fix_default(default_value, name),
        options: options2
      };
      this.prototype._props = {
        ...this.prototype._props,
        [name]: refined_prop
      };
    }
  }
  static internal(obj) {
    const _object = {};
    for (const [name, prop] of entries(isFunction(obj) ? obj(kinds_exports) : obj)) {
      const [type, default_value, options2 = {}] = prop;
      _object[name] = [type, default_value, { ...options2, internal: true }];
    }
    this.define(_object);
  }
  static mixins(defs2) {
    function rename2(prefix, mixin) {
      const result = {};
      for (const [name, prop] of entries(mixin)) {
        result[prefix + name] = prop;
      }
      return result;
    }
    const mixin_defs = {};
    const mixins = [];
    for (const def of isArray(defs2) ? defs2 : [defs2]) {
      if (isArray(def)) {
        const [prefix, mixin] = def;
        extend(mixin_defs, rename2(prefix, mixin));
        mixins.push([prefix, mixin]);
      } else {
        const mixin = def;
        extend(mixin_defs, mixin);
        mixins.push(["", mixin]);
      }
    }
    this.define(mixin_defs);
    this.prototype._mixins = [...this.prototype._mixins, ...mixins];
  }
  static override(obj) {
    for (const [name, prop] of entries(obj)) {
      const default_value = this._fix_default(prop, name);
      if (!(name in this.prototype._props)) {
        throw new Error(`attempted to override nonexistent '${this.prototype.type}.${name}'`);
      }
      const value2 = this.prototype._props[name];
      const props = { ...this.prototype._props };
      props[name] = { ...value2, default_value };
      this.prototype._props = props;
    }
  }
  static toString() {
    return this.__qualified__;
  }
  toString() {
    return `${this.type}(${this.id})`;
  }
  property(name) {
    if (name in this.properties) {
      return this.properties[name];
    } else {
      throw new Error(`unknown property ${this.type}.${name}`);
    }
  }
  get attributes() {
    const attrs = {};
    for (const prop of this) {
      if (!prop.is_unset) {
        attrs[prop.attr] = prop.get_value();
      }
    }
    return attrs;
  }
  [clone2](cloner) {
    const attrs = /* @__PURE__ */ new Map();
    for (const prop of this) {
      if (prop.dirty) {
        attrs.set(prop.attr, cloner.clone(prop.get_value()));
      }
    }
    return new this.constructor(attrs);
  }
  [equals](that, cmp) {
    for (const p0 of this) {
      const p1 = that.property(p0.attr);
      if (!cmp.eq(p0.get_value(), p1.get_value())) {
        return false;
      }
    }
    return true;
  }
  [pretty](printer) {
    const T = printer.token;
    const items = [];
    for (const prop of this) {
      if (prop.dirty) {
        const value2 = prop.get_value();
        items.push(`${prop.attr}${T(":")} ${printer.to_string(value2)}`);
      }
    }
    const cls = this.constructor.__qualified__;
    return `${cls}${T("(")}${T("{")}${items.join(`${T(",")} `)}${T("}")}${T(")")}`;
  }
  [serialize](serializer) {
    const ref = this.ref();
    serializer.add_ref(this, ref);
    const attributes = {};
    for (const prop of this) {
      if (prop.syncable && (serializer.include_defaults || prop.dirty) && !(prop.readonly && prop.is_unset)) {
        const value2 = prop.get_value();
        attributes[prop.attr] = serializer.encode(value2);
      }
    }
    const { type: name, id } = this;
    const rep = { type: "object", name, id };
    return is_empty2(attributes) ? rep : { ...rep, attributes };
  }
  initialize_props(vals) {
    const vals_proxy = dict(vals);
    const visited = /* @__PURE__ */ new Set();
    for (const prop of this) {
      const val = vals_proxy.get(prop.attr);
      prop.initialize(val);
      visited.add(prop.attr);
    }
    for (const [attr2, val] of vals_proxy) {
      if (!visited.has(attr2)) {
        this.property(attr2).set_value(val);
      }
    }
  }
  finalize() {
    this.initialize();
  }
  initialize() {
  }
  assert_initialized() {
    for (const prop of this) {
      if (prop.syncable && !prop.readonly) {
        prop.get_value();
      }
    }
  }
  connect_signals() {
    for (const prop of this) {
      if (!(prop instanceof VectorSpec || prop instanceof ScalarSpec)) {
        continue;
      }
      if (prop.is_unset) {
        continue;
      }
      const value2 = prop.get_value();
      if (value2.transform != null) {
        this.connect(value2.transform.change, () => this.transformchange.emit());
      }
      if (isExpr(value2)) {
        this.connect(value2.expr.change, () => this.exprchange.emit());
      }
    }
  }
  disconnect_signals() {
    Signal.disconnect_receiver(this);
  }
  destroy() {
    this.disconnect_signals();
    this.destroyed.emit();
  }
  // Create a new model with exact attribute values to this one, but new identity.
  clone(attrs) {
    const cloner = new Cloner();
    const that = cloner.clone(this);
    if (attrs != null) {
      that.setv(attrs);
    }
    return that;
  }
  _clear_watchers() {
    this._watchers = /* @__PURE__ */ new WeakMap();
  }
  changed_for(obj) {
    const changed = this._watchers.get(obj);
    this._watchers.set(obj, false);
    return changed ?? true;
  }
  // Set a hash of model attributes on the object, firing `"change"`. This is
  // the core primitive operation of a model, updating the data and notifying
  // anyone who needs to know about the change in state. The heart of the beast.
  _setv(changes, options2) {
    const check_eq = options2.check_eq;
    const changed = /* @__PURE__ */ new Set();
    const changing = this._changing;
    this._changing = true;
    for (const [prop, value2] of changes) {
      if (check_eq === false || prop.is_unset || !is_equal(prop.get_value(), value2)) {
        prop.set_value(value2);
        changed.add(prop);
      }
    }
    if (changed.size > 0) {
      this._clear_watchers();
      this._pending = true;
    }
    for (const prop of changed) {
      prop.change.emit();
    }
    if (!changing) {
      if (!(options2.no_change ?? false)) {
        while (this._pending) {
          this._pending = false;
          this.change.emit();
        }
      }
      this._pending = false;
      this._changing = false;
    }
    return changed;
  }
  setv(changed_attrs, options2 = {}) {
    const changes = entries(changed_attrs);
    if (changes.length == 0) {
      return;
    }
    if (options2.silent ?? false) {
      this._clear_watchers();
      for (const [attr2, value2] of changes) {
        this.properties[attr2].set_value(value2);
      }
      return;
    }
    const changed = /* @__PURE__ */ new Map();
    const previous = /* @__PURE__ */ new Map();
    for (const [attr2, value2] of changes) {
      const prop = this.properties[attr2];
      changed.set(prop, value2);
      previous.set(prop, prop.is_unset ? void 0 : prop.get_value());
    }
    const updated = this._setv(changed, options2);
    const { document: document2 } = this;
    if (document2 != null) {
      const changed2 = [];
      for (const [prop, value2] of previous) {
        if (updated.has(prop)) {
          changed2.push([prop, value2, prop.get_value()]);
        }
      }
      for (const [prop, old_value, new_value] of changed2) {
        if (prop.may_have_refs && this._needs_invalidate(old_value, new_value)) {
          document2._invalidate_all_models();
          break;
        }
      }
      const sync = options2.sync ?? true;
      this._push_changes(changed2, sync);
    }
  }
  ref() {
    return { id: this.id };
  }
  *[Symbol.iterator]() {
    yield* values(this.properties);
  }
  *syncable_properties() {
    for (const prop of this) {
      if (prop.syncable) {
        yield prop;
      }
    }
  }
  *own_properties() {
    const self2 = Object.getPrototypeOf(this);
    const base2 = Object.getPrototypeOf(self2);
    const exclude = new Set(keys(base2._props));
    for (const prop of this) {
      if (!exclude.has(prop.attr)) {
        yield prop;
      }
    }
  }
  // add all references from 'v' to 'result', if recurse
  // is true then descend into refs, if false only
  // descend into non-refs
  static _value_record_references(value2, refs, options2) {
    if (!isObject(value2) || !may_have_refs(value2)) {
      return;
    }
    const { recursive } = options2;
    if (value2 instanceof _HasProps) {
      if (!refs.has(value2)) {
        refs.add(value2);
        if (recursive) {
          for (const prop of value2.syncable_properties()) {
            if (!prop.is_unset && prop.may_have_refs) {
              const value3 = prop.get_value();
              _HasProps._value_record_references(value3, refs, { recursive });
            }
          }
        }
      }
    } else if (isIterable(value2)) {
      for (const elem of value2) {
        _HasProps._value_record_references(elem, refs, { recursive });
      }
    } else if (isPlainObject(value2)) {
      for (const elem of values(value2)) {
        _HasProps._value_record_references(elem, refs, { recursive });
      }
    }
  }
  static references(value2, options2) {
    const refs = /* @__PURE__ */ new Set();
    _HasProps._value_record_references(value2, refs, options2);
    return refs;
  }
  references() {
    return _HasProps.references(this, { recursive: true });
  }
  _doc_attached() {
  }
  _doc_detached() {
  }
  attach_document(doc) {
    if (this.document != null) {
      if (this.document == doc) {
        return;
      } else {
        throw new Error("models must be owned by only a single document");
      }
    }
    this.document = doc;
    this._doc_attached();
  }
  detach_document() {
    this._doc_detached();
    this.document = null;
  }
  _needs_invalidate(old_value, new_value) {
    const new_refs = /* @__PURE__ */ new Set();
    _HasProps._value_record_references(new_value, new_refs, { recursive: false });
    const old_refs = /* @__PURE__ */ new Set();
    _HasProps._value_record_references(old_value, old_refs, { recursive: false });
    for (const new_id of new_refs) {
      if (!old_refs.has(new_id)) {
        return true;
      }
    }
    for (const old_id of old_refs) {
      if (!new_refs.has(old_id)) {
        return true;
      }
    }
    return false;
  }
  _push_changes(changes, sync) {
    if (!this.is_syncable) {
      return;
    }
    const { document: document2 } = this;
    if (document2 == null) {
      return;
    }
    const events3 = [];
    for (const [prop, , new_value] of changes) {
      if (prop.syncable) {
        const event2 = new ModelChangedEvent(document2, this, prop.attr, new_value);
        event2.sync = sync;
        events3.push(event2);
      }
    }
    if (events3.length != 0) {
      let event2;
      if (events3.length == 1) {
        [event2] = events3;
      } else {
        event2 = new DocumentEventBatch(document2, events3);
      }
      document2._trigger_on_change(event2);
    }
  }
  on_change(properties, fn) {
    for (const property of isArray(properties) ? properties : [properties]) {
      this.connect(property.change, fn);
    }
  }
  stream_to(prop, new_data, rollover, { sync } = {}) {
    const data3 = prop.get_value();
    stream_to_columns(data3, new_data, rollover);
    this._clear_watchers();
    prop.set_value(data3);
    this.streaming.emit();
    if (this.document != null) {
      const event2 = new ColumnsStreamedEvent(this.document, this, prop.attr, new_data, rollover);
      event2.sync = sync ?? true;
      this.document._trigger_on_change(event2);
    }
  }
  patch_to(prop, patches, { sync } = {}) {
    const data3 = prop.get_value();
    const patched = patch_to_columns(data3, patches);
    this._clear_watchers();
    prop.set_value(data3);
    this.patching.emit([...patched]);
    if (this.document != null) {
      const event2 = new ColumnsPatchedEvent(this.document, this, prop.attr, patches);
      event2.sync = sync ?? true;
      this.document._trigger_on_change(event2);
    }
  }
};
__publicField(_HasProps, "__name__");
__publicField(_HasProps, "__module__");
_HasProps.prototype._props = {};
_HasProps.prototype._mixins = [];
var HasProps = _HasProps;

// node_modules/@bokeh/bokehjs/build/js/lib/core/resolvers.js
var ModelResolver = class {
  constructor(parent, models = []) {
    __publicField(this, "parent");
    __publicField(this, "_known_models", /* @__PURE__ */ new Map());
    this.parent = parent;
    for (const model2 of models) {
      this.register(model2);
    }
  }
  get(name) {
    var _a34;
    return this._known_models.get(name) ?? ((_a34 = this.parent) == null ? void 0 : _a34.get(name)) ?? null;
  }
  register(model2, force = false) {
    const name = model2.__qualified__;
    if (force || this.get(name) == null) {
      this._known_models.set(name, model2);
    } else {
      console.warn(`Model '${name}' was already registered with this resolver`);
    }
  }
  get names() {
    return [...this._known_models.keys()].sort();
  }
};
__publicField(ModelResolver, "__name__", "ModelResolver");

// node_modules/@bokeh/bokehjs/build/js/lib/base.js
var default_resolver = new ModelResolver(null);
var Models = new Proxy(default_resolver, {
  get(target, name, receiver) {
    if (isString(name)) {
      const model2 = target.get(name);
      if (model2 != null) {
        return model2;
      }
    }
    return Reflect.get(target, name, receiver);
  },
  has(target, name) {
    if (isString(name)) {
      const model2 = target.get(name);
      if (model2 != null) {
        return true;
      }
    }
    return Reflect.has(target, name);
  },
  ownKeys(target) {
    return target.names;
  },
  getOwnPropertyDescriptor(target, name) {
    if (isString(name)) {
      const model2 = target.get(name);
      if (model2 != null) {
        return { configurable: true, enumerable: true, writable: false, value: model2 };
      }
    }
    return Reflect.getOwnPropertyDescriptor(target, name);
  }
});
function is_HasProps(obj) {
  return isObject(obj) && obj.prototype instanceof HasProps;
}
function register_models(models, force = false) {
  for (const model2 of isArray(models) ? models : values(models)) {
    if (is_HasProps(model2)) {
      default_resolver.register(model2, force);
    }
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/slice.js
var Slice = class {
  constructor({ start: start2, stop, step } = {}) {
    __publicField(this, "start");
    __publicField(this, "stop");
    __publicField(this, "step");
    this.start = start2 ?? null;
    this.stop = stop ?? null;
    this.step = step ?? null;
  }
  [serialize](serializer) {
    return {
      type: "slice",
      start: serializer.encode(this.start),
      stop: serializer.encode(this.stop),
      step: serializer.encode(this.step)
    };
  }
};
__publicField(Slice, "__name__", "Slice");

// node_modules/@bokeh/bokehjs/build/js/lib/core/serialization/deserializer.js
var _decoders = /* @__PURE__ */ new Map();
var DeserializationError = class extends Error {
};
__publicField(DeserializationError, "__name__", "DeserializationError");
var Deserializer = class {
  constructor(resolver, references = /* @__PURE__ */ new Map(), finalize) {
    __publicField(this, "resolver");
    __publicField(this, "references");
    __publicField(this, "finalize");
    __publicField(this, "_decoding", false);
    __publicField(this, "_buffers", /* @__PURE__ */ new Map());
    __publicField(this, "_finalizable", /* @__PURE__ */ new Set());
    this.resolver = resolver;
    this.references = references;
    this.finalize = finalize;
  }
  static register(type, decoder) {
    if (!_decoders.has(type)) {
      _decoders.set(type, decoder);
    } else {
      throw new Error(`'${type}' already registered for decoding`);
    }
  }
  decode(obj, buffers) {
    var _a34;
    if (buffers != null) {
      for (const [id, buffer] of buffers) {
        this._buffers.set(id, buffer);
      }
    }
    if (this._decoding) {
      return this._decode(obj);
    }
    this._decoding = true;
    let finalizable;
    const decoded = (() => {
      try {
        return this._decode(obj);
      } finally {
        finalizable = new Set(this._finalizable);
        this._decoding = false;
        this._buffers.clear();
        this._finalizable.clear();
      }
    })();
    for (const instance of finalizable) {
      (_a34 = this.finalize) == null ? void 0 : _a34.call(this, instance);
      instance.finalize();
      instance.assert_initialized();
    }
    for (const instance of finalizable) {
      instance.connect_signals();
    }
    return decoded;
  }
  _decode(obj) {
    if (isArray(obj)) {
      return this._decode_plain_array(obj);
    } else if (isPlainObject(obj)) {
      if (isString(obj.type)) {
        const decoder = _decoders.get(obj.type);
        if (decoder != null) {
          return decoder(obj, this);
        }
        switch (obj.type) {
          case "ref":
            return this._decode_ref(obj);
          case "symbol":
            return this._decode_symbol(obj);
          case "number":
            return this._decode_number(obj);
          case "array":
            return this._decode_array(obj);
          case "set":
            return this._decode_set(obj);
          case "map":
            return this._decode_map(obj);
          case "bytes":
            return this._decode_bytes(obj);
          case "slice":
            return this._decode_slice(obj);
          case "date":
            return this._decode_date(obj);
          case "value":
            return this._decode_value(obj);
          case "field":
            return this._decode_field(obj);
          case "expr":
            return this._decode_expr(obj);
          case "typed_array":
            return this._decode_typed_array(obj);
          case "ndarray":
            return this._decode_ndarray(obj);
          case "object": {
            if (isString(obj.id)) {
              return this._decode_object_ref(obj);
            } else {
              return this._decode_object(obj);
            }
          }
          default: {
            this.error(`unable to decode an object of type '${obj.type}'`);
          }
        }
      } else if (isString(obj.id)) {
        return this._decode_ref(obj);
      } else {
        return this._decode_plain_object(obj);
      }
    } else {
      return obj;
    }
  }
  _decode_symbol(obj) {
    this.error(`can't resolve named symbol '${obj.name}'`);
  }
  _decode_number(obj) {
    if ("value" in obj) {
      const { value: value2 } = obj;
      if (isString(value2)) {
        switch (value2) {
          case "nan":
            return NaN;
          case "+inf":
            return Infinity;
          case "-inf":
            return -Infinity;
        }
      } else if (isNumber(value2)) {
        return value2;
      }
    }
    this.error(`invalid number representation '${obj}'`);
  }
  _decode_plain_array(obj) {
    return map(obj, (item3) => this._decode(item3));
  }
  _decode_plain_object(obj) {
    const decoded = {};
    for (const [key, val] of entries(obj)) {
      decoded[key] = this._decode(val);
    }
    return decoded;
  }
  _decode_array(obj) {
    const decoded = [];
    for (const entry2 of obj.entries ?? []) {
      decoded.push(this._decode(entry2));
    }
    return decoded;
  }
  _decode_set(obj) {
    const decoded = /* @__PURE__ */ new Set();
    for (const entry2 of obj.entries ?? []) {
      decoded.add(this._decode(entry2));
    }
    return decoded;
  }
  _decode_map(obj) {
    const entries2 = map(obj.entries ?? [], ([key, val]) => [this._decode(key), this._decode(val)]);
    const is_plain = entries2.every(([key, _val]) => isString(key));
    if (is_plain) {
      return Object.fromEntries(entries2);
    } else {
      return new Map(entries2);
    }
  }
  _decode_bytes(obj) {
    const { data: data3 } = obj;
    if (is_ref(data3)) {
      const buffer = this._buffers.get(data3.id);
      if (buffer != null) {
        return buffer;
      } else {
        this.error(`buffer for id=${data3.id} not found`);
      }
    } else if (isString(data3)) {
      return base64_to_buffer(data3);
    } else {
      return data3.buffer;
    }
  }
  _decode_slice(obj) {
    const start2 = this._decode(obj.start);
    const stop = this._decode(obj.stop);
    const step = this._decode(obj.step);
    return new Slice({ start: start2, stop, step });
  }
  _decode_date(obj) {
    const iso = this._decode(obj.iso);
    return new Date(iso);
  }
  _decode_value(obj) {
    const value2 = this._decode(obj.value);
    const transform2 = obj.transform != null ? this._decode(obj.transform) : void 0;
    const units = obj.units != null ? this._decode(obj.units) : void 0;
    return { value: value2, transform: transform2, units };
  }
  _decode_field(obj) {
    const field = this._decode(obj.field);
    const transform2 = obj.transform != null ? this._decode(obj.transform) : void 0;
    const units = obj.units != null ? this._decode(obj.units) : void 0;
    return { field, transform: transform2, units };
  }
  _decode_expr(obj) {
    const expr2 = this._decode(obj.expr);
    const transform2 = obj.transform != null ? this._decode(obj.transform) : void 0;
    const units = obj.units != null ? this._decode(obj.units) : void 0;
    return { expr: expr2, transform: transform2, units };
  }
  _decode_typed_array(obj) {
    const { array: array2, order, dtype } = obj;
    const buffer = this._decode(array2);
    if (order != BYTE_ORDER) {
      swap(buffer, dtype);
    }
    switch (dtype) {
      case "uint8":
        return new Uint8Array(buffer);
      case "int8":
        return new Int8Array(buffer);
      case "uint16":
        return new Uint16Array(buffer);
      case "int16":
        return new Int16Array(buffer);
      case "uint32":
        return new Uint32Array(buffer);
      case "int32":
        return new Int32Array(buffer);
      case "float32":
        return new Float32Array(buffer);
      case "float64":
        return new Float64Array(buffer);
      default:
        this.error(`unsupported dtype '${dtype}'`);
    }
  }
  _decode_ndarray(obj) {
    const { array: array2, order, dtype, shape } = obj;
    const decoded = this._decode(array2);
    if (decoded instanceof ArrayBuffer && order != BYTE_ORDER) {
      swap(decoded, dtype);
    }
    return ndarray(decoded, { dtype, shape });
  }
  _decode_object(obj) {
    const { name: type, attributes } = obj;
    const cls = this._resolve_type(type);
    if (attributes != null) {
      return new cls(this._decode(attributes));
    } else {
      return new cls();
    }
  }
  _decode_ref(obj) {
    const instance = this.references.get(obj.id);
    if (instance != null) {
      return instance;
    } else {
      this.error(`reference ${obj.id} isn't known`);
    }
  }
  _decode_object_ref(obj) {
    const { id, name: type, attributes } = obj;
    const ref = this.references.get(id);
    if (ref != null) {
      if (ref.type == type) {
        const decoded_attributes = this._decode(attributes ?? {});
        ref.setv(decoded_attributes, { sync: false });
        return ref;
      } else {
        this.error(`type mismatch for an existing reference '${ref}', expected '${type}'`);
      }
    } else {
      const cls = this._resolve_type(type);
      const instance = new cls({ id });
      this.references.set(id, instance);
      const decoded_attributes = this._decode(attributes ?? {});
      instance.initialize_props(decoded_attributes);
      this._finalizable.add(instance);
      return instance;
    }
  }
  error(message) {
    throw new DeserializationError(message);
  }
  warning(message) {
    logger.warn(message);
  }
  _resolve_type(type) {
    const cls = this.resolver.get(type);
    if (cls != null) {
      return cls;
    } else {
      this.error(`could not resolve type '${type}', which could be due to a widget or a custom model not being registered before first usage`);
    }
  }
};
__publicField(Deserializer, "__name__", "Deserializer");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/version.js
var version_re = /^(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)(?:(?<type>-dev\.|-rc\.|.dev|rc)(?<revision>\d+))?(?:\+(?<build>\d+)\..+)?$/;
var ReleaseType;
(function(ReleaseType2) {
  ReleaseType2[ReleaseType2["Dev"] = 0] = "Dev";
  ReleaseType2[ReleaseType2["Candidate"] = 1] = "Candidate";
  ReleaseType2[ReleaseType2["Release"] = 2] = "Release";
})(ReleaseType || (ReleaseType = {}));
var Version = class {
  constructor(major, minor, patch, type = ReleaseType.Release, revision = 0, build = 0) {
    __publicField(this, "major");
    __publicField(this, "minor");
    __publicField(this, "patch");
    __publicField(this, "type");
    __publicField(this, "revision");
    __publicField(this, "build");
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this.type = type;
    this.revision = revision;
    this.build = build;
  }
  static from(version2) {
    return parse_version(version2);
  }
  toString() {
    const { major, minor, patch, type, revision, build } = this;
    let version2 = `${major}.${minor}.${patch}`;
    switch (type) {
      case ReleaseType.Dev:
        version2 += `-dev.${revision}`;
      case ReleaseType.Candidate:
        version2 += `-rc.${revision}`;
      case ReleaseType.Release:
    }
    if (build != 0) {
      version2 += `+${build}`;
    }
    return version2;
  }
  [equals](that) {
    const { major, minor, patch, type, revision } = this;
    return major == that.major && minor == that.minor && patch == that.patch && type == that.type && revision == that.revision;
  }
};
__publicField(Version, "__name__", "Version");
function parse_version(version2) {
  const result = version_re.exec(version2);
  if (result == null || result.groups == null) {
    return null;
  }
  const { groups } = result;
  const major = Number(groups.major);
  const minor = Number(groups.minor);
  const patch = Number(groups.patch);
  const type = (() => {
    switch (groups.type) {
      case "-dev.":
      case ".dev":
        return ReleaseType.Dev;
      case "-rc.":
      case "rc":
        return ReleaseType.Candidate;
      default:
        return ReleaseType.Release;
    }
  })();
  const revision = typeof groups.revision == "undefined" ? 0 : Number(groups.revision);
  const build = typeof groups.build == "undefined" ? 0 : Number(groups.build);
  return new Version(major, minor, patch, type, revision, build);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/callbacks.js
function execute(cb, obj, ...args) {
  if (isFunction(cb)) {
    return cb(obj, ...args);
  } else {
    return cb.execute(obj, ...args);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/model.js
var _Model = class _Model extends HasProps {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_js_callbacks");
  }
  get is_syncable() {
    return this.syncable;
  }
  [equals](that, cmp) {
    return (cmp.structural ? true : cmp.eq(this.id, that.id)) && super[equals](that, cmp);
  }
  initialize() {
    super.initialize();
    this._js_callbacks = /* @__PURE__ */ new Map();
  }
  connect_signals() {
    super.connect_signals();
    this._update_property_callbacks();
    this.connect(this.properties.js_property_callbacks.change, () => this._update_property_callbacks());
    this.connect(this.properties.js_event_callbacks.change, () => this._update_event_callbacks());
    this.connect(this.properties.subscribed_events.change, () => this._update_event_callbacks());
  }
  /*protected*/
  _process_event(event2) {
    for (const callback of dict(this.js_event_callbacks).get(event2.event_name) ?? []) {
      void execute(callback, event2);
    }
    if (this.document != null && this.subscribed_events.has(event2.event_name)) {
      this.document.event_manager.send_event(event2);
    }
  }
  trigger_event(event2) {
    if (this.document != null) {
      event2.origin = this;
      this.document.event_manager.trigger(event2);
    }
  }
  _update_event_callbacks() {
    if (this.document == null) {
      logger.warn("WARNING: Document not defined for updating event callbacks");
      return;
    }
    this.document.event_manager.subscribed_models.add(this);
  }
  _update_property_callbacks() {
    const signal_for = (event2) => {
      const [evt, attr2 = null] = event2.split(":");
      return attr2 != null ? this.properties[attr2][evt] : this[evt];
    };
    for (const [event2, callbacks] of this._js_callbacks) {
      const signal = signal_for(event2);
      for (const cb of callbacks) {
        this.disconnect(signal, cb);
      }
    }
    this._js_callbacks.clear();
    for (const [event2, callbacks] of dict(this.js_property_callbacks)) {
      const wrappers = callbacks.map((cb) => () => execute(cb, this));
      this._js_callbacks.set(event2, wrappers);
      const signal = signal_for(event2);
      for (const cb of wrappers) {
        this.connect(signal, cb);
      }
    }
  }
  _doc_attached() {
    if (this.js_event_callbacks.size != 0 || this.subscribed_events.size != 0) {
      this._update_event_callbacks();
    }
  }
  _doc_detached() {
    this.document.event_manager.subscribed_models.delete(this);
  }
  select(selector) {
    if (isString(selector)) {
      return [...this.references()].filter((ref) => ref instanceof _Model && ref.name === selector);
    } else if (isPlainObject(selector) && "type" in selector) {
      return [...this.references()].filter((ref) => ref.type == selector.type);
    } else if (selector.prototype instanceof HasProps) {
      return [...this.references()].filter((ref) => ref instanceof selector);
    } else {
      throw new Error(`invalid selector ${selector}`);
    }
  }
  select_one(selector) {
    const result = this.select(selector);
    switch (result.length) {
      case 0:
        return null;
      case 1:
        return result[0];
      default:
        throw new Error(`found multiple objects matching the given selector ${selector}`);
    }
  }
  get_one(selector) {
    const result = this.select_one(selector);
    if (result != null) {
      return result;
    } else {
      throw new Error(`could not find any objects matching the given selector ${selector}`);
    }
  }
  on_event(event2, callback) {
    const name = isString(event2) ? event2 : event2.prototype.event_name;
    const js_event_callbacks = dict(this.js_event_callbacks);
    const callbacks = js_event_callbacks.get(name) ?? [];
    js_event_callbacks.set(name, [...callbacks, callback]);
  }
};
__publicField(_Model, "__name__", "Model");
_Model.define(({ Any: Any2, Unknown: Unknown2, Bool: Bool2, Str: Str2, List: List2, Set: Set4, Dict: Dict2, Nullable: Nullable2 }) => ({
  tags: [List2(Unknown2), []],
  name: [Nullable2(Str2), null],
  js_property_callbacks: [Dict2(List2(
    Any2
    /*TODO*/
  )), {}],
  js_event_callbacks: [Dict2(List2(
    Any2
    /*TODO*/
  )), {}],
  subscribed_events: [Set4(Str2), new globalThis.Set()],
  syncable: [Bool2, true]
}));
var Model = _Model;

// node_modules/@bokeh/bokehjs/build/js/lib/document/defs.js
function decode_def(def, deserializer) {
  var _a34;
  function kind_of(ref) {
    if (isString(ref)) {
      switch (ref) {
        case "Any":
          return Any;
        case "Unknown":
          return Unknown;
        case "Bool":
          return Bool;
        case "Float":
          return Float;
        case "Int":
          return Int;
        case "Bytes":
          return Bytes;
        case "Str":
          return Str;
        case "Null":
          return Null;
      }
    } else {
      switch (ref[0]) {
        case "Regex": {
          const [, regex2, flags] = ref;
          return Regex(new RegExp(regex2, flags));
        }
        case "Nullable": {
          const [, sub_ref] = ref;
          return Nullable(kind_of(sub_ref));
        }
        case "Or": {
          const [, sub_ref, ...sub_refs] = ref;
          return Or(kind_of(sub_ref), ...sub_refs.map(kind_of));
        }
        case "Tuple": {
          const [, sub_ref, ...sub_refs] = ref;
          return Tuple(kind_of(sub_ref), ...sub_refs.map(kind_of));
        }
        case "List": {
          const [, sub_ref] = ref;
          return List(kind_of(sub_ref));
        }
        case "Struct": {
          const [, ...entry_refs] = ref;
          const entries2 = entry_refs.map(([key, val_ref]) => [key, kind_of(val_ref)]);
          return Struct(to_object(entries2));
        }
        case "Dict": {
          const [, val_ref] = ref;
          return Dict(kind_of(val_ref));
        }
        case "Mapping": {
          const [, key_ref, val_ref] = ref;
          return Mapping(kind_of(key_ref), kind_of(val_ref));
        }
        case "Enum": {
          const [, ...items] = ref;
          return Enum(...items);
        }
        case "Ref": {
          const [, model_ref] = ref;
          const model3 = deserializer.resolver.get(model_ref.id);
          if (model3 != null) {
            return Ref(model3);
          } else {
            throw new Error(`${model_ref.id} wasn't defined before referencing it`);
          }
        }
        case "AnyRef": {
          return AnyRef();
        }
      }
    }
  }
  const base2 = (() => {
    var _a35;
    const name = ((_a35 = def.extends) == null ? void 0 : _a35.id) ?? "Model";
    if (name == "Model") {
      return Model;
    }
    const base3 = deserializer.resolver.get(name);
    if (base3 != null) {
      return base3;
    } else {
      throw new Error(`base model ${name} of ${def.name} is not defined`);
    }
  })();
  const model2 = (_a34 = class extends base2 {
  }, __publicField(_a34, "__qualified__", def.name), _a34);
  function decode(value2) {
    if (value2 === void 0) {
      return value2;
    } else {
      return deserializer.decode(value2);
    }
  }
  for (const prop of def.properties ?? []) {
    const kind = kind_of(prop.kind);
    model2.define({ [prop.name]: [kind, decode(prop.default)] });
  }
  for (const prop of def.overrides ?? []) {
    model2.override({ [prop.name]: decode(prop.default) });
  }
  deserializer.resolver.register(model2);
  return model2;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/bokeh_events.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Deserializer.register("event", (rep, deserializer) => {
  const cls = deserializable_events.get(rep.name);
  if (cls !== void 0 && cls.from_values != null) {
    const values2 = deserializer.decode(rep.values);
    assert(isPlainObject(values2));
    return cls.from_values(values2);
  } else {
    deserializer.error(`deserialization of '${rep.name}' event is not supported`);
  }
});
function event(event_name) {
  return (cls) => {
    cls.prototype.event_name = event_name;
  };
}
var deserializable_events = /* @__PURE__ */ new Map();
function server_event(event_name) {
  return (cls) => {
    if (deserializable_events.has(event_name)) {
      throw new Error(`'${event_name}' event is already registered`);
    }
    deserializable_events.set(event_name, cls);
    cls.prototype.event_name = event_name;
    cls.prototype.publish = false;
  };
}
var _BokehEvent = class _BokehEvent {
  [serialize](serializer) {
    const { event_name: name, event_values } = this;
    const values2 = serializer.encode(event_values);
    return { type: "event", name, values: values2 };
  }
  [equals](that, cmp) {
    return this.event_name == that.event_name && cmp.eq(this.event_values, that.event_values);
  }
};
__publicField(_BokehEvent, "__name__", "BokehEvent");
_BokehEvent.prototype.publish = true;
var BokehEvent = _BokehEvent;
var ModelEvent = class extends BokehEvent {
  constructor() {
    super(...arguments);
    __publicField(this, "origin", null);
  }
  get event_values() {
    return { model: this.origin };
  }
};
__publicField(ModelEvent, "__name__", "ModelEvent");
var DocumentEvent2 = class extends BokehEvent {
};
__publicField(DocumentEvent2, "__name__", "DocumentEvent");
var _a;
var DocumentReady = (_a = class extends DocumentEvent2 {
  get event_values() {
    return {};
  }
}, __publicField(_a, "__name__", "DocumentReady"), _a);
DocumentReady = __decorate([
  event("document_ready")
], DocumentReady);
var ConnectionEvent = class extends DocumentEvent2 {
};
__publicField(ConnectionEvent, "__name__", "ConnectionEvent");
var _ConnectionLost = class _ConnectionLost extends ConnectionEvent {
  constructor() {
    super(...arguments);
    __publicField(this, "timestamp", /* @__PURE__ */ new Date());
  }
  get event_values() {
    const { timestamp } = this;
    return { timestamp };
  }
};
__publicField(_ConnectionLost, "__name__", "ConnectionLost");
_ConnectionLost.prototype.event_name = "connection_lost";
_ConnectionLost.prototype.publish = false;
var ConnectionLost = _ConnectionLost;
var _a2;
var AxisClick = (_a2 = class extends ModelEvent {
  constructor(model2, value2) {
    super();
    __publicField(this, "model");
    __publicField(this, "value");
    this.model = model2;
    this.value = value2;
  }
  get event_values() {
    const { value: value2 } = this;
    return { ...super.event_values, value: value2 };
  }
}, __publicField(_a2, "__name__", "AxisClick"), _a2);
AxisClick = __decorate([
  event("axis_click")
], AxisClick);
var _a3;
var ButtonClick = (_a3 = class extends ModelEvent {
}, __publicField(_a3, "__name__", "ButtonClick"), _a3);
ButtonClick = __decorate([
  event("button_click")
], ButtonClick);
var _a4;
var LegendItemClick = (_a4 = class extends ModelEvent {
  constructor(model2, item3) {
    super();
    __publicField(this, "model");
    __publicField(this, "item");
    this.model = model2;
    this.item = item3;
  }
  get event_values() {
    const { item: item3 } = this;
    return { ...super.event_values, item: item3 };
  }
}, __publicField(_a4, "__name__", "LegendItemClick"), _a4);
LegendItemClick = __decorate([
  event("legend_item_click")
], LegendItemClick);
var _a5;
var MenuItemClick = (_a5 = class extends ModelEvent {
  constructor(item3) {
    super();
    __publicField(this, "item");
    this.item = item3;
  }
  get event_values() {
    const { item: item3 } = this;
    return { ...super.event_values, item: item3 };
  }
}, __publicField(_a5, "__name__", "MenuItemClick"), _a5);
MenuItemClick = __decorate([
  event("menu_item_click")
], MenuItemClick);
var _a6;
var ValueSubmit = (_a6 = class extends ModelEvent {
  constructor(value2) {
    super();
    __publicField(this, "value");
    this.value = value2;
  }
  get event_values() {
    const { value: value2 } = this;
    return { ...super.event_values, value: value2 };
  }
}, __publicField(_a6, "__name__", "ValueSubmit"), _a6);
ValueSubmit = __decorate([
  event("value_submit")
], ValueSubmit);
var UIEvent = class extends ModelEvent {
};
__publicField(UIEvent, "__name__", "UIEvent");
var _a7;
var LODStart = (_a7 = class extends UIEvent {
}, __publicField(_a7, "__name__", "LODStart"), _a7);
LODStart = __decorate([
  event("lodstart")
], LODStart);
var _a8;
var LODEnd = (_a8 = class extends UIEvent {
}, __publicField(_a8, "__name__", "LODEnd"), _a8);
LODEnd = __decorate([
  event("lodend")
], LODEnd);
var _a9;
var RangesUpdate = (_a9 = class extends UIEvent {
  constructor(x0, x1, y0, y1) {
    super();
    __publicField(this, "x0");
    __publicField(this, "x1");
    __publicField(this, "y0");
    __publicField(this, "y1");
    this.x0 = x0;
    this.x1 = x1;
    this.y0 = y0;
    this.y1 = y1;
  }
  get event_values() {
    const { x0, x1, y0, y1 } = this;
    return { ...super.event_values, x0, x1, y0, y1 };
  }
}, __publicField(_a9, "__name__", "RangesUpdate"), _a9);
RangesUpdate = __decorate([
  event("rangesupdate")
], RangesUpdate);
var _a10;
var SelectionGeometry = (_a10 = class extends UIEvent {
  constructor(geometry, final) {
    super();
    __publicField(this, "geometry");
    __publicField(this, "final");
    this.geometry = geometry;
    this.final = final;
  }
  get event_values() {
    const { geometry, final } = this;
    return { ...super.event_values, geometry, final };
  }
}, __publicField(_a10, "__name__", "SelectionGeometry"), _a10);
SelectionGeometry = __decorate([
  event("selectiongeometry")
], SelectionGeometry);
var _a11;
var Reset = (_a11 = class extends UIEvent {
}, __publicField(_a11, "__name__", "Reset"), _a11);
Reset = __decorate([
  event("reset")
], Reset);
var PointEvent = class extends UIEvent {
  constructor(sx, sy, x2, y2, modifiers) {
    super();
    __publicField(this, "sx");
    __publicField(this, "sy");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "modifiers");
    this.sx = sx;
    this.sy = sy;
    this.x = x2;
    this.y = y2;
    this.modifiers = modifiers;
  }
  get event_values() {
    const { sx, sy, x: x2, y: y2, modifiers } = this;
    return { ...super.event_values, sx, sy, x: x2, y: y2, modifiers };
  }
};
__publicField(PointEvent, "__name__", "PointEvent");
var _a12;
var Pan = (_a12 = class extends PointEvent {
  /* TODO: direction: -1 | 1 */
  constructor(sx, sy, x2, y2, delta_x, delta_y, modifiers) {
    super(sx, sy, x2, y2, modifiers);
    __publicField(this, "delta_x");
    __publicField(this, "delta_y");
    this.delta_x = delta_x;
    this.delta_y = delta_y;
  }
  get event_values() {
    const {
      delta_x,
      delta_y
      /*, direction*/
    } = this;
    return {
      ...super.event_values,
      delta_x,
      delta_y
      /*, direction*/
    };
  }
}, __publicField(_a12, "__name__", "Pan"), _a12);
Pan = __decorate([
  event("pan")
], Pan);
var _a13;
var Pinch = (_a13 = class extends PointEvent {
  constructor(sx, sy, x2, y2, scale, modifiers) {
    super(sx, sy, x2, y2, modifiers);
    __publicField(this, "scale");
    this.scale = scale;
  }
  get event_values() {
    const { scale } = this;
    return { ...super.event_values, scale };
  }
}, __publicField(_a13, "__name__", "Pinch"), _a13);
Pinch = __decorate([
  event("pinch")
], Pinch);
var _a14;
var Rotate = (_a14 = class extends PointEvent {
  constructor(sx, sy, x2, y2, rotation, modifiers) {
    super(sx, sy, x2, y2, modifiers);
    __publicField(this, "rotation");
    this.rotation = rotation;
  }
  get event_values() {
    const { rotation } = this;
    return { ...super.event_values, rotation };
  }
}, __publicField(_a14, "__name__", "Rotate"), _a14);
Rotate = __decorate([
  event("rotate")
], Rotate);
var _a15;
var MouseWheel = (_a15 = class extends PointEvent {
  constructor(sx, sy, x2, y2, delta, modifiers) {
    super(sx, sy, x2, y2, modifiers);
    __publicField(this, "delta");
    this.delta = delta;
  }
  get event_values() {
    const { delta } = this;
    return { ...super.event_values, delta };
  }
}, __publicField(_a15, "__name__", "MouseWheel"), _a15);
MouseWheel = __decorate([
  event("wheel")
], MouseWheel);
var _a16;
var MouseMove = (_a16 = class extends PointEvent {
}, __publicField(_a16, "__name__", "MouseMove"), _a16);
MouseMove = __decorate([
  event("mousemove")
], MouseMove);
var _a17;
var MouseEnter = (_a17 = class extends PointEvent {
}, __publicField(_a17, "__name__", "MouseEnter"), _a17);
MouseEnter = __decorate([
  event("mouseenter")
], MouseEnter);
var _a18;
var MouseLeave = (_a18 = class extends PointEvent {
}, __publicField(_a18, "__name__", "MouseLeave"), _a18);
MouseLeave = __decorate([
  event("mouseleave")
], MouseLeave);
var _a19;
var Tap = (_a19 = class extends PointEvent {
}, __publicField(_a19, "__name__", "Tap"), _a19);
Tap = __decorate([
  event("tap")
], Tap);
var _a20;
var DoubleTap = (_a20 = class extends PointEvent {
}, __publicField(_a20, "__name__", "DoubleTap"), _a20);
DoubleTap = __decorate([
  event("doubletap")
], DoubleTap);
var _a21;
var Press = (_a21 = class extends PointEvent {
}, __publicField(_a21, "__name__", "Press"), _a21);
Press = __decorate([
  event("press")
], Press);
var _a22;
var PressUp = (_a22 = class extends PointEvent {
}, __publicField(_a22, "__name__", "PressUp"), _a22);
PressUp = __decorate([
  event("pressup")
], PressUp);
var _a23;
var PanStart = (_a23 = class extends PointEvent {
}, __publicField(_a23, "__name__", "PanStart"), _a23);
PanStart = __decorate([
  event("panstart")
], PanStart);
var _a24;
var PanEnd = (_a24 = class extends PointEvent {
}, __publicField(_a24, "__name__", "PanEnd"), _a24);
PanEnd = __decorate([
  event("panend")
], PanEnd);
var _a25;
var PinchStart = (_a25 = class extends PointEvent {
}, __publicField(_a25, "__name__", "PinchStart"), _a25);
PinchStart = __decorate([
  event("pinchstart")
], PinchStart);
var _a26;
var PinchEnd = (_a26 = class extends PointEvent {
}, __publicField(_a26, "__name__", "PinchEnd"), _a26);
PinchEnd = __decorate([
  event("pinchend")
], PinchEnd);
var _a27;
var RotateStart = (_a27 = class extends PointEvent {
}, __publicField(_a27, "__name__", "RotateStart"), _a27);
RotateStart = __decorate([
  event("rotatestart")
], RotateStart);
var _a28;
var RotateEnd = (_a28 = class extends PointEvent {
}, __publicField(_a28, "__name__", "RotateEnd"), _a28);
RotateEnd = __decorate([
  event("rotateend")
], RotateEnd);

// node_modules/@bokeh/bokehjs/build/js/lib/document/document.js
Deserializer.register("model", decode_def);
var EventManager = class {
  constructor(document2) {
    __publicField(this, "document");
    __publicField(this, "subscribed_models", /* @__PURE__ */ new Set());
    this.document = document2;
  }
  send_event(bokeh_event) {
    if (bokeh_event.publish) {
      const event2 = new MessageSentEvent(this.document, "bokeh_event", bokeh_event);
      this.document._trigger_on_change(event2);
    }
    this.document._trigger_on_event(bokeh_event);
  }
  trigger(event2) {
    for (const model2 of this.subscribed_models) {
      if (event2.origin != null && event2.origin != model2) {
        continue;
      }
      model2._process_event(event2);
    }
  }
};
__publicField(EventManager, "__name__", "EventManager");
var documents = [];
var DEFAULT_TITLE = "Bokeh Application";
var _Document = class _Document {
  constructor(options2 = {}) {
    /** @experimental */
    __publicField(this, "views_manager");
    __publicField(this, "event_manager");
    __publicField(this, "idle");
    __publicField(this, "_init_timestamp");
    __publicField(this, "_resolver");
    __publicField(this, "_title");
    __publicField(this, "_roots");
    /*protected*/
    __publicField(this, "_all_models");
    __publicField(this, "_new_models");
    __publicField(this, "_all_models_freeze_count");
    __publicField(this, "_callbacks");
    __publicField(this, "_document_callbacks");
    __publicField(this, "_message_callbacks");
    __publicField(this, "_idle_roots");
    __publicField(this, "_interactive_timestamp");
    __publicField(this, "_interactive_plot");
    __publicField(this, "_interactive_finalize");
    documents.push(this);
    this._init_timestamp = Date.now();
    this._resolver = options2.resolver ?? new ModelResolver(default_resolver);
    this._title = DEFAULT_TITLE;
    this._roots = [];
    this._all_models = /* @__PURE__ */ new Map();
    this._new_models = /* @__PURE__ */ new Set();
    this._all_models_freeze_count = 0;
    this._callbacks = /* @__PURE__ */ new Map();
    this._document_callbacks = /* @__PURE__ */ new Map();
    this._message_callbacks = /* @__PURE__ */ new Map();
    this.event_manager = new EventManager(this);
    this.idle = new Signal0(this, "idle");
    this._idle_roots = /* @__PURE__ */ new WeakSet();
    this._interactive_timestamp = null;
    this._interactive_plot = null;
    if (options2.roots != null) {
      this._add_roots(...options2.roots);
    }
    this.on_message("bokeh_event", (event2) => {
      assert(event2 instanceof ModelEvent);
      this.event_manager.trigger(event2);
    });
  }
  [equals](that, _cmp) {
    return this == that;
  }
  get all_models() {
    return new Set(this._all_models.values());
  }
  get is_idle() {
    for (const root of this._roots) {
      if (!this._idle_roots.has(root)) {
        return false;
      }
    }
    return true;
  }
  notify_idle(model2) {
    this._idle_roots.add(model2);
    if (this.is_idle) {
      logger.info(`document idle at ${Date.now() - this._init_timestamp} ms`);
      this.event_manager.send_event(new DocumentReady());
      this.idle.emit();
    }
  }
  clear() {
    this._push_all_models_freeze();
    try {
      while (this._roots.length > 0) {
        this.remove_root(this._roots[0]);
      }
    } finally {
      this._pop_all_models_freeze();
    }
  }
  interactive_start(plot, finalize = null) {
    if (this._interactive_plot == null) {
      this._interactive_plot = plot;
      this._interactive_plot.trigger_event(new LODStart());
    }
    this._interactive_finalize = finalize;
    this._interactive_timestamp = Date.now();
  }
  interactive_stop() {
    if (this._interactive_plot != null) {
      this._interactive_plot.trigger_event(new LODEnd());
      if (this._interactive_finalize != null) {
        this._interactive_finalize();
      }
    }
    this._interactive_plot = null;
    this._interactive_timestamp = null;
    this._interactive_finalize = null;
  }
  interactive_duration() {
    if (this._interactive_timestamp == null) {
      return -1;
    } else {
      return Date.now() - this._interactive_timestamp;
    }
  }
  destructively_move(dest_doc) {
    if (dest_doc === this) {
      throw new Error("Attempted to overwrite a document with itself");
    }
    dest_doc.clear();
    const roots = copy(this._roots);
    this.clear();
    for (const root of roots) {
      if (root.document != null) {
        throw new Error(`Somehow we didn't detach ${root}`);
      }
    }
    if (this._all_models.size != 0) {
      throw new Error(`this._all_models still had stuff in it: ${this._all_models}`);
    }
    for (const root of roots) {
      dest_doc.add_root(root);
    }
    dest_doc.set_title(this._title);
  }
  // TODO other fields of doc
  _push_all_models_freeze() {
    this._all_models_freeze_count += 1;
  }
  _pop_all_models_freeze() {
    this._all_models_freeze_count -= 1;
    if (this._all_models_freeze_count === 0) {
      this._recompute_all_models();
    }
  }
  /*protected*/
  _invalidate_all_models() {
    logger.debug("invalidating document models");
    if (this._all_models_freeze_count === 0) {
      this._recompute_all_models();
    }
  }
  _recompute_all_models() {
    let new_all_models_set = /* @__PURE__ */ new Set();
    for (const r of this._roots) {
      new_all_models_set = union2(new_all_models_set, r.references());
    }
    const old_all_models_set = new Set(this._all_models.values());
    const to_detach = difference2(old_all_models_set, new_all_models_set);
    const to_attach = difference2(new_all_models_set, old_all_models_set);
    const recomputed = /* @__PURE__ */ new Map();
    for (const model2 of new_all_models_set) {
      recomputed.set(model2.id, model2);
    }
    for (const d of to_detach) {
      d.detach_document();
    }
    for (const model2 of to_attach) {
      model2.attach_document(this);
      this._new_models.add(model2);
    }
    this._all_models = recomputed;
  }
  roots() {
    return this._roots;
  }
  _add_roots(...models) {
    models = models.filter((model2) => !this._roots.includes(model2));
    if (models.length == 0) {
      return false;
    }
    this._push_all_models_freeze();
    try {
      this._roots.push(...models);
    } finally {
      this._pop_all_models_freeze();
    }
    return true;
  }
  _remove_root(model2) {
    const i2 = this._roots.indexOf(model2);
    if (i2 < 0) {
      return false;
    }
    this._push_all_models_freeze();
    try {
      this._roots.splice(i2, 1);
    } finally {
      this._pop_all_models_freeze();
    }
    return true;
  }
  _set_title(title3) {
    const new_title = title3 != this._title;
    if (new_title) {
      this._title = title3;
    }
    return new_title;
  }
  add_root(model2, { sync } = {}) {
    if (this._add_roots(model2)) {
      const event2 = new RootAddedEvent(this, model2);
      event2.sync = sync ?? true;
      this._trigger_on_change(event2);
    }
  }
  remove_root(model2, { sync } = {}) {
    if (this._remove_root(model2)) {
      const event2 = new RootRemovedEvent(this, model2);
      event2.sync = sync ?? true;
      this._trigger_on_change(event2);
    }
  }
  set_title(title3, { sync } = {}) {
    if (this._set_title(title3)) {
      const event2 = new TitleChangedEvent(this, title3);
      event2.sync = sync ?? true;
      this._trigger_on_change(event2);
    }
  }
  title() {
    return this._title;
  }
  get_model_by_id(model_id) {
    return this._all_models.get(model_id) ?? null;
  }
  get_model_by_name(name) {
    const found = [];
    for (const model2 of this._all_models.values()) {
      if (model2 instanceof Model && model2.name == name) {
        found.push(model2);
      }
    }
    switch (found.length) {
      case 0:
        return null;
      case 1:
        return found[0];
      default:
        throw new Error(`Multiple models are named '${name}'`);
    }
  }
  on_message(msg_type, callback) {
    const message_callbacks = this._message_callbacks.get(msg_type);
    if (message_callbacks == null) {
      this._message_callbacks.set(msg_type, /* @__PURE__ */ new Set([callback]));
    } else {
      message_callbacks.add(callback);
    }
  }
  remove_on_message(msg_type, callback) {
    var _a34;
    (_a34 = this._message_callbacks.get(msg_type)) == null ? void 0 : _a34.delete(callback);
  }
  _trigger_on_message(msg_type, msg_data) {
    const message_callbacks = this._message_callbacks.get(msg_type);
    if (message_callbacks != null) {
      for (const cb of message_callbacks) {
        cb(msg_data);
      }
    }
  }
  on_change(callback, allow_batches = false) {
    if (!this._callbacks.has(callback)) {
      this._callbacks.set(callback, allow_batches);
    }
  }
  remove_on_change(callback) {
    this._callbacks.delete(callback);
  }
  _trigger_on_change(event2) {
    for (const [callback, allow_batches] of this._callbacks) {
      if (!allow_batches && event2 instanceof DocumentEventBatch) {
        for (const ev of event2.events) {
          callback(ev);
        }
      } else {
        callback(event2);
      }
    }
  }
  _trigger_on_event(event2) {
    const callbacks = this._document_callbacks.get(event2.event_name);
    if (callbacks != null) {
      for (const callback of callbacks) {
        void execute(callback, this, event2);
      }
    }
  }
  on_event(event2, ...callbacks) {
    const name = isString(event2) ? event2 : event2.prototype.event_name;
    const existing = this._document_callbacks.get(name) ?? [];
    const added = callbacks;
    this._document_callbacks.set(name, [...existing, ...added]);
  }
  to_json_string(include_defaults = true) {
    return JSON.stringify(this.to_json(include_defaults));
  }
  to_json(include_defaults = true) {
    const serializer = new Serializer({ include_defaults });
    const roots = serializer.encode(this._roots);
    return {
      version,
      title: this._title,
      roots
    };
  }
  static from_json_string(s2, events3) {
    const json = JSON.parse(s2);
    return _Document.from_json(json, events3);
  }
  static _handle_version(json) {
    if (json.version == null) {
      logger.warn("'version' field is missing");
    }
    const py_version = json.version ?? "0.0.0";
    const py_ver = Version.from(py_version);
    const js_ver = Version.from(version);
    const message = `new document using Bokeh ${py_version} and BokehJS ${version}`;
    if (is_equal(py_ver, js_ver)) {
      logger.debug(message);
    } else {
      logger.warn(`Bokeh/BokehJS version mismatch: ${message}`);
    }
  }
  static from_json(doc_json, events3) {
    logger.debug("Creating Document from JSON");
    _Document._handle_version(doc_json);
    const resolver = new ModelResolver(default_resolver);
    if (doc_json.defs != null) {
      const deserializer2 = new Deserializer(resolver);
      deserializer2.decode(doc_json.defs);
    }
    const doc = new _Document({ resolver });
    doc._push_all_models_freeze();
    const listener = (event2) => events3 == null ? void 0 : events3.push(event2);
    doc.on_change(listener, true);
    const deserializer = new Deserializer(resolver, doc._all_models, (obj) => obj.attach_document(doc));
    const roots = deserializer.decode(doc_json.roots);
    const callbacks = (() => {
      if (doc_json.callbacks != null) {
        return deserializer.decode(doc_json.callbacks);
      } else {
        return {};
      }
    })();
    doc.remove_on_change(listener);
    for (const [event2, event_callbacks] of entries(callbacks)) {
      doc.on_event(event2, ...event_callbacks);
    }
    for (const root of roots) {
      doc.add_root(root);
    }
    if (doc_json.title != null) {
      doc.set_title(doc_json.title);
    }
    doc._pop_all_models_freeze();
    return doc;
  }
  replace_with_json(json) {
    const replacement = _Document.from_json(json);
    replacement.destructively_move(this);
  }
  create_json_patch(events3) {
    for (const event2 of events3) {
      if (event2.document != this) {
        throw new Error("Cannot create a patch using events from a different document");
      }
    }
    const references = /* @__PURE__ */ new Map();
    for (const model2 of this._all_models.values()) {
      if (!this._new_models.has(model2)) {
        references.set(model2, model2.ref());
      }
    }
    const serializer = new Serializer({ references, binary: true });
    const patch = { events: serializer.encode(events3) };
    this._new_models.clear();
    return patch;
  }
  apply_json_patch(patch, buffers = /* @__PURE__ */ new Map()) {
    this._push_all_models_freeze();
    const deserializer = new Deserializer(this._resolver, this._all_models, (obj) => obj.attach_document(this));
    const events3 = deserializer.decode(patch.events, buffers);
    for (const event2 of events3) {
      switch (event2.kind) {
        case "MessageSent": {
          const { msg_type, msg_data } = event2;
          this._trigger_on_message(msg_type, msg_data);
          break;
        }
        case "ModelChanged": {
          const { model: model2, attr: attr2, new: value2 } = event2;
          model2.setv({ [attr2]: value2 }, { sync: false });
          break;
        }
        case "ColumnDataChanged": {
          const { model: model2, attr: attr2, data: data3, cols } = event2;
          if (cols != null) {
            const new_data = dict(data3);
            const current_data = dict(model2.property(attr2).get_value());
            for (const [name, column] of current_data) {
              if (!new_data.has(name)) {
                new_data.set(name, column);
              }
            }
          }
          model2.setv({ data: data3 }, { sync: false, check_eq: false });
          break;
        }
        case "ColumnsStreamed": {
          const { model: model2, attr: attr2, data: data3, rollover } = event2;
          const prop = model2.property(attr2);
          model2.stream_to(prop, data3, rollover, { sync: false });
          break;
        }
        case "ColumnsPatched": {
          const { model: model2, attr: attr2, patches } = event2;
          const prop = model2.property(attr2);
          model2.patch_to(prop, patches, { sync: false });
          break;
        }
        case "RootAdded": {
          this.add_root(event2.model, { sync: false });
          break;
        }
        case "RootRemoved": {
          this.remove_root(event2.model, { sync: false });
          break;
        }
        case "TitleChanged": {
          this.set_title(event2.title, { sync: false });
          break;
        }
        default: {
          throw new Error(`unknown patch event type '${event2.kind}'`);
        }
      }
    }
    this._pop_all_models_freeze();
  }
};
__publicField(_Document, "__name__", "Document");
var Document = _Document;

// node_modules/@bokeh/bokehjs/build/js/lib/core/build_views.js
async function _build_view(view_cls, model2, options2) {
  assert(view_cls != null, "model doesn't implement a view");
  const view = new view_cls({ ...options2, model: model2 });
  view.initialize();
  await view.lazy_initialize();
  return view;
}
async function build_view(model2, options2 = { parent: null }, cls = (model3) => model3.default_view) {
  const view = await _build_view(cls(model2), model2, options2);
  view.connect_signals();
  return view;
}
async function build_views(view_storage, models, options2 = { parent: null }, cls = (model2) => model2.default_view) {
  const to_remove = difference([...view_storage.keys()], models);
  const removed_views = [];
  for (const model2 of to_remove) {
    const view = view_storage.get(model2);
    if (view != null) {
      view_storage.delete(model2);
      removed_views.push(view);
      view.remove();
    }
  }
  const created_views = [];
  const new_models = models.filter((model2) => !view_storage.has(model2));
  for (const model2 of new_models) {
    const view = await _build_view(cls(model2), model2, options2);
    view_storage.set(model2, view);
    created_views.push(view);
  }
  for (const view of created_views) {
    view.connect_signals();
  }
  return {
    created: created_views,
    removed: removed_views
  };
}
function remove_views(view_storage) {
  for (const [model2, view] of view_storage) {
    view.remove();
    view_storage.delete(model2);
  }
}
function traverse_views(views, fn) {
  const visited = /* @__PURE__ */ new Set();
  const queue = [...views];
  while (true) {
    const view = queue.shift();
    if (view === void 0) {
      break;
    }
    if (visited.has(view)) {
      continue;
    }
    visited.add(view);
    queue.push(...view.children());
    fn(view);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/view_manager.js
var AbstractViewQuery = class {
  *all_views() {
    yield* this.query(() => true);
  }
  *query(fn) {
    const visited = /* @__PURE__ */ new Set();
    function* descend(view) {
      if (visited.has(view)) {
        return;
      }
      visited.add(view);
      if (fn(view)) {
        yield view;
      }
      for (const child of view.children()) {
        yield* descend(child);
      }
    }
    for (const view of this) {
      yield* descend(view);
    }
  }
  query_one(fn) {
    for (const view of this.query(fn)) {
      return view;
    }
    return null;
  }
  *find(model2) {
    yield* this.query((view) => view.model == model2);
  }
  *find_by_id(id) {
    yield* this.query((view) => view.model.id == id);
  }
  find_one(model2) {
    for (const view of this.find(model2)) {
      return view;
    }
    return null;
  }
  find_one_by_id(id) {
    for (const view of this.find_by_id(id)) {
      return view;
    }
    return null;
  }
  get_one(model2) {
    const view = this.find_one(model2);
    if (view != null) {
      return view;
    } else {
      throw new Error(`cannot find a view for ${model2}`);
    }
  }
  get_one_by_id(id) {
    const view = this.find_one_by_id(id);
    if (view != null) {
      return view;
    } else {
      throw new Error(`cannot find a view for a model with '${id}' identity`);
    }
  }
  find_all(model2) {
    return [...this.find(model2)];
  }
  find_all_by_id(id) {
    return [...this.find_by_id(id)];
  }
};
__publicField(AbstractViewQuery, "__name__", "AbstractViewQuery");
var ViewQuery = class extends AbstractViewQuery {
  constructor(view) {
    super();
    __publicField(this, "view");
    this.view = view;
  }
  *[Symbol.iterator]() {
    yield this.view;
  }
  toString() {
    return `ViewQuery(${this.view})`;
  }
};
__publicField(ViewQuery, "__name__", "ViewQuery");
var ViewManager = class extends AbstractViewQuery {
  constructor(roots = [], global) {
    super();
    __publicField(this, "global");
    __publicField(this, "_roots");
    this.global = global;
    this._roots = new Set(roots);
  }
  toString() {
    const views = [...this._roots].map((view) => `${view}`).join(", ");
    return `ViewManager(${views})`;
  }
  async build_view(model2, parent = null) {
    const view = await build_view(model2, { owner: this, parent });
    if (parent == null) {
      this.add(view);
    }
    return view;
  }
  get(model2) {
    for (const view of this._roots) {
      if (view.model == model2) {
        return view;
      }
    }
    return null;
  }
  get_by_id(id) {
    for (const view of this._roots) {
      if (view.model.id == id) {
        return view;
      }
    }
    return null;
  }
  add(view) {
    var _a34;
    this._roots.add(view);
    (_a34 = this.global) == null ? void 0 : _a34.add(view);
  }
  delete(view) {
    var _a34;
    this._roots.delete(view);
    (_a34 = this.global) == null ? void 0 : _a34.delete(view);
  }
  remove(view) {
    this.delete(view);
  }
  clear() {
    for (const view of this) {
      view.remove();
    }
  }
  /* TODO (TS 5.2)
  [Symbol.dispose](): void {
    this.clear()
  }
  */
  get roots() {
    return [...this._roots];
  }
  *[Symbol.iterator]() {
    yield* this._roots;
  }
};
__publicField(ViewManager, "__name__", "ViewManager");

// node_modules/@bokeh/bokehjs/build/js/lib/models/coordinates/coordinate.js
var Coordinate = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Coordinate, "__name__", "Coordinate");

// node_modules/@bokeh/bokehjs/build/js/lib/models/coordinates/node.js
var ImplicitTarget = Enum("canvas", "plot", "frame", "parent");
var NodeTarget = Or(Ref(Model), ImplicitTarget);
var _BoxNodes = class _BoxNodes {
  constructor(target, frozen = false) {
    __publicField(this, "target");
    __publicField(this, "frozen");
    __publicField(this, "_left", null);
    __publicField(this, "_right", null);
    __publicField(this, "_top", null);
    __publicField(this, "_bottom", null);
    this.target = target;
    this.frozen = frozen;
  }
  _node(symbol2) {
    const { target, frozen } = this;
    const node = new Node2({ target, symbol: symbol2 });
    if (frozen) {
      this[`_${symbol2}`] = node;
    }
    return node;
  }
  get left() {
    return this._left ?? this._node("left");
  }
  get right() {
    return this._right ?? this._node("right");
  }
  get top() {
    return this._top ?? this._node("top");
  }
  get bottom() {
    return this._bottom ?? this._node("bottom");
  }
  freeze() {
    return new _BoxNodes(this.target, true);
  }
};
__publicField(_BoxNodes, "__name__", "BoxNodes");
var BoxNodes = _BoxNodes;
var _Node = class _Node extends Coordinate {
  constructor(attrs) {
    super(attrs);
  }
  static get frame() {
    return this._frame_nodes;
  }
  static get canvas() {
    return this._canvas_nodes;
  }
};
__publicField(_Node, "__name__", "Node");
_Node.define(({ Str: Str2, Int: Int2 }) => ({
  target: [NodeTarget],
  symbol: [Str2],
  offset: [Int2, 0]
}));
__publicField(_Node, "_frame_nodes", new BoxNodes("frame"));
__publicField(_Node, "_canvas_nodes", new BoxNodes("canvas"));
var Node2 = _Node;

// node_modules/@bokeh/bokehjs/build/js/lib/models/coordinates/xy.js
var _XY = class _XY extends Coordinate {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_XY, "__name__", "XY");
_XY.define(({ Float: Float2 }) => ({
  x: [Float2],
  y: [Float2]
}));
var XY = _XY;

// node_modules/@bokeh/bokehjs/build/js/lib/models/coordinates/indexed.js
var _Indexed = class _Indexed extends Coordinate {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Indexed, "__name__", "Indexed");
_Indexed.define(({ Int: Int2, AnyRef: AnyRef2 }) => ({
  index: [Int2],
  renderer: [AnyRef2()]
}));
var Indexed = _Indexed;

// node_modules/@bokeh/bokehjs/build/js/lib/core/view.js
var View = class {
  constructor(options2) {
    __publicField(this, "removed", new Signal0(this, "removed"));
    __publicField(this, "model");
    __publicField(this, "parent");
    __publicField(this, "root");
    __publicField(this, "owner");
    __publicField(this, "views", new ViewQuery(this));
    __publicField(this, "_ready", Promise.resolve(void 0));
    /** @internal */
    __publicField(this, "_slots", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_destroyed", false);
    __publicField(this, "_has_finished", false);
    __publicField(this, "_idle_notified", false);
    const { model: model2, parent, owner } = options2;
    this.model = model2;
    this.parent = parent;
    if (parent == null) {
      this.root = this;
      this.owner = owner ?? new ViewManager([this]);
    } else {
      this.root = parent.root;
      this.owner = this.root.owner;
    }
  }
  get ready() {
    return this._ready;
  }
  connect(signal, slot2) {
    let new_slot = this._slots.get(slot2);
    if (new_slot == null) {
      new_slot = (args, sender) => {
        const promise = Promise.resolve(slot2.call(this, args, sender));
        this._ready = this._ready.then(() => promise);
        if (this.root != this) {
          this.root._ready = this.root._ready.then(() => this._ready);
        }
      };
      this._slots.set(slot2, new_slot);
    }
    return signal.connect(new_slot, this);
  }
  disconnect(signal, slot2) {
    return signal.disconnect(slot2, this);
  }
  initialize() {
  }
  async lazy_initialize() {
  }
  remove() {
    this.disconnect_signals();
    this.owner.remove(this);
    this.removed.emit();
    this._destroyed = true;
  }
  get is_destroyed() {
    return this._destroyed;
  }
  toString() {
    return `${this.model.type}View(${this.model.id})`;
  }
  [equals](that, _cmp) {
    return Object.is(this, that);
  }
  *children() {
  }
  mark_finished() {
    this._has_finished = true;
  }
  /**
   * Mark as finished even if e.g. external resources were not loaded yet.
   */
  force_finished() {
    this.mark_finished();
  }
  finish() {
    this.mark_finished();
    this.notify_finished();
  }
  notify_finished() {
    if (!this.is_root) {
      this.root.notify_finished();
    } else {
      if (!this._idle_notified && this.has_finished()) {
        const { document: document2 } = this.model;
        if (document2 != null) {
          this._idle_notified = true;
          document2.notify_idle(this.model);
        }
      }
    }
  }
  serializable_state() {
    const children = [...this.children()].filter((view) => view.model.is_syncable).map((view) => view.serializable_state()).filter((item3) => item3.bbox != null && item3.bbox.is_valid && !item3.bbox.is_empty);
    return {
      type: this.model.type,
      children
    };
  }
  get is_root() {
    return this.parent == null;
  }
  has_finished() {
    return this._has_finished;
  }
  get is_idle() {
    return this.has_finished();
  }
  connect_signals() {
  }
  disconnect_signals() {
    Signal.disconnect_receiver(this);
  }
  on_change(properties, fn) {
    for (const property of isArray(properties) ? properties : [properties]) {
      this.connect(property.change, fn);
    }
  }
  on_transitive_change(property, fn) {
    const collect = () => {
      const value2 = property.is_unset ? [] : property.get_value();
      return HasProps.references(value2, { recursive: false });
    };
    const connect = (models2) => {
      for (const model2 of models2) {
        this.connect(model2.change, fn);
      }
    };
    const disconnect = (models2) => {
      for (const model2 of models2) {
        this.disconnect(model2.change, fn);
      }
    };
    let models = collect();
    connect(models);
    this.on_change(property, () => {
      disconnect(models);
      models = collect();
      connect(models);
      fn();
    });
  }
  cursor(_sx, _sy) {
    return null;
  }
  resolve_frame() {
    return null;
  }
  resolve_canvas() {
    return null;
  }
  resolve_plot() {
    return null;
  }
  resolve_target(target) {
    if (isString(target)) {
      const ascend = (fn) => {
        let obj = this;
        while (obj != null) {
          const view = fn(obj);
          if (view != null) {
            return view;
          } else {
            obj = obj.parent;
          }
        }
        return null;
      };
      switch (target) {
        case "parent":
          return this.parent;
        case "frame":
          return ascend((view) => view.resolve_frame());
        case "canvas":
          return ascend((view) => view.resolve_canvas());
        case "plot":
          return ascend((view) => view.resolve_plot());
      }
    } else {
      const queue = [this.root];
      while (true) {
        const child = queue.shift();
        if (child == null) {
          break;
        } else if (child.model == target) {
          return child;
        } else {
          queue.push(...child.children());
        }
      }
      return null;
    }
  }
  resolve_symbol(_node) {
    return { x: NaN, y: NaN };
  }
  resolve_node(node) {
    const target = this.resolve_target(node.target);
    if (target != null) {
      return target.resolve_symbol(node);
    } else {
      return { x: NaN, y: NaN };
    }
  }
  resolve_coordinate(coord) {
    var _a34, _b4;
    if (coord instanceof XY) {
      let obj = this;
      while (obj != null && obj.resolve_xy == null) {
        obj = obj.parent;
      }
      return ((_a34 = obj == null ? void 0 : obj.resolve_xy) == null ? void 0 : _a34.call(obj, coord)) ?? { x: NaN, y: NaN };
    } else if (coord instanceof Indexed) {
      let obj = this;
      while (obj != null && obj.resolve_indexed == null) {
        obj = obj.parent;
      }
      return ((_b4 = obj == null ? void 0 : obj.resolve_indexed) == null ? void 0 : _b4.call(obj, coord)) ?? { x: NaN, y: NaN };
    } else if (coord instanceof Node2) {
      return this.resolve_node(coord);
    } else {
      return { x: NaN, y: NaN };
    }
  }
  resolve_as_xy(coord) {
    const value2 = this.resolve_coordinate(coord);
    return isNumber(value2) ? { x: NaN, y: NaN } : value2;
  }
  resolve_as_scalar(coord, dim) {
    const value2 = this.resolve_coordinate(coord);
    return isNumber(value2) ? value2 : value2[dim];
  }
};
__publicField(View, "__name__", "View");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/bbox.js
var { min: min2, max: max3, round } = Math;
function empty() {
  return {
    x0: Infinity,
    y0: Infinity,
    x1: -Infinity,
    y1: -Infinity
  };
}
function positive_x() {
  return {
    x0: Number.MIN_VALUE,
    y0: -Infinity,
    x1: Infinity,
    y1: Infinity
  };
}
function positive_y() {
  return {
    x0: -Infinity,
    y0: Number.MIN_VALUE,
    x1: Infinity,
    y1: Infinity
  };
}
function _min(a2, b2) {
  if (isNaN(a2)) {
    return b2;
  } else if (isNaN(b2)) {
    return a2;
  } else {
    return min2(a2, b2);
  }
}
function _max(a2, b2) {
  if (isNaN(a2)) {
    return b2;
  } else if (isNaN(b2)) {
    return a2;
  } else {
    return max3(a2, b2);
  }
}
function union3(a2, b2) {
  return {
    x0: _min(a2.x0, b2.x0),
    x1: _max(a2.x1, b2.x1),
    y0: _min(a2.y0, b2.y0),
    y1: _max(a2.y1, b2.y1)
  };
}
var _BBox = class _BBox {
  constructor(box, correct = false) {
    __publicField(this, "x0");
    __publicField(this, "y0");
    __publicField(this, "x1");
    __publicField(this, "y1");
    __publicField(this, "_x_percent");
    __publicField(this, "_y_percent");
    __publicField(this, "_x_screen");
    __publicField(this, "_y_screen");
    __publicField(this, "_x_view");
    __publicField(this, "_y_view");
    if (box == null) {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 0;
      this.y1 = 0;
    } else if ("x0" in box) {
      const { x0, y0, x1, y1 } = box;
      if (!isFinite(x0 + y0 + x1 + y1)) {
        this.x0 = NaN;
        this.y0 = NaN;
        this.x1 = NaN;
        this.y1 = NaN;
      } else {
        if (!(x0 <= x1 && y0 <= y1)) {
          throw new Error(`invalid bbox {x0: ${x0}, y0: ${y0}, x1: ${x1}, y1: ${y1}}`);
        }
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
    } else if ("x" in box) {
      const { x: x2, y: y2, width, height, origin = "top_left" } = box;
      if (!(width >= 0 && height >= 0)) {
        throw new Error(`invalid bbox {x: ${x2}, y: ${y2}, width: ${width}, height: ${height}}`);
      }
      const base_origin = (() => {
        switch (origin) {
          case "left":
            return "center_left";
          case "right":
            return "center_right";
          case "top":
            return "top_center";
          case "bottom":
            return "bottom_center";
          case "center":
            return "center_center";
          default:
            return origin;
        }
      })();
      const [y_align, x_align] = base_origin.split("_", 2);
      const y_coeff = (() => {
        switch (y_align) {
          case "top":
            return 0;
          case "center":
            return 0.5;
          case "bottom":
            return 1;
        }
      })();
      const x_coeff = (() => {
        switch (x_align) {
          case "left":
            return 0;
          case "center":
            return 0.5;
          case "right":
            return 1;
        }
      })();
      const d_width = x_coeff * width;
      const d_height = y_coeff * height;
      const x0 = x2 - d_width;
      const y0 = y2 - d_height;
      const x1 = x0 + width;
      const y1 = y0 + height;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    } else {
      let left2, right3;
      let top, bottom;
      if ("width" in box) {
        if ("left" in box) {
          left2 = box.left;
          right3 = left2 + box.width;
        } else if ("right" in box) {
          right3 = box.right;
          left2 = right3 - box.width;
        } else {
          const w2 = box.width / 2;
          left2 = box.hcenter - w2;
          right3 = box.hcenter + w2;
        }
      } else {
        left2 = box.left;
        right3 = box.right;
      }
      if ("height" in box) {
        if ("top" in box) {
          top = box.top;
          bottom = top + box.height;
        } else if ("bottom" in box) {
          bottom = box.bottom;
          top = bottom - box.height;
        } else {
          const h22 = box.height / 2;
          top = box.vcenter - h22;
          bottom = box.vcenter + h22;
        }
      } else {
        top = box.top;
        bottom = box.bottom;
      }
      if (left2 > right3 || top > bottom) {
        if (correct) {
          if (left2 > right3) {
            left2 = right3;
          }
          if (top > bottom) {
            top = bottom;
          }
        } else {
          throw new Error(`invalid bbox {left: ${left2}, top: ${top}, right: ${right3}, bottom: ${bottom}}`);
        }
      }
      this.x0 = left2;
      this.y0 = top;
      this.x1 = right3;
      this.y1 = bottom;
    }
  }
  static from_lrtb({ left: left2, right: right3, top, bottom }) {
    return new _BBox({
      x0: min2(left2, right3),
      y0: min2(top, bottom),
      x1: max3(left2, right3),
      y1: max3(top, bottom)
    });
  }
  static from_rect({ x0, y0, x1, y1 }) {
    return new _BBox({
      x0: min2(x0, x1),
      y0: min2(y0, y1),
      x1: max3(x0, x1),
      y1: max3(y0, y1)
    });
  }
  static empty() {
    return new _BBox({ x0: 0, y0: 0, x1: 0, y1: 0 });
  }
  static invalid() {
    return new _BBox({ x0: NaN, y0: NaN, x1: NaN, y1: NaN });
  }
  clone() {
    return new _BBox(this);
  }
  equals(that) {
    return this.x0 == that.x0 && this.y0 == that.y0 && this.x1 == that.x1 && this.y1 == that.y1;
  }
  [equals](that, cmp) {
    return cmp.eq(this.x0, that.x0) && cmp.eq(this.y0, that.y0) && cmp.eq(this.x1, that.x1) && cmp.eq(this.y1, that.y1);
  }
  toString() {
    return `BBox({left: ${this.left}, top: ${this.top}, width: ${this.width}, height: ${this.height}})`;
  }
  get is_valid() {
    const { x0, x1, y0, y1 } = this;
    return isFinite(x0 + x1 + y0 + y1);
  }
  get is_empty() {
    const { x0, x1, y0, y1 } = this;
    return x0 == 0 && x1 == 0 && y0 == 0 && y1 == 0;
  }
  get left() {
    return this.x0;
  }
  get top() {
    return this.y0;
  }
  get right() {
    return this.x1;
  }
  get bottom() {
    return this.y1;
  }
  get p0() {
    return { x: this.x0, y: this.y0 };
  }
  get p1() {
    return { x: this.x1, y: this.y1 };
  }
  get x() {
    return this.x0;
  }
  get y() {
    return this.y0;
  }
  get width() {
    return this.x1 - this.x0;
  }
  get height() {
    return this.y1 - this.y0;
  }
  get size() {
    return { width: this.width, height: this.height };
  }
  get rect() {
    const { x0, y0, x1, y1 } = this;
    return {
      p0: { x: x0, y: y0 },
      p1: { x: x1, y: y0 },
      p2: { x: x1, y: y1 },
      p3: { x: x0, y: y1 }
    };
  }
  get box() {
    const { x: x2, y: y2, width, height } = this;
    return { x: x2, y: y2, width, height };
  }
  get lrtb() {
    const { left: left2, right: right3, top, bottom } = this;
    return { left: left2, right: right3, top, bottom };
  }
  get x_range() {
    return { start: this.x0, end: this.x1 };
  }
  get y_range() {
    return { start: this.y0, end: this.y1 };
  }
  get h_range() {
    return this.x_range;
  }
  get v_range() {
    return this.y_range;
  }
  get ranges() {
    return [this.x_range, this.y_range];
  }
  get aspect() {
    return this.width / this.height;
  }
  get x_center() {
    return (this.left + this.right) / 2;
  }
  get y_center() {
    return (this.top + this.bottom) / 2;
  }
  get hcenter() {
    return this.x_center;
  }
  get vcenter() {
    return this.y_center;
  }
  get area() {
    return this.width * this.height;
  }
  resolve(symbol2) {
    switch (symbol2) {
      case "top_left":
        return this.top_left;
      case "top_center":
        return this.top_center;
      case "top_right":
        return this.top_right;
      case "center_left":
        return this.center_left;
      case "center_center":
        return this.center_center;
      case "center_right":
        return this.center_right;
      case "bottom_left":
        return this.bottom_left;
      case "bottom_center":
        return this.bottom_center;
      case "bottom_right":
        return this.bottom_right;
      case "center":
        return this.center;
      case "top":
        return this.top;
      case "left":
        return this.left;
      case "right":
        return this.right;
      case "bottom":
        return this.bottom;
      case "width":
        return this.width;
      case "height":
        return this.height;
      default:
        return { x: NaN, y: NaN };
    }
  }
  get top_left() {
    return { x: this.left, y: this.top };
  }
  get top_center() {
    return { x: this.hcenter, y: this.top };
  }
  get top_right() {
    return { x: this.right, y: this.top };
  }
  get center_left() {
    return { x: this.left, y: this.vcenter };
  }
  get center_center() {
    return { x: this.hcenter, y: this.vcenter };
  }
  get center_right() {
    return { x: this.right, y: this.vcenter };
  }
  get bottom_left() {
    return { x: this.left, y: this.bottom };
  }
  get bottom_center() {
    return { x: this.hcenter, y: this.bottom };
  }
  get bottom_right() {
    return { x: this.right, y: this.bottom };
  }
  get center() {
    return { x: this.hcenter, y: this.vcenter };
  }
  round() {
    return new _BBox({
      x0: round(this.x0),
      x1: round(this.x1),
      y0: round(this.y0),
      y1: round(this.y1)
    });
  }
  relative() {
    const { width, height } = this;
    return new _BBox({ x: 0, y: 0, width, height });
  }
  translate(tx, ty) {
    const { x: x2, y: y2, width, height } = this;
    return new _BBox({ x: tx + x2, y: ty + y2, width, height });
  }
  scale(factor) {
    return new _BBox({
      x0: this.x0 * factor,
      x1: this.x1 * factor,
      y0: this.y0 * factor,
      y1: this.y1 * factor
    });
  }
  relativize(x2, y2) {
    return [x2 - this.x, y2 - this.y];
  }
  contains(x2, y2) {
    return this.x0 <= x2 && x2 <= this.x1 && this.y0 <= y2 && y2 <= this.y1;
  }
  clip(x2, y2) {
    if (x2 < this.x0) {
      x2 = this.x0;
    } else if (x2 > this.x1) {
      x2 = this.x1;
    }
    if (y2 < this.y0) {
      y2 = this.y0;
    } else if (y2 > this.y1) {
      y2 = this.y1;
    }
    return [x2, y2];
  }
  grow_by(size2) {
    return new _BBox({
      left: this.left - size2,
      right: this.right + size2,
      top: this.top - size2,
      bottom: this.bottom + size2
    });
  }
  shrink_by(size2) {
    return new _BBox({
      left: this.left + size2,
      right: this.right - size2,
      top: this.top + size2,
      bottom: this.bottom - size2
    }, true);
  }
  union(that) {
    return new _BBox({
      x0: min2(this.x0, that.x0),
      y0: min2(this.y0, that.y0),
      x1: max3(this.x1, that.x1),
      y1: max3(this.y1, that.y1)
    });
  }
  intersection(that) {
    if (!this.intersects(that)) {
      return null;
    } else {
      return new _BBox({
        x0: max3(this.x0, that.x0),
        y0: max3(this.y0, that.y0),
        x1: min2(this.x1, that.x1),
        y1: min2(this.y1, that.y1)
      });
    }
  }
  intersects(that) {
    return !(that.x1 < this.x0 || that.x0 > this.x1 || that.y1 < this.y0 || that.y0 > this.y1);
  }
  get x_percent() {
    const self2 = this;
    return this._x_percent ?? (this._x_percent = {
      compute(x2) {
        return self2.left + x2 * self2.width;
      },
      invert(sx) {
        return (sx - self2.left) / self2.width;
      },
      v_compute(xs) {
        const { left: left2, width } = self2;
        return new ScreenArray(map(xs, (x2) => left2 + x2 * width));
      },
      v_invert(sxs) {
        const { left: left2, width } = self2;
        return map(sxs, (sx) => (sx - left2) / width);
      },
      get source_range() {
        return self2.x_range;
      },
      get target_range() {
        return self2.x_range;
      }
    });
  }
  get y_percent() {
    const self2 = this;
    return this._y_percent ?? (this._y_percent = {
      compute(y2) {
        return self2.top + y2 * self2.height;
      },
      invert(sy) {
        return (sy - self2.top) / self2.height;
      },
      v_compute(ys) {
        const { top, height } = self2;
        return new ScreenArray(map(ys, (y2) => top + y2 * height));
      },
      v_invert(sys) {
        const { top, height } = self2;
        return map(sys, (sy) => (sy - top) / height);
      },
      get source_range() {
        return self2.y_range;
      },
      get target_range() {
        return self2.y_range;
      }
    });
  }
  get x_screen() {
    const self2 = this;
    return this._x_screen ?? (this._x_screen = {
      compute(x2) {
        return self2.left + x2;
      },
      invert(sx) {
        return sx - self2.left;
      },
      v_compute(xs) {
        const { left: left2 } = self2;
        return new ScreenArray(map(xs, (x2) => left2 + x2));
      },
      v_invert(sxs) {
        const { left: left2 } = self2;
        return map(sxs, (sx) => sx - left2);
      },
      get source_range() {
        return self2.x_range;
      },
      get target_range() {
        return self2.x_range;
      }
    });
  }
  get y_screen() {
    const self2 = this;
    return this._y_screen ?? (this._y_screen = {
      compute(y2) {
        return self2.top + y2;
      },
      invert(sy) {
        return sy - self2.top;
      },
      v_compute(ys) {
        const { top } = self2;
        return new ScreenArray(map(ys, (y2) => top + y2));
      },
      v_invert(sys) {
        const { top } = self2;
        return map(sys, (sy) => sy - top);
      },
      get source_range() {
        return self2.y_range;
      },
      get target_range() {
        return self2.y_range;
      }
    });
  }
  get x_view() {
    const self2 = this;
    return this._x_view ?? (this._x_view = {
      compute(x2) {
        return self2.left + x2;
      },
      invert(sx) {
        return sx - self2.left;
      },
      v_compute(xs) {
        const { left: left2 } = self2;
        return new ScreenArray(map(xs, (x2) => left2 + x2));
      },
      v_invert(sxs) {
        const { left: left2 } = self2;
        return map(sxs, (sx) => sx - left2);
      },
      get source_range() {
        return self2.x_range;
      },
      get target_range() {
        return self2.x_range;
      }
    });
  }
  get y_view() {
    const self2 = this;
    return this._y_view ?? (this._y_view = {
      compute(y2) {
        return self2.bottom - y2;
      },
      invert(sy) {
        return self2.bottom - sy;
      },
      v_compute(ys) {
        const { bottom } = self2;
        return new ScreenArray(map(ys, (y2) => bottom - y2));
      },
      v_invert(sys) {
        const { bottom } = self2;
        return map(sys, (sy) => bottom - sy);
      },
      get source_range() {
        return self2.y_range;
      },
      get target_range() {
        return { start: self2.bottom, end: self2.top };
      }
    });
  }
  get xview() {
    return this.x_view;
  }
  get yview() {
    return this.y_view;
  }
};
__publicField(_BBox, "__name__", "BBox");
var BBox = _BBox;

// node_modules/@bokeh/bokehjs/build/js/lib/core/css.js
var _style_decl = document.createElement("div").style;
function _css_name(attr2) {
  if (attr2.startsWith("--")) {
    return attr2;
  }
  const name = attr2.replaceAll(/_/g, "-").replaceAll(/[A-Z]/g, (c) => `-${c.toLowerCase()}`);
  if (name in _style_decl) {
    return name;
  }
  const webkit_name = `-webkit-${name}`;
  if (webkit_name in _style_decl) {
    return webkit_name;
  }
  const moz_name = `-moz-${name}`;
  if (moz_name in _style_decl) {
    return moz_name;
  }
  logger.warn(`unknown CSS property '${attr2}'`);
  return null;
}
function* _iter_styles(styles3) {
  if (isPlainObject(styles3) || styles3 instanceof Map) {
    for (const [key, val] of entries(styles3)) {
      const name = _css_name(key);
      if (name != null) {
        yield [name, val];
      }
    }
  } else {
    for (const prop of styles3.own_properties()) {
      if (prop.dirty) {
        const name = _css_name(prop.attr);
        if (name != null) {
          yield [name, prop.get_value()];
        }
      }
    }
  }
}
function apply_styles(declaration, styles3) {
  for (const [name, value2] of _iter_styles(styles3)) {
    if (isString(value2)) {
      declaration.setProperty(name, value2);
    } else {
      declaration.removeProperty(name);
    }
  }
}
function compose_stylesheet(stylesheet2) {
  const css = [];
  for (const [selector, styles3] of entries(stylesheet2)) {
    css.push(`${selector} {`);
    for (const [name, value2] of _iter_styles(styles3)) {
      if (isString(value2) && value2.length != 0) {
        css.push(`  ${name}: ${value2};`);
      }
    }
    css.push("}");
  }
  return css.join("\n");
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/dom.js
var _element = (tag) => {
  return (attrs = {}, ...children) => {
    const element = document.createElement(tag);
    if (!isPlainObject(attrs)) {
      children = [attrs, ...children];
      attrs = {};
    } else {
      attrs = { ...attrs };
    }
    if (attrs.class != null) {
      const classes = (() => {
        if (isString(attrs.class)) {
          return attrs.class.split(/\s+/);
        } else {
          return attrs.class;
        }
      })();
      for (const cls of classes) {
        if (cls != null) {
          element.classList.add(cls);
        }
      }
      delete attrs.class;
    }
    if (attrs.style != null) {
      if (isString(attrs.style)) {
        element.setAttribute("style", attrs.style);
      } else {
        apply_styles(element.style, attrs.style);
      }
      delete attrs.style;
    }
    if (attrs.data != null) {
      for (const [key, data3] of entries(attrs.data)) {
        if (data3 != null) {
          element.dataset[key] = data3;
        }
      }
      delete attrs.data;
    }
    for (const [attr2, value2] of entries(attrs)) {
      if (value2 == null) {
        continue;
      } else if (isBoolean(value2)) {
        element.toggleAttribute(attr2, value2);
      } else if (isNumber(value2)) {
        element.setAttribute(attr2, `${value2}`);
      } else if (isString(value2)) {
        element.setAttribute(attr2, value2);
      } else {
        logger.warn(`unable to set attribute: ${attr2} = ${value2}`);
      }
    }
    function append(child) {
      if (isString(child)) {
        element.append(document.createTextNode(child));
      } else if (child instanceof Node) {
        element.append(child);
      } else if (child instanceof NodeList || child instanceof HTMLCollection) {
        element.append(...child);
      } else if (child != null && child !== false) {
        throw new Error(`expected a DOM element, string, false or null, got ${JSON.stringify(child)}`);
      }
    }
    for (const child of children) {
      if (isArray(child)) {
        for (const _child of child) {
          append(_child);
        }
      } else {
        append(child);
      }
    }
    return element;
  };
};
function create_element(tag, attrs, ...children) {
  return _element(tag)(attrs, ...children);
}
var a = _element("a");
var abbr = _element("abbr");
var address = _element("address");
var area = _element("area");
var article = _element("article");
var aside = _element("aside");
var audio = _element("audio");
var b = _element("b");
var base = _element("base");
var bdi = _element("bdi");
var bdo = _element("bdo");
var blockquote = _element("blockquote");
var body = _element("body");
var br = _element("br");
var button = _element("button");
var canvas2 = _element("canvas");
var caption = _element("caption");
var cite = _element("cite");
var code = _element("code");
var col = _element("col");
var colgroup = _element("colgroup");
var data2 = _element("data");
var datalist = _element("datalist");
var dd = _element("dd");
var del = _element("del");
var details = _element("details");
var dfn = _element("dfn");
var dialog = _element("dialog");
var div = _element("div");
var dl = _element("dl");
var dt = _element("dt");
var em = _element("em");
var embed = _element("embed");
var fieldset = _element("fieldset");
var figcaption = _element("figcaption");
var figure = _element("figure");
var footer = _element("footer");
var form = _element("form");
var h1 = _element("h1");
var h2 = _element("h2");
var h3 = _element("h3");
var h4 = _element("h4");
var h5 = _element("h5");
var h6 = _element("h6");
var head2 = _element("head");
var header = _element("header");
var hgroup = _element("hgroup");
var hr = _element("hr");
var html = _element("html");
var i = _element("i");
var iframe = _element("iframe");
var img = _element("img");
var input = _element("input");
var ins = _element("ins");
var kbd = _element("kbd");
var label = _element("label");
var legend = _element("legend");
var li = _element("li");
var link = _element("link");
var main = _element("main");
var map3 = _element("map");
var mark = _element("mark");
var menu = _element("menu");
var meta = _element("meta");
var meter = _element("meter");
var nav = _element("nav");
var noscript = _element("noscript");
var object = _element("object");
var ol = _element("ol");
var optgroup = _element("optgroup");
var option = _element("option");
var output = _element("output");
var p = _element("p");
var picture = _element("picture");
var pre = _element("pre");
var progress = _element("progress");
var q = _element("q");
var rp = _element("rp");
var rt = _element("rt");
var ruby = _element("ruby");
var s = _element("s");
var samp = _element("samp");
var script = _element("script");
var search = _element("search");
var section = _element("section");
var select = _element("select");
var slot = _element("slot");
var small = _element("small");
var source = _element("source");
var span = _element("span");
var strong = _element("strong");
var style = _element("style");
var sub = _element("sub");
var summary = _element("summary");
var sup = _element("sup");
var table = _element("table");
var tbody = _element("tbody");
var td = _element("td");
var template = _element("template");
var textarea = _element("textarea");
var tfoot = _element("tfoot");
var th2 = _element("th");
var thead = _element("thead");
var time = _element("time");
var title = _element("title");
var tr = _element("tr");
var track = _element("track");
var u = _element("u");
var ul = _element("ul");
var video = _element("video");
var wbr = _element("wbr");
function text(str) {
  return document.createTextNode(str);
}
function nbsp() {
  return text(" ");
}
function prepend2(element, ...nodes) {
  const first = element.firstChild;
  for (const node of nodes) {
    element.insertBefore(node, first);
  }
}
function empty2(node, attrs = false) {
  let child;
  while ((child = node.firstChild) != null) {
    node.removeChild(child);
  }
  if (attrs && node instanceof Element) {
    for (const attr2 of node.attributes) {
      node.removeAttributeNode(attr2);
    }
  }
}
function contains2(element, child) {
  let current = child;
  while (current.parentNode != null) {
    const parent = current.parentNode;
    if (parent == element) {
      return true;
    } else if (parent instanceof ShadowRoot) {
      current = parent.host;
    } else {
      current = parent;
    }
  }
  return false;
}
function display(element, display2 = true) {
  element.style.display = display2 ? "" : "none";
}
function undisplay(element) {
  element.style.display = "none";
}
function show(element) {
  element.style.visibility = "";
}
function hide(element) {
  element.style.visibility = "hidden";
}
function offset_bbox(element) {
  const { top, left: left2, width, height } = element.getBoundingClientRect();
  return new BBox({
    left: left2 + scrollX - document.documentElement.clientLeft,
    top: top + scrollY - document.documentElement.clientTop,
    width,
    height
  });
}
function bounding_box(el) {
  const { x: x2, y: y2, width, height } = el.getBoundingClientRect();
  return new BBox({ x: x2, y: y2, width, height });
}
function box_size(el) {
  const { width, height } = el.getBoundingClientRect();
  return { width, height };
}
function position(el, box, margin) {
  const { style: style2 } = el;
  style2.left = `${box.x}px`;
  style2.top = `${box.y}px`;
  style2.width = `${box.width}px`;
  style2.height = `${box.height}px`;
  if (margin == null) {
    style2.margin = "";
  } else {
    const { top, right: right3, bottom, left: left2 } = margin;
    style2.margin = `${top}px ${right3}px ${bottom}px ${left2}px`;
  }
}
var ClassList = class {
  constructor(class_list) {
    __publicField(this, "class_list");
    this.class_list = class_list;
  }
  get values() {
    const values2 = [];
    for (let i2 = 0; i2 < this.class_list.length; i2++) {
      const item3 = this.class_list.item(i2);
      if (item3 != null) {
        values2.push(item3);
      }
    }
    return values2;
  }
  has(cls) {
    return this.class_list.contains(cls);
  }
  add(...classes) {
    for (const cls of classes) {
      this.class_list.add(cls);
    }
    return this;
  }
  remove(...classes) {
    for (const cls of classes) {
      if (isArray(cls)) {
        cls.forEach((cls2) => this.class_list.remove(cls2));
      } else {
        this.class_list.remove(cls);
      }
    }
    return this;
  }
  clear() {
    for (const cls of this.values) {
      this.class_list.remove(cls);
    }
    return this;
  }
  toggle(cls, activate) {
    const add2 = activate != null ? activate : !this.has(cls);
    if (add2) {
      this.add(cls);
    } else {
      this.remove(cls);
    }
    return this;
  }
};
__publicField(ClassList, "__name__", "ClassList");
function toggle_attribute(el, attr2, state) {
  if (state == null) {
    state = !el.hasAttribute(attr2);
  }
  if (state) {
    el.setAttribute(attr2, "true");
  } else {
    el.removeAttribute(attr2);
  }
}
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["None"] = 0] = "None";
  MouseButton2[MouseButton2["Primary"] = 1] = "Primary";
  MouseButton2[MouseButton2["Secondary"] = 2] = "Secondary";
  MouseButton2[MouseButton2["Auxiliary"] = 4] = "Auxiliary";
  MouseButton2[MouseButton2["Left"] = 1] = "Left";
  MouseButton2[MouseButton2["Right"] = 2] = "Right";
  MouseButton2[MouseButton2["Middle"] = 4] = "Middle";
})(MouseButton || (MouseButton = {}));
var StyleSheet = class {
  constructor() {
    __publicField(this, "el");
  }
  install(el) {
    el.append(this.el);
  }
  uninstall() {
    this.el.remove();
  }
};
__publicField(StyleSheet, "__name__", "StyleSheet");
var InlineStyleSheet = class extends StyleSheet {
  constructor(css) {
    super();
    __publicField(this, "el", style());
    if (isString(css)) {
      this._update(css);
    } else if (css != null) {
      this._update(compose_stylesheet(css));
    }
  }
  get css() {
    return this.el.textContent ?? "";
  }
  _update(css) {
    this.el.textContent = css;
  }
  clear() {
    this.replace("");
  }
  _to_css(css, styles3) {
    if (styles3 == null) {
      return css;
    } else {
      return compose_stylesheet({ [css]: styles3 });
    }
  }
  replace(css, styles3) {
    this._update(this._to_css(css, styles3));
  }
  prepend(css, styles3) {
    this._update(`${this._to_css(css, styles3)}
${this.css}`);
  }
  append(css, styles3) {
    this._update(`${this.css}
${this._to_css(css, styles3)}`);
  }
  remove() {
    this.el.remove();
  }
};
__publicField(InlineStyleSheet, "__name__", "InlineStyleSheet");
var GlobalInlineStyleSheet = class extends InlineStyleSheet {
  install() {
    if (!this.el.isConnected) {
      document.head.appendChild(this.el);
    }
  }
};
__publicField(GlobalInlineStyleSheet, "__name__", "GlobalInlineStyleSheet");
var ImportedStyleSheet = class extends StyleSheet {
  constructor(url2) {
    super();
    __publicField(this, "el");
    this.el = link({ rel: "stylesheet", href: url2 });
  }
  replace(url2) {
    this.el.href = url2;
  }
  remove() {
    this.el.remove();
  }
};
__publicField(ImportedStyleSheet, "__name__", "ImportedStyleSheet");
var GlobalImportedStyleSheet = class extends ImportedStyleSheet {
  install() {
    if (!this.el.isConnected) {
      document.head.appendChild(this.el);
    }
  }
};
__publicField(GlobalImportedStyleSheet, "__name__", "GlobalImportedStyleSheet");
async function dom_ready() {
  if (document.readyState == "loading") {
    return new Promise((resolve, _reject) => {
      document.addEventListener("DOMContentLoaded", () => resolve(), { once: true });
    });
  }
}
function px(value2) {
  return isNumber(value2) ? `${value2}px` : value2;
}
var supports_adopted_stylesheets = "adoptedStyleSheets" in ShadowRoot.prototype;

// node_modules/@bokeh/bokehjs/build/js/lib/core/dom_view.js
import base_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/base.css.js";
var _DOMView = class _DOMView extends View {
  constructor() {
    super(...arguments);
    __publicField(this, "el");
    __publicField(this, "shadow_el");
    __publicField(this, "_was_built", false);
  }
  get bbox() {
    return void 0;
  }
  serializable_state() {
    const state = super.serializable_state();
    const { bbox } = this;
    return bbox != null ? { ...state, bbox: bbox.round() } : state;
  }
  get children_el() {
    return this.shadow_el ?? this.el;
  }
  initialize() {
    super.initialize();
    this.el = this._create_element();
  }
  remove() {
    this.el.remove();
    super.remove();
  }
  stylesheets() {
    return [];
  }
  css_classes() {
    return [];
  }
  render_to(target) {
    this.render();
    target.appendChild(this.el);
  }
  after_render() {
    this.reposition();
  }
  r_after_render() {
    for (const child_view of this.children()) {
      if (child_view instanceof _DOMView) {
        child_view.r_after_render();
      }
    }
    this.after_render();
    this._was_built = true;
  }
  _create_element() {
    return create_element(this.constructor.tag_name, {});
  }
  reposition(_displayed) {
  }
  /**
   * Build a top-level DOM view (e.g. during embedding).
   */
  build(target) {
    assert(this.is_root);
    this.render_to(target);
    this.r_after_render();
    this.notify_finished();
  }
  /**
   * Define where to render this element or let the parent decide.
   *
   * This is useful when creating "floating" components or adding
   * components to canvas' layers.
   */
  rendering_target() {
    return null;
  }
};
__publicField(_DOMView, "__name__", "DOMView");
__publicField(_DOMView, "tag_name", "div");
var DOMView = _DOMView;
var DOMElementView = class extends DOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "class_list");
  }
  initialize() {
    super.initialize();
    this.class_list = new ClassList(this.el.classList);
  }
};
__publicField(DOMElementView, "__name__", "DOMElementView");
var DOMComponentView = class extends DOMElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_applied_stylesheets", []);
    __publicField(this, "_applied_css_classes", []);
  }
  initialize() {
    super.initialize();
    this.shadow_el = this.el.attachShadow({ mode: "open" });
  }
  stylesheets() {
    return [...super.stylesheets(), base_css];
  }
  empty() {
    empty2(this.shadow_el);
    this.class_list.clear();
    this._applied_css_classes = [];
    this._applied_stylesheets = [];
  }
  render() {
    this.empty();
    this._update_stylesheets();
    this._update_css_classes();
    this._update_css_variables();
  }
  reposition(_displayed) {
    this._update_css_variables();
  }
  *_stylesheets() {
    for (const style2 of this.stylesheets()) {
      yield isString(style2) ? new InlineStyleSheet(style2) : style2;
    }
  }
  *_css_classes() {
    yield `bk-${this.model.type.replace(/\./g, "-")}`;
    yield* this.css_classes();
  }
  *_css_variables() {
  }
  _apply_stylesheets(stylesheets) {
    this._applied_stylesheets.push(...stylesheets);
    stylesheets.forEach((stylesheet2) => stylesheet2.install(this.shadow_el));
  }
  _apply_css_classes(classes) {
    this._applied_css_classes.push(...classes);
    this.class_list.add(...classes);
  }
  _update_stylesheets() {
    this._applied_stylesheets.forEach((stylesheet2) => stylesheet2.uninstall());
    this._applied_stylesheets = [];
    this._apply_stylesheets([...this._stylesheets()]);
  }
  _update_css_classes() {
    this.class_list.remove(this._applied_css_classes);
    this._applied_css_classes = [];
    this._apply_css_classes([...this._css_classes()]);
  }
  _update_css_variables() {
    for (const [name, value2] of this._css_variables()) {
      const full_name = name.startsWith("--") ? name : `--${name}`;
      this.el.style.setProperty(full_name, value2);
    }
  }
};
__publicField(DOMComponentView, "__name__", "DOMComponentView");

// node_modules/@bokeh/bokehjs/build/js/lib/embed/standalone.js
var index = new Proxy(new ViewManager(), {
  get(manager, property) {
    if (isString(property)) {
      const view = manager.get_by_id(property);
      if (view != null) {
        return view;
      }
    }
    return Reflect.get(manager, property);
  },
  has(manager, property) {
    if (isString(property)) {
      const view = manager.get_by_id(property);
      if (view != null) {
        return true;
      }
    }
    return Reflect.has(manager, property);
  },
  ownKeys(manager) {
    return manager.roots.map((root) => root.model.id);
  },
  getOwnPropertyDescriptor(manager, property) {
    if (isString(property)) {
      const view = manager.get_by_id(property);
      if (view != null) {
        return { configurable: true, enumerable: true, writable: false, value: view };
      }
    }
    return Reflect.getOwnPropertyDescriptor(manager, property);
  }
});
async function add_document_standalone(document2, element, roots = [], use_for_title = false) {
  assert(document2.views_manager == null);
  const views = new ViewManager([], index);
  document2.views_manager = views;
  async function render_view(model2) {
    const view = await views.build_view(model2);
    if (view instanceof DOMView) {
      const i2 = document2.roots().indexOf(model2);
      const root_el = roots[i2] ?? element;
      view.build(root_el);
    }
    index.add(view);
  }
  async function render_model(model2) {
    if (model2.default_view != null) {
      await render_view(model2);
    } else {
      document2.notify_idle(model2);
    }
  }
  function unrender_model(model2) {
    const view = views.get(model2);
    view == null ? void 0 : view.remove();
  }
  for (const model2 of document2.roots()) {
    await render_model(model2);
  }
  if (use_for_title) {
    window.document.title = document2.title();
  }
  document2.on_change((event2) => {
    if (event2 instanceof RootAddedEvent) {
      void render_model(event2.model);
    } else if (event2 instanceof RootRemovedEvent) {
      unrender_model(event2.model);
    } else if (use_for_title && event2 instanceof TitleChangedEvent) {
      window.document.title = event2.title;
    }
  });
  return views;
}

// node_modules/@bokeh/bokehjs/build/js/lib/protocol/message.js
var _Message = class _Message {
  constructor(header4, metadata, content2) {
    __publicField(this, "header");
    __publicField(this, "metadata");
    __publicField(this, "content");
    __publicField(this, "_buffers", /* @__PURE__ */ new Map());
    this.header = header4;
    this.metadata = metadata;
    this.content = content2;
  }
  get buffers() {
    return this._buffers;
  }
  static assemble(header_json, metadata_json, content_json) {
    const header4 = JSON.parse(header_json);
    const metadata = JSON.parse(metadata_json);
    const content2 = JSON.parse(content_json);
    return new _Message(header4, metadata, content2);
  }
  assemble_buffer(buf_header, buf_payload) {
    const nb = this.header.num_buffers ?? 0;
    if (nb <= this._buffers.size) {
      throw new Error(`too many buffers received, expecting ${nb}`);
    }
    const { id } = JSON.parse(buf_header);
    this._buffers.set(id, buf_payload);
  }
  static create(msgtype, metadata, content2) {
    const header4 = _Message.create_header(msgtype);
    return new _Message(header4, metadata, content2);
  }
  static create_header(msgtype) {
    return {
      msgid: unique_id(),
      msgtype
    };
  }
  complete() {
    const { num_buffers } = this.header;
    return num_buffers == null || this._buffers.size == num_buffers;
  }
  send(socket) {
    assert(this.header.num_buffers == null);
    const buffers = [];
    const content_json = JSON.stringify(this.content, (_2, val) => {
      if (val instanceof Buffer) {
        const ref = { id: `${buffers.length}` };
        buffers.push([ref, val.buffer]);
        return ref;
      } else {
        return val;
      }
    });
    const num_buffers = buffers.length;
    if (num_buffers > 0) {
      this.header.num_buffers = num_buffers;
    }
    const header_json = JSON.stringify(this.header);
    const metadata_json = JSON.stringify(this.metadata);
    socket.send(header_json);
    socket.send(metadata_json);
    socket.send(content_json);
    for (const [ref, buffer] of buffers) {
      socket.send(JSON.stringify(ref));
      socket.send(buffer);
    }
  }
  msgid() {
    return this.header.msgid;
  }
  msgtype() {
    return this.header.msgtype;
  }
  reqid() {
    return this.header.reqid;
  }
  // return the reason we should close on bad protocol, if there is one
  problem() {
    if (!("msgid" in this.header)) {
      return "No msgid in header";
    } else if (!("msgtype" in this.header)) {
      return "No msgtype in header";
    } else {
      return null;
    }
  }
};
__publicField(_Message, "__name__", "Message");
var Message = _Message;

// node_modules/@bokeh/bokehjs/build/js/lib/protocol/receiver.js
var Receiver = class {
  constructor() {
    __publicField(this, "message", null);
    __publicField(this, "_partial", null);
    __publicField(this, "_fragments", []);
    __publicField(this, "_buf_header", null);
    __publicField(this, "_current_consumer", this._HEADER);
  }
  consume(fragment) {
    this._current_consumer(fragment);
  }
  _HEADER(fragment) {
    this._assume_text(fragment);
    this.message = null;
    this._partial = null;
    this._fragments = [fragment];
    this._buf_header = null;
    this._current_consumer = this._METADATA;
  }
  _METADATA(fragment) {
    this._assume_text(fragment);
    this._fragments.push(fragment);
    this._current_consumer = this._CONTENT;
  }
  _CONTENT(fragment) {
    this._assume_text(fragment);
    this._fragments.push(fragment);
    const [header_json, metadata_json, content_json] = this._fragments;
    assert(header_json != null && metadata_json != null && content_json != null);
    this._partial = Message.assemble(header_json, metadata_json, content_json);
    this._check_complete();
  }
  _BUFFER_HEADER(fragment) {
    this._assume_text(fragment);
    this._buf_header = fragment;
    this._current_consumer = this._BUFFER_PAYLOAD;
  }
  _BUFFER_PAYLOAD(fragment) {
    this._assume_binary(fragment);
    assert(this._partial != null && this._buf_header != null);
    this._partial.assemble_buffer(this._buf_header, fragment);
    this._check_complete();
  }
  _assume_text(fragment) {
    if (!isString(fragment)) {
      throw new Error("Expected text fragment but received binary fragment");
    }
  }
  _assume_binary(fragment) {
    if (!(fragment instanceof ArrayBuffer)) {
      throw new Error("Expected binary fragment but received text fragment");
    }
  }
  _check_complete() {
    if (this._partial.complete()) {
      this.message = this._partial;
      this._current_consumer = this._HEADER;
    } else {
      this._current_consumer = this._BUFFER_HEADER;
    }
  }
};
__publicField(Receiver, "__name__", "Receiver");

// node_modules/@bokeh/bokehjs/build/js/lib/client/session.js
var ClientSession = class {
  constructor(_connection, document2) {
    __publicField(this, "_connection");
    __publicField(this, "document");
    __publicField(this, "_document_listener", (event2) => {
      this._document_changed(event2);
    });
    this._connection = _connection;
    this.document = document2;
    this.document.on_change(this._document_listener, true);
  }
  // XXX: this is only needed in tests
  get id() {
    return this._connection.id;
  }
  handle(message) {
    const msgtype = message.msgtype();
    switch (msgtype) {
      case "PATCH-DOC": {
        this._handle_patch(message);
        break;
      }
      case "OK": {
        this._handle_ok(message);
        break;
      }
      case "ERROR": {
        this._handle_error(message);
        break;
      }
      default:
        logger.debug(`Doing nothing with message '${msgtype}'`);
    }
  }
  notify_connection_lost() {
    this.document.event_manager.send_event(new ConnectionLost());
  }
  close() {
    this._connection.close();
  }
  /*protected*/
  _connection_closed() {
    this.document.remove_on_change(this._document_listener);
  }
  // Sends a request to the server for info about the server, such as its Bokeh
  // version. Returns a promise, the value of the promise is a free-form dictionary
  // of server details.
  async request_server_info() {
    const message = Message.create("SERVER-INFO-REQ", {}, {});
    const reply = await this._connection.send_with_reply(message);
    return reply.content;
  }
  // Sends some request to the server (no guarantee about which one) and returns
  // a promise which is completed when the server replies. The purpose of this
  // is that if you wait for the promise to be completed, you know the server
  // has processed the request. This is useful when writing tests because once
  // the server has processed this request it should also have processed any
  // events or requests you sent previously, which means you can check for the
  // results of that processing without a race condition. (This assumes the
  // server processes events in sequence, which it mostly has to semantically,
  // since reordering events might change the final state.)
  async force_roundtrip() {
    await this.request_server_info();
  }
  _document_changed(event2) {
    const events3 = (() => {
      const events4 = event2 instanceof DocumentEventBatch ? event2.sync ? event2.events : [] : [event2];
      return events4.filter((event3) => event3.sync);
    })();
    if (events3.length == 0) {
      return;
    }
    const patch = this.document.create_json_patch(events3);
    const message = Message.create("PATCH-DOC", {}, patch);
    this._connection.send(message);
  }
  _handle_patch(message) {
    this.document.apply_json_patch(message.content, message.buffers);
  }
  _handle_ok(message) {
    logger.trace(`Unhandled OK reply to ${message.reqid()}`);
  }
  _handle_error(message) {
    logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content.text}`);
  }
};
__publicField(ClientSession, "__name__", "ClientSession");

// node_modules/@bokeh/bokehjs/build/js/lib/client/connection.js
var DEFAULT_SERVER_WEBSOCKET_URL = "ws://localhost:5006/ws";
var DEFAULT_TOKEN = "eyJzZXNzaW9uX2lkIjogImRlZmF1bHQifQ";
var _connection_count = 0;
function parse_token(token2) {
  let payload = token2.split(".")[0];
  const mod = payload.length % 4;
  if (mod != 0) {
    payload = payload + "=".repeat(4 - mod);
  }
  return JSON.parse(atob(payload.replace(/_/g, "/").replace(/-/g, "+")));
}
var ClientConnection = class {
  constructor(url2 = DEFAULT_SERVER_WEBSOCKET_URL, token2 = DEFAULT_TOKEN, args_string = null) {
    __publicField(this, "url");
    __publicField(this, "token");
    __publicField(this, "args_string");
    __publicField(this, "_number", _connection_count++);
    __publicField(this, "socket", null);
    __publicField(this, "session", null);
    __publicField(this, "closed_permanently", false);
    __publicField(this, "id");
    __publicField(this, "_current_handler", null);
    __publicField(this, "_pending_replies", /* @__PURE__ */ new Map());
    __publicField(this, "_pending_messages", []);
    __publicField(this, "_receiver", new Receiver());
    this.url = url2;
    this.token = token2;
    this.args_string = args_string;
    this.id = parse_token(token2).session_id.split(".")[0];
    logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`);
  }
  async connect() {
    if (this.closed_permanently) {
      throw new Error("Cannot connect() a closed ClientConnection");
    }
    if (this.socket != null) {
      throw new Error("Already connected");
    }
    this._current_handler = null;
    this._pending_replies.clear();
    this._pending_messages = [];
    try {
      let versioned_url = `${this.url}`;
      if (this.args_string != null && this.args_string.length > 0) {
        versioned_url += `?${this.args_string}`;
      }
      this.socket = new WebSocket(versioned_url, ["bokeh", this.token]);
      return new Promise((resolve, reject) => {
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = () => this._on_open(resolve, reject);
        this.socket.onmessage = (event2) => this._on_message(event2);
        this.socket.onclose = (event2) => this._on_close(event2, reject);
        this.socket.onerror = () => this._on_error(reject);
      });
    } catch (error) {
      logger.error(`websocket creation failed to url: ${this.url}`);
      logger.error(` - ${error}`);
      throw error;
    }
  }
  close() {
    if (!this.closed_permanently) {
      logger.debug(`Permanently closing websocket connection ${this._number}`);
      this.closed_permanently = true;
      if (this.socket != null) {
        this.socket.close(1e3, `close method called on ClientConnection ${this._number}`);
      }
      this.session._connection_closed();
    }
  }
  _schedule_reconnect(milliseconds) {
    const retry = () => {
      var _a34;
      if (!this.closed_permanently) {
        logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`);
        (_a34 = this.session) == null ? void 0 : _a34.notify_connection_lost();
      }
      return;
    };
    setTimeout(retry, milliseconds);
  }
  send(message) {
    if (this.socket != null) {
      message.send(this.socket);
    } else {
      logger.error("not connected so cannot send", message);
    }
  }
  async send_with_reply(message) {
    const reply = await new Promise((resolve, reject) => {
      this._pending_replies.set(message.msgid(), { resolve, reject });
      this.send(message);
    });
    if (reply.msgtype() == "ERROR") {
      throw new Error(`Error reply ${reply.content.text}`);
    } else {
      return reply;
    }
  }
  async _pull_doc_json() {
    const message = Message.create("PULL-DOC-REQ", {}, {});
    const reply = await this.send_with_reply(message);
    if (!("doc" in reply.content)) {
      throw new Error("No 'doc' field in PULL-DOC-REPLY");
    }
    return reply.content.doc;
  }
  async _repull_session_doc(resolve, reject) {
    logger.debug(this.session != null ? "Repulling session" : "Pulling session for first time");
    try {
      const doc_json = await this._pull_doc_json();
      if (this.session == null) {
        if (this.closed_permanently) {
          logger.debug("Got new document after connection was already closed");
          reject(new Error("The connection has been closed"));
        } else {
          const events3 = [];
          const document2 = Document.from_json(doc_json, events3);
          this.session = new ClientSession(this, document2);
          for (const event2 of events3) {
            document2._trigger_on_change(event2);
          }
          for (const msg of this._pending_messages) {
            this.session.handle(msg);
          }
          this._pending_messages = [];
          logger.debug("Created a new session from new pulled doc");
          resolve(this.session);
        }
      } else {
        this.session.document.replace_with_json(doc_json);
        logger.debug("Updated existing session with new pulled doc");
      }
    } catch (error) {
      console.trace(error);
      logger.error(`Failed to repull session ${error}`);
      reject(error instanceof Error ? error : `${error}`);
    }
  }
  _on_open(resolve, reject) {
    logger.info(`Websocket connection ${this._number} is now open`);
    this._current_handler = (message) => {
      this._awaiting_ack_handler(message, resolve, reject);
    };
  }
  _on_message(event2) {
    if (this._current_handler == null) {
      logger.error("Got a message with no current handler set");
    }
    try {
      this._receiver.consume(event2.data);
    } catch (e) {
      this._close_bad_protocol(`${e}`);
    }
    const msg = this._receiver.message;
    if (msg != null) {
      const problem = msg.problem();
      if (problem != null) {
        this._close_bad_protocol(problem);
      }
      this._current_handler(msg);
    }
  }
  _on_close(event2, reject) {
    logger.info(`Lost websocket ${this._number} connection, ${event2.code} (${event2.reason})`);
    this.socket = null;
    this._pending_replies.forEach((pr) => pr.reject("Disconnected"));
    this._pending_replies.clear();
    if (!this.closed_permanently) {
      this._schedule_reconnect(2e3);
    }
    reject(new Error(`Lost websocket connection, ${event2.code} (${event2.reason})`));
  }
  _on_error(reject) {
    logger.debug(`Websocket error on socket ${this._number}`);
    const msg = "Could not open websocket";
    logger.error(`Failed to connect to Bokeh server: ${msg}`);
    reject(new Error(msg));
  }
  _close_bad_protocol(detail) {
    logger.error(`Closing connection: ${detail}`);
    if (this.socket != null) {
      this.socket.close(1002, detail);
    }
  }
  _awaiting_ack_handler(message, resolve, reject) {
    if (message.msgtype() === "ACK") {
      this._current_handler = (message2) => this._steady_state_handler(message2);
      void this._repull_session_doc(resolve, reject);
    } else {
      this._close_bad_protocol("First message was not an ACK");
    }
  }
  _steady_state_handler(message) {
    const reqid = message.reqid();
    const pr = this._pending_replies.get(reqid);
    if (pr != null) {
      this._pending_replies.delete(reqid);
      pr.resolve(message);
    } else if (this.session != null) {
      this.session.handle(message);
    } else if (message.msgtype() != "PATCH-DOC") {
      this._pending_messages.push(message);
    }
  }
};
__publicField(ClientConnection, "__name__", "ClientConnection");
function pull_session(url2, token2, args_string) {
  const connection = new ClientConnection(url2, token2, args_string);
  return connection.connect();
}

// node_modules/@bokeh/bokehjs/build/js/lib/embed/server.js
function _get_ws_url(app_path, absolute_url) {
  if (absolute_url === void 0 && _is_frame_HTMLElement(frameElement) && frameElement.dataset.absoluteUrl !== void 0) {
    absolute_url = frameElement.dataset.absoluteUrl;
  }
  let loc;
  if (absolute_url != null) {
    loc = document.createElement("a");
    loc.href = absolute_url;
  } else {
    loc = window.location;
  }
  const protocol = loc.protocol == "https:" ? "wss:" : "ws:";
  if (app_path != null) {
    if (app_path == "/") {
      app_path = "";
    }
  } else {
    app_path = loc.pathname.replace(/\/+$/, "");
  }
  return `${protocol}//${loc.host}${app_path}/ws`;
}
function _is_frame_HTMLElement(frame) {
  if (frame === null) {
    return false;
  }
  if (frame.tagName.toUpperCase() === "IFRAME") {
    return true;
  }
  return false;
}
var _sessions = /* @__PURE__ */ new Map();
function _get_session(websocket_url, token2, args_string) {
  const session_id = parse_token(token2).session_id;
  if (!_sessions.has(websocket_url)) {
    _sessions.set(websocket_url, /* @__PURE__ */ new Map());
  }
  const subsessions = _sessions.get(websocket_url);
  if (!subsessions.has(session_id)) {
    subsessions.set(session_id, pull_session(websocket_url, token2, args_string));
  }
  return subsessions.get(session_id);
}
async function add_document_from_session(websocket_url, token2, element, roots = [], use_for_title = false) {
  const args_string = window.location.search.substring(1);
  let session;
  try {
    session = await _get_session(websocket_url, token2, args_string);
  } catch (error) {
    const session_id = parse_token(token2).session_id;
    logger.error(`Failed to load Bokeh session ${session_id}: ${error}`);
    throw error;
  }
  return add_document_standalone(session.document, element, roots, use_for_title);
}

// node_modules/@bokeh/bokehjs/build/js/lib/embed/dom.js
function _get_element(target) {
  let element = isString(target) ? document.getElementById(target) : target;
  if (element == null) {
    throw new Error(`Error rendering Bokeh model: could not find ${isString(target) ? `#${target}` : target} HTML tag`);
  }
  if (!contains2(document.body, element)) {
    throw new Error(`Error rendering Bokeh model: element ${isString(target) ? `#${target}` : target} must be under <body>`);
  }
  if (element instanceof HTMLElement && element.tagName == "SCRIPT") {
    const root_el = div();
    element.replaceWith(root_el);
    element = root_el;
  }
  return element;
}
function _resolve_element(item3) {
  const { elementid } = item3;
  if (elementid != null) {
    return _get_element(elementid);
  } else {
    return document.body;
  }
}
function _resolve_root_elements(item3) {
  const roots = [];
  if (item3.root_ids != null && item3.roots != null) {
    for (const root_id of item3.root_ids) {
      roots.push(_get_element(item3.roots[root_id]));
    }
  }
  return roots;
}

// node_modules/@bokeh/bokehjs/build/js/lib/embed/notebook.js
var kernels = {};
function _handle_notebook_comms(receiver, comm_msg) {
  if (comm_msg.buffers.length > 0) {
    receiver.consume(comm_msg.buffers[0].buffer);
  } else {
    receiver.consume(comm_msg.content.data);
  }
  const msg = receiver.message;
  if (msg != null) {
    this.apply_json_patch(msg.content, msg.buffers);
  }
}
function _init_comms(target, doc) {
  if (typeof Jupyter !== "undefined" && Jupyter.notebook.kernel != null) {
    logger.info(`Registering Jupyter comms for target ${target}`);
    const comm_manager = Jupyter.notebook.kernel.comm_manager;
    try {
      comm_manager.register_target(target, (comm) => {
        logger.info(`Registering Jupyter comms for target ${target}`);
        const r = new Receiver();
        comm.on_msg(_handle_notebook_comms.bind(doc, r));
      });
    } catch (e) {
      logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);
    }
  } else if (doc.roots()[0].id in kernels) {
    logger.info(`Registering JupyterLab comms for target ${target}`);
    const kernel = kernels[doc.roots()[0].id];
    try {
      kernel.registerCommTarget(target, (comm) => {
        logger.info(`Registering JupyterLab comms for target ${target}`);
        const r = new Receiver();
        comm.onMsg = _handle_notebook_comms.bind(doc, r);
      });
    } catch (e) {
      logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);
    }
  } else if (typeof google != "undefined" && google.colab.kernel != null) {
    logger.info(`Registering Google Colab comms for target ${target}`);
    const comm_manager = google.colab.kernel.comms;
    try {
      comm_manager.registerTarget(target, async (comm) => {
        logger.info(`Registering Google Colab comms for target ${target}`);
        const r = new Receiver();
        for await (const message of comm.messages) {
          const content2 = { data: message.data };
          const buffers = [];
          for (const buffer of message.buffers ?? []) {
            buffers.push(new DataView(buffer));
          }
          const msg = { content: content2, buffers };
          _handle_notebook_comms.bind(doc)(r, msg);
        }
      });
    } catch (e) {
      logger.warn(`Google Colab comms failed to register. push_notebook() will not function. (exception reported: ${e})`);
    }
  } else {
    console.warn("Jupyter notebooks comms not available. push_notebook() will not function. If running JupyterLab ensure the latest @bokeh/jupyter_bokeh extension is installed. In an exported notebook this warning is expected.");
  }
}
async function embed_items_notebook(docs_json, render_items) {
  if (size(docs_json) != 1) {
    throw new Error("embed_items_notebook expects exactly one document in docs_json");
  }
  const document2 = Document.from_json(values(docs_json)[0]);
  for (const item3 of render_items) {
    if (item3.notebook_comms_target != null) {
      _init_comms(item3.notebook_comms_target, document2);
    }
    const element = _resolve_element(item3);
    const roots = _resolve_root_elements(item3);
    await add_document_standalone(document2, element, roots);
    for (const root of roots) {
      if (root instanceof HTMLElement) {
        root.removeAttribute("id");
      }
    }
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/embed/index.js
async function embed_item(item3, target) {
  const docs_json = {};
  const doc_id = uuid4();
  docs_json[doc_id] = item3.doc;
  if (target == null) {
    target = item3.target_id;
  }
  const roots = { [item3.root_id]: target };
  const render_item = { roots, root_ids: [item3.root_id], docid: doc_id };
  await defer();
  const [views] = await _embed_items(docs_json, [render_item]);
  return views;
}
async function embed_items(docs_json, render_items, app_path, absolute_url) {
  await defer();
  return _embed_items(docs_json, render_items, app_path, absolute_url);
}
async function _embed_items(docs_json, render_items, app_path, absolute_url) {
  if (isString(docs_json)) {
    docs_json = JSON.parse(unescape(docs_json));
  }
  const docs = {};
  for (const [docid, doc_json] of entries(docs_json)) {
    docs[docid] = Document.from_json(doc_json);
  }
  const views = [];
  for (const item3 of render_items) {
    const element = _resolve_element(item3);
    const roots = _resolve_root_elements(item3);
    if (item3.docid != null) {
      views.push(await add_document_standalone(docs[item3.docid], element, roots, item3.use_for_title));
    } else if (item3.token != null) {
      const websocket_url = _get_ws_url(app_path, absolute_url);
      logger.debug(`embed: computed ws url: ${websocket_url}`);
      try {
        views.push(await add_document_from_session(websocket_url, item3.token, element, roots, item3.use_for_title));
        console.log("Bokeh items were rendered successfully");
      } catch (error) {
        if (settings.dev) {
          throw error;
        } else {
          console.error("Error rendering Bokeh items:", error);
        }
      }
    } else {
      throw new Error("Error rendering Bokeh items: either 'docid' or 'token' was expected.");
    }
  }
  return views;
}

// node_modules/@bokeh/bokehjs/build/js/lib/protocol/index.js
var protocol_exports = {};
__export(protocol_exports, {
  Message: () => Message,
  Receiver: () => Receiver
});

// node_modules/@bokeh/bokehjs/build/js/lib/safely.js
function _burst_into_flames(error) {
  const box = document.createElement("div");
  box.style.backgroundColor = "#f2dede";
  box.style.border = "1px solid #a94442";
  box.style.borderRadius = "4px";
  box.style.display = "inline-block";
  box.style.fontFamily = "sans-serif";
  box.style.marginTop = "5px";
  box.style.minWidth = "200px";
  box.style.padding = "5px 5px 5px 10px";
  box.classList.add("bokeh-error-box-into-flames");
  const button2 = document.createElement("span");
  button2.style.backgroundColor = "#a94442";
  button2.style.borderRadius = "0px 4px 0px 0px";
  button2.style.color = "white";
  button2.style.cursor = "pointer";
  button2.style.cssFloat = "right";
  button2.style.fontSize = "0.8em";
  button2.style.margin = "-6px -6px 0px 0px";
  button2.style.padding = "2px 5px 4px 5px";
  button2.title = "close";
  button2.setAttribute("aria-label", "close");
  button2.appendChild(document.createTextNode("x"));
  button2.addEventListener("click", () => body2.removeChild(box));
  const title3 = document.createElement("h3");
  title3.style.color = "#a94442";
  title3.style.margin = "8px 0px 0px 0px";
  title3.style.padding = "0px";
  title3.appendChild(document.createTextNode("Bokeh Error"));
  const message = document.createElement("pre");
  message.style.whiteSpace = "unset";
  message.style.overflowX = "auto";
  message.appendChild(document.createTextNode(error));
  box.appendChild(button2);
  box.appendChild(title3);
  box.appendChild(message);
  const body2 = document.getElementsByTagName("body")[0];
  body2.insertBefore(box, body2.firstChild);
}
function safely(fn, silent = false) {
  try {
    return fn();
  } catch (error) {
    const text2 = error instanceof Error && error.stack != null ? error.stack : `${error}`;
    _burst_into_flames(text2);
    if (!silent) {
      throw error;
    } else {
      return;
    }
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/index.js
var models_exports = {};
__export(models_exports, {
  ActionItem: () => ActionItem,
  ActionTool: () => ActionTool,
  AdaptiveTicker: () => AdaptiveTicker,
  AjaxDataSource: () => AjaxDataSource,
  AllIndices: () => AllIndices,
  AllLabels: () => AllLabels,
  Angular: () => Angular,
  Annotation: () => Annotation,
  AnnularWedge: () => AnnularWedge,
  Annulus: () => Annulus,
  Arc: () => Arc,
  AreaVisuals: () => AreaVisuals,
  Arrow: () => Arrow,
  ArrowHead: () => ArrowHead,
  Ascii: () => Ascii,
  Axis: () => Axis,
  BBoxTileSource: () => BBoxTileSource,
  Band: () => Band,
  BaseColorBar: () => BaseColorBar,
  BasicTickFormatter: () => BasicTickFormatter,
  BasicTicker: () => BasicTicker,
  Bezier: () => Bezier,
  BinnedTicker: () => BinnedTicker,
  Block: () => Block,
  BooleanFilter: () => BooleanFilter,
  BoxAnnotation: () => BoxAnnotation,
  BoxEditTool: () => BoxEditTool,
  BoxInteractionHandles: () => BoxInteractionHandles,
  BoxSelectTool: () => BoxSelectTool,
  BoxZoomTool: () => BoxZoomTool,
  BuiltinIcon: () => BuiltinIcon,
  ByCSS: () => ByCSS,
  ByClass: () => ByClass,
  ByID: () => ByID,
  ByXPath: () => ByXPath,
  CDSView: () => CDSView,
  Canvas: () => Canvas,
  CanvasTexture: () => CanvasTexture,
  CartesianFrame: () => CartesianFrame,
  CategoricalAxis: () => CategoricalAxis,
  CategoricalColorMapper: () => CategoricalColorMapper,
  CategoricalMarkerMapper: () => CategoricalMarkerMapper,
  CategoricalPatternMapper: () => CategoricalPatternMapper,
  CategoricalScale: () => CategoricalScale,
  CategoricalTickFormatter: () => CategoricalTickFormatter,
  CategoricalTicker: () => CategoricalTicker,
  CheckableItem: () => CheckableItem,
  Circle: () => Circle,
  ClickButton: () => ClickButton,
  ClickPanTool: () => ClickPanTool,
  CloseDialog: () => CloseDialog,
  ColorBar: () => ColorBar,
  ColorMapper: () => ColorMapper,
  Column: () => Column2,
  ColumnDataSource: () => ColumnDataSource,
  ColumnarDataSource: () => ColumnarDataSource,
  Comparison: () => Comparison,
  CompositeScale: () => CompositeScale,
  CompositeTicker: () => CompositeTicker,
  ContinuousAxis: () => ContinuousAxis,
  ContinuousColorMapper: () => ContinuousColorMapper,
  ContinuousScale: () => ContinuousScale,
  ContinuousTicker: () => ContinuousTicker,
  ContourColorBar: () => ContourColorBar,
  ContourRenderer: () => ContourRenderer,
  CoordinateMapping: () => CoordinateMapping,
  CopyTool: () => CopyTool,
  CrosshairTool: () => CrosshairTool,
  CumSum: () => CumSum,
  CustomAction: () => CustomAction,
  CustomJS: () => CustomJS,
  CustomJSCompare: () => CustomJSCompare,
  CustomJSExpr: () => CustomJSExpr,
  CustomJSFilter: () => CustomJSFilter,
  CustomJSHover: () => CustomJSHover,
  CustomJSTickFormatter: () => CustomJSTickFormatter,
  CustomJSTicker: () => CustomJSTicker,
  CustomJSTransform: () => CustomJSTransform,
  CustomLabelingPolicy: () => CustomLabelingPolicy,
  DataRange: () => DataRange,
  DataRange1d: () => DataRange1d,
  DataSource: () => DataSource,
  DatetimeAxis: () => DatetimeAxis,
  DatetimeTickFormatter: () => DatetimeTickFormatter,
  DatetimeTicker: () => DatetimeTicker,
  DaysTicker: () => DaysTicker,
  Decoration: () => Decoration,
  Dialog: () => Dialog,
  DifferenceFilter: () => DifferenceFilter,
  DividerItem: () => DividerItem,
  Dodge: () => Dodge,
  EdgeCoordinates: () => EdgeCoordinates,
  EdgesAndLinkedNodes: () => EdgesAndLinkedNodes,
  EdgesOnly: () => EdgesOnly,
  EditTool: () => EditTool,
  Ellipse: () => Ellipse,
  EqHistColorMapper: () => EqHistColorMapper,
  ExamineTool: () => ExamineTool,
  Examiner: () => Examiner,
  Expression: () => Expression,
  FactorRange: () => FactorRange,
  Figure: () => Figure,
  Filter: () => Filter,
  FixedTicker: () => FixedTicker,
  FlexBox: () => FlexBox,
  FreehandDrawTool: () => FreehandDrawTool,
  FullscreenTool: () => FullscreenTool,
  GMap: () => GMap,
  GMapOptions: () => GMapOptions,
  GMapPlot: () => GMapPlot,
  GeoJSONDataSource: () => GeoJSONDataSource,
  GestureTool: () => GestureTool,
  Glyph: () => Glyph,
  GlyphRenderer: () => GlyphRenderer,
  GraphCoordinates: () => GraphCoordinates,
  GraphHitTestPolicy: () => GraphHitTestPolicy,
  GraphLayout: () => GraphLayout,
  GraphRenderer: () => GraphRenderer,
  Grid: () => Grid2,
  GridBox: () => GridBox,
  GridPlot: () => GridPlot,
  GroupBox: () => GroupBox,
  GroupByModels: () => GroupByModels,
  GroupByName: () => GroupByName,
  GroupFilter: () => GroupFilter,
  GuideRenderer: () => GuideRenderer,
  HArea: () => HArea,
  HAreaStep: () => HAreaStep,
  HBar: () => HBar,
  HBox: () => HBox,
  HSpan: () => HSpan,
  HStrip: () => HStrip,
  HTMLLabel: () => HTMLLabel,
  HTMLLabelSet: () => HTMLLabelSet,
  HTMLTitle: () => HTMLTitle,
  HelpTool: () => HelpTool,
  HexTile: () => HexTile,
  HoverTool: () => HoverTool,
  Image: () => Image4,
  ImageRGBA: () => ImageRGBA,
  ImageStack: () => ImageStack,
  ImageURL: () => ImageURL,
  ImageURLTexture: () => ImageURLTexture,
  ImperialLength: () => ImperialLength,
  IndexFilter: () => IndexFilter,
  Indexed: () => Indexed,
  InspectTool: () => InspectTool,
  Interpolator: () => Interpolator,
  IntersectRenderers: () => IntersectRenderers,
  IntersectionFilter: () => IntersectionFilter,
  InversionFilter: () => InversionFilter,
  Jitter: () => Jitter,
  Label: () => Label,
  LabelSet: () => LabelSet,
  LabelingPolicy: () => LabelingPolicy,
  LassoSelectTool: () => LassoSelectTool,
  LayoutDOM: () => LayoutDOM,
  LayoutProvider: () => LayoutProvider,
  Legend: () => Legend,
  LegendItem: () => LegendItem,
  Line: () => Line3,
  LineEditTool: () => LineEditTool,
  LinearAxis: () => LinearAxis,
  LinearColorMapper: () => LinearColorMapper,
  LinearInterpolationScale: () => LinearInterpolationScale,
  LinearInterpolator: () => LinearInterpolator,
  LinearScale: () => LinearScale,
  LogAxis: () => LogAxis,
  LogColorMapper: () => LogColorMapper,
  LogScale: () => LogScale,
  LogTickFormatter: () => LogTickFormatter,
  LogTicker: () => LogTicker,
  MapOptions: () => MapOptions,
  Marking: () => Marking,
  MathML: () => MathML,
  MathMLGlyph: () => MathMLGlyph,
  MathText: () => MathText,
  Maximum: () => Maximum,
  Menu: () => Menu,
  MercatorAxis: () => MercatorAxis,
  MercatorTickFormatter: () => MercatorTickFormatter,
  MercatorTicker: () => MercatorTicker,
  MercatorTileSource: () => MercatorTileSource,
  Metric: () => Metric,
  MetricLength: () => MetricLength,
  Minimum: () => Minimum,
  MonthsTicker: () => MonthsTicker,
  MultiLine: () => MultiLine,
  MultiPolygons: () => MultiPolygons,
  NanCompare: () => NanCompare,
  Ngon: () => Ngon,
  NoOverlap: () => NoOverlap,
  Node: () => Node2,
  NodeCoordinates: () => NodeCoordinates,
  NodesAndAdjacentNodes: () => NodesAndAdjacentNodes,
  NodesAndLinkedEdges: () => NodesAndLinkedEdges,
  NodesOnly: () => NodesOnly,
  NormalHead: () => NormalHead,
  NumeralTickFormatter: () => NumeralTickFormatter,
  OnOffButton: () => OnOffButton,
  OpenDialog: () => OpenDialog,
  OpenHead: () => OpenHead,
  OpenURL: () => OpenURL,
  PanTool: () => PanTool,
  Pane: () => Pane,
  Panel: () => Panel,
  ParkMillerLCG: () => ParkMillerLCG,
  Patch: () => Patch,
  Patches: () => Patches,
  PlainText: () => PlainText,
  Plot: () => Plot,
  PointDrawTool: () => PointDrawTool,
  PolarTransform: () => PolarTransform,
  PolyAnnotation: () => PolyAnnotation,
  PolyDrawTool: () => PolyDrawTool,
  PolyEditTool: () => PolyEditTool,
  PolySelectTool: () => PolySelectTool,
  PolyTool: () => PolyTool,
  PrintfTickFormatter: () => PrintfTickFormatter,
  QUADKEYTileSource: () => QUADKEYTileSource,
  Quad: () => Quad,
  Quadratic: () => Quadratic,
  Range: () => Range,
  Range1d: () => Range1d,
  RangeTool: () => RangeTool,
  Ray: () => Ray,
  ReciprocalMetric: () => ReciprocalMetric,
  ReciprocalMetricLength: () => ReciprocalMetricLength,
  Rect: () => Rect,
  RedoTool: () => RedoTool,
  Renderer: () => Renderer,
  RendererGroup: () => RendererGroup,
  ResetTool: () => ResetTool,
  Row: () => Row2,
  SVGIcon: () => SVGIcon,
  SaveTool: () => SaveTool,
  ScalarExpression: () => ScalarExpression,
  Scale: () => Scale,
  ScaleBar: () => ScaleBar,
  ScanningColorMapper: () => ScanningColorMapper,
  Scatter: () => Scatter,
  ScrollBox: () => ScrollBox,
  Segment: () => Segment,
  SelectTool: () => SelectTool,
  Selection: () => Selection,
  SelectionPolicy: () => SelectionPolicy,
  ServerSentDataSource: () => ServerSentDataSource,
  SetValue: () => SetValue,
  SingleIntervalTicker: () => SingleIntervalTicker,
  Slope: () => Slope,
  Spacer: () => Spacer,
  Span: () => Span2,
  Spline: () => Spline,
  Stack: () => Stack2,
  StackColorMapper: () => StackColorMapper,
  StaticLayoutProvider: () => StaticLayoutProvider,
  Step: () => Step,
  StepInterpolator: () => StepInterpolator,
  SymmetricDifferenceFilter: () => SymmetricDifferenceFilter,
  TMSTileSource: () => TMSTileSource,
  TabPanel: () => TabPanel,
  TablerIcon: () => TablerIcon,
  Tabs: () => Tabs,
  TapTool: () => TapTool,
  TeX: () => TeX,
  TeXGlyph: () => TeXGlyph,
  TeeHead: () => TeeHead,
  Text: () => Text4,
  TextAnnotation: () => TextAnnotation,
  Texture: () => Texture,
  TickFormatter: () => TickFormatter,
  Ticker: () => Ticker,
  TileRenderer: () => TileRenderer,
  TileSource: () => TileSource,
  Title: () => Title,
  ToggleVisibility: () => ToggleVisibility,
  Tool: () => Tool,
  ToolButton: () => ToolButton,
  ToolProxy: () => ToolProxy,
  Toolbar: () => Toolbar,
  ToolbarPanel: () => ToolbarPanel,
  Tooltip: () => Tooltip,
  Transform: () => Transform,
  UIElement: () => UIElement,
  UndoTool: () => UndoTool,
  UnionFilter: () => UnionFilter,
  UnionRenderers: () => UnionRenderers,
  VArea: () => VArea,
  VAreaStep: () => VAreaStep,
  VBar: () => VBar,
  VBox: () => VBox,
  VSpan: () => VSpan,
  VStrip: () => VStrip,
  VeeHead: () => VeeHead,
  WMTSTileSource: () => WMTSTileSource,
  WebDataSource: () => WebDataSource,
  Wedge: () => Wedge,
  WeightedStackColorMapper: () => WeightedStackColorMapper,
  WheelPanTool: () => WheelPanTool,
  WheelZoomTool: () => WheelZoomTool,
  Whisker: () => Whisker,
  XComponent: () => XComponent,
  XY: () => XY,
  YComponent: () => YComponent,
  YearsTicker: () => YearsTicker,
  ZoomInTool: () => ZoomInTool,
  ZoomOutTool: () => ZoomOutTool
});

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/area_visuals.js
var _AreaVisuals = class _AreaVisuals extends Model {
  constructor(attrs) {
    super(attrs);
  }
  clone(attrs) {
    return super.clone(attrs);
  }
};
__publicField(_AreaVisuals, "__name__", "AreaVisuals");
_AreaVisuals.mixins([
  Line,
  Fill,
  Hatch,
  ["hover_", Line],
  ["hover_", Fill],
  ["hover_", Hatch]
]);
var AreaVisuals = _AreaVisuals;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/styles.js
var _Styles = class _Styles extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Styles, "__name__", "Styles");
_Styles.define(({ Str: Str2, Nullable: Nullable2 }) => ({
  align_content: [Nullable2(Str2), null],
  align_items: [Nullable2(Str2), null],
  align_self: [Nullable2(Str2), null],
  alignment_baseline: [Nullable2(Str2), null],
  all: [Nullable2(Str2), null],
  animation: [Nullable2(Str2), null],
  animation_delay: [Nullable2(Str2), null],
  animation_direction: [Nullable2(Str2), null],
  animation_duration: [Nullable2(Str2), null],
  animation_fill_mode: [Nullable2(Str2), null],
  animation_iteration_count: [Nullable2(Str2), null],
  animation_name: [Nullable2(Str2), null],
  animation_play_state: [Nullable2(Str2), null],
  animation_timing_function: [Nullable2(Str2), null],
  aspect_ratio: [Nullable2(Str2), null],
  backface_visibility: [Nullable2(Str2), null],
  background: [Nullable2(Str2), null],
  background_attachment: [Nullable2(Str2), null],
  background_clip: [Nullable2(Str2), null],
  background_color: [Nullable2(Str2), null],
  background_image: [Nullable2(Str2), null],
  background_origin: [Nullable2(Str2), null],
  background_position: [Nullable2(Str2), null],
  background_position_x: [Nullable2(Str2), null],
  background_position_y: [Nullable2(Str2), null],
  background_repeat: [Nullable2(Str2), null],
  background_size: [Nullable2(Str2), null],
  baseline_shift: [Nullable2(Str2), null],
  block_size: [Nullable2(Str2), null],
  border: [Nullable2(Str2), null],
  border_block_end: [Nullable2(Str2), null],
  border_block_end_color: [Nullable2(Str2), null],
  border_block_end_style: [Nullable2(Str2), null],
  border_block_end_width: [Nullable2(Str2), null],
  border_block_start: [Nullable2(Str2), null],
  border_block_start_color: [Nullable2(Str2), null],
  border_block_start_style: [Nullable2(Str2), null],
  border_block_start_width: [Nullable2(Str2), null],
  border_bottom: [Nullable2(Str2), null],
  border_bottom_color: [Nullable2(Str2), null],
  border_bottom_left_radius: [Nullable2(Str2), null],
  border_bottom_right_radius: [Nullable2(Str2), null],
  border_bottom_style: [Nullable2(Str2), null],
  border_bottom_width: [Nullable2(Str2), null],
  border_collapse: [Nullable2(Str2), null],
  border_color: [Nullable2(Str2), null],
  border_image: [Nullable2(Str2), null],
  border_image_outset: [Nullable2(Str2), null],
  border_image_repeat: [Nullable2(Str2), null],
  border_image_slice: [Nullable2(Str2), null],
  border_image_source: [Nullable2(Str2), null],
  border_image_width: [Nullable2(Str2), null],
  border_inline_end: [Nullable2(Str2), null],
  border_inline_end_color: [Nullable2(Str2), null],
  border_inline_end_style: [Nullable2(Str2), null],
  border_inline_end_width: [Nullable2(Str2), null],
  border_inline_start: [Nullable2(Str2), null],
  border_inline_start_color: [Nullable2(Str2), null],
  border_inline_start_style: [Nullable2(Str2), null],
  border_inline_start_width: [Nullable2(Str2), null],
  border_left: [Nullable2(Str2), null],
  border_left_color: [Nullable2(Str2), null],
  border_left_style: [Nullable2(Str2), null],
  border_left_width: [Nullable2(Str2), null],
  border_radius: [Nullable2(Str2), null],
  border_right: [Nullable2(Str2), null],
  border_right_color: [Nullable2(Str2), null],
  border_right_style: [Nullable2(Str2), null],
  border_right_width: [Nullable2(Str2), null],
  border_spacing: [Nullable2(Str2), null],
  border_style: [Nullable2(Str2), null],
  border_top: [Nullable2(Str2), null],
  border_top_color: [Nullable2(Str2), null],
  border_top_left_radius: [Nullable2(Str2), null],
  border_top_right_radius: [Nullable2(Str2), null],
  border_top_style: [Nullable2(Str2), null],
  border_top_width: [Nullable2(Str2), null],
  border_width: [Nullable2(Str2), null],
  bottom: [Nullable2(Str2), null],
  box_shadow: [Nullable2(Str2), null],
  box_sizing: [Nullable2(Str2), null],
  break_after: [Nullable2(Str2), null],
  break_before: [Nullable2(Str2), null],
  break_inside: [Nullable2(Str2), null],
  caption_side: [Nullable2(Str2), null],
  caret_color: [Nullable2(Str2), null],
  clear: [Nullable2(Str2), null],
  clip: [Nullable2(Str2), null],
  clip_path: [Nullable2(Str2), null],
  clip_rule: [Nullable2(Str2), null],
  color: [Nullable2(Str2), null],
  color_interpolation: [Nullable2(Str2), null],
  color_interpolation_filters: [Nullable2(Str2), null],
  column_count: [Nullable2(Str2), null],
  column_fill: [Nullable2(Str2), null],
  column_gap: [Nullable2(Str2), null],
  column_rule: [Nullable2(Str2), null],
  column_rule_color: [Nullable2(Str2), null],
  column_rule_style: [Nullable2(Str2), null],
  column_rule_width: [Nullable2(Str2), null],
  column_span: [Nullable2(Str2), null],
  column_width: [Nullable2(Str2), null],
  columns: [Nullable2(Str2), null],
  content: [Nullable2(Str2), null],
  counter_increment: [Nullable2(Str2), null],
  counter_reset: [Nullable2(Str2), null],
  cursor: [Nullable2(Str2), null],
  direction: [Nullable2(Str2), null],
  display: [Nullable2(Str2), null],
  dominant_baseline: [Nullable2(Str2), null],
  empty_cells: [Nullable2(Str2), null],
  fill: [Nullable2(Str2), null],
  fill_opacity: [Nullable2(Str2), null],
  fill_rule: [Nullable2(Str2), null],
  filter: [Nullable2(Str2), null],
  flex: [Nullable2(Str2), null],
  flex_basis: [Nullable2(Str2), null],
  flex_direction: [Nullable2(Str2), null],
  flex_flow: [Nullable2(Str2), null],
  flex_grow: [Nullable2(Str2), null],
  flex_shrink: [Nullable2(Str2), null],
  flex_wrap: [Nullable2(Str2), null],
  float: [Nullable2(Str2), null],
  flood_color: [Nullable2(Str2), null],
  flood_opacity: [Nullable2(Str2), null],
  font: [Nullable2(Str2), null],
  font_family: [Nullable2(Str2), null],
  font_feature_settings: [Nullable2(Str2), null],
  font_kerning: [Nullable2(Str2), null],
  font_size: [Nullable2(Str2), null],
  font_size_adjust: [Nullable2(Str2), null],
  font_stretch: [Nullable2(Str2), null],
  font_style: [Nullable2(Str2), null],
  font_synthesis: [Nullable2(Str2), null],
  font_variant: [Nullable2(Str2), null],
  font_variant_caps: [Nullable2(Str2), null],
  font_variant_east_asian: [Nullable2(Str2), null],
  font_variant_ligatures: [Nullable2(Str2), null],
  font_variant_numeric: [Nullable2(Str2), null],
  font_variant_position: [Nullable2(Str2), null],
  font_weight: [Nullable2(Str2), null],
  gap: [Nullable2(Str2), null],
  glyph_orientation_vertical: [Nullable2(Str2), null],
  grid: [Nullable2(Str2), null],
  grid_area: [Nullable2(Str2), null],
  grid_auto_columns: [Nullable2(Str2), null],
  grid_auto_flow: [Nullable2(Str2), null],
  grid_auto_rows: [Nullable2(Str2), null],
  grid_column: [Nullable2(Str2), null],
  grid_column_end: [Nullable2(Str2), null],
  grid_column_gap: [Nullable2(Str2), null],
  grid_column_start: [Nullable2(Str2), null],
  grid_gap: [Nullable2(Str2), null],
  grid_row: [Nullable2(Str2), null],
  grid_row_end: [Nullable2(Str2), null],
  grid_row_gap: [Nullable2(Str2), null],
  grid_row_start: [Nullable2(Str2), null],
  grid_template: [Nullable2(Str2), null],
  grid_template_areas: [Nullable2(Str2), null],
  grid_template_columns: [Nullable2(Str2), null],
  grid_template_rows: [Nullable2(Str2), null],
  height: [Nullable2(Str2), null],
  hyphens: [Nullable2(Str2), null],
  image_orientation: [Nullable2(Str2), null],
  image_rendering: [Nullable2(Str2), null],
  inline_size: [Nullable2(Str2), null],
  justify_content: [Nullable2(Str2), null],
  justify_items: [Nullable2(Str2), null],
  justify_self: [Nullable2(Str2), null],
  left: [Nullable2(Str2), null],
  letter_spacing: [Nullable2(Str2), null],
  lighting_color: [Nullable2(Str2), null],
  line_break: [Nullable2(Str2), null],
  line_height: [Nullable2(Str2), null],
  list_style: [Nullable2(Str2), null],
  list_style_image: [Nullable2(Str2), null],
  list_style_position: [Nullable2(Str2), null],
  list_style_type: [Nullable2(Str2), null],
  margin: [Nullable2(Str2), null],
  margin_block_end: [Nullable2(Str2), null],
  margin_block_start: [Nullable2(Str2), null],
  margin_bottom: [Nullable2(Str2), null],
  margin_inline_end: [Nullable2(Str2), null],
  margin_inline_start: [Nullable2(Str2), null],
  margin_left: [Nullable2(Str2), null],
  margin_right: [Nullable2(Str2), null],
  margin_top: [Nullable2(Str2), null],
  marker: [Nullable2(Str2), null],
  marker_end: [Nullable2(Str2), null],
  marker_mid: [Nullable2(Str2), null],
  marker_start: [Nullable2(Str2), null],
  mask: [Nullable2(Str2), null],
  mask_composite: [Nullable2(Str2), null],
  mask_image: [Nullable2(Str2), null],
  mask_position: [Nullable2(Str2), null],
  mask_repeat: [Nullable2(Str2), null],
  mask_size: [Nullable2(Str2), null],
  mask_type: [Nullable2(Str2), null],
  max_block_size: [Nullable2(Str2), null],
  max_height: [Nullable2(Str2), null],
  max_inline_size: [Nullable2(Str2), null],
  max_width: [Nullable2(Str2), null],
  min_block_size: [Nullable2(Str2), null],
  min_height: [Nullable2(Str2), null],
  min_inline_size: [Nullable2(Str2), null],
  min_width: [Nullable2(Str2), null],
  object_fit: [Nullable2(Str2), null],
  object_position: [Nullable2(Str2), null],
  opacity: [Nullable2(Str2), null],
  order: [Nullable2(Str2), null],
  orphans: [Nullable2(Str2), null],
  outline: [Nullable2(Str2), null],
  outline_color: [Nullable2(Str2), null],
  outline_offset: [Nullable2(Str2), null],
  outline_style: [Nullable2(Str2), null],
  outline_width: [Nullable2(Str2), null],
  overflow: [Nullable2(Str2), null],
  overflow_anchor: [Nullable2(Str2), null],
  overflow_wrap: [Nullable2(Str2), null],
  overflow_x: [Nullable2(Str2), null],
  overflow_y: [Nullable2(Str2), null],
  overscroll_behavior: [Nullable2(Str2), null],
  overscroll_behavior_block: [Nullable2(Str2), null],
  overscroll_behavior_inline: [Nullable2(Str2), null],
  overscroll_behavior_x: [Nullable2(Str2), null],
  overscroll_behavior_y: [Nullable2(Str2), null],
  padding: [Nullable2(Str2), null],
  padding_block_end: [Nullable2(Str2), null],
  padding_block_start: [Nullable2(Str2), null],
  padding_bottom: [Nullable2(Str2), null],
  padding_inline_end: [Nullable2(Str2), null],
  padding_inline_start: [Nullable2(Str2), null],
  padding_left: [Nullable2(Str2), null],
  padding_right: [Nullable2(Str2), null],
  padding_top: [Nullable2(Str2), null],
  page_break_after: [Nullable2(Str2), null],
  page_break_before: [Nullable2(Str2), null],
  page_break_inside: [Nullable2(Str2), null],
  paint_order: [Nullable2(Str2), null],
  perspective: [Nullable2(Str2), null],
  perspective_origin: [Nullable2(Str2), null],
  place_content: [Nullable2(Str2), null],
  place_items: [Nullable2(Str2), null],
  place_self: [Nullable2(Str2), null],
  pointer_events: [Nullable2(Str2), null],
  position: [Nullable2(Str2), null],
  quotes: [Nullable2(Str2), null],
  resize: [Nullable2(Str2), null],
  right: [Nullable2(Str2), null],
  rotate: [Nullable2(Str2), null],
  row_gap: [Nullable2(Str2), null],
  ruby_align: [Nullable2(Str2), null],
  ruby_position: [Nullable2(Str2), null],
  scale: [Nullable2(Str2), null],
  scroll_behavior: [Nullable2(Str2), null],
  shape_rendering: [Nullable2(Str2), null],
  stop_color: [Nullable2(Str2), null],
  stop_opacity: [Nullable2(Str2), null],
  stroke: [Nullable2(Str2), null],
  stroke_dasharray: [Nullable2(Str2), null],
  stroke_dashoffset: [Nullable2(Str2), null],
  stroke_linecap: [Nullable2(Str2), null],
  stroke_linejoin: [Nullable2(Str2), null],
  stroke_miterlimit: [Nullable2(Str2), null],
  stroke_opacity: [Nullable2(Str2), null],
  stroke_width: [Nullable2(Str2), null],
  tab_size: [Nullable2(Str2), null],
  table_layout: [Nullable2(Str2), null],
  text_align: [Nullable2(Str2), null],
  text_align_last: [Nullable2(Str2), null],
  text_anchor: [Nullable2(Str2), null],
  text_combine_upright: [Nullable2(Str2), null],
  text_decoration: [Nullable2(Str2), null],
  text_decoration_color: [Nullable2(Str2), null],
  text_decoration_line: [Nullable2(Str2), null],
  text_decoration_style: [Nullable2(Str2), null],
  text_emphasis: [Nullable2(Str2), null],
  text_emphasis_color: [Nullable2(Str2), null],
  text_emphasis_position: [Nullable2(Str2), null],
  text_emphasis_style: [Nullable2(Str2), null],
  text_indent: [Nullable2(Str2), null],
  text_justify: [Nullable2(Str2), null],
  text_orientation: [Nullable2(Str2), null],
  text_overflow: [Nullable2(Str2), null],
  text_rendering: [Nullable2(Str2), null],
  text_shadow: [Nullable2(Str2), null],
  text_transform: [Nullable2(Str2), null],
  text_underline_position: [Nullable2(Str2), null],
  top: [Nullable2(Str2), null],
  touch_action: [Nullable2(Str2), null],
  transform: [Nullable2(Str2), null],
  transform_box: [Nullable2(Str2), null],
  transform_origin: [Nullable2(Str2), null],
  transform_style: [Nullable2(Str2), null],
  transition: [Nullable2(Str2), null],
  transition_delay: [Nullable2(Str2), null],
  transition_duration: [Nullable2(Str2), null],
  transition_property: [Nullable2(Str2), null],
  transition_timing_function: [Nullable2(Str2), null],
  translate: [Nullable2(Str2), null],
  unicode_bidi: [Nullable2(Str2), null],
  user_select: [Nullable2(Str2), null],
  vertical_align: [Nullable2(Str2), null],
  visibility: [Nullable2(Str2), null],
  white_space: [Nullable2(Str2), null],
  widows: [Nullable2(Str2), null],
  width: [Nullable2(Str2), null],
  will_change: [Nullable2(Str2), null],
  word_break: [Nullable2(Str2), null],
  word_spacing: [Nullable2(Str2), null],
  word_wrap: [Nullable2(Str2), null],
  writing_mode: [Nullable2(Str2), null],
  z_index: [Nullable2(Str2), null]
}));
var Styles = _Styles;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/stylesheets.js
var StyleSheet2 = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(StyleSheet2, "__name__", "StyleSheet");
var _InlineStyleSheet = class _InlineStyleSheet extends StyleSheet2 {
  constructor(attrs) {
    super(attrs);
  }
  underlying() {
    return new InlineStyleSheet(this.css);
  }
};
__publicField(_InlineStyleSheet, "__name__", "InlineStyleSheet");
_InlineStyleSheet.define(({ Str: Str2 }) => ({
  css: [Str2]
}));
var InlineStyleSheet2 = _InlineStyleSheet;
var _ImportedStyleSheet = class _ImportedStyleSheet extends StyleSheet2 {
  constructor(attrs) {
    super(attrs);
  }
  underlying() {
    return new ImportedStyleSheet(this.url);
  }
};
__publicField(_ImportedStyleSheet, "__name__", "ImportedStyleSheet");
_ImportedStyleSheet.define(({ Str: Str2 }) => ({
  url: [Str2]
}));
var ImportedStyleSheet2 = _ImportedStyleSheet;
var GlobalInlineStyleSheet2 = class extends InlineStyleSheet2 {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_underlying", null);
  }
  underlying() {
    if (this._underlying == null) {
      this._underlying = new GlobalInlineStyleSheet(this.css);
    }
    return this._underlying;
  }
};
__publicField(GlobalInlineStyleSheet2, "__name__", "GlobalInlineStyleSheet");
var GlobalImportedStyleSheet2 = class extends ImportedStyleSheet2 {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_underlying", null);
  }
  underlying() {
    if (this._underlying == null) {
      this._underlying = new GlobalImportedStyleSheet(this.url);
    }
    return this._underlying;
  }
};
__publicField(GlobalImportedStyleSheet2, "__name__", "GlobalImportedStyleSheet");

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/styled_element.js
var StylesLike = Or(Dict(Nullable(Str)), Ref(Styles));
var StyleSheets = List(Or(Ref(StyleSheet2), Str, Dict(StylesLike)));
var CSSVariables = Dict(Ref(Node2));
var StyledElementView = class extends DOMComponentView {
  constructor() {
    super(...arguments);
    __publicField(this, "style", new InlineStyleSheet());
  }
  connect_signals() {
    super.connect_signals();
    const { styles: styles3, css_classes, css_variables, stylesheets } = this.model.properties;
    this.on_change(styles3, () => this._update_styles());
    this.on_change(css_classes, () => this._update_css_classes());
    this.on_transitive_change(css_variables, () => this._update_css_variables());
    this.on_change(stylesheets, () => this._update_stylesheets());
  }
  render() {
    super.render();
    this._apply_styles();
  }
  *_css_classes() {
    yield* super._css_classes();
    yield* this.model.css_classes;
  }
  *_css_variables() {
    yield* super._css_variables();
    for (const [name, node] of entries(this.model.css_variables)) {
      const value2 = this.resolve_coordinate(node);
      if (isNumber(value2)) {
        yield [name, `${value2}px`];
      }
    }
  }
  *_stylesheets() {
    yield* super._stylesheets();
    yield this.style;
    yield* this._computed_stylesheets();
  }
  *_computed_stylesheets() {
    for (const stylesheet2 of this.model.stylesheets) {
      if (stylesheet2 instanceof StyleSheet2) {
        yield stylesheet2.underlying();
      } else {
        yield new InlineStyleSheet(stylesheet2);
      }
    }
  }
  _apply_styles() {
    apply_styles(this.el.style, this.model.styles);
  }
  _update_styles() {
    this.el.removeAttribute("style");
    this._apply_styles();
  }
};
__publicField(StyledElementView, "__name__", "StyledElementView");
var _StyledElement = class _StyledElement extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_StyledElement, "__name__", "StyledElement");
_StyledElement.define(({ List: List2, Str: Str2 }) => ({
  css_classes: [List2(Str2), []],
  css_variables: [CSSVariables, {}],
  styles: [StylesLike, {}],
  stylesheets: [StyleSheets, []]
}));
var StyledElement = _StyledElement;

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/fill.js
var Fill2 = class extends VisualProperties {
  constructor() {
    super(...arguments);
    __publicField(this, "Values");
  }
  get doit() {
    const color = this.get_fill_color();
    const alpha = this.get_fill_alpha();
    return !(color == null || alpha == 0);
  }
  apply(ctx, rule = "nonzero") {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.fill(rule);
    }
    return doit;
  }
  values() {
    return {
      color: this.get_fill_color(),
      alpha: this.get_fill_alpha()
    };
  }
  set_value(ctx) {
    const color = this.get_fill_color();
    const alpha = this.get_fill_alpha();
    ctx.fillStyle = color2css(color, alpha);
  }
  get_fill_color() {
    const css_color = this._get_css_value("fill-color");
    if (css_color != "") {
      return css_color;
    }
    return this.fill_color.get_value();
  }
  get_fill_alpha() {
    const css_alpha = this._get_css_value("fill-alpha");
    if (css_alpha != "") {
      const alpha = Number(css_alpha);
      if (isFinite(alpha)) {
        return alpha;
      }
    }
    return this.fill_alpha.get_value();
  }
};
__publicField(Fill2, "__name__", "Fill");
var FillScalar2 = class extends VisualUniforms {
  constructor() {
    super(...arguments);
    __publicField(this, "Values");
  }
  get doit() {
    const color = this.fill_color.value;
    const alpha = this.fill_alpha.value;
    return !(color == 0 || alpha == 0);
  }
  apply(ctx, rule = "nonzero") {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.fill(rule);
    }
    return doit;
  }
  values() {
    return {
      color: this.fill_color.value,
      alpha: this.fill_alpha.value
    };
  }
  set_value(ctx) {
    const color = this.fill_color.value;
    const alpha = this.fill_alpha.value;
    ctx.fillStyle = color2css(color, alpha);
  }
};
__publicField(FillScalar2, "__name__", "FillScalar");
var FillVector2 = class extends VisualUniforms {
  constructor() {
    super(...arguments);
    __publicField(this, "Values");
  }
  get doit() {
    const { fill_color } = this;
    if (fill_color.is_Scalar() && fill_color.value == 0) {
      return false;
    }
    const { fill_alpha } = this;
    if (fill_alpha.is_Scalar() && fill_alpha.value == 0) {
      return false;
    }
    return true;
  }
  v_doit(i2) {
    if (this.fill_color.get(i2) == 0) {
      return false;
    }
    if (this.fill_alpha.get(i2) == 0) {
      return false;
    }
    return true;
  }
  apply(ctx, i2, rule = "nonzero") {
    const doit = this.v_doit(i2);
    if (doit) {
      this.set_vectorize(ctx, i2);
      ctx.fill(rule);
    }
    return doit;
  }
  values(i2) {
    return {
      color: this.fill_color.get(i2),
      alpha: this.fill_alpha.get(i2)
    };
  }
  set_vectorize(ctx, i2) {
    const color = this.fill_color.get(i2);
    const alpha = this.fill_alpha.get(i2);
    ctx.fillStyle = color2css(color, alpha);
  }
};
__publicField(FillVector2, "__name__", "FillVector");
Fill2.prototype.type = "fill";
Fill2.prototype.attrs = Object.keys(Fill);
FillScalar2.prototype.type = "fill";
FillScalar2.prototype.attrs = Object.keys(FillScalar);
FillVector2.prototype.type = "fill";
FillVector2.prototype.attrs = Object.keys(FillVector);

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/text.js
var _font_cache = /* @__PURE__ */ new Map();
function load_font(font, obj) {
  const objs = _font_cache.get(font);
  if (objs == null) {
    const objs2 = new WeakSet([obj]);
    _font_cache.set(font, objs2);
  } else if (!objs.has(obj)) {
    objs.add(obj);
  } else {
    return;
  }
  const { fonts } = document;
  if (!fonts.check(font)) {
    void fonts.load(font).then(() => obj.request_paint());
  }
}
var Text2 = class extends VisualProperties {
  get doit() {
    const color = this.get_text_color();
    const alpha = this.get_text_alpha();
    return !(color == null || alpha == 0);
  }
  update() {
    if (!this.doit) {
      return;
    }
    const font = this.font_value();
    load_font(font, this.obj);
  }
  values() {
    return {
      color: this.get_text_color(),
      outline_color: this.get_text_outline_color(),
      alpha: this.get_text_alpha(),
      font: this.get_text_font(),
      font_size: this.get_text_font_size(),
      font_style: this.get_text_font_style(),
      align: this.get_text_align(),
      baseline: this.get_text_baseline(),
      line_height: this.get_text_line_height()
    };
  }
  set_value(ctx) {
    const color = this.get_text_color();
    const outline_color = this.get_text_outline_color();
    const alpha = this.get_text_alpha();
    ctx.fillStyle = color2css(color, alpha);
    ctx.strokeStyle = color2css(outline_color, alpha);
    ctx.font = this.font_value();
    ctx.textAlign = this.get_text_align();
    ctx.textBaseline = this.get_text_baseline();
  }
  font_value() {
    const style2 = this.get_text_font_style();
    const size2 = this.get_text_font_size();
    const face = this.get_text_font();
    return `${style2} ${size2} ${face}`;
  }
  get_text_color() {
    const css_color = this._get_css_value("text-color");
    if (css_color != "") {
      return css_color;
    }
    return this.text_color.get_value();
  }
  get_text_outline_color() {
    const css_color = this._get_css_value("text-outline-color");
    if (css_color != "") {
      return css_color;
    }
    return this.text_outline_color.get_value();
  }
  get_text_alpha() {
    const css_alpha = this._get_css_value("text-alpha");
    if (css_alpha != "") {
      const alpha = Number(css_alpha);
      if (isFinite(alpha)) {
        return alpha;
      }
    }
    return this.text_alpha.get_value();
  }
  get_text_font() {
    const css_font = this._get_css_value("text-font");
    if (css_font != "") {
      return css_font;
    }
    return this.text_font.get_value();
  }
  get_text_font_size() {
    const css_font_size = this._get_css_value("text-font-size");
    if (css_font_size != "") {
      return css_font_size;
    }
    return this.text_font_size.get_value();
  }
  get_text_font_style() {
    const css_font_style = this._get_css_value("text-font-style");
    if (FontStyle.valid(css_font_style)) {
      return css_font_style;
    }
    return this.text_font_style.get_value();
  }
  get_text_align() {
    const css_align = this._get_css_value("text-align");
    if (TextAlign.valid(css_align)) {
      return css_align;
    }
    return this.text_align.get_value();
  }
  get_text_baseline() {
    const css_baseline = this._get_css_value("text-baseline");
    if (TextBaseline.valid(css_baseline)) {
      return css_baseline;
    }
    return this.text_baseline.get_value();
  }
  get_text_line_height() {
    const css_line_height = this._get_css_value("line-height");
    if (css_line_height != "") {
      const line_height = Number(css_line_height);
      if (isFinite(line_height)) {
        return line_height;
      }
    }
    return this.text_line_height.get_value();
  }
};
__publicField(Text2, "__name__", "Text");
var TextScalar2 = class extends VisualUniforms {
  get doit() {
    const color = this.text_color.value;
    const alpha = this.text_alpha.value;
    return !(color == 0 || alpha == 0);
  }
  update() {
    if (!this.doit) {
      return;
    }
    const font = this.font_value();
    load_font(font, this.obj);
  }
  values() {
    return {
      color: this.text_color.value,
      outline_color: this.text_outline_color.value,
      alpha: this.text_alpha.value,
      font: this.text_font.value,
      font_size: this.text_font_size.value,
      font_style: this.text_font_style.value,
      align: this.text_align.value,
      baseline: this.text_baseline.value,
      line_height: this.text_line_height.value
    };
  }
  set_value(ctx) {
    const color = this.text_color.value;
    const alpha = this.text_alpha.value;
    const outline_color = this.text_outline_color.value;
    const font = this.font_value();
    const align = this.text_align.value;
    const baseline = this.text_baseline.value;
    ctx.fillStyle = color2css(color, alpha);
    ctx.strokeStyle = color2css(outline_color, alpha);
    ctx.font = font;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
  }
  font_value() {
    const style2 = this.text_font_style.value;
    const size2 = this.text_font_size.value;
    const face = this.text_font.value;
    return `${style2} ${size2} ${face}`;
  }
};
__publicField(TextScalar2, "__name__", "TextScalar");
var TextVector2 = class extends VisualUniforms {
  _assert_font(i2) {
    const font = this.font_value(i2);
    load_font(font, this.obj);
  }
  values(i2) {
    this._assert_font(i2);
    return {
      color: this.text_color.get(i2),
      outline_color: this.text_outline_color.get(i2),
      alpha: this.text_alpha.get(i2),
      font: this.text_font.get(i2),
      font_size: this.text_font_size.get(i2),
      font_style: this.text_font_style.get(i2),
      align: this.text_align.get(i2),
      baseline: this.text_baseline.get(i2),
      line_height: this.text_line_height.get(i2)
    };
  }
  get doit() {
    const { text_color } = this;
    if (text_color.is_Scalar() && text_color.value == 0) {
      return false;
    }
    const { text_alpha } = this;
    if (text_alpha.is_Scalar() && text_alpha.value == 0) {
      return false;
    }
    return true;
  }
  v_doit(i2) {
    if (this.text_color.get(i2) == 0) {
      return false;
    }
    if (this.text_alpha.get(i2) == 0) {
      return false;
    }
    return true;
  }
  apply(ctx, i2) {
    const doit = this.v_doit(i2);
    if (doit) {
      this.set_vectorize(ctx, i2);
    }
    return doit;
  }
  set_vectorize(ctx, i2) {
    this._assert_font(i2);
    const color = this.text_color.get(i2);
    const outline_color = this.text_outline_color.get(i2);
    const alpha = this.text_alpha.get(i2);
    const font = this.font_value(i2);
    const align = this.text_align.get(i2);
    const baseline = this.text_baseline.get(i2);
    ctx.fillStyle = color2css(color, alpha);
    ctx.strokeStyle = color2css(outline_color, alpha);
    ctx.font = font;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
  }
  font_value(i2) {
    const style2 = this.text_font_style.get(i2);
    const size2 = this.text_font_size.get(i2);
    const face = this.text_font.get(i2);
    return `${style2} ${size2} ${face}`;
  }
};
__publicField(TextVector2, "__name__", "TextVector");
Text2.prototype.type = "text";
Text2.prototype.attrs = Object.keys(Text);
TextScalar2.prototype.type = "text";
TextScalar2.prototype.attrs = Object.keys(TextScalar);
TextVector2.prototype.type = "text";
TextVector2.prototype.attrs = Object.keys(TextVector);

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/hatch.js
var Hatch2 = class extends VisualProperties {
  constructor() {
    super(...arguments);
    __publicField(this, "_hatch_image");
    __publicField(this, "_update_iteration", 0);
  }
  update() {
    this._update_iteration++;
    this._hatch_image = null;
    if (!this.doit) {
      return;
    }
    const color = this.get_hatch_color();
    const alpha = this.get_hatch_alpha();
    const scale = this.get_hatch_scale();
    const pattern = this.get_hatch_pattern();
    const weight = this.get_hatch_weight();
    const finalize = (image) => {
      this._hatch_image = image;
    };
    const textures = dict(this.get_hatch_extra());
    const texture = textures.get(pattern);
    if (texture != null) {
      const image = texture.get_pattern(color, alpha, scale, weight);
      if (image instanceof Promise) {
        const { _update_iteration } = this;
        void image.then((image2) => {
          if (this._update_iteration == _update_iteration) {
            finalize(image2);
            this.obj.request_paint();
          }
        });
      } else {
        finalize(image);
      }
    } else {
      const layer2 = this.obj.canvas.create_layer();
      const image = get_pattern(layer2, pattern, color, alpha, scale, weight);
      finalize(image);
    }
  }
  get doit() {
    const color = this.get_hatch_color();
    const alpha = this.get_hatch_alpha();
    const pattern = this.get_hatch_pattern();
    return !(color == null || alpha == 0 || pattern == " " || pattern == "blank" || pattern == null);
  }
  apply(ctx, rule = "nonzero") {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.layer.undo_transform(() => ctx.fill(rule));
    }
    return doit;
  }
  set_value(ctx) {
    const pattern = this.pattern(ctx);
    ctx.fillStyle = pattern ?? "transparent";
  }
  pattern(ctx) {
    const image = this._hatch_image;
    if (image == null) {
      return null;
    } else {
      return ctx.createPattern(image, this.repetition());
    }
  }
  repetition() {
    const pattern = this.get_hatch_pattern();
    const textures = dict(this.get_hatch_extra());
    const texture = textures.get(pattern);
    if (texture == null) {
      return "repeat";
    } else {
      switch (texture.repetition) {
        case "repeat":
          return "repeat";
        case "repeat_x":
          return "repeat-x";
        case "repeat_y":
          return "repeat-y";
        case "no_repeat":
          return "no-repeat";
      }
    }
  }
  get_hatch_color() {
    const css_color = this._get_css_value("hatch-color");
    if (css_color != "") {
      return css_color;
    }
    return this.hatch_color.get_value();
  }
  get_hatch_alpha() {
    const css_alpha = this._get_css_value("hatch-alpha");
    if (css_alpha != "") {
      const alpha = Number(css_alpha);
      if (isFinite(alpha)) {
        return alpha;
      }
    }
    return this.hatch_alpha.get_value();
  }
  get_hatch_scale() {
    const css_scale = this._get_css_value("hatch-scale");
    if (css_scale != "") {
      const scale = Number(css_scale);
      if (isFinite(scale)) {
        return scale;
      }
    }
    return this.hatch_scale.get_value();
  }
  get_hatch_pattern() {
    const css_pattern = this._get_css_value("hatch-pattern");
    if (css_pattern != "") {
      if (css_pattern == "none") {
        return null;
      } else {
        return css_pattern;
      }
    }
    return this.hatch_pattern.get_value();
  }
  get_hatch_weight() {
    const css_weight = this._get_css_value("hatch-weight");
    if (css_weight != "") {
      const weight = Number(css_weight);
      if (isFinite(weight)) {
        return weight;
      }
    }
    return this.hatch_weight.get_value();
  }
  get_hatch_extra() {
    return this.hatch_extra.get_value();
  }
};
__publicField(Hatch2, "__name__", "Hatch");
var HatchScalar2 = class extends VisualUniforms {
  constructor() {
    super(...arguments);
    __publicField(this, "_hatch_image");
    __publicField(this, "_static_doit", false);
    __publicField(this, "_update_iteration", 0);
  }
  _compute_static_doit() {
    const color = this.hatch_color.value;
    const alpha = this.hatch_alpha.value;
    const pattern = this.hatch_pattern.value;
    return !(color == 0 || alpha == 0 || pattern == " " || pattern == "blank" || pattern == null);
  }
  update() {
    this._update_iteration++;
    const n2 = this.hatch_color.length;
    this._hatch_image = new UniformScalar(null, n2);
    this._static_doit = this._compute_static_doit();
    if (!this._static_doit) {
      return;
    }
    const color = this.hatch_color.value;
    const alpha = this.hatch_alpha.value;
    const scale = this.hatch_scale.value;
    const pattern = this.hatch_pattern.value;
    const weight = this.hatch_weight.value;
    const finalize = (image) => {
      this._hatch_image = new UniformScalar(image, n2);
    };
    const textures = dict(this.hatch_extra.value);
    const texture = textures.get(pattern);
    if (texture != null) {
      const image = texture.get_pattern(color, alpha, scale, weight);
      if (image instanceof Promise) {
        const { _update_iteration } = this;
        void image.then((image2) => {
          if (this._update_iteration == _update_iteration) {
            finalize(image2);
            this.obj.request_paint();
          }
        });
      } else {
        finalize(image);
      }
    } else {
      const layer2 = this.obj.canvas.create_layer();
      const image = get_pattern(layer2, pattern, color, alpha, scale, weight);
      finalize(image);
    }
  }
  get doit() {
    return this._static_doit;
  }
  apply(ctx, rule = "nonzero") {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.layer.undo_transform(() => ctx.fill(rule));
    }
    return doit;
  }
  set_value(ctx) {
    ctx.fillStyle = this.pattern(ctx) ?? "transparent";
  }
  pattern(ctx) {
    const image = this._hatch_image.value;
    if (image == null) {
      return null;
    } else {
      return ctx.createPattern(image, this.repetition());
    }
  }
  repetition() {
    const pattern = this.hatch_pattern.value;
    if (pattern != null) {
      const textures = dict(this.hatch_extra.value);
      const texture = textures.get(pattern);
      if (texture != null) {
        switch (texture.repetition) {
          case "repeat":
            return "repeat";
          case "repeat_x":
            return "repeat-x";
          case "repeat_y":
            return "repeat-y";
          case "no_repeat":
            return "no-repeat";
        }
      }
    }
    return "repeat";
  }
};
__publicField(HatchScalar2, "__name__", "HatchScalar");
var HatchVector2 = class extends VisualUniforms {
  constructor() {
    super(...arguments);
    __publicField(this, "_hatch_image");
    __publicField(this, "_static_doit", false);
    __publicField(this, "_update_iteration", 0);
  }
  _compute_static_doit() {
    const { hatch_color } = this;
    if (hatch_color.is_Scalar() && hatch_color.value == 0) {
      return false;
    }
    const { hatch_alpha } = this;
    if (hatch_alpha.is_Scalar() && hatch_alpha.value == 0) {
      return false;
    }
    const { hatch_pattern } = this;
    if (hatch_pattern.is_Scalar()) {
      const pattern = hatch_pattern.value;
      if (pattern == " " || pattern == "blank" || pattern == null) {
        return false;
      }
    }
    return true;
  }
  update() {
    this._update_iteration++;
    const n2 = this.hatch_color.length;
    this._hatch_image = new UniformScalar(null, n2);
    this._static_doit = this._compute_static_doit();
    if (!this._static_doit) {
      return;
    }
    const resolve_image = (pattern, color, alpha, scale, weight, finalize) => {
      const textures = dict(this.hatch_extra.value);
      const texture = textures.get(pattern);
      if (texture != null) {
        const image = texture.get_pattern(color, alpha, scale, weight);
        if (image instanceof Promise) {
          const { _update_iteration } = this;
          void image.then((image2) => {
            if (this._update_iteration == _update_iteration) {
              finalize(image2);
              this.obj.request_paint();
            }
          });
        } else {
          finalize(image);
        }
      } else {
        const layer2 = this.obj.canvas.create_layer();
        const image = get_pattern(layer2, pattern, color, alpha, scale, weight);
        finalize(image);
      }
    };
    if (this.hatch_color.is_Scalar() && this.hatch_alpha.is_Scalar() && this.hatch_scale.is_Scalar() && this.hatch_pattern.is_Scalar() && this.hatch_weight.is_Scalar()) {
      const color = this.hatch_color.value;
      const alpha = this.hatch_alpha.value;
      const scale = this.hatch_scale.value;
      const pattern = this.hatch_pattern.value;
      const weight = this.hatch_weight.value;
      resolve_image(pattern, color, alpha, scale, weight, (image) => {
        this._hatch_image = new UniformScalar(image, n2);
      });
    } else {
      const images = new Array(n2);
      images.fill(null);
      this._hatch_image = new UniformVector(images);
      for (let i2 = 0; i2 < n2; i2++) {
        const color = this.hatch_color.get(i2);
        const alpha = this.hatch_alpha.get(i2);
        const scale = this.hatch_scale.get(i2);
        const pattern = this.hatch_pattern.get(i2);
        const weight = this.hatch_weight.get(i2);
        resolve_image(pattern, color, alpha, scale, weight, (image) => {
          images[i2] = image;
        });
      }
    }
  }
  get doit() {
    return this._static_doit;
  }
  v_doit(i2) {
    if (!this.doit) {
      return false;
    }
    if (this.hatch_color.get(i2) == 0) {
      return false;
    }
    if (this.hatch_alpha.get(i2) == 0) {
      return false;
    }
    const pattern = this.hatch_pattern.get(i2);
    if (pattern == " " || pattern == "blank" || pattern == null) {
      return false;
    }
    return true;
  }
  apply(ctx, i2, rule = "nonzero") {
    const doit = this.v_doit(i2);
    if (doit) {
      this.set_vectorize(ctx, i2);
      ctx.layer.undo_transform(() => ctx.fill(rule));
    }
    return doit;
  }
  set_vectorize(ctx, i2) {
    ctx.fillStyle = this.pattern(ctx, i2) ?? "transparent";
  }
  pattern(ctx, i2) {
    const image = this._hatch_image.get(i2);
    if (image == null) {
      return null;
    } else {
      return ctx.createPattern(image, this.repetition(i2));
    }
  }
  repetition(i2) {
    const pattern = this.hatch_pattern.get(i2);
    if (pattern != null) {
      const textures = dict(this.hatch_extra.value);
      const texture = textures.get(pattern);
      if (texture != null) {
        switch (texture.repetition) {
          case "repeat":
            return "repeat";
          case "repeat_x":
            return "repeat-x";
          case "repeat_y":
            return "repeat-y";
          case "no_repeat":
            return "no-repeat";
        }
      }
    }
    return "repeat";
  }
};
__publicField(HatchVector2, "__name__", "HatchVector");
Hatch2.prototype.type = "hatch";
Hatch2.prototype.attrs = Object.keys(Hatch);
HatchScalar2.prototype.type = "hatch";
HatchScalar2.prototype.attrs = Object.keys(HatchScalar);
HatchVector2.prototype.type = "hatch";
HatchVector2.prototype.attrs = Object.keys(HatchVector);

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/image.js
var Image3 = class extends VisualProperties {
  get doit() {
    const alpha = this.global_alpha.get_value();
    return !(alpha == 0);
  }
  apply(ctx) {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
    }
    return doit;
  }
  values() {
    return {
      global_alpha: this.global_alpha.get_value()
    };
  }
  set_value(ctx) {
    const alpha = this.global_alpha.get_value();
    ctx.globalAlpha = alpha;
  }
};
__publicField(Image3, "__name__", "Image");
var ImageScalar2 = class extends VisualUniforms {
  get doit() {
    const alpha = this.global_alpha.value;
    return !(alpha == 0);
  }
  apply(ctx) {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
    }
    return doit;
  }
  values() {
    return {
      global_alpha: this.global_alpha.value
    };
  }
  set_value(ctx) {
    const alpha = this.global_alpha.value;
    ctx.globalAlpha = alpha;
  }
};
__publicField(ImageScalar2, "__name__", "ImageScalar");
var ImageVector2 = class extends VisualUniforms {
  get doit() {
    const { global_alpha } = this;
    if (global_alpha.is_Scalar() && global_alpha.value == 0) {
      return false;
    }
    return true;
  }
  v_doit(i2) {
    if (this.global_alpha.get(i2) == 0) {
      return false;
    }
    return true;
  }
  apply(ctx, i2) {
    const doit = this.v_doit(i2);
    if (doit) {
      this.set_vectorize(ctx, i2);
    }
    return doit;
  }
  values(i2) {
    return {
      alpha: this.global_alpha.get(i2)
    };
  }
  set_vectorize(ctx, i2) {
    const alpha = this.global_alpha.get(i2);
    ctx.globalAlpha = alpha;
  }
};
__publicField(ImageVector2, "__name__", "ImageVector");
Image3.prototype.type = "image";
Image3.prototype.attrs = Object.keys(Image2);
ImageScalar2.prototype.type = "image";
ImageScalar2.prototype.attrs = Object.keys(ImageScalar);
ImageVector2.prototype.type = "image";
ImageVector2.prototype.attrs = Object.keys(ImageVector);

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/index.js
var Visuals = class {
  constructor(view) {
    __publicField(this, "_visuals", []);
    for (const [prefix, mixin] of view.model._mixins) {
      const visual = (() => {
        switch (mixin) {
          case Line:
            return new Line2(view, prefix);
          case LineScalar:
            return new LineScalar2(view, prefix);
          case LineVector:
            return new LineVector2(view, prefix);
          case Fill:
            return new Fill2(view, prefix);
          case FillScalar:
            return new FillScalar2(view, prefix);
          case FillVector:
            return new FillVector2(view, prefix);
          case Text:
            return new Text2(view, prefix);
          case TextScalar:
            return new TextScalar2(view, prefix);
          case TextVector:
            return new TextVector2(view, prefix);
          case Hatch:
            return new Hatch2(view, prefix);
          case HatchScalar:
            return new HatchScalar2(view, prefix);
          case HatchVector:
            return new HatchVector2(view, prefix);
          case Image2:
            return new Image3(view, prefix);
          case ImageScalar:
            return new ImageScalar2(view, prefix);
          case ImageVector:
            return new ImageVector2(view, prefix);
          default:
            throw new Error("unknown visual");
        }
      })();
      if (visual instanceof VisualProperties) {
        visual.update();
      }
      this._visuals.push(visual);
      Object.defineProperty(this, prefix + visual.type, {
        get() {
          return visual;
        },
        configurable: false,
        enumerable: true
      });
    }
  }
  *[Symbol.iterator]() {
    yield* this._visuals;
  }
};
__publicField(Visuals, "__name__", "Visuals");

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/transform.js
var Transform = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Transform, "__name__", "Transform");

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/range.js
var Bounds = Nullable(Or(Tuple(Nullable(Float), Nullable(Float)), Auto));
var _Range = class _Range extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_computed_bounds");
    __publicField(this, "have_updated_interactively", false);
    /** @internal */
    __publicField(this, "frames", /* @__PURE__ */ new Set());
  }
  get computed_bounds() {
    return this._computed_bounds;
  }
  get is_reversed() {
    return this.start > this.end;
  }
  get is_valid() {
    return isFinite(this.min) && isFinite(this.max);
  }
  get interval() {
    return [this.start, this.end];
  }
  get span() {
    return Math.abs(this.end - this.start);
  }
  get linked_plots() {
    return new Set(map2(this.frames, (frame) => frame.parent));
  }
};
__publicField(_Range, "__name__", "Range");
_Range.define(({ Float: Float2, Nullable: Nullable2 }) => ({
  bounds: [Bounds, null, {
    on_update(bounds, obj) {
      const [lower, upper] = bounds == "auto" || bounds == null ? [null, null] : bounds;
      obj._computed_bounds = [lower ?? -Infinity, upper ?? Infinity];
    }
  }],
  min_interval: [Nullable2(Float2), null],
  max_interval: [Nullable2(Float2), null]
}));
var Range = _Range;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/numerical_range.js
var _NumericalRange = class _NumericalRange extends Range {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_NumericalRange, "__name__", "NumericalRange");
_NumericalRange.define(({ Float: Float2 }) => ({
  start: [Float2, unset, {
    convert(value2, obj) {
      const [lower, upper] = obj.computed_bounds;
      return clamp(value2, lower, upper);
    }
  }],
  end: [Float2, unset, {
    convert(value2, obj) {
      const [lower, upper] = obj.computed_bounds;
      return clamp(value2, lower, upper);
    }
  }]
}));
var NumericalRange = _NumericalRange;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/range1d.js
var _Range1d = class _Range1d extends NumericalRange {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_reset_start");
    __publicField(this, "_reset_end");
  }
  _set_auto_bounds() {
    if (this.bounds == "auto") {
      const min10 = Math.min(this._reset_start, this._reset_end);
      const max18 = Math.max(this._reset_start, this._reset_end);
      this._computed_bounds = [min10, max18];
    }
  }
  initialize() {
    super.initialize();
    this._set_auto_bounds();
  }
  get min() {
    return Math.min(this.start, this.end);
  }
  get max() {
    return Math.max(this.start, this.end);
  }
  reset() {
    this._set_auto_bounds();
    const { _reset_start, _reset_end } = this;
    if (this.start != _reset_start || this.end != _reset_end) {
      this.setv({ start: _reset_start, end: _reset_end });
    } else {
      this.change.emit();
    }
  }
  map(fn) {
    return new _Range1d({ start: fn(this.start), end: fn(this.end) });
  }
  widen(v) {
    let { start: start2, end } = this;
    if (this.is_reversed) {
      start2 += v;
      end -= v;
    } else {
      start2 -= v;
      end += v;
    }
    return new _Range1d({ start: start2, end });
  }
};
__publicField(_Range1d, "__name__", "Range1d");
_Range1d.define(({ Float: Float2, Nullable: Nullable2 }) => ({
  reset_start: [Nullable2(Float2), null, {
    on_update(reset_start, self2) {
      self2._reset_start = reset_start ?? self2.start;
    }
  }],
  reset_end: [Nullable2(Float2), null, {
    on_update(reset_end, self2) {
      self2._reset_end = reset_end ?? self2.end;
    }
  }]
}));
_Range1d.override({
  start: 0,
  end: 1
});
var Range1d = _Range1d;

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/scale.js
var _Scale = class _Scale extends Transform {
  constructor(attrs) {
    super(attrs);
  }
  compute(x2) {
    return this.s_compute(x2);
  }
  v_compute(xs) {
    const result = new ScreenArray(xs.length);
    const { s_compute } = this;
    for (let i2 = 0; i2 < xs.length; i2++) {
      result[i2] = s_compute(xs[i2]);
    }
    return result;
  }
  invert(sx) {
    return this.s_invert(sx);
  }
  v_invert(sxs) {
    const result = new Float64Array(sxs.length);
    const { s_invert } = this;
    for (let i2 = 0; i2 < sxs.length; i2++) {
      result[i2] = s_invert(sxs[i2]);
    }
    return result;
  }
  r_compute(x0, x1) {
    const { s_compute } = this;
    if (this.target_range.is_reversed) {
      return [s_compute(x1), s_compute(x0)];
    } else {
      return [s_compute(x0), s_compute(x1)];
    }
  }
  r_invert(sx0, sx1) {
    const { s_invert } = this;
    if (this.target_range.is_reversed) {
      return [s_invert(sx1), s_invert(sx0)];
    } else {
      return [s_invert(sx0), s_invert(sx1)];
    }
  }
};
__publicField(_Scale, "__name__", "Scale");
_Scale.internal(({ Ref: Ref2 }) => ({
  source_range: [Ref2(Range)],
  target_range: [Ref2(Range1d)]
}));
var Scale = _Scale;

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/continuous_scale.js
var ContinuousScale = class extends Scale {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(ContinuousScale, "__name__", "ContinuousScale");

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/linear_scale.js
var LinearScale = class extends ContinuousScale {
  constructor(attrs) {
    super(attrs);
  }
  get s_compute() {
    const [factor, offset3] = this._linear_compute_state();
    return (x2) => factor * x2 + offset3;
  }
  get s_invert() {
    const [factor, offset3] = this._linear_compute_state();
    return (sx) => (sx - offset3) / factor;
  }
  /*protected*/
  _linear_compute_state() {
    const source_start = this.source_range.start;
    const source_end = this.source_range.end;
    const target_start = this.target_range.start;
    const target_end = this.target_range.end;
    const factor = (target_end - target_start) / (source_end - source_start);
    const offset3 = -(factor * source_start) + target_start;
    return [factor, offset3];
  }
};
__publicField(LinearScale, "__name__", "LinearScale");

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/log_scale.js
var LogScale = class extends ContinuousScale {
  constructor(attrs) {
    super(attrs);
  }
  get s_compute() {
    const [factor, offset3, inter_factor, inter_offset] = this._compute_state();
    return (x2) => {
      if (inter_factor == 0) {
        return 0;
      } else {
        const _x = (Math.log(x2) - inter_offset) / inter_factor;
        return isFinite(_x) ? _x * factor + offset3 : NaN;
      }
    };
  }
  get s_invert() {
    const [factor, offset3, inter_factor, inter_offset] = this._compute_state();
    return (xprime) => {
      const value2 = (xprime - offset3) / factor;
      return Math.exp(inter_factor * value2 + inter_offset);
    };
  }
  _get_safe_factor(orig_start, orig_end) {
    let start2 = orig_start < 0 ? 0 : orig_start;
    let end = orig_end < 0 ? 0 : orig_end;
    if (start2 == end) {
      if (start2 == 0) {
        [start2, end] = [1, 10];
      } else {
        const log_val = Math.log10(start2);
        start2 = 10 ** Math.floor(log_val);
        if (Math.ceil(log_val) != Math.floor(log_val)) {
          end = 10 ** Math.ceil(log_val);
        } else {
          end = 10 ** (Math.ceil(log_val) + 1);
        }
      }
    }
    return [start2, end];
  }
  /*protected*/
  _compute_state() {
    const source_start = this.source_range.start;
    const source_end = this.source_range.end;
    const target_start = this.target_range.start;
    const target_end = this.target_range.end;
    const screen_range = target_end - target_start;
    const [start2, end] = this._get_safe_factor(source_start, source_end);
    let inter_factor;
    let inter_offset;
    if (start2 == 0) {
      inter_factor = Math.log(end);
      inter_offset = 0;
    } else {
      inter_factor = Math.log(end / start2);
      inter_offset = Math.log(start2);
    }
    const factor = screen_range;
    const offset3 = target_start;
    return [factor, offset3, inter_factor, inter_offset];
  }
};
__publicField(LogScale, "__name__", "LogScale");

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/categorical_scale.js
var { _linear_compute_state } = LinearScale.prototype;
var CategoricalScale = class extends Scale {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "source_range");
  }
  get s_compute() {
    const [factor, offset3] = _linear_compute_state.call(this);
    const range2 = this.source_range;
    return (x2) => factor * range2.synthetic(x2) + offset3;
  }
  get s_invert() {
    const [factor, offset3] = _linear_compute_state.call(this);
    return (sx) => (sx - offset3) / factor;
  }
};
__publicField(CategoricalScale, "__name__", "CategoricalScale");

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/composite_scale.js
var _CompositeScale = class _CompositeScale extends Scale {
  constructor(attrs) {
    super(attrs);
  }
  get s_compute() {
    const source_compute = this.source_scale.s_compute;
    const target_compute = this.target_scale.s_compute;
    return (x2) => target_compute(source_compute(x2));
  }
  get s_invert() {
    const source_invert = this.source_scale.s_invert;
    const target_invert = this.target_scale.s_invert;
    return (sx) => source_invert(target_invert(sx));
  }
  compute(x2) {
    return this.s_compute(x2);
  }
  v_compute(xs) {
    const { s_compute } = this;
    return map(xs, s_compute);
  }
  invert(sx) {
    return this.s_invert(sx);
  }
  v_invert(sxs) {
    const { s_invert } = this;
    return map(sxs, s_invert);
  }
};
__publicField(_CompositeScale, "__name__", "CompositeScale");
_CompositeScale.define(({ Ref: Ref2 }) => ({
  source_scale: [Ref2(Scale)],
  target_scale: [Ref2(Scale)]
}));
var CompositeScale = _CompositeScale;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/data_range.js
var _DataRange = class _DataRange extends NumericalRange {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DataRange, "__name__", "DataRange");
_DataRange.define(({ List: List2, AnyRef: AnyRef2, Or: Or2, Auto: Auto2 }) => ({
  renderers: [Or2(List2(AnyRef2()), Auto2), []]
}));
_DataRange.override({
  start: NaN,
  end: NaN
});
var DataRange = _DataRange;

// node_modules/@bokeh/bokehjs/build/js/lib/models/util.js
function compute_renderers(renderers, all_renderers) {
  return renderers == "auto" ? all_renderers : renderers ?? [];
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/data_range1d.js
var auto_ranged = Symbol("auto_ranged");
function is_auto_ranged(r) {
  return auto_ranged in r;
}
var _DataRange1d = class _DataRange1d extends DataRange {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_initial_start");
    __publicField(this, "_initial_end");
    __publicField(this, "_initial_range_padding");
    __publicField(this, "_initial_range_padding_units");
    __publicField(this, "_initial_follow");
    __publicField(this, "_initial_follow_interval");
    __publicField(this, "_initial_default_span");
    __publicField(this, "_plot_bounds");
    __publicField(this, "have_updated_interactively", false);
  }
  initialize() {
    super.initialize();
    this._initial_start = isNaN(this.start) ? null : this.start;
    this._initial_end = isNaN(this.end) ? null : this.end;
    this._initial_range_padding = this.range_padding;
    this._initial_range_padding_units = this.range_padding_units;
    this._initial_follow = this.follow;
    this._initial_follow_interval = this.follow_interval;
    this._initial_default_span = this.default_span;
    this._plot_bounds = /* @__PURE__ */ new Map();
  }
  get min() {
    return Math.min(this.start, this.end);
  }
  get max() {
    return Math.max(this.start, this.end);
  }
  computed_renderers() {
    const { renderers } = this;
    const all_renderers = flat_map(this.linked_plots, (plot) => plot.auto_ranged_renderers.map((r) => r.model));
    return compute_renderers(renderers.length == 0 ? "auto" : renderers, [...all_renderers]);
  }
  /*protected*/
  _compute_plot_bounds(renderers, bounds) {
    let result = empty();
    for (const r of renderers) {
      const rect = bounds.get(r);
      if (rect != null && (r.visible || !this.only_visible)) {
        result = union3(result, rect);
      }
    }
    return result;
  }
  adjust_bounds_for_aspect(bounds, ratio) {
    const result = empty();
    let width = bounds.x1 - bounds.x0;
    if (width <= 0) {
      width = 1;
    }
    let height = bounds.y1 - bounds.y0;
    if (height <= 0) {
      height = 1;
    }
    const xcenter = 0.5 * (bounds.x1 + bounds.x0);
    const ycenter = 0.5 * (bounds.y1 + bounds.y0);
    if (width < ratio * height) {
      width = ratio * height;
    } else {
      height = width / ratio;
    }
    result.x1 = xcenter + 0.5 * width;
    result.x0 = xcenter - 0.5 * width;
    result.y1 = ycenter + 0.5 * height;
    result.y0 = ycenter - 0.5 * height;
    return result;
  }
  /*protected*/
  _compute_min_max(plot_bounds, dimension) {
    let overall = empty();
    for (const [plot, rect] of plot_bounds) {
      if (plot.model.visible) {
        overall = union3(overall, rect);
      }
    }
    let min10, max18;
    if (dimension == 0) {
      [min10, max18] = [overall.x0, overall.x1];
    } else {
      [min10, max18] = [overall.y0, overall.y1];
    }
    return [min10, max18];
  }
  /*protected*/
  _compute_range(min10, max18) {
    const { range_padding } = this;
    const min_interval = this.min_interval ?? 0;
    const max_interval = this.max_interval ?? Infinity;
    let start2, end;
    if (this._initial_start != null) {
      min10 = this._initial_start;
    }
    if (this._initial_end != null) {
      max18 = this._initial_end;
    }
    if (this.scale_hint == "log") {
      if (isNaN(min10) || !isFinite(min10) || min10 <= 0) {
        if (isNaN(max18) || !isFinite(max18) || max18 <= 0) {
          min10 = 0.1;
        } else {
          min10 = max18 / 100;
        }
        logger.warn(`could not determine minimum data value for log axis, DataRange1d using value ${min10}`);
      }
      if (isNaN(max18) || !isFinite(max18) || max18 <= 0) {
        if (isNaN(min10) || !isFinite(min10) || min10 <= 0) {
          max18 = 10;
        } else {
          max18 = min10 * 100;
        }
        logger.warn(`could not determine maximum data value for log axis, DataRange1d using value ${max18}`);
      }
      let center, span2;
      if (max18 == min10) {
        span2 = this.default_span + 1e-3;
        center = Math.log10(min10);
      } else {
        let log_min, log_max;
        if (this.range_padding_units == "percent") {
          log_min = Math.log10(min10);
          log_max = Math.log10(max18);
          span2 = (log_max - log_min) * (1 + range_padding);
        } else {
          log_min = Math.log10(min10 - range_padding);
          log_max = Math.log10(max18 + range_padding);
          span2 = log_max - log_min;
        }
        center = (log_min + log_max) / 2;
      }
      span2 = clamp(span2, min_interval, max_interval);
      start2 = 10 ** (center - span2 / 2);
      end = 10 ** (center + span2 / 2);
    } else {
      let span2;
      if (max18 == min10) {
        span2 = this.default_span;
      } else {
        if (this.range_padding_units == "percent") {
          span2 = (max18 - min10) * (1 + range_padding);
        } else {
          span2 = max18 - min10 + 2 * range_padding;
        }
      }
      span2 = clamp(span2, min_interval, max_interval);
      const center = (max18 + min10) / 2;
      start2 = center - span2 / 2;
      end = center + span2 / 2;
    }
    let follow_sign = 1;
    if (this.flipped) {
      [start2, end] = [end, start2];
      follow_sign = -1;
    }
    const follow_interval = this.follow_interval;
    if (follow_interval != null && Math.abs(start2 - end) > follow_interval) {
      if (this.follow == "start") {
        end = start2 + follow_sign * follow_interval;
      } else if (this.follow == "end") {
        start2 = end - follow_sign * follow_interval;
      }
    }
    return [start2, end];
  }
  update(bounds, dimension, plot, ratio) {
    if (this.have_updated_interactively) {
      return;
    }
    const renderers = this.computed_renderers();
    let total_bounds = this._compute_plot_bounds(renderers, bounds);
    if (ratio != null) {
      total_bounds = this.adjust_bounds_for_aspect(total_bounds, ratio);
    }
    this._plot_bounds.set(plot, total_bounds);
    const [min10, max18] = this._compute_min_max(this._plot_bounds.entries(), dimension);
    let [start2, end] = this._compute_range(min10, max18);
    if (this._initial_start != null) {
      if (this.scale_hint == "log") {
        if (this._initial_start > 0) {
          start2 = this._initial_start;
        }
      } else {
        start2 = this._initial_start;
      }
    }
    if (this._initial_end != null) {
      if (this.scale_hint == "log") {
        if (this._initial_end > 0) {
          end = this._initial_end;
        }
      } else {
        end = this._initial_end;
      }
    }
    let needs_emit = false;
    if (this.bounds == "auto") {
      this._computed_bounds = [start2, end];
      needs_emit = true;
    }
    const [_start, _end] = [this.start, this.end];
    if (start2 != _start || end != _end) {
      const new_range = {};
      if (start2 != _start) {
        new_range.start = start2;
      }
      if (end != _end) {
        new_range.end = end;
      }
      this.setv(new_range);
      needs_emit = false;
    }
    if (needs_emit) {
      this.change.emit();
    }
  }
  reset() {
    this.have_updated_interactively = false;
    this.setv({
      range_padding: this._initial_range_padding,
      range_padding_units: this._initial_range_padding_units,
      follow: this._initial_follow,
      follow_interval: this._initial_follow_interval,
      default_span: this._initial_default_span
    }, { silent: true });
    this.change.emit();
  }
};
__publicField(_DataRange1d, "__name__", "DataRange1d");
_DataRange1d.define(({ Bool: Bool2, Float: Float2, Nullable: Nullable2 }) => ({
  range_padding: [Float2, 0.1],
  range_padding_units: [PaddingUnits, "percent"],
  flipped: [Bool2, false],
  follow: [Nullable2(StartEnd), null],
  follow_interval: [Nullable2(Float2), null],
  default_span: [Float2, 2],
  only_visible: [Bool2, false]
}));
_DataRange1d.internal(({ Enum: Enum2 }) => ({
  scale_hint: [Enum2("log", "auto"), "auto"]
}));
var DataRange1d = _DataRange1d;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ranges/factor_range.js
var Factor = Or(Str, Tuple(Str, Str), Tuple(Str, Str, Str));
var FactorSeq = Or(List(Str), List(Tuple(Str, Str)), List(Tuple(Str, Str, Str)));
function map_one_level(factors, padding2, offset3 = 0) {
  const mapping = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < factors.length; i2++) {
    const factor = factors[i2];
    if (mapping.has(factor)) {
      throw new Error(`duplicate factor or subfactor: ${factor}`);
    }
    mapping.set(factor, { value: 0.5 + i2 * (1 + padding2) + offset3 });
  }
  const inner_padding = (factors.length - 1) * padding2;
  return { mapping, inner_padding };
}
function map_two_levels(factors, outer_pad, factor_pad, offset3 = 0) {
  const mapping = /* @__PURE__ */ new Map();
  const tops = /* @__PURE__ */ new Map();
  for (const [f0, f1] of factors) {
    const top = tops.get(f0) ?? [];
    tops.set(f0, [...top, f1]);
  }
  let suboffset = offset3;
  let total_subpad = 0;
  for (const [f0, top] of tops) {
    const n2 = top.length;
    const sub2 = map_one_level(top, factor_pad, suboffset);
    total_subpad += sub2.inner_padding;
    const subtot = sum(top.map((f1) => sub2.mapping.get(f1).value));
    mapping.set(f0, { value: subtot / n2, mapping: sub2.mapping });
    suboffset += n2 + outer_pad + sub2.inner_padding;
  }
  const inner_padding = (tops.size - 1) * outer_pad + total_subpad;
  return { mapping, tops: [...mapping.keys()], inner_padding };
}
function map_three_levels(factors, outer_pad, inner_pad, factor_pad, offset3 = 0) {
  const mapping = /* @__PURE__ */ new Map();
  const tops = /* @__PURE__ */ new Map();
  for (const [f0, f1, f2] of factors) {
    const top = tops.get(f0) ?? [];
    tops.set(f0, [...top, [f1, f2]]);
  }
  let suboffset = offset3;
  let total_subpad = 0;
  for (const [f0, top] of tops) {
    const n2 = top.length;
    const sub2 = map_two_levels(top, inner_pad, factor_pad, suboffset);
    total_subpad += sub2.inner_padding;
    const subtot = sum(top.map(([f1]) => sub2.mapping.get(f1).value));
    mapping.set(f0, { value: subtot / n2, mapping: sub2.mapping });
    suboffset += n2 + outer_pad + sub2.inner_padding;
  }
  const mids = [];
  for (const [f0, L2] of mapping) {
    for (const f1 of L2.mapping.keys()) {
      mids.push([f0, f1]);
    }
  }
  const inner_padding = (tops.size - 1) * outer_pad + total_subpad;
  return { mapping, tops: [...mapping.keys()], mids, inner_padding };
}
var is_l1 = (x2) => isString(x2);
var is_l2 = (x2) => isArray(x2) && x2.length == 2 && isString(x2[0]) && isString(x2[1]);
var is_l3 = (x2) => isArray(x2) && x2.length == 3 && isString(x2[0]) && isString(x2[1]) && isString(x2[2]);
var FactorMapper = class {
  constructor({ levels, mapping, tops = null, mids = null, inner_padding }) {
    __publicField(this, "levels");
    __publicField(this, "mids");
    __publicField(this, "tops");
    __publicField(this, "inner_padding");
    __publicField(this, "mapping");
    this.levels = levels;
    this.mapping = mapping;
    this.tops = tops;
    this.mids = mids;
    this.inner_padding = inner_padding;
  }
  static compute_levels(factors) {
    if (every(factors, is_l1)) {
      return 1;
    }
    if (every(factors, is_l2)) {
      return 2;
    }
    if (every(factors, is_l3)) {
      return 3;
    }
    throw TypeError("factor levels are inconsistent");
  }
  static for(range2) {
    switch (this.compute_levels(range2.factors)) {
      case 1: {
        return new L1FactorMapper(range2);
      }
      case 2: {
        return new L2FactorMapper(range2);
      }
      case 3: {
        return new L3FactorMapper(range2);
      }
    }
  }
  map(x2) {
    if (isNumber(x2)) {
      return x2;
    }
    const [boxed, offset3] = (() => {
      if (isString(x2)) {
        return [[x2], 0];
      }
      const last2 = x2[x2.length - 1];
      if (isNumber(last2)) {
        return [x2.slice(0, -1), last2];
      }
      return [x2, 0];
    })();
    if (boxed.length > this.levels) {
      throw new Error(`Attempted to map ${boxed.length} levels of factors with an L${this.levels}FactorMap`);
    }
    return this.lookup_value(boxed) + offset3;
  }
  lookup_value(x2) {
    var _a34;
    return ((_a34 = this.lookup_entry(x2)) == null ? void 0 : _a34.value) ?? NaN;
  }
};
__publicField(FactorMapper, "__name__", "FactorMapper");
var L1FactorMapper = class extends FactorMapper {
  constructor(range2) {
    const { factors, factor_padding } = range2;
    const spec = map_one_level(factors, factor_padding);
    super({ levels: 1, ...spec });
  }
  lookup_entry(x2) {
    const [f0] = x2;
    return this.mapping.get(f0) ?? null;
  }
};
__publicField(L1FactorMapper, "__name__", "L1FactorMapper");
var L2FactorMapper = class extends FactorMapper {
  constructor(range2) {
    const { factors, group_padding, factor_padding } = range2;
    const spec = map_two_levels(factors, group_padding, factor_padding);
    super({ levels: 2, ...spec });
  }
  lookup_entry(x2) {
    var _a34;
    if (x2.length == 1) {
      const [f0] = x2;
      return this.mapping.get(f0) ?? null;
    } else {
      const [f0, f1] = x2;
      return ((_a34 = this.mapping.get(f0)) == null ? void 0 : _a34.mapping.get(f1)) ?? null;
    }
  }
};
__publicField(L2FactorMapper, "__name__", "L2FactorMapper");
var L3FactorMapper = class extends FactorMapper {
  constructor(range2) {
    const { factors, group_padding, subgroup_padding, factor_padding } = range2;
    const spec = map_three_levels(factors, group_padding, subgroup_padding, factor_padding);
    super({ levels: 3, ...spec });
  }
  lookup_entry(x2) {
    var _a34, _b4, _c;
    if (x2.length == 1) {
      const [f0] = x2;
      return this.mapping.get(f0) ?? null;
    } else if (x2.length == 2) {
      const [f0, f1] = x2;
      return ((_a34 = this.mapping.get(f0)) == null ? void 0 : _a34.mapping.get(f1)) ?? null;
    } else {
      const [f0, f1, f2] = x2;
      return ((_c = (_b4 = this.mapping.get(f0)) == null ? void 0 : _b4.mapping.get(f1)) == null ? void 0 : _c.mapping.get(f2)) ?? null;
    }
  }
};
__publicField(L3FactorMapper, "__name__", "L3FactorMapper");
var _FactorRange = class _FactorRange extends Range {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "mapper");
    __publicField(this, "invalidate_synthetic", new Signal0(this, "invalidate_synthetic"));
  }
  get min() {
    return this.start;
  }
  get max() {
    return this.end;
  }
  initialize() {
    super.initialize();
    this.configure();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.properties.factors.change, () => this.reset());
    this.connect(this.properties.factor_padding.change, () => this.reset());
    this.connect(this.properties.group_padding.change, () => this.reset());
    this.connect(this.properties.subgroup_padding.change, () => this.reset());
    this.connect(this.properties.range_padding.change, () => this.reset());
    this.connect(this.properties.range_padding_units.change, () => this.reset());
  }
  reset() {
    this.configure();
    this.invalidate_synthetic.emit();
  }
  /** Convert a categorical factor into a synthetic coordinate. */
  synthetic(x2) {
    return this.mapper.map(x2);
  }
  /** Convert an array of categorical factors into synthetic coordinates. */
  v_synthetic(xs) {
    return ScreenArray.from(xs, (x2) => this.synthetic(x2));
  }
  /** Convert a synthetic coordinate into a categorical factor. */
  factor(x2) {
    for (const f2 of this.factors) {
      const v = this.mapper.map(f2);
      if (x2 >= v - 0.5 && x2 < v + 0.5) {
        return f2;
      }
    }
    return null;
  }
  compute_bounds(inner_padding) {
    const interval = this.factors.length + inner_padding;
    const padding2 = (() => {
      switch (this.range_padding_units) {
        case "percent": {
          return interval * this.range_padding / 2;
        }
        case "absolute": {
          return this.range_padding;
        }
      }
    })();
    return [-padding2, interval + padding2];
  }
  configure() {
    this.mapper = FactorMapper.for(this);
    const [start2, end] = this.compute_bounds(this.mapper.inner_padding);
    this.setv({ start: start2, end }, { silent: true });
    if (this.bounds == "auto") {
      this._computed_bounds = [start2, end];
    }
  }
};
__publicField(_FactorRange, "__name__", "FactorRange");
_FactorRange.define(({ Float: Float2 }) => ({
  factors: [FactorSeq, []],
  factor_padding: [Float2, 0],
  subgroup_padding: [Float2, 0.8],
  group_padding: [Float2, 1.4],
  range_padding: [Float2, 0],
  range_padding_units: [PaddingUnits, "percent"],
  start: [Float2, unset, { readonly: true }],
  end: [Float2, unset, { readonly: true }]
}));
var FactorRange = _FactorRange;

// node_modules/@bokeh/bokehjs/build/js/lib/models/coordinates/coordinate_mapping.js
var CoordinateTransform = class {
  constructor(x_scale, y_scale) {
    __publicField(this, "x_scale");
    __publicField(this, "y_scale");
    __publicField(this, "x_source");
    __publicField(this, "y_source");
    __publicField(this, "ranges");
    __publicField(this, "scales");
    this.x_scale = x_scale;
    this.y_scale = y_scale;
    this.x_source = this.x_scale.source_range;
    this.y_source = this.y_scale.source_range;
    this.ranges = [this.x_source, this.y_source];
    this.scales = [this.x_scale, this.y_scale];
  }
  map_to_screen(xs, ys) {
    const sxs = this.x_scale.v_compute(xs);
    const sys = this.y_scale.v_compute(ys);
    return [sxs, sys];
  }
  map_from_screen(sxs, sys) {
    const xs = this.x_scale.v_invert(sxs);
    const ys = this.y_scale.v_invert(sys);
    return [xs, ys];
  }
};
__publicField(CoordinateTransform, "__name__", "CoordinateTransform");
var _CoordinateMapping = class _CoordinateMapping extends Model {
  constructor(attrs) {
    super(attrs);
  }
  get x_ranges() {
    return /* @__PURE__ */ new Map([["default", this.x_source]]);
  }
  get y_ranges() {
    return /* @__PURE__ */ new Map([["default", this.y_source]]);
  }
  _get_scale(range2, scale, target) {
    const factor_range = range2 instanceof FactorRange;
    const categorical_scale = scale instanceof CategoricalScale;
    if (factor_range != categorical_scale) {
      throw new Error(`Range ${range2.type} is incompatible is Scale ${scale.type}`);
    }
    if (scale instanceof LogScale && range2 instanceof DataRange1d) {
      range2.scale_hint = "log";
    }
    const derived_scale = scale.clone();
    derived_scale.setv({ source_range: range2, target_range: target });
    return derived_scale;
  }
  get_transform(frame) {
    const { x_source, x_scale, x_target } = this;
    const x_source_scale = this._get_scale(x_source, x_scale, x_target);
    const { y_source, y_scale, y_target } = this;
    const y_source_scale = this._get_scale(y_source, y_scale, y_target);
    const xscale = new CompositeScale({
      source_scale: x_source_scale,
      source_range: x_source_scale.source_range,
      target_scale: frame.x_scale,
      target_range: frame.x_target
    });
    const yscale = new CompositeScale({
      source_scale: y_source_scale,
      source_range: y_source_scale.source_range,
      target_scale: frame.y_scale,
      target_range: frame.y_target
    });
    return new CoordinateTransform(xscale, yscale);
  }
};
__publicField(_CoordinateMapping, "__name__", "CoordinateMapping");
_CoordinateMapping.define(({ Ref: Ref2 }) => ({
  x_source: [Ref2(Range), () => new DataRange1d()],
  y_source: [Ref2(Range), () => new DataRange1d()],
  x_scale: [Ref2(Scale), () => new LinearScale()],
  y_scale: [Ref2(Scale), () => new LinearScale()],
  x_target: [Ref2(Range)],
  y_target: [Ref2(Range)]
}));
var CoordinateMapping = _CoordinateMapping;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/affine.js
var { sin, cos } = Math;
var _AffineTransform = class _AffineTransform {
  constructor(a2 = 1, b2 = 0, c = 0, d = 1, e = 0, f2 = 0) {
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    __publicField(this, "e");
    __publicField(this, "f");
    this.a = a2;
    this.b = b2;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f2;
  }
  toString() {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    return `matrix(${a2}, ${b2}, ${c}, ${d}, ${e}, ${f2})`;
  }
  static from_DOMMatrix(matrix) {
    const { a: a2, b: b2, c, d, e, f: f2 } = matrix;
    return new _AffineTransform(a2, b2, c, d, e, f2);
  }
  to_DOMMatrix() {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    return new DOMMatrix([a2, b2, c, d, e, f2]);
  }
  clone() {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    return new _AffineTransform(a2, b2, c, d, e, f2);
  }
  [equals](that, cmp) {
    return cmp.eq(this.a, that.a) && cmp.eq(this.b, that.b) && cmp.eq(this.c, that.c) && cmp.eq(this.d, that.d) && cmp.eq(this.e, that.e) && cmp.eq(this.f, that.f);
  }
  reset() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
  }
  get is_identity() {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    return a2 == 1 && b2 == 0 && c == 0 && d == 1 && e == 0 && f2 == 0;
  }
  apply_point(p2) {
    const [x2, y2] = this.apply(p2.x, p2.y);
    return { x: x2, y: y2 };
  }
  apply_rect(rect) {
    const p0 = this.apply_point(rect.p0);
    const p1 = this.apply_point(rect.p1);
    const p2 = this.apply_point(rect.p2);
    const p3 = this.apply_point(rect.p3);
    return { p0, p1, p2, p3 };
  }
  apply(x2, y2) {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    return [
      a2 * x2 + c * y2 + e,
      b2 * x2 + d * y2 + f2
    ];
  }
  iv_apply(xs, ys) {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    const n2 = xs.length;
    for (let i2 = 0; i2 < n2; i2++) {
      const x2 = xs[i2];
      const y2 = ys[i2];
      xs[i2] = a2 * x2 + c * y2 + e;
      ys[i2] = b2 * x2 + d * y2 + f2;
    }
  }
  transform(A, B, C, D, E, F) {
    const { a: a2, b: b2, c, d, e, f: f2 } = this;
    this.a = a2 * A + c * B;
    this.c = a2 * C + c * D;
    this.e = a2 * E + c * F + e;
    this.b = b2 * A + d * B;
    this.d = b2 * C + d * D;
    this.f = b2 * E + d * F + f2;
    return this;
  }
  translate(tx, ty) {
    return this.transform(1, 0, 0, 1, tx, ty);
  }
  scale(cx, cy) {
    return this.transform(cx, 0, 0, cy, 0, 0);
  }
  skew(sx, sy) {
    return this.transform(1, sy, sx, 1, 0, 0);
  }
  rotate(angle) {
    if (angle == 0) {
      return this;
    }
    const s2 = sin(angle);
    const c = cos(angle);
    return this.transform(c, s2, -s2, c, 0, 0);
  }
  rotate_ccw(angle) {
    return this.rotate(-angle);
  }
  rotate_around(x2, y2, angle) {
    this.translate(x2, y2);
    this.rotate(angle);
    this.translate(-x2, -y2);
    return this;
  }
  translate_x(tx) {
    return this.translate(tx, 0);
  }
  translate_y(ty) {
    return this.translate(0, ty);
  }
  flip() {
    return this.scale(-1, -1);
  }
  flip_x() {
    return this.scale(1, -1);
  }
  flip_y() {
    return this.scale(-1, 1);
  }
  inverse() {
    return _AffineTransform.from_DOMMatrix(this.to_DOMMatrix().inverse());
  }
};
__publicField(_AffineTransform, "__name__", "AffineTransform");
var AffineTransform = _AffineTransform;
function rotate_around(point, center, angle) {
  if (angle == 0) {
    return point;
  } else {
    const tr2 = new AffineTransform();
    tr2.rotate_around(center.x, center.y, angle);
    const [x2, y2] = tr2.apply(point.x, point.y);
    return { x: x2, y: y2 };
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/random.js
var { PI: PI2, log: log2, sin: sin2, cos: cos2, sqrt: sqrt2, floor } = Math;
var MAX_INT32 = 2147483647;
var AbstractRandom = class {
  float() {
    return (this.integer() - 1) / (MAX_INT32 - 1);
  }
  floats(n2, a2 = 0, b2 = 1) {
    const result = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      result[i2] = a2 + this.float() * (b2 - a2);
    }
    return result;
  }
  choices(n2, items) {
    const k = items.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      result[i2] = items[this.integer() % k];
    }
    return result;
  }
  uniform(loc, scale) {
    return loc + (this.float() - 0.5) * scale;
  }
  uniforms(loc, scale, size2) {
    return Float64Array.from({ length: size2 }, () => this.uniform(loc, scale));
  }
  normal(loc, scale) {
    return this.normals(loc, scale, 1)[0];
  }
  normals(loc, scale, size2) {
    const [mu, sigma] = [loc, scale];
    const array2 = new Float64Array(size2);
    for (let i2 = 0; i2 < size2; i2 += 2) {
      const u2 = this.float();
      const v = this.float();
      const common = sqrt2(-2 * log2(u2));
      array2[i2] = mu + sigma * (common * cos2(2 * PI2 * v));
      if (i2 + 1 < size2) {
        array2[i2 + 1] = mu + sigma * (common * sin2(2 * PI2 * v));
      }
    }
    return array2;
  }
};
__publicField(AbstractRandom, "__name__", "AbstractRandom");
var SystemRandom = class extends AbstractRandom {
  integer() {
    return floor(Math.random() * MAX_INT32);
  }
};
__publicField(SystemRandom, "__name__", "SystemRandom");
var LCGRandom = class extends AbstractRandom {
  constructor(seed) {
    super();
    __publicField(this, "_seed");
    this._seed = seed % MAX_INT32;
    if (this._seed <= 0) {
      this._seed += MAX_INT32 - 1;
    }
  }
  integer() {
    this._seed = 48271 * this._seed % MAX_INT32;
    return this._seed;
  }
};
__publicField(LCGRandom, "__name__", "LCGRandom");
var Random = class extends LCGRandom {
};
__publicField(Random, "__name__", "Random");
var random = new Random(Date.now());

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/svg.js
function createNamedToNumberedLookup(input12, radix) {
  const lookup = /* @__PURE__ */ new Map();
  const items = input12.split(",");
  radix = radix ?? 10;
  for (let i2 = 0; i2 < items.length; i2 += 2) {
    const entity = `&${items[i2 + 1]};`;
    const base10 = parseInt(items[i2], radix);
    lookup.set(entity, `&#${base10};`);
  }
  lookup.set("\\xa0", "&#160;");
  return lookup;
}
function getTextAnchor(textAlign) {
  const mapping = { left: "start", right: "end", center: "middle", start: "start", end: "end" };
  return textAlign in mapping ? mapping[textAlign] : mapping.start;
}
function getDominantBaseline(textBaseline) {
  const mapping = { alphabetic: "alphabetic", hanging: "hanging", top: "text-before-edge", bottom: "text-after-edge", middle: "central" };
  return textBaseline in mapping ? mapping[textBaseline] : mapping.alphabetic;
}
var namedEntities = createNamedToNumberedLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
var STYLES = {
  strokeStyle: {
    svgAttr: "stroke",
    // corresponding svg attribute
    canvas: "#000000",
    // canvas default
    svg: "none",
    // svg default
    apply: "stroke"
    // apply on stroke() or fill()
  },
  fillStyle: {
    svgAttr: "fill",
    canvas: "#000000",
    svg: null,
    // svg default is black, but we need to special case this to handle canvas stroke without fill
    apply: "fill"
  },
  lineCap: {
    svgAttr: "stroke-linecap",
    canvas: "butt",
    svg: "butt",
    apply: "stroke"
  },
  lineJoin: {
    svgAttr: "stroke-linejoin",
    canvas: "miter",
    svg: "miter",
    apply: "stroke"
  },
  miterLimit: {
    svgAttr: "stroke-miterlimit",
    canvas: 10,
    svg: 4,
    apply: "stroke"
  },
  lineWidth: {
    svgAttr: "stroke-width",
    canvas: 1,
    svg: 1,
    apply: "stroke"
  },
  globalAlpha: {
    svgAttr: "opacity",
    canvas: 1,
    svg: 1,
    apply: "fill stroke"
  },
  shadowColor: {
    canvas: "#000000"
  },
  shadowOffsetX: {
    canvas: 0
  },
  shadowOffsetY: {
    canvas: 0
  },
  shadowBlur: {
    canvas: 0
  },
  lineDash: {
    svgAttr: "stroke-dasharray",
    canvas: [],
    svg: null,
    apply: "stroke"
  },
  lineDashOffset: {
    svgAttr: "stroke-dashoffset",
    canvas: 0,
    svg: 0,
    apply: "stroke"
  },
  direction: {
    canvas: "inherit"
  },
  font: {
    // font converts to multiple svg attributes, there is custom logic for this
    canvas: "10px sans-serif"
  },
  fontKerning: {
    canvas: "auto"
  },
  fontStretch: {
    canvas: "normal"
  },
  fontVariantCaps: {
    canvas: "normal"
  },
  letterSpacing: {
    canvas: "0px"
  },
  textAlign: {
    canvas: "start"
  },
  textBaseline: {
    canvas: "alphabetic"
  },
  textRendering: {
    canvas: "auto"
  },
  wordSpacing: {
    canvas: "0px"
  }
};
function is_VideoFrame(image) {
  return typeof VideoFrame !== "undefined" && image instanceof VideoFrame;
}
function width_height(image) {
  if (is_VideoFrame(image)) {
    return [image.codedWidth, image.codedHeight];
  } else {
    let to_number = function(val) {
      return isNumber(val) ? val : val.baseVal.value;
    };
    const { width, height } = image;
    return [to_number(width), to_number(height)];
  }
}
var CanvasGradient = class {
  constructor(gradientNode, ctx) {
    __publicField(this, "__root");
    __publicField(this, "__ctx");
    this.__root = gradientNode;
    this.__ctx = ctx;
  }
  /**
   * Adds a color stop to the gradient root
   */
  addColorStop(offset3, color) {
    if (this.__root.nodeName === "linearGradient" && this.__root.getAttribute("x1") === this.__root.getAttribute("x2") && this.__root.getAttribute("y1") === this.__root.getAttribute("y2")) {
      return;
    }
    if (this.__root.nodeName === "radialGradient" && this.__root.getAttribute("cx") === this.__root.getAttribute("fx") && this.__root.getAttribute("cy") === this.__root.getAttribute("fy") && this.__root.getAttribute("r") === this.__root.getAttribute("r0")) {
      return;
    }
    const stop = this.__ctx.__createElement("stop");
    stop.setAttribute("offset", `${offset3}`);
    if (color.indexOf("rgba") !== -1) {
      const regex2 = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
      const matches = regex2.exec(color);
      const [, r, g, b2, a2] = matches;
      stop.setAttribute("stop-color", `rgb(${r},${g},${b2})`);
      stop.setAttribute("stop-opacity", a2);
    } else {
      stop.setAttribute("stop-color", color);
    }
    this.__root.appendChild(stop);
  }
};
__publicField(CanvasGradient, "__name__", "CanvasGradient");
var CanvasPattern = class {
  constructor(pattern, ctx) {
    __publicField(this, "__root");
    __publicField(this, "__ctx");
    this.__root = pattern;
    this.__ctx = ctx;
  }
  setTransform(_transform) {
    throw new Error("not implemented");
  }
};
__publicField(CanvasPattern, "__name__", "CanvasPattern");
var _SVGRenderingContext2D = class _SVGRenderingContext2D {
  constructor(options2) {
    __publicField(this, "__canvas");
    __publicField(this, "__ctx");
    __publicField(this, "__root");
    __publicField(this, "__ids");
    __publicField(this, "__defs");
    __publicField(this, "__stack");
    __publicField(this, "__document");
    __publicField(this, "__currentElement");
    __publicField(this, "__currentDefaultPath", "");
    __publicField(this, "__currentPosition", null);
    __publicField(this, "strokeStyle");
    __publicField(this, "fillStyle");
    __publicField(this, "lineCap");
    __publicField(this, "lineJoin");
    __publicField(this, "miterLimit");
    __publicField(this, "lineWidth");
    __publicField(this, "globalAlpha", 1);
    __publicField(this, "globalCompositeOperation");
    // TODO: implement
    __publicField(this, "shadowColor");
    __publicField(this, "shadowOffsetX");
    __publicField(this, "shadowOffsetY");
    __publicField(this, "shadowBlur");
    __publicField(this, "lineDash");
    __publicField(this, "lineDashOffset");
    __publicField(this, "filter");
    // TODO: implement
    __publicField(this, "imageSmoothingEnabled");
    // TODO: implement
    __publicField(this, "imageSmoothingQuality");
    // TODO: implement
    __publicField(this, "direction");
    // TODO
    __publicField(this, "font");
    __publicField(this, "fontKerning");
    // TODO
    __publicField(this, "fontStretch");
    // TODO
    __publicField(this, "fontVariantCaps");
    // TODO
    __publicField(this, "letterSpacing");
    // TODO
    __publicField(this, "textAlign");
    __publicField(this, "textBaseline");
    __publicField(this, "textRendering");
    // TODO
    __publicField(this, "wordSpacing");
    // TODO
    __publicField(this, "_width");
    __publicField(this, "_height");
    __publicField(this, "_transform", new AffineTransform());
    __publicField(this, "_clip_path", null);
    this.__document = (options2 == null ? void 0 : options2.document) ?? document;
    if ((options2 == null ? void 0 : options2.ctx) != null) {
      this.__ctx = options2.ctx;
    } else {
      this.__canvas = this.__document.createElement("canvas");
      this.__ctx = this.__canvas.getContext("2d");
    }
    this.reset();
    this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.__root.setAttribute("version", "1.1");
    this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    this.__currentElement = this.__root;
    this.width = (options2 == null ? void 0 : options2.width) ?? 500;
    this.height = (options2 == null ? void 0 : options2.height) ?? 500;
    this.__ids = /* @__PURE__ */ new Set();
    this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
    this.__root.appendChild(this.__defs);
  }
  get canvas() {
    return this;
  }
  get width() {
    return this._width;
  }
  set width(width) {
    this._width = width;
    this.__root.setAttribute("width", `${width}`);
  }
  get height() {
    return this._height;
  }
  set height(height) {
    this._height = height;
    this.__root.setAttribute("height", `${height}`);
  }
  // helper function that generates a random string
  _random_string() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
    let str;
    do {
      str = _SVGRenderingContext2D.__random.choices(12, chars).join("");
    } while (this.__ids.has(str));
    return str;
  }
  /**
   * Creates the specified svg element
   */
  __createElement(elementName, properties = {}, resetFill = false) {
    const element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName);
    if (resetFill) {
      element.setAttribute("fill", "none");
      element.setAttribute("stroke", "none");
    }
    const keys2 = Object.keys(properties);
    for (const key of keys2) {
      element.setAttribute(key, `${properties[key]}`);
    }
    return element;
  }
  /**
   * Applies default canvas styles to the context
   */
  __setDefaultStyles() {
    for (const [key, val] of typed_entries(STYLES)) {
      this[key] = val.canvas;
    }
  }
  /**
   * Applies styles on restore
   */
  __applyStyleState(style_state) {
    for (const [key, val] of typed_entries(style_state)) {
      this[key] = val;
    }
  }
  /**
   * Gets the current style state
   */
  __getStyleState() {
    const style_state = {};
    for (const [key, _val] of typed_entries(STYLES)) {
      style_state[key] = this[key];
    }
    return style_state;
  }
  /**
   * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
   */
  __applyStyleToCurrentElement(type) {
    const currentElement = this.__currentElement;
    for (const [key, style2] of typed_entries(STYLES)) {
      const value2 = this[key];
      if (style2.apply != null && style2.apply.includes(type)) {
        if (value2 instanceof CanvasPattern) {
          for (const def of [...value2.__ctx.__defs.childNodes]) {
            if (def instanceof Element) {
              const id2 = def.getAttribute("id");
              this.__ids.add(id2);
              this.__defs.appendChild(def);
            }
          }
          const id = value2.__root.getAttribute("id");
          currentElement.setAttribute(style2.apply, `url(#${id})`);
        } else if (value2 instanceof CanvasGradient) {
          const id = value2.__root.getAttribute("id");
          currentElement.setAttribute(style2.apply, `url(#${id})`);
        } else if (style2.svg !== value2) {
          if ((style2.svgAttr === "stroke" || style2.svgAttr === "fill") && isString(value2) && value2.indexOf("rgb") !== -1) {
            const [r, g, b2, a2] = css4_parse(value2) ?? transparent();
            const opacity = a2 * this.globalAlpha;
            currentElement.setAttribute(style2.svgAttr, `rgb(${r},${g},${b2})`);
            currentElement.setAttribute(`${style2.svgAttr}-opacity`, `${opacity}`);
          } else {
            let attr2 = style2.svgAttr;
            if (key === "globalAlpha") {
              attr2 = `${type}-${style2.svgAttr}`;
              if (currentElement.getAttribute(attr2) != null) {
                continue;
              }
            }
            currentElement.setAttribute(attr2, `${value2}`);
          }
        }
      }
    }
  }
  /**
    * Returns the serialized value of the svg so far
    * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
    *                           If true, we attempt to find all named entities and encode it as a numeric entity.
    * @return serialized svg
    */
  get_serialized_svg(fixNamedEntities = false) {
    let serialized = new XMLSerializer().serializeToString(this.__root);
    if (fixNamedEntities) {
      for (const [key, value2] of namedEntities) {
        const regexp = new RegExp(key, "gi");
        if (regexp.test(serialized)) {
          serialized = serialized.replace(regexp, value2);
        }
      }
    }
    return serialized;
  }
  get_svg() {
    return this.__root;
  }
  /**
    * Will generate a group tag.
    */
  save() {
    this.__stack.push({
      transform: this._transform,
      clip_path: this._clip_path,
      attributes: this.__getStyleState()
    });
    this._transform = this._transform.clone();
  }
  /**
    * Sets current element to parent, or just root if already root
    */
  restore() {
    if (this.__stack.length == 0) {
      return;
    }
    const { transform: transform2, clip_path, attributes } = this.__stack.pop();
    this._transform = transform2;
    this._clip_path = clip_path;
    this.__applyStyleState(attributes);
  }
  isContextLost() {
    return false;
  }
  reset() {
    this.__setDefaultStyles();
    this.__stack = [];
  }
  _apply_transform(element, transform2 = this._transform) {
    if (!transform2.is_identity) {
      element.setAttribute("transform", transform2.toString());
    }
  }
  /**
    *  scales the current element
    */
  scale(x2, y2) {
    if (!isFinite(x2) || y2 != null && !isFinite(y2)) {
      return;
    }
    this._transform.scale(x2, y2 ?? x2);
  }
  /**
    * rotates the current element
    */
  rotate(angle) {
    if (!isFinite(angle)) {
      return;
    }
    this._transform.rotate(angle);
  }
  /**
    * translates the current element
    */
  translate(x2, y2) {
    if (!isFinite(x2 + y2)) {
      return;
    }
    this._transform.translate(x2, y2);
  }
  /**
    * applies a transform to the current element
    */
  transform(a2, b2, c, d, e, f2) {
    if (!isFinite(a2 + b2 + c + d + e + f2)) {
      return;
    }
    this._transform.transform(a2, b2, c, d, e, f2);
  }
  /**
    * Create a new Path Element
    */
  beginPath() {
    this.__currentDefaultPath = "";
    this.__currentPosition = null;
    this.__init_element();
  }
  __init_element() {
    const path = this.__createElement("path", {}, true);
    this.__root.appendChild(path);
    this.__currentElement = path;
  }
  /**
    * Helper function to apply currentDefaultPath to current path element
    */
  __applyCurrentDefaultPath() {
    const currentElement = this.__currentElement;
    if (currentElement.nodeName === "path") {
      currentElement.setAttribute("d", this.__currentDefaultPath);
    } else {
      console.error("Attempted to apply path command to node", currentElement.nodeName);
    }
  }
  /**
    * Helper function to add path command
    */
  __addPathCommand(x2, y2, path) {
    const separator = this.__currentDefaultPath == "" ? "" : " ";
    this.__currentDefaultPath += separator + path;
    this.__currentPosition = { x: x2, y: y2 };
  }
  get _hasCurrentDefaultPath() {
    return this.__currentDefaultPath != "";
  }
  /**
    * Adds the move command to the current path element,
    * if the currentPathElement is not empty create a new path element
    */
  moveTo(x2, y2) {
    if (!isFinite(x2 + y2)) {
      return;
    }
    const currentElement = this.__currentElement;
    if (currentElement.nodeName !== "path") {
      this.beginPath();
    }
    const [tx, ty] = this._transform.apply(x2, y2);
    this.__addPathCommand(tx, ty, `M ${tx} ${ty}`);
  }
  /**
    * Closes the current path
    */
  closePath() {
    if (this._hasCurrentDefaultPath) {
      this.__addPathCommand(NaN, NaN, "Z");
    }
  }
  /**
    * Adds a line to command
    */
  lineTo(x2, y2) {
    if (!isFinite(x2 + y2)) {
      return;
    }
    if (!this._hasCurrentDefaultPath) {
      this.moveTo(x2, y2);
    } else {
      const [tx, ty] = this._transform.apply(x2, y2);
      this.__addPathCommand(tx, ty, `L ${tx} ${ty}`);
    }
  }
  /**
    * Add a bezier command
    */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2) {
    if (!isFinite(cp1x + cp1y + cp2x + cp2y + x2 + y2)) {
      return;
    }
    const [tx, ty] = this._transform.apply(x2, y2);
    const [tcp1x, tcp1y] = this._transform.apply(cp1x, cp1y);
    const [tcp2x, tcp2y] = this._transform.apply(cp2x, cp2y);
    this.__addPathCommand(tx, ty, `C ${tcp1x} ${tcp1y} ${tcp2x} ${tcp2y} ${tx} ${ty}`);
  }
  /**
    * Adds a quadratic curve to command
    */
  quadraticCurveTo(cpx, cpy, x2, y2) {
    if (!isFinite(cpx + cpy + x2 + y2)) {
      return;
    }
    const [tx, ty] = this._transform.apply(x2, y2);
    const [tcpx, tcpy] = this._transform.apply(cpx, cpy);
    this.__addPathCommand(tx, ty, `Q ${tcpx} ${tcpy} ${tx} ${ty}`);
  }
  /**
    * Adds the arcTo to the current path
    *
    * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
    */
  arcTo(x1, y1, x2, y2, radius) {
    if (!isFinite(x1 + y1 + x2 + y2 + radius)) {
      return;
    }
    if (this.__currentPosition == null) {
      return;
    }
    const inverse2 = this._transform.inverse();
    const [x0, y0] = inverse2.apply(this.__currentPosition.x, this.__currentPosition.y);
    if (radius < 0) {
      throw new Error(`IndexSizeError: The radius provided (${radius}) is negative.`);
    }
    if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
      this.lineTo(x1, y1);
      return;
    }
    function normalize([x4, y4]) {
      const len = Math.sqrt(x4 ** 2 + y4 ** 2);
      return [x4 / len, y4 / len];
    }
    const unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
    const unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
    if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
      this.lineTo(x1, y1);
      return;
    }
    const cos3 = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
    const theta = Math.acos(Math.abs(cos3));
    const unit_vec_p1_origin = normalize([
      unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
      unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
    ]);
    const len_p1_origin = radius / Math.sin(theta / 2);
    const x3 = x1 + len_p1_origin * unit_vec_p1_origin[0];
    const y3 = y1 + len_p1_origin * unit_vec_p1_origin[1];
    const unit_vec_origin_start_tangent = [
      -unit_vec_p1_p0[1],
      unit_vec_p1_p0[0]
    ];
    const unit_vec_origin_end_tangent = [
      unit_vec_p1_p2[1],
      -unit_vec_p1_p2[0]
    ];
    function getAngle(vector) {
      const x4 = vector[0];
      const y4 = vector[1];
      if (y4 >= 0) {
        return Math.acos(x4);
      } else {
        return -Math.acos(x4);
      }
    }
    const startAngle = getAngle(unit_vec_origin_start_tangent);
    const endAngle = getAngle(unit_vec_origin_end_tangent);
    this.lineTo(x3 + unit_vec_origin_start_tangent[0] * radius, y3 + unit_vec_origin_start_tangent[1] * radius);
    this.arc(x3, y3, radius, startAngle, endAngle);
  }
  /**
    * Sets the stroke property on the current element
    */
  stroke() {
    if (this.__currentElement.nodeName === "path") {
      this.__currentElement.setAttribute("paint-order", "fill");
    }
    this.__applyCurrentDefaultPath();
    this.__applyStyleToCurrentElement("stroke");
    if (this._clip_path != null) {
      this.__currentElement.setAttribute("clip-path", this._clip_path);
    }
  }
  fill(path_or_fill_rule, fill_rule) {
    let path = null;
    if (path_or_fill_rule instanceof Path2D) {
      path = path_or_fill_rule;
    } else if (fill_rule == null) {
      fill_rule = path_or_fill_rule;
    } else {
      throw new Error("invalid arguments");
    }
    if (path != null) {
      throw new Error("not implemented");
    }
    if (this.__currentElement.getAttribute("fill") != "none") {
      this.__init_element();
    }
    if (this.__currentElement.nodeName === "path") {
      this.__currentElement.setAttribute("paint-order", "stroke");
    }
    this.__applyCurrentDefaultPath();
    this.__applyStyleToCurrentElement("fill");
    if (fill_rule != null) {
      this.__currentElement.setAttribute("fill-rule", fill_rule);
    }
    if (this._clip_path != null) {
      this.__currentElement.setAttribute("clip-path", this._clip_path);
    }
  }
  /**
    *  Adds a rectangle to the path.
    */
  rect(x2, y2, width, height) {
    if (!isFinite(x2 + y2 + width + height)) {
      return;
    }
    this.moveTo(x2, y2);
    this.lineTo(x2 + width, y2);
    this.lineTo(x2 + width, y2 + height);
    this.lineTo(x2, y2 + height);
    this.lineTo(x2, y2);
    this.closePath();
  }
  /**
    * adds a rectangle element
    */
  fillRect(x2, y2, width, height) {
    if (!isFinite(x2 + y2 + width + height)) {
      return;
    }
    this.beginPath();
    this.rect(x2, y2, width, height);
    this.fill();
  }
  /**
    * Draws a rectangle with no fill
    * @param x
    * @param y
    * @param width
    * @param height
    */
  strokeRect(x2, y2, width, height) {
    if (!isFinite(x2 + y2 + width + height)) {
      return;
    }
    this.beginPath();
    this.rect(x2, y2, width, height);
    this.stroke();
  }
  /**
    * Clear entire canvas:
    * 1. save current transforms
    * 2. remove all the childNodes of the root g element
    */
  __clearCanvas() {
    empty2(this.__defs);
    empty2(this.__root);
    this.__root.appendChild(this.__defs);
    this.__currentElement = this.__root;
  }
  /**
    * "Clears" a canvas by just drawing a white rectangle in the current group.
    */
  clearRect(x2, y2, width, height) {
    if (!isFinite(x2 + y2 + width + height)) {
      return;
    }
    if (x2 === 0 && y2 === 0 && width === this.width && height === this.height) {
      this.__clearCanvas();
      return;
    }
    const rect = this.__createElement("rect", { x: x2, y: y2, width, height, fill: "#FFFFFF" }, true);
    this._apply_transform(rect);
    this.__root.appendChild(rect);
  }
  roundRect(_x, _y, _w, _h, _radii) {
    throw new Error("not implemented");
  }
  /**
    * Adds a linear gradient to a defs tag.
    * Returns a canvas gradient object that has a reference to it's parent def
    */
  createLinearGradient(x1, y1, x2, y2) {
    if (!isFinite(x1 + y1 + x2 + y2)) {
      throw new Error("The provided double value is non-finite");
    }
    const [tx1, ty1] = this._transform.apply(x1, y1);
    const [tx2, ty2] = this._transform.apply(x2, y2);
    const grad = this.__createElement("linearGradient", {
      id: this._random_string(),
      x1: `${tx1}px`,
      x2: `${tx2}px`,
      y1: `${ty1}px`,
      y2: `${ty2}px`,
      gradientUnits: "userSpaceOnUse"
    }, false);
    this.__defs.appendChild(grad);
    return new CanvasGradient(grad, this);
  }
  /**
    * Adds a radial gradient to a defs tag.
    * Returns a canvas gradient object that has a reference to it's parent def
    */
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    if (!isFinite(x0 + y0 + r0 + x1 + y1 + r1)) {
      throw new Error("The provided double value is non-finite");
    }
    const [tx0, ty0] = this._transform.apply(x0, y0);
    const [tx1, ty1] = this._transform.apply(x1, y1);
    const grad = this.__createElement("radialGradient", {
      id: this._random_string(),
      cx: `${tx1}px`,
      cy: `${ty1}px`,
      r: `${r1}px`,
      r0: `${r0}px`,
      fx: `${tx0}px`,
      fy: `${ty0}px`,
      gradientUnits: "userSpaceOnUse"
    }, false);
    this.__defs.appendChild(grad);
    return new CanvasGradient(grad, this);
  }
  createConicGradient(_start_angle, _x, _y) {
    throw Error("not implemented");
  }
  /**
    * Parses the font string and returns svg mapping
    */
  __parseFont() {
    const regex2 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
    const [, style2, decoration, weight, size2, , family] = regex2.exec(this.font);
    const data3 = {
      style: style2 ?? "normal",
      size: size2 ?? "10px",
      family: family ?? "sans-serif",
      weight: weight ?? "normal",
      decoration: decoration ?? "normal"
    };
    return data3;
  }
  /**
    * Fills or strokes text
    */
  __applyText(text2, x2, y2, action) {
    const font = this.__parseFont();
    const text_el = this.__createElement("text", {
      "font-family": font.family,
      "font-size": font.size,
      "font-style": font.style,
      "font-weight": font.weight,
      "text-decoration": font.decoration,
      x: x2,
      y: y2,
      "text-anchor": getTextAnchor(this.textAlign),
      "dominant-baseline": getDominantBaseline(this.textBaseline)
    }, true);
    text_el.appendChild(this.__document.createTextNode(text2));
    this._apply_transform(text_el);
    this.__currentElement = text_el;
    this.__applyStyleToCurrentElement(action);
    const el = (() => {
      if (this._clip_path != null) {
        const g = this.__createElement("g");
        g.setAttribute("clip-path", this._clip_path);
        g.appendChild(text_el);
        return g;
      } else {
        return text_el;
      }
    })();
    this.__root.appendChild(el);
  }
  /**
    * Creates a text element, in position x,y
    */
  fillText(text2, x2, y2) {
    if (!isFinite(x2 + y2)) {
      return;
    }
    this.__applyText(text2, x2, y2, "fill");
  }
  /**
    * Strokes text
    */
  strokeText(text2, x2, y2) {
    if (!isFinite(x2 + y2)) {
      return;
    }
    this.__applyText(text2, x2, y2, "stroke");
  }
  /**
    * No need to implement this for svg.
    */
  measureText(text2) {
    this.__ctx.font = this.font;
    return this.__ctx.measureText(text2);
  }
  arc(x2, y2, radius, start_angle, end_angle, counterclockwise = false) {
    this.ellipse(x2, y2, radius, radius, 0, start_angle, end_angle, counterclockwise);
  }
  ellipse(x2, y2, radius_x, radius_y, rotation, start_angle, end_angle, counterclockwise = false) {
    if (!isFinite(x2 + y2 + radius_x + radius_y + rotation + start_angle + end_angle)) {
      return;
    }
    if (radius_x < 0 || radius_y < 0) {
      throw new DOMException("IndexSizeError, radius can't be negative");
    }
    const initial_diff = counterclockwise ? end_angle - start_angle : start_angle - end_angle;
    start_angle = start_angle % (2 * Math.PI);
    end_angle = end_angle % (2 * Math.PI);
    const transform2 = new AffineTransform().translate(x2, y2).rotate(rotation);
    const dx = radius_x * Math.cos(start_angle);
    const dy = radius_y * Math.sin(start_angle);
    const [start_x, start_y] = transform2.apply(dx, dy);
    this.lineTo(start_x, start_y);
    const rotation_in_degrees = rotation * 180 / Math.PI;
    const sweep_flag = counterclockwise ? 0 : 1;
    if (Math.abs(start_angle - end_angle) < 2 * float32_epsilon && !(Math.abs(initial_diff) < 2 * float32_epsilon && initial_diff < 0)) {
      const [tstart_x, tstart_y] = this._transform.apply(start_x, start_y);
      const dx2 = radius_x * Math.cos(start_angle + Math.PI);
      const dy2 = radius_y * Math.sin(start_angle + Math.PI);
      const [mid_x, mid_y] = transform2.apply(dx2, dy2);
      const [tmid_x, tmid_y] = this._transform.apply(mid_x, mid_y);
      this.__addPathCommand(tstart_x, tstart_y, `A ${radius_x} ${radius_y} ${rotation_in_degrees} 0 ${sweep_flag} ${tmid_x} ${tmid_y} A ${radius_x} ${radius_y} ${rotation_in_degrees} 0 ${sweep_flag} ${tstart_x} ${tstart_y}`);
    } else {
      const dx2 = radius_x * Math.cos(end_angle);
      const dy2 = radius_y * Math.sin(end_angle);
      const [end_x, end_y] = transform2.apply(dx2, dy2);
      let diff = end_angle - start_angle;
      if (diff < 0) {
        diff += 2 * Math.PI;
      }
      const large_arc_flag = counterclockwise !== diff > Math.PI ? 1 : 0;
      const [tend_x, tend_y] = this._transform.apply(end_x, end_y);
      this.__addPathCommand(tend_x, tend_y, `A ${radius_x} ${radius_y} ${rotation_in_degrees} ${large_arc_flag} ${sweep_flag} ${tend_x} ${tend_y}`);
    }
  }
  clip(path_or_fill_rule, fill_rule) {
    let path = null;
    if (path_or_fill_rule instanceof Path2D) {
      path = path_or_fill_rule;
    } else if (fill_rule == null) {
      fill_rule = path_or_fill_rule;
    } else {
      throw new Error("invalid arguments");
    }
    if (path != null) {
      throw new Error("not implemented");
    }
    const clip_path = this.__createElement("clipPath");
    const id = this._random_string();
    this.__applyCurrentDefaultPath();
    if (fill_rule != null) {
      this.__currentElement.setAttribute("clip-rule", fill_rule);
    }
    clip_path.setAttribute("id", id);
    clip_path.appendChild(this.__currentElement);
    this.__defs.appendChild(clip_path);
    this._clip_path = `url(#${id})`;
  }
  /**
    * Draws a canvas, image or mock context to this canvas.
    * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
    * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
    */
  drawImage(image, ...args) {
    let dx, dy;
    let dw, dh;
    let sx, sy;
    let sw, sh;
    if (args.length == 2) {
      [dx, dy] = args;
      if (!isFinite(dx + dy)) {
        return;
      }
      sx = 0;
      sy = 0;
      const [w, h7] = width_height(image);
      dw = sw = w;
      dh = sh = h7;
    } else if (args.length == 4) {
      [dx, dy, dw, dh] = args;
      if (!isFinite(dx + dy + dw + dh)) {
        return;
      }
      sx = 0;
      sy = 0;
      const [w, h7] = width_height(image);
      sw = w;
      sh = h7;
    } else if (args.length === 8) {
      [sx, sy, sw, sh, dx, dy, dw, dh] = args;
      if (!isFinite(sx + sy + sw + sh + dx + dy + dw + dh)) {
        return;
      }
    } else {
      throw new Error(`Inavlid number of arguments passed to drawImage: ${arguments.length}`);
    }
    const parent = this.__root;
    const transform2 = this._transform.clone().translate(dx, dy);
    if (image instanceof _SVGRenderingContext2D || image instanceof SVGSVGElement) {
      const svg_node = image instanceof SVGSVGElement ? image : image.get_svg();
      const svg = svg_node.cloneNode(true);
      let scope2;
      if (transform2.is_identity && this.globalAlpha == 1 && this._clip_path == null) {
        scope2 = parent;
      } else {
        scope2 = this.__createElement("g");
        if (!transform2.is_identity) {
          this._apply_transform(scope2, transform2);
        }
        if (this.globalAlpha != 1) {
          scope2.setAttribute("opacity", `${this.globalAlpha}`);
        }
        if (this._clip_path != null) {
          scope2.setAttribute("clip-path", this._clip_path);
        }
        parent.appendChild(scope2);
      }
      for (const child of [...svg.childNodes]) {
        if (child instanceof SVGDefsElement) {
          for (const def of [...child.childNodes]) {
            if (def instanceof Element) {
              const id = def.getAttribute("id");
              this.__ids.add(id);
              this.__defs.appendChild(def.cloneNode(true));
            }
          }
        } else {
          scope2.appendChild(child.cloneNode(true));
        }
      }
    } else if (image instanceof HTMLImageElement || image instanceof SVGImageElement) {
      const svgImage = this.__createElement("image");
      svgImage.setAttribute("width", `${dw}`);
      svgImage.setAttribute("height", `${dh}`);
      svgImage.setAttribute("preserveAspectRatio", "none");
      if (this.globalAlpha != 1) {
        svgImage.setAttribute("opacity", `${this.globalAlpha}`);
      }
      if (sx != 0 || sy != 0 || sw !== image.width || sh !== image.height) {
        const canvas3 = this.__document.createElement("canvas");
        canvas3.width = dw;
        canvas3.height = dh;
        const context = canvas3.getContext("2d");
        context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
        image = canvas3;
      }
      this._apply_transform(svgImage, transform2);
      const url2 = image instanceof HTMLCanvasElement ? image.toDataURL() : image.getAttribute("src");
      svgImage.setAttribute("href", url2);
      if (this._clip_path != null) {
        const scope2 = this.__createElement("g");
        scope2.setAttribute("clip-path", this._clip_path);
        scope2.appendChild(svgImage);
        parent.appendChild(scope2);
      } else {
        parent.appendChild(svgImage);
      }
    } else if (image instanceof HTMLCanvasElement) {
      const svgImage = this.__createElement("image");
      svgImage.setAttribute("width", `${dw}`);
      svgImage.setAttribute("height", `${dh}`);
      svgImage.setAttribute("preserveAspectRatio", "none");
      if (this.globalAlpha != 1) {
        svgImage.setAttribute("opacity", `${this.globalAlpha}`);
      }
      const canvas3 = this.__document.createElement("canvas");
      canvas3.width = dw;
      canvas3.height = dh;
      const context = canvas3.getContext("2d");
      context.imageSmoothingEnabled = false;
      context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
      image = canvas3;
      this._apply_transform(svgImage, transform2);
      svgImage.setAttribute("href", image.toDataURL());
      if (this._clip_path != null) {
        const scope2 = this.__createElement("g");
        scope2.setAttribute("clip-path", this._clip_path);
        scope2.appendChild(svgImage);
        parent.appendChild(scope2);
      } else {
        parent.appendChild(svgImage);
      }
    }
  }
  /**
    * Generates a pattern tag
    */
  createPattern(image, _repetition) {
    const pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern");
    const id = this._random_string();
    const [width, height] = width_height(image);
    pattern.setAttribute("id", id);
    pattern.setAttribute("width", `${width}`);
    pattern.setAttribute("height", `${height}`);
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    if (image instanceof HTMLCanvasElement || image instanceof HTMLImageElement || image instanceof SVGImageElement) {
      const img2 = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
      const url2 = image instanceof HTMLCanvasElement ? image.toDataURL() : image.getAttribute("src");
      img2.setAttribute("href", url2);
      pattern.appendChild(img2);
      this.__defs.appendChild(pattern);
    } else if (image instanceof _SVGRenderingContext2D) {
      for (const child of [...image.__root.childNodes]) {
        if (!(child instanceof SVGDefsElement)) {
          pattern.appendChild(child.cloneNode(true));
        }
      }
      this.__defs.appendChild(pattern);
    } else if (image instanceof SVGSVGElement) {
      for (const child of [...image.childNodes]) {
        if (!(child instanceof SVGDefsElement)) {
          pattern.appendChild(child.cloneNode(true));
        }
      }
      this.__defs.appendChild(pattern);
    } else {
      throw new Error("unsupported");
    }
    return new CanvasPattern(pattern, this);
  }
  getLineDash() {
    const { lineDash } = this;
    if (isString(lineDash)) {
      return lineDash.split(",").map((v) => parseInt(v));
    } else if (lineDash == null) {
      return [];
    } else {
      return lineDash;
    }
  }
  setLineDash(segments) {
    if (segments.length > 0) {
      this.lineDash = segments.join(",");
    } else {
      this.lineDash = null;
    }
  }
  getTransform() {
    return this._transform.to_DOMMatrix();
  }
  setTransform(...args) {
    let matrix;
    if (isNumber(args[0])) {
      matrix = new DOMMatrix(args);
    } else if (args[0] instanceof DOMMatrix) {
      matrix = args[0];
    } else {
      matrix = new DOMMatrix(Object.values(args[0] == null));
    }
    this._transform = AffineTransform.from_DOMMatrix(matrix);
  }
  resetTransform() {
    this._transform = new AffineTransform();
  }
  isPointInPath(..._args) {
    throw new Error("not implemented");
  }
  isPointInStroke(..._args) {
    throw new Error("not implemented");
  }
  createImageData(..._args) {
    throw new Error("not implemented");
  }
  getImageData(_sx, _sy, _sw, _sh) {
    throw new Error("not implemented");
  }
  putImageData(..._args) {
    throw new Error("not implemented");
  }
  drawFocusIfNeeded(..._args) {
    throw new Error("not implemented");
  }
  scrollPathIntoView(..._args) {
    throw new Error("not implemented");
  }
};
__publicField(_SVGRenderingContext2D, "__name__", "SVGRenderingContext2D");
//__currentElementsToStyle: {element: SVGElement, children: SVGElement[]} | null = null
__publicField(_SVGRenderingContext2D, "__random", random);
var SVGRenderingContext2D = _SVGRenderingContext2D;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/canvas.js
var CanvasLayer = class {
  constructor(backend, hidpi) {
    __publicField(this, "backend");
    __publicField(this, "hidpi");
    __publicField(this, "_canvas");
    __publicField(this, "_ctx");
    __publicField(this, "_el");
    __publicField(this, "pixel_ratio", 1);
    __publicField(this, "bbox", new BBox());
    this.backend = backend;
    this.hidpi = hidpi;
    switch (backend) {
      case "webgl":
      case "canvas": {
        this._el = this._canvas = canvas2({ class: "bk-layer" });
        const ctx = this.canvas.getContext("2d");
        if (ctx == null) {
          throw new Error("unable to obtain 2D rendering context");
        }
        this._ctx = ctx;
        if (hidpi) {
          this.pixel_ratio = devicePixelRatio;
        }
        break;
      }
      case "svg": {
        const ctx = new SVGRenderingContext2D();
        this._ctx = ctx;
        this._canvas = ctx.get_svg();
        this._el = div({ class: "bk-layer" });
        const shadow_el = this._el.attachShadow({ mode: "open" });
        shadow_el.appendChild(this._canvas);
        break;
      }
    }
    this._ctx.layer = this;
  }
  get canvas() {
    return this._canvas;
  }
  get ctx() {
    return this._ctx;
  }
  get el() {
    return this._el;
  }
  resize(width, height) {
    if (this.bbox.width == width && this.bbox.height == height) {
      return;
    }
    this.bbox = new BBox({ left: 0, top: 0, width, height });
    const { target } = this;
    target.width = width * this.pixel_ratio;
    target.height = height * this.pixel_ratio;
  }
  get target() {
    return this._ctx instanceof SVGRenderingContext2D ? this._ctx : this.canvas;
  }
  undo_transform(fn) {
    const { ctx } = this;
    const current_transform = ctx.getTransform();
    ctx.resetTransform();
    try {
      fn(ctx);
    } finally {
      ctx.setTransform(current_transform);
    }
  }
  prepare() {
    const { ctx, hidpi, pixel_ratio } = this;
    ctx.save();
    if (hidpi) {
      ctx.scale(pixel_ratio, pixel_ratio);
      ctx.translate(0.5, 0.5);
    }
    this.clear();
  }
  clear() {
    const { x: x2, y: y2, width, height } = this.bbox;
    this.ctx.clearRect(x2, y2, width, height);
  }
  finish() {
    this.ctx.restore();
  }
  to_blob() {
    const { _canvas } = this;
    if (_canvas instanceof HTMLCanvasElement) {
      return new Promise((resolve, reject) => {
        _canvas.toBlob((blob) => blob != null ? resolve(blob) : reject(), "image/png");
      });
    } else {
      const ctx = this._ctx;
      const svg = ctx.get_serialized_svg(true);
      const blob = new Blob([svg], { type: "image/svg+xml" });
      return Promise.resolve(blob);
    }
  }
};
__publicField(CanvasLayer, "__name__", "CanvasLayer");

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/ui_element.js
import ui_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/ui.css.js";
var { round: round2, floor: floor2 } = Math;
var UIElementView = class extends StyledElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_display", new InlineStyleSheet());
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "_resize_observer");
    __publicField(this, "_context_menu", null);
    __publicField(this, "_resized", false);
    __publicField(this, "_is_displayed", false);
  }
  *_stylesheets() {
    yield* super._stylesheets();
    yield this._display;
  }
  stylesheets() {
    return [...super.stylesheets(), ui_css];
  }
  update_style() {
    this.style.clear();
  }
  box_sizing() {
    return {
      width_policy: "auto",
      height_policy: "auto",
      width: null,
      height: null,
      aspect_ratio: null
    };
  }
  get bbox() {
    return this._bbox;
  }
  update_bbox() {
    return this._update_bbox();
  }
  _update_bbox() {
    const displayed = (() => {
      if (!this.el.isConnected) {
        return false;
      } else if (this.el.offsetParent != null) {
        return true;
      } else {
        const { position: position2, display: display2 } = getComputedStyle(this.el);
        return position2 == "fixed" && display2 != "none";
      }
    })();
    const bbox = !displayed ? new BBox() : (() => {
      const self2 = this.el.getBoundingClientRect();
      const { left: left2, top } = (() => {
        if (this.parent != null) {
          const parent = this.parent.el.getBoundingClientRect();
          return {
            left: self2.left - parent.left,
            top: self2.top - parent.top
          };
        } else {
          return { left: 0, top: 0 };
        }
      })();
      return new BBox({
        left: round2(left2),
        top: round2(top),
        width: floor2(self2.width),
        height: floor2(self2.height)
      });
    })();
    const changed = !this._bbox.equals(bbox);
    this._bbox = bbox;
    this._is_displayed = displayed;
    return changed;
  }
  initialize() {
    super.initialize();
    this._resize_observer = new ResizeObserver((_entries) => this.after_resize());
    this._resize_observer.observe(this.el, { box: "border-box" });
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { context_menu } = this.model;
    if (context_menu != null) {
      this._context_menu = await build_view(context_menu, { parent: this });
    }
  }
  connect_signals() {
    super.connect_signals();
    const { visible } = this.model.properties;
    this.on_change(visible, () => this._update_visible());
    this.el.addEventListener("contextmenu", (event2) => this.show_context_menu(event2));
  }
  get_context_menu(_xy) {
    return this._context_menu;
  }
  show_context_menu(event2) {
    if (!event2.shiftKey) {
      const rect = this.el.getBoundingClientRect();
      const x2 = event2.x - rect.x;
      const y2 = event2.y - rect.y;
      const context_menu = this.get_context_menu({ x: x2, y: y2 });
      if (context_menu != null) {
        event2.stopPropagation();
        event2.preventDefault();
        context_menu.show({ x: x2, y: y2 });
      }
    }
  }
  remove() {
    var _a34;
    this._resize_observer.disconnect();
    (_a34 = this._context_menu) == null ? void 0 : _a34.remove();
    super.remove();
  }
  _after_resize() {
  }
  after_resize() {
    this._resized = true;
    if (this.update_bbox()) {
      this._after_resize();
    }
    this.finish();
  }
  render() {
    super.render();
    this._apply_visible();
  }
  _after_render() {
    this.update_style();
    this.update_bbox();
  }
  after_render() {
    super.after_render();
    this._after_render();
    if (!this._has_finished) {
      if (!this.is_displayed) {
        this.force_finished();
      } else {
        void defer().then(() => {
          if (!this._resized) {
            this.finish();
          }
        });
      }
    }
  }
  get is_displayed() {
    return this._is_displayed;
  }
  _apply_visible() {
    if (this.model.visible) {
      this._display.clear();
    } else {
      this._display.replace(":host { display: none !important; }");
    }
  }
  _update_visible() {
    this._apply_visible();
  }
  export(type = "auto", hidpi = true) {
    const output_backend = type == "auto" || type == "png" ? "canvas" : "svg";
    const canvas3 = new CanvasLayer(output_backend, hidpi);
    const { width, height } = this.bbox;
    canvas3.resize(width, height);
    return canvas3;
  }
  resolve_symbol(node) {
    const value2 = this.bbox.resolve(node.symbol);
    const { offset: offset3 } = node;
    if (isNumber(value2)) {
      return value2 + offset3;
    } else {
      const { x: x2, y: y2 } = value2;
      return { x: x2 + offset3, y: y2 + offset3 };
    }
  }
};
__publicField(UIElementView, "__name__", "UIElementView");
var _UIElement = class _UIElement extends StyledElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_UIElement, "__name__", "UIElement");
_UIElement.define(({ Bool: Bool2, AnyRef: AnyRef2, Nullable: Nullable2 }) => ({
  visible: [Bool2, true],
  context_menu: [Nullable2(AnyRef2()), null]
}));
var UIElement = _UIElement;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/menus/menu_item.js
var MenuItem = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(MenuItem, "__name__", "MenuItem");

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/callback.js
var Callback = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Callback, "__name__", "Callback");

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/menus/action_item.js
var IconLike = Or(ToolIcon, Regex(/^--/), Regex(/^\./), Regex(/^data:image/));
var _ActionItem = class _ActionItem extends MenuItem {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ActionItem, "__name__", "ActionItem");
_ActionItem.define(({ Bool: Bool2, Str: Str2, Nullable: Nullable2, AnyRef: AnyRef2, Ref: Ref2, Func }) => ({
  icon: [Nullable2(IconLike), null],
  label: [Str2],
  tooltip: [Nullable2(Str2), null],
  shortcut: [Nullable2(Str2), null],
  menu: [Nullable2(AnyRef2()), null],
  disabled: [Bool2, false],
  action: [Nullable2(Or(Ref2(Callback), Func())), null]
}));
var ActionItem = _ActionItem;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/menus/checkable_item.js
var _CheckableItem = class _CheckableItem extends ActionItem {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CheckableItem, "__name__", "CheckableItem");
_CheckableItem.define(({ Bool: Bool2 }) => ({
  checked: [Bool2, false]
}));
var CheckableItem = _CheckableItem;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/menus/divider_item.js
var DividerItem = class extends MenuItem {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(DividerItem, "__name__", "DividerItem");

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/menus/menu.js
import menus_css, * as menus from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/menus_.css.js";
import icons_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var MenuView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_menu_views", /* @__PURE__ */ new Map());
    __publicField(this, "prevent_hide");
    __publicField(this, "_open", false);
    __publicField(this, "_item_click", (item3) => {
      if (!item3.disabled) {
        const { action } = item3;
        if (action != null) {
          void execute(action, this.model, { item: item3 });
        }
        this.hide();
      }
    });
    __publicField(this, "_on_mousedown", (event2) => {
      var _a34;
      if (event2.composedPath().includes(this.el)) {
        return;
      }
      if (((_a34 = this.prevent_hide) == null ? void 0 : _a34.call(this, event2)) ?? false) {
        return;
      }
      this.hide();
    });
    __publicField(this, "_on_keydown", (event2) => {
      if (event2.key == "Escape") {
        this.hide();
      }
    });
    __publicField(this, "_on_blur", () => {
      this.hide();
    });
  }
  *children() {
    yield* super.children();
    yield* this._menu_views.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const menus3 = this.model.items.map((item3) => item3 instanceof ActionItem ? item3.menu : null).filter((item3) => item3 != null);
    await build_views(this._menu_views, menus3, { parent: this });
  }
  get is_open() {
    return this._open;
  }
  remove() {
    this._unlisten();
    remove_views(this._menu_views);
    super.remove();
  }
  _listen() {
    document.addEventListener("mousedown", this._on_mousedown);
    document.addEventListener("keydown", this._on_keydown);
    window.addEventListener("blur", this._on_blur);
  }
  _unlisten() {
    document.removeEventListener("mousedown", this._on_mousedown);
    document.removeEventListener("keydown", this._on_keydown);
    window.removeEventListener("blur", this._on_blur);
  }
  stylesheets() {
    return [...super.stylesheets(), menus_css, icons_css];
  }
  render() {
    super.render();
    const items = (() => {
      const { reversed: reversed2, items: items2 } = this.model;
      return reversed2 ? reversed(items2) : items2;
    })();
    for (const item3 of items) {
      if (item3 instanceof DividerItem) {
        const item_el = div({ class: menus.divider });
        this.shadow_el.append(item_el);
      } else if (item3 instanceof ActionItem) {
        const check_el = div({ class: menus.check });
        const icon_el = div({ class: menus.icon });
        const label_el = div({ class: menus.label }, item3.label);
        const shortcut_el = div({ class: menus.shortcut }, item3.shortcut);
        const chevron_el = div({ class: menus.chevron });
        const { icon: icon3 } = item3;
        if (icon3 != null) {
          if (icon3.startsWith("data:image")) {
            const url2 = `url("${encodeURI(icon3)}")`;
            icon_el.style.backgroundImage = url2;
          } else if (icon3.startsWith("--")) {
            icon_el.style.backgroundImage = `var(${icon3})`;
          } else if (icon3.startsWith(".")) {
            const cls = icon3.substring(1);
            icon_el.classList.add(cls);
          } else if (ToolIcon.valid(icon3)) {
            const cls = `bk-tool-icon-${icon3.replace(/_/g, "-")}`;
            icon_el.classList.add(cls);
          }
        }
        const item_el = div({ class: menus.item, title: item3.tooltip, tabIndex: 0 }, check_el, icon_el, label_el, shortcut_el, chevron_el);
        item_el.classList.toggle(menus.menu, item3.menu != null);
        item_el.classList.toggle(menus.disabled, item3.disabled);
        if (item3 instanceof CheckableItem) {
          item_el.classList.add(menus.checkable);
          item_el.classList.toggle(menus.checked, item3.checked);
        }
        item_el.addEventListener("click", () => {
          this._item_click(item3);
        });
        item_el.addEventListener("keydown", (event2) => {
          if (event2.key == "Enter") {
            this._item_click(item3);
          }
        });
        const { menu: menu5 } = item3;
        if (menu5 != null) {
          item_el.addEventListener("pointerenter", () => {
            const menu_view = this._menu_views.get(menu5);
            menu_view._show_submenu(item_el);
          });
          item_el.addEventListener("pointerleave", () => {
            const menu_view = this._menu_views.get(menu5);
            menu_view.hide();
          });
        }
        this.shadow_el.append(item_el);
      }
    }
  }
  _show_submenu(target) {
    if (this.model.items.length == 0) {
      this.hide();
      return;
    }
    this.render();
    target.append(this.el);
    const { style: style2 } = this.el;
    style2.left = "100%";
    style2.top = "0";
    this._listen();
    this._open = true;
  }
  show(at) {
    if (this.model.items.length == 0) {
      this.hide();
      return;
    }
    const { parent } = this;
    if (parent == null) {
      this.hide();
      return;
    }
    this.render();
    const target = parent.el.shadowRoot ?? parent.el;
    target.append(this.el);
    const { style: style2 } = this.el;
    style2.left = px(at.x);
    style2.top = px(at.y);
    this._listen();
    this._open = true;
  }
  hide() {
    if (this._open) {
      this._open = false;
      this._unlisten();
      this.el.remove();
    }
  }
};
__publicField(MenuView, "__name__", "MenuView");
var _Menu = class _Menu extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Menu, "__name__", "Menu");
_Menu.prototype.default_view = MenuView;
_Menu.define(({ Bool: Bool2, List: List2, Ref: Ref2 }) => ({
  items: [List2(Ref2(MenuItem)), []],
  reversed: [Bool2, false]
}));
var Menu = _Menu;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/renderer_group.js
var _RendererGroup = class _RendererGroup extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RendererGroup, "__name__", "RendererGroup");
_RendererGroup.define(({ Bool: Bool2 }) => ({
  visible: [Bool2, true]
}));
var RendererGroup = _RendererGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/renderer.js
var RendererView = class extends StyledElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "visuals");
    __publicField(this, "position", new InlineStyleSheet());
    __publicField(this, "_context_menu", null);
    __publicField(this, "_coordinates");
    __publicField(this, "_custom_coordinates", null);
  }
  rendering_target() {
    return this.plot_view.canvas_view.underlays_el;
  }
  get context_menu() {
    return this._context_menu;
  }
  get coordinates() {
    const { _coordinates } = this;
    if (_coordinates != null) {
      return _coordinates;
    } else {
      return this._coordinates = this._initialize_coordinates();
    }
  }
  set coordinates(custom_coordinates) {
    this._custom_coordinates = custom_coordinates;
  }
  stylesheets() {
    return [...super.stylesheets(), this.position];
  }
  initialize() {
    super.initialize();
    this.visuals = new Visuals(this);
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { context_menu } = this.model;
    if (context_menu != null) {
      this._context_menu = await build_view(context_menu, { parent: this.plot_view });
    }
  }
  remove() {
    var _a34;
    (_a34 = this._context_menu) == null ? void 0 : _a34.remove();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const { group } = this.model;
    if (group != null) {
      this.on_change(group.properties.visible, () => {
        this.model.visible = group.visible;
      });
    }
    const { x_range_name, y_range_name } = this.model.properties;
    this.on_change([x_range_name, y_range_name], () => delete this._coordinates);
    this.connect(this.plot_view.frame.model.change, () => delete this._coordinates);
  }
  _initialize_coordinates() {
    if (this._custom_coordinates != null) {
      return this._custom_coordinates;
    }
    const { coordinates } = this.model;
    const { frame } = this.plot_view;
    if (coordinates != null) {
      return coordinates.get_transform(frame);
    } else {
      const { x_range_name, y_range_name } = this.model;
      const x_scale = frame.x_scales.get(x_range_name);
      const y_scale = frame.y_scales.get(y_range_name);
      assert(x_scale != null, `missing '${x_range_name}' range`);
      assert(y_scale != null, `missing '${y_range_name}' range`);
      return new CoordinateTransform(x_scale, y_scale);
    }
  }
  get plot_view() {
    return this.parent;
  }
  get plot_model() {
    return this.parent.model;
  }
  get layer() {
    const { overlays, primary } = this.canvas;
    return this.model.level == "overlay" ? overlays : primary;
  }
  get canvas() {
    return this.plot_view.canvas_view;
  }
  request_paint() {
    this.plot_view.request_paint(this);
  }
  request_layout() {
    this.plot_view.request_layout();
  }
  notify_finished() {
    this.plot_view.notify_finished();
  }
  notify_finished_after_paint() {
    this.plot_view.notify_finished_after_paint();
  }
  get needs_clip() {
    return false;
  }
  get has_webgl() {
    return false;
  }
  /*
  get visible(): boolean {
    const {visible, group} = this.model
    return !visible ? false : (group?.visible ?? true)
  }
  */
  get displayed() {
    return this.model.visible;
  }
  get is_renderable() {
    return true;
  }
  paint() {
    this.update_geometry();
    this.compute_geometry();
    this.update_position();
    if (this.displayed && this.is_renderable) {
      this._paint();
    }
    this.mark_finished();
  }
  renderer_view(_renderer) {
    return void 0;
  }
  /**
   * Geometry setup that doesn't change between paints.
   */
  update_geometry() {
  }
  /**
   * Geometry setup that changes between paints.
   */
  compute_geometry() {
  }
  /**
   * Updates the position of the associated DOM element.
   */
  update_position() {
    const { bbox, position: position2 } = this;
    if (bbox != null && bbox.is_valid) {
      position2.replace(`
      :host {
        position: absolute;
        left:     ${bbox.left}px;
        top:      ${bbox.top}px;
        width:    ${bbox.width}px;
        height:   ${bbox.height}px;
      }
      `);
    } else {
      position2.replace(`
      :host {
        display: none;
      }
      `);
    }
  }
  resolve_frame() {
    return this.plot_view.frame;
  }
  resolve_canvas() {
    return this.plot_view.canvas;
  }
  resolve_plot() {
    return this.plot_view;
  }
  resolve_symbol(node) {
    const target = this;
    const { bbox } = target;
    if (bbox == null) {
      return { x: NaN, y: NaN };
    } else {
      const value2 = bbox.resolve(node.symbol);
      const { offset: offset3 } = node;
      if (isNumber(value2)) {
        return value2 + offset3;
      } else {
        const { x: x2, y: y2 } = value2;
        return { x: x2 + offset3, y: y2 + offset3 };
      }
    }
  }
  get attribution() {
    return null;
  }
};
__publicField(RendererView, "__name__", "RendererView");
var _Renderer = class _Renderer extends StyledElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Renderer, "__name__", "Renderer");
_Renderer.define(({ Bool: Bool2, Str: Str2, Ref: Ref2, Nullable: Nullable2 }) => ({
  group: [Nullable2(Ref2(RendererGroup)), null],
  level: [RenderLevel, "image"],
  visible: [Bool2, true],
  x_range_name: [Str2, "default"],
  y_range_name: [Str2, "default"],
  coordinates: [Nullable2(Ref2(CoordinateMapping)), null],
  propagate_hover: [Bool2, false],
  context_menu: [Nullable2(Ref2(Menu)), null]
}));
var Renderer = _Renderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/dom_node.js
var DOMNodeView = class extends DOMView {
};
__publicField(DOMNodeView, "__name__", "DOMNodeView");
var DOMNode = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(DOMNode, "__name__", "DOMNode");
__publicField(DOMNode, "__module__", "bokeh.models.dom");

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/composite_renderer.js
var ElementLike = Or(Ref(UIElement), Ref(DOMNode));
var CompositeRendererView = class extends RendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "_renderer_views", /* @__PURE__ */ new Map());
    __publicField(this, "_element_views", /* @__PURE__ */ new Map());
    __publicField(this, "_computed_renderers", []);
    __publicField(this, "_computed_elements", []);
    __publicField(this, "_has_rendered_elements", false);
  }
  get renderer_views() {
    return this.model.renderers.map((renderer) => this._renderer_views.get(renderer));
  }
  get element_views() {
    return this.model.elements.map((element) => this._element_views.get(element));
  }
  *children() {
    yield* super.children();
    yield* this.renderer_views;
    yield* this.element_views;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._build_renderers();
    await this._build_elements();
  }
  get computed_renderers() {
    return [...this.model.renderers, ...this._computed_renderers];
  }
  get computed_renderer_views() {
    return this.computed_renderers.map((item3) => this._renderer_views.get(item3)).filter((rv) => rv != null);
  }
  async _build_renderers() {
    return await build_views(this._renderer_views, this.computed_renderers, { parent: this.plot_view });
  }
  get computed_elements() {
    return [...this.model.elements, ...this._computed_elements];
  }
  get computed_element_views() {
    return this.computed_elements.map((item3) => this._element_views.get(item3)).filter((ev) => ev != null);
  }
  async _build_elements() {
    return await build_views(this._element_views, this.computed_elements, { parent: this.plot_view });
  }
  async _update_renderers() {
    await this._build_renderers();
  }
  async _update_elements() {
    const { created } = await this._build_elements();
    const created_elements = new Set(created);
    for (const element_view of this.element_views) {
      element_view.el.remove();
    }
    for (const element_view of this.element_views) {
      const is_new = created_elements.has(element_view);
      const target = element_view.rendering_target() ?? this.shadow_el;
      if (is_new) {
        element_view.render_to(target);
      } else {
        target.append(element_view.el);
      }
    }
    this.r_after_render();
  }
  remove() {
    remove_views(this._renderer_views);
    remove_views(this._element_views);
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const { renderers, elements } = this.model.properties;
    this.on_change(renderers, async () => {
      await this._update_renderers();
    });
    this.on_change(elements, async () => {
      await this._update_elements();
    });
  }
  paint() {
    if (!this._has_rendered_elements) {
      for (const element_view of this.element_views) {
        const target = element_view.rendering_target() ?? this.shadow_el;
        element_view.render_to(target);
      }
      this._has_rendered_elements = true;
    }
    super.paint();
    if (this.displayed && this.is_renderable) {
      for (const renderer of this.computed_renderer_views) {
        renderer.paint();
      }
    }
    const { displayed } = this;
    for (const element_view of this.element_views) {
      element_view.reposition(displayed);
    }
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    for (const renderer_view of this.renderer_views) {
      if (!renderer_view.has_finished()) {
        return false;
      }
    }
    for (const element_view of this.element_views) {
      if (!element_view.has_finished()) {
        return false;
      }
    }
    return true;
  }
};
__publicField(CompositeRendererView, "__name__", "CompositeRendererView");
var _CompositeRenderer = class _CompositeRenderer extends Renderer {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CompositeRenderer, "__name__", "CompositeRenderer");
_CompositeRenderer.define(({ List: List2, Ref: Ref2 }) => ({
  renderers: [List2(Ref2(Renderer)), []],
  elements: [List2(ElementLike), []]
}));
var CompositeRenderer = _CompositeRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/annotation.js
var AnnotationView = class extends CompositeRendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "layout");
    __publicField(this, "panel");
  }
  get bbox() {
    var _a34;
    return super.bbox ?? ((_a34 = this.layout) == null ? void 0 : _a34.bbox);
  }
  get_size() {
    if (this.displayed) {
      const { width, height } = this._get_size();
      return { width: Math.round(width), height: Math.round(height) };
    } else {
      return { width: 0, height: 0 };
    }
  }
  _get_size() {
    throw new Error("not implemented");
  }
  connect_signals() {
    super.connect_signals();
    const p2 = this.model.properties;
    this.on_change(p2.visible, () => {
      if (this.layout != null) {
        this.layout.visible = this.model.visible;
        this.plot_view.request_layout();
      }
    });
  }
  get needs_clip() {
    return this.layout == null;
  }
};
__publicField(AnnotationView, "__name__", "AnnotationView");
var _Annotation = class _Annotation extends CompositeRenderer {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Annotation, "__name__", "Annotation");
_Annotation.override({
  level: "annotation"
});
var Annotation = _Annotation;

// node_modules/@bokeh/bokehjs/build/js/lib/models/selections/selection.js
var OpaqueIndices = Arrayable(Int);
var MultiIndices = Mapping(Int, OpaqueIndices);
var _Selection = class _Selection extends Model {
  constructor(attrs) {
    super(attrs);
  }
  get_view() {
    return this.view;
  }
  get selected_glyph() {
    return this.selected_glyphs.length > 0 ? this.selected_glyphs[0] : null;
  }
  add_to_selected_glyphs(glyph) {
    this.selected_glyphs.push(glyph);
  }
  update(selection, _final = true, mode = "replace") {
    switch (mode) {
      case "replace": {
        this.update_through_replacement(selection);
        break;
      }
      case "toggle": {
        this.update_through_toggle(selection);
        break;
      }
      case "append": {
        this.update_through_union(selection);
        break;
      }
      case "intersect": {
        this.update_through_intersection(selection);
        break;
      }
      case "subtract": {
        this.update_through_subtraction(selection);
        break;
      }
      case "xor": {
        this.update_through_symmetric_difference(selection);
        break;
      }
    }
  }
  // TODO `size` wouldn't be needed if `indices` was an instance of
  // `Indices` class, instead of an array of numbers. Then also we
  // could just call `.invert()` on the class.
  invert(size2) {
    const indices = new Set(this.indices);
    const inversion = [];
    for (let i2 = 0; i2 < size2; i2++) {
      if (!indices.has(i2)) {
        inversion.push(i2);
      }
    }
    this.indices = inversion;
  }
  clear() {
    this.indices = [];
    this.line_indices = [];
    this.multiline_indices = /* @__PURE__ */ new Map();
    this.image_indices = [];
    this.view = null;
    this.selected_glyphs = [];
  }
  map(mapper) {
    return new _Selection({
      ...this.attributes,
      indices: map(this.indices, mapper),
      // NOTE: line_indices don't support subset indexing
      multiline_indices: new Map(map([...this.multiline_indices.entries()], ([index2, line_indices]) => [mapper(index2), line_indices])),
      image_indices: this.image_indices.map((image_index) => ({ ...image_index, index: mapper(image_index.index) }))
    });
  }
  is_empty() {
    return this.indices.length == 0 && this.line_indices.length == 0 && this.image_indices.length == 0;
  }
  _union_image_indices(...collection) {
    const is = /* @__PURE__ */ new Map();
    const js = /* @__PURE__ */ new Map();
    const result = [];
    for (const indices of collection) {
      for (const image_index of indices) {
        const { index: index2, i: i2, j } = image_index;
        const iis = is.get(index2);
        const ijs = js.get(index2);
        if (iis != null && ijs != null) {
          if (!iis.has(i2) || !ijs.has(j)) {
            result.push(image_index);
            iis.add(i2);
            ijs.add(j);
          }
        } else {
          result.push(image_index);
          is.set(index2, /* @__PURE__ */ new Set([i2]));
          js.set(index2, /* @__PURE__ */ new Set([j]));
        }
      }
    }
    return result;
  }
  update_through_replacement(other) {
    this.indices = other.indices;
    this.line_indices = other.line_indices;
    this.multiline_indices = other.multiline_indices;
    this.image_indices = other.image_indices;
    this.view = other.view;
    this.selected_glyphs = other.selected_glyphs;
  }
  update_through_toggle(other) {
    this.indices = difference(other.indices, this.indices);
    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);
    this.line_indices = union(other.line_indices, this.line_indices);
    this.image_indices = this._union_image_indices(this.image_indices, other.image_indices);
    this.view = other.view;
    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);
  }
  update_through_union(other) {
    this.indices = union(this.indices, other.indices);
    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);
    this.line_indices = union(other.line_indices, this.line_indices);
    this.image_indices = this._union_image_indices(this.image_indices, other.image_indices);
    this.view = other.view;
    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);
  }
  update_through_intersection(other) {
    this.indices = intersection(this.indices, other.indices);
    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);
    this.line_indices = union(other.line_indices, this.line_indices);
    this.image_indices = this._union_image_indices(this.image_indices, other.image_indices);
    this.view = other.view;
    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);
  }
  update_through_subtraction(other) {
    this.indices = difference(this.indices, other.indices);
    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);
    this.line_indices = union(other.line_indices, this.line_indices);
    this.image_indices = this._union_image_indices(this.image_indices, other.image_indices);
    this.view = other.view;
    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);
  }
  update_through_symmetric_difference(other) {
    this.indices = symmetric_difference(this.indices, other.indices);
    this.selected_glyphs = union(other.selected_glyphs, this.selected_glyphs);
    this.line_indices = union(other.line_indices, this.line_indices);
    this.image_indices = this._union_image_indices(this.image_indices, other.image_indices);
    this.view = other.view;
    this.multiline_indices = merge(other.multiline_indices, this.multiline_indices);
  }
};
__publicField(_Selection, "__name__", "Selection");
_Selection.define(({ Int: Int2, List: List2, Struct: Struct2 }) => ({
  indices: [OpaqueIndices, []],
  line_indices: [OpaqueIndices, []],
  multiline_indices: [MultiIndices, /* @__PURE__ */ new Map()],
  image_indices: [List2(Struct2({ index: Int2, i: Int2, j: Int2, flat_index: Int2 })), []]
}));
_Selection.internal(({ List: List2, AnyRef: AnyRef2, Nullable: Nullable2 }) => ({
  selected_glyphs: [List2(AnyRef2()), []],
  view: [Nullable2(AnyRef2()), null]
}));
var Selection = _Selection;

// node_modules/@bokeh/bokehjs/build/js/lib/core/selection_manager.js
function is_GlyphRendererView(renderer_view) {
  return renderer_view.model.type == "GlyphRenderer";
}
function is_GraphRendererView(renderer_view) {
  return renderer_view.model.type == "GraphRenderer";
}
var SelectionManager = class {
  constructor(source2) {
    __publicField(this, "source");
    __publicField(this, "inspectors", /* @__PURE__ */ new Map());
    this.source = source2;
  }
  select(renderer_views, geometry, final, mode = "replace") {
    const glyph_renderer_views = [];
    const graph_renderer_views = [];
    for (const r of renderer_views) {
      if (is_GlyphRendererView(r)) {
        glyph_renderer_views.push(r);
      } else if (is_GraphRendererView(r)) {
        graph_renderer_views.push(r);
      }
    }
    let did_hit = false;
    for (const r of graph_renderer_views) {
      const hit_test_result = r.model.selection_policy.hit_test(geometry, r);
      did_hit = did_hit || r.model.selection_policy.do_selection(hit_test_result, r.model, final, mode);
    }
    if (glyph_renderer_views.length > 0) {
      const hit_test_result = this.source.selection_policy.hit_test(geometry, glyph_renderer_views);
      did_hit = did_hit || this.source.selection_policy.do_selection(hit_test_result, this.source, final, mode);
    }
    return did_hit;
  }
  inspect(renderer_view, geometry) {
    let did_hit = false;
    if (is_GlyphRendererView(renderer_view)) {
      const hit_test_result = renderer_view.hit_test(geometry);
      if (hit_test_result != null) {
        did_hit = !hit_test_result.is_empty();
        const inspection = this.get_or_create_inspector(renderer_view.model);
        inspection.update(hit_test_result, true, "replace");
        this.source.setv({ inspected: inspection }, { silent: true });
        this.source.inspect.emit([renderer_view.model, { geometry }]);
      }
    } else if (is_GraphRendererView(renderer_view)) {
      const hit_test_result = renderer_view.model.inspection_policy.hit_test(geometry, renderer_view);
      did_hit = renderer_view.model.inspection_policy.do_inspection(hit_test_result, geometry, renderer_view, false, "replace");
    }
    return did_hit;
  }
  invert(rview) {
    const n2 = this.source.get_length();
    if (n2 == null) {
      return;
    }
    this.source.selected.invert(n2);
    if (rview != null) {
      this.get_or_create_inspector(rview.model).invert(n2);
    }
  }
  clear(rview) {
    this.source.selected.clear();
    if (rview != null) {
      this.get_or_create_inspector(rview.model).clear();
    }
  }
  get_or_create_inspector(renderer) {
    let selection = this.inspectors.get(renderer);
    if (selection == null) {
      selection = new Selection();
      this.inspectors.set(renderer, selection);
    }
    return selection;
  }
};
__publicField(SelectionManager, "__name__", "SelectionManager");

// node_modules/@bokeh/bokehjs/build/js/lib/models/selections/interaction_policy.js
var SelectionPolicy = class extends Model {
  do_selection(hit_test_result, source2, final, mode) {
    if (hit_test_result == null) {
      return false;
    } else {
      source2.selected.update(hit_test_result, final, mode);
      source2._select.emit();
      return !source2.selected.is_empty();
    }
  }
};
__publicField(SelectionPolicy, "__name__", "SelectionPolicy");
var IntersectRenderers = class extends SelectionPolicy {
  hit_test(geometry, renderer_views) {
    const hit_test_result_renderers = [];
    for (const r of renderer_views) {
      const result = r.hit_test(geometry);
      if (result != null) {
        hit_test_result_renderers.push(result);
      }
    }
    if (hit_test_result_renderers.length > 0) {
      const hit_test_result = hit_test_result_renderers[0];
      for (const hit_test_result_other of hit_test_result_renderers) {
        hit_test_result.update_through_intersection(hit_test_result_other);
      }
      return hit_test_result;
    } else {
      return null;
    }
  }
};
__publicField(IntersectRenderers, "__name__", "IntersectRenderers");
var UnionRenderers = class extends SelectionPolicy {
  hit_test(geometry, renderer_views) {
    const hit_test_result_renderers = [];
    for (const r of renderer_views) {
      const result = r.hit_test(geometry);
      if (result != null) {
        hit_test_result_renderers.push(result);
      }
    }
    if (hit_test_result_renderers.length > 0) {
      const hit_test_result = hit_test_result_renderers[0];
      for (const hit_test_result_other of hit_test_result_renderers) {
        hit_test_result.update_through_union(hit_test_result_other);
      }
      return hit_test_result;
    } else {
      return null;
    }
  }
};
__publicField(UnionRenderers, "__name__", "UnionRenderers");

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/data_source.js
var _DataSource = class _DataSource extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DataSource, "__name__", "DataSource");
_DataSource.define(({ Ref: Ref2 }) => ({
  selected: [Ref2(Selection), () => new Selection(), { readonly: true }]
}));
var DataSource = _DataSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/columnar_data_source.js
var _ColumnarDataSource = class _ColumnarDataSource extends DataSource {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_select");
    __publicField(this, "inspect");
    __publicField(this, "selection_manager", new SelectionManager(this));
  }
  get_array(key) {
    const data3 = dict(this.data);
    let column = data3.get(key);
    if (column == null) {
      data3.set(key, column = []);
    } else if (!isArray(column)) {
      data3.set(key, column = Array.from(column));
    }
    return column;
  }
  initialize() {
    super.initialize();
    this._select = new Signal0(this, "select");
    this.inspect = new Signal(this, "inspect");
  }
  get inferred_defaults() {
    const defaults3 = /* @__PURE__ */ new Map();
    for (const [name, array2] of entries(this.data)) {
      const value2 = (() => {
        if (is_NDArray(array2)) {
          switch (array2.dtype) {
            case "bool":
              return false;
            case "uint8":
            case "int8":
            case "uint16":
            case "int16":
            case "uint32":
            case "int32":
            case "float32":
            case "float64":
              return 0;
            case "object":
              return null;
          }
        } else if (isArray(array2) && array2.length != 0) {
          const [item3] = array2;
          if (item3 === null) {
            return null;
          } else if (isBoolean(item3)) {
            return false;
          } else if (isNumber(item3)) {
            return 0;
          } else if (isString(item3)) {
            return "";
          } else if (isArray(item3)) {
            return [];
          }
        }
        return void 0;
      })();
      if (value2 !== void 0) {
        defaults3.set(name, value2);
      }
    }
    return defaults3;
  }
  get(name) {
    const column = this.get_column(name);
    assert(column != null, `unknown column '${name}' in ${this}`);
    return column;
  }
  set(name, column) {
    dict(this.data).set(name, column);
  }
  get_column(name) {
    const data3 = dict(this.data);
    return data3.get(name) ?? null;
  }
  columns() {
    return keys(this.data);
  }
  get_length(soft = true) {
    const lengths = uniq(values(this.data).map((v) => is_NDArray(v) ? v.shape[0] : v.length));
    switch (lengths.length) {
      case 0: {
        return null;
      }
      case 1: {
        return lengths[0];
      }
      default: {
        const msg = "data source has columns of inconsistent lengths";
        if (soft) {
          logger.warn(msg);
          return lengths.sort()[0];
        } else {
          throw new Error(msg);
        }
      }
    }
  }
  get length() {
    return this.get_length() ?? 0;
  }
  clear() {
    const data3 = clone(this.data);
    const proxy = dict(data3);
    for (const [name, column] of proxy) {
      const empty3 = new column.constructor(0);
      proxy.set(name, empty3);
    }
    this.data = data3;
  }
  stream(new_data, rollover, { sync } = {}) {
    this.stream_to(this.properties.data, new_data, rollover, { sync });
  }
  patch(patches, { sync } = {}) {
    this.patch_to(this.properties.data, patches, { sync });
  }
};
__publicField(_ColumnarDataSource, "__name__", "ColumnarDataSource");
_ColumnarDataSource.define(({ Ref: Ref2, Dict: Dict2, Unknown: Unknown2 }) => ({
  default_values: [Dict2(Unknown2), {}],
  selection_policy: [Ref2(SelectionPolicy), () => new UnionRenderers()]
}));
_ColumnarDataSource.internal(({ AnyRef: AnyRef2 }) => ({
  inspected: [AnyRef2(), () => new Selection()]
}));
var ColumnarDataSource = _ColumnarDataSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/column_data_source.js
var _ColumnDataSource = class _ColumnDataSource extends ColumnarDataSource {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ColumnDataSource, "__name__", "ColumnDataSource");
_ColumnDataSource.define(({ Unknown: Unknown2, Dict: Dict2, Arrayable: Arrayable2 }) => ({
  data: [Dict2(Arrayable2(Unknown2)), {}]
}));
var ColumnDataSource = _ColumnDataSource;

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var i2 = 1; i2 <= 60; ++i2) {
    defs2("EPSG:" + (32600 + i2), "+proj=utm +zone=" + i2 + " +datum=WGS84 +units=m");
    defs2("EPSG:" + (32700 + i2), "+proj=utm +zone=" + i2 + " +south +datum=WGS84 +units=m");
  }
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;

// node_modules/proj4/lib/constants/PrimeMeridian.js
var exports2 = {};
exports2.greenwich = 0;
exports2.lisbon = -9.131906111111;
exports2.paris = 2.337229166667;
exports2.bogota = -74.080916666667;
exports2.madrid = -3.687938888889;
exports2.rome = 12.452333333333;
exports2.bern = 7.439583333333;
exports2.jakarta = 106.807719444444;
exports2.ferro = -17.666666666667;
exports2.brussels = 4.367975;
exports2.stockholm = 18.058277777778;
exports2.athens = 23.7163375;
exports2.oslo = 10.722916666667;

// node_modules/proj4/lib/constants/units.js
var units_default = {
  "mm": { to_meter: 1e-3 },
  "cm": { to_meter: 0.01 },
  "ft": { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  "fath": { to_meter: 1.8288 },
  "kmi": { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  "km": { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  "mi": { to_meter: 1609.344 },
  "yd": { to_meter: 0.9144 },
  "ch": { to_meter: 20.1168 },
  "link": { to_meter: 0.201168 },
  "dm": { to_meter: 0.01 },
  "in": { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};

// node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys2 = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i2 = -1;
  var testkey, processedKey;
  while (++i2 < keys2.length) {
    testkey = keys2[i2];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a2) {
    return a2;
  }).reduce(function(p2, a2) {
    var split2 = a2.split("=");
    split2.push(true);
    p2[split2[0].toLowerCase()] = split2[1];
    return p2;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v) {
      self2.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self2.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self2.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self2.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self2.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self2.long0 = v * D2R;
    },
    lon_1: function(v) {
      self2.long1 = v * D2R;
    },
    lon_2: function(v) {
      self2.long2 = v * D2R;
    },
    alpha: function(v) {
      self2.alpha = parseFloat(v) * D2R;
    },
    gamma: function(v) {
      self2.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self2.longc = v * D2R;
    },
    x_0: function(v) {
      self2.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self2.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self2.k0 = parseFloat(v);
    },
    k: function(v) {
      self2.k0 = parseFloat(v);
    },
    a: function(v) {
      self2.a = parseFloat(v);
    },
    b: function(v) {
      self2.b = parseFloat(v);
    },
    r: function(v) {
      self2.a = self2.b = parseFloat(v);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v) {
      self2.zone = parseInt(v, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v) {
      self2.datum_params = v.split(",").map(function(a2) {
        return parseFloat(a2);
      });
    },
    to_meter: function(v) {
      self2.to_meter = parseFloat(v);
    },
    units: function(v) {
      self2.units = v;
      var unit = match(units_default, v);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self2.from_greenwich = v * D2R;
    },
    pm: function(v) {
      var pm = match(exports2, v);
      self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self2.axis = v;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}

// node_modules/wkt-parser/parser.js
var parser_default = parseString;
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser(text2) {
  if (typeof text2 !== "string") {
    throw new Error("not a string");
  }
  this.text = text2.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

// node_modules/wkt-parser/process.js
function mapit(obj, key, value2) {
  if (Array.isArray(key)) {
    value2.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value2.reduce(function(newObj, item3) {
    sExpr(item3, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === "PARAMETER") {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i2;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      v[0] = ["name", v[0]];
      mapit(obj, key, v);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      v[0] = ["name", v[0]];
      mapit(obj, key, v);
      obj[key].type = key;
      return;
    default:
      i2 = -1;
      while (++i2 < v.length) {
        if (!Array.isArray(v[i2])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}

// node_modules/wkt-parser/index.js
var D2R2 = 0.017453292519943295;
var knownTypes = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}
function d2r(input12) {
  return input12 * D2R2;
}
function cleanWKT(wkt) {
  var keys2 = Object.keys(wkt);
  for (var i2 = 0, ii = keys2.length; i2 < ii; ++i2) {
    var key = keys2[i2];
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (typeof wkt[key] === "object") {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ":" + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i2 = 0, ii = wkt.AXIS.length; i2 < ii; ++i2) {
      var axis = [wkt.AXIS[i2][0].toLowerCase(), wkt.AXIS[i2][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode === "belge_1972") {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  function toMeter(input12) {
    var ratio = wkt.to_meter || 1;
    return input12 * ratio;
  }
  var renamer = function(a2) {
    return rename(wkt, a2);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === "Albers_Conic_Equal_Area" || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === "Stereographic_South_Pole" || wkt.projName === "Polar Stereographic (variant B)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === "Polar_Stereographic") {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
  }
}
function wkt_parser_default(wkt) {
  var lisp = parser_default(wkt);
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projString_default(arguments[1]);
      } else {
        defs[name] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        } else {
          defs(v);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
global_default(defs);
var defs_default = defs;

// node_modules/proj4/lib/parseCode.js
function testObj(code2) {
  return typeof code2 === "string";
}
function testDef(code2) {
  return code2 in defs_default;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code2) {
  return codeWords.some(function(word) {
    return code2.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item3) {
  var auth = match(item3, "authority");
  if (!auth) {
    return;
  }
  var code2 = match(auth, "epsg");
  return code2 && codes.indexOf(code2) > -1;
}
function checkProjStr(item3) {
  var ext = match(item3, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code2) {
  return code2[0] === "+";
}
function parse(code2) {
  if (testObj(code2)) {
    if (testDef(code2)) {
      return defs_default[code2];
    }
    if (testWKT(code2)) {
      var out = wkt_parser_default(code2);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code2)) {
      return projString_default(code2);
    }
  } else {
    return code2;
  }
}
var parseCode_default = parse;

// node_modules/proj4/lib/extend.js
function extend_default(destination, source2) {
  destination = destination || {};
  var value2, property;
  if (!source2) {
    return destination;
  }
  for (property in source2) {
    value2 = source2[property];
    if (value2 !== void 0) {
      destination[property] = value2;
    }
  }
  return destination;
}

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}

// node_modules/proj4/lib/common/sign.js
function sign_default(x2) {
  return x2 < 0 ? -1 : 1;
}

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x2) {
  return Math.abs(x2) <= SPI ? x2 : x2 - sign_default(x2) * TWO_PI;
}

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i2 = 0; i2 <= 15; i2++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}

// node_modules/proj4/lib/projections/merc.js
function init2() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p2) {
  var lon = p2.x;
  var lat = p2.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x2, y2;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x2 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x2 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y2 = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p2.x = x2;
    p2.y = y2;
    return p2;
  }
}
function inverse(p2) {
  var x2 = p2.x - this.x0;
  var y2 = p2.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y2 / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y2 / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x2 / (this.a * this.k0));
  p2.x = lon;
  p2.y = lat;
  return p2;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
var merc_default = {
  init: init2,
  forward,
  inverse,
  names
};

// node_modules/proj4/lib/projections/longlat.js
function init3() {
}
function identity(pt) {
  return pt;
}
var names2 = ["longlat", "identity"];
var longlat_default = {
  init: init3,
  forward: identity,
  inverse: identity,
  names: names2
};

// node_modules/proj4/lib/projections.js
var projs = [merc_default, longlat_default];
var names3 = {};
var projStore = [];
function add(proj, i2) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i2);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n2) {
    names3[n2.toLowerCase()] = len;
  });
  return this;
}
function get(name) {
  if (!name) {
    return false;
  }
  var n2 = name.toLowerCase();
  if (typeof names3[n2] !== "undefined" && projStore[names3[n2]]) {
    return projStore[names3[n2]];
  }
}
function start() {
  projs.forEach(add);
}
var projections_default = {
  start,
  add,
  get
};

// node_modules/proj4/lib/constants/Ellipsoid.js
var exports3 = {};
exports3.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports3.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports3.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports3.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports3.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports3.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports3.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports3.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports3.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports3.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports3.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports3.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports3.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports3.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports3.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports3.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
exports3.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports3.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports3.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports3.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports3.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports3.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports3.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports3.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports3.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports3.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports3.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports3.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports3.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports3.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports3.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports3.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports3.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports3.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports3.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports3.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports3.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports3.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports3.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports3.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports3.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports3.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports3.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports3.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a2, b2, rf, R_A) {
  var a22 = a2 * a2;
  var b22 = b2 * b2;
  var es = (a22 - b22) / a22;
  var e = 0;
  if (R_A) {
    a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a22 = a2 * a2;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a22 - b22) / b22;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a2, b2, rf, ellps, sphere2) {
  if (!a2) {
    var ellipse = match(exports3, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a2 = ellipse.a;
    b2 = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b2) {
    b2 = (1 - 1 / rf) * a2;
  }
  if (rf === 0 || Math.abs(a2 - b2) < EPSLN) {
    sphere2 = true;
    b2 = a2;
  }
  return {
    a: a2,
    b: b2,
    rf,
    sphere: sphere2
  };
}

// node_modules/proj4/lib/constants/Datum.js
var datums = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  }
};
for (key in datums) {
  datum2 = datums[key];
  datums[datum2.datumName] = datum2;
}
var datum2;
var key;
var Datum_default = datums;

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a2, b2, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a2;
  out.b = b2;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default = datum;

// node_modules/proj4/lib/nadgrid.js
var loadedNadgrids = {};
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value2) {
  if (value2.length === 0) {
    return null;
  }
  var optional = value2[0] === "@";
  if (optional) {
    value2 = value2.slice(1);
  }
  if (value2 === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value2,
    mandatory: !optional,
    grid: loadedNadgrids[value2] || null,
    isNull: false
  };
}

// node_modules/proj4/lib/Proj.js
function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parseCode_default(srsCode);
  if (typeof json !== "object") {
    callback("Could not parse to valid json: " + srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if (!ourProj) {
    callback("Could not get projection name from: " + srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(Datum_default, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum_default(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection.projections = projections_default;
Projection.projections.start();
var Proj_default = Projection;

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source2, dest) {
  if (source2.datum_type !== dest.datum_type) {
    return false;
  } else if (source2.a !== dest.a || Math.abs(source2.es - dest.es) > 5e-11) {
    return false;
  } else if (source2.datum_type === PJD_3PARAM) {
    return source2.datum_params[0] === dest.datum_params[0] && source2.datum_params[1] === dest.datum_params[1] && source2.datum_params[2] === dest.datum_params[2];
  } else if (source2.datum_type === PJD_7PARAM) {
    return source2.datum_params[0] === dest.datum_params[0] && source2.datum_params[1] === dest.datum_params[1] && source2.datum_params[2] === dest.datum_params[2] && source2.datum_params[3] === dest.datum_params[3] && source2.datum_params[4] === dest.datum_params[4] && source2.datum_params[5] === dest.datum_params[5] && source2.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p2, es, a2) {
  var Longitude = p2.x;
  var Latitude = p2.y;
  var Height = p2.z ? p2.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p2.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p2.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p2, es, a2, b2) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p2.x;
  var Y = p2.y;
  var Z = p2.z ? p2.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);
  if (P / a2 < genau) {
    Longitude = 0;
    if (RR / a2 < genau) {
      Latitude = HALF_PI;
      Height = -b2;
      return {
        x: p2.x,
        y: p2.y,
        z: p2.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x + datum_params[0],
      y: p2.y + datum_params[1],
      z: p2.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p2.x - Rz_BF * p2.y + Ry_BF * p2.z) + Dx_BF,
      y: M_BF * (Rz_BF * p2.x + p2.y - Rx_BF * p2.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p2.x + Rx_BF * p2.y + p2.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p2, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p2.x - datum_params[0],
      y: p2.y - datum_params[1],
      z: p2.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p2.x - Dx_BF) / M_BF;
    var y_tmp = (p2.y - Dy_BF) / M_BF;
    var z_tmp = (p2.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source2, dest, point) {
  if (compareDatums(source2, dest)) {
    return point;
  }
  if (source2.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source2.a;
  var source_es = source2.es;
  if (source2.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source2, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source2.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source2.datum_type)) {
    point = geocentricToWgs84(point, source2.datum_type, source2.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source2, inverse2, point) {
  if (source2.grids === null || source2.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input12 = { x: -point.x, y: point.y };
  var output2 = { x: Number.NaN, y: Number.NaN };
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  outer:
    for (var i2 = 0; i2 < source2.grids.length; i2++) {
      var grid = source2.grids[i2];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output2 = input12;
        break;
      }
      onlyMandatoryGrids = grid.mandatory;
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrids = grid.grid.subgrids;
      for (var j = 0, jj = subgrids.length; j < jj; j++) {
        var subgrid = subgrids[j];
        var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
        var minX = subgrid.ll[0] - epsilon;
        var minY = subgrid.ll[1] - epsilon;
        var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
        var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
        if (minY > input12.y || minX > input12.x || maxY < input12.y || maxX < input12.x) {
          continue;
        }
        output2 = applySubgridShift(input12, inverse2, subgrid);
        if (!isNaN(output2.x)) {
          break outer;
        }
      }
    }
  if (isNaN(output2.x)) {
    console.log("Failed to find a grid shift table for location '" + -input12.x * R2D + " " + input12.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output2.x;
  point.y = output2.y;
  return 0;
}
function applySubgridShift(pin2, inverse2, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin2.x)) {
    return val;
  }
  var tb = { x: pin2.x, y: pin2.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse2) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i2 = 9, tol2 = 1e-12;
    var dif, del2;
    do {
      del2 = nadInterpolate(t, ct);
      if (isNaN(del2.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del2.x + t.x), y: tb.y - (del2.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i2-- && Math.abs(dif.x) > tol2 && Math.abs(dif.y) > tol2);
    if (i2 < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin2.x + t.x;
      val.y = pin2.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin2, ct) {
  var t = { x: pin2.x / ct.del[0], y: pin2.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v, t, i2;
  var out = {};
  for (i2 = 0; i2 < 3; i2++) {
    if (denorm && i2 === 2 && point.z === void 0) {
      continue;
    }
    if (i2 === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i2]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i2 === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i2]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v = zin;
      t = "z";
    }
    switch (crs.axis[i2]) {
      case "e":
        out[t] = v;
        break;
      case "w":
        out[t] = -v;
        break;
      case "n":
        out[t] = v;
        break;
      case "s":
        out[t] = -v;
        break;
      case "u":
        if (point[t] !== void 0) {
          out.z = v;
        }
        break;
      case "d":
        if (point[t] !== void 0) {
          out.z = -v;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array2) {
  var out = {
    x: array2[0],
    y: array2[1]
  };
  if (array2.length > 2) {
    out.z = array2[2];
  }
  if (array2.length > 3) {
    out.m = array2[3];
  }
  return out;
}

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}

// node_modules/proj4/lib/transform.js
function checkNotWGS(source2, dest) {
  return (source2.datum.datum_type === PJD_3PARAM || source2.datum.datum_type === PJD_7PARAM || source2.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source2.datumCode !== "WGS84";
}
function transform(source2, dest, point, enforceAxis) {
  var wgs843;
  if (Array.isArray(point)) {
    point = toPoint_default(point);
  } else {
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== void 0;
  checkSanity_default(point);
  if (source2.datum && dest.datum && checkNotWGS(source2, dest)) {
    wgs843 = new Proj_default("WGS84");
    point = transform(source2, wgs843, point, enforceAxis);
    source2 = wgs843;
  }
  if (enforceAxis && source2.axis !== "enu") {
    point = adjust_axis_default(source2, false, point);
  }
  if (source2.projName === "longlat") {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source2.to_meter) {
      point = {
        x: point.x * source2.to_meter,
        y: point.y * source2.to_meter,
        z: point.z || 0
      };
    }
    point = source2.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source2.from_greenwich) {
    point.x += source2.from_greenwich;
  }
  point = datum_transform_default(source2.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}

// node_modules/proj4/lib/core.js
var wgs84 = Proj_default("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys2;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.slice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys2 = Object.keys(coords);
    if (keys2.length === 2) {
      return out;
    }
    keys2.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item3) {
  if (item3 instanceof Proj_default) {
    return item3;
  }
  if (item3.oProj) {
    return item3.oProj;
  }
  return Proj_default(item3);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var core_default = proj4;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/projections.js
var mercator = new Proj_default("GOOGLE");
var wgs842 = new Proj_default("WGS84");
var _wgs84_mercator = core_default(wgs842, mercator);
var wgs84_mercator = {
  compute(x2, y2) {
    if (isFinite(x2) && isFinite(y2)) {
      return _wgs84_mercator.forward([x2, y2]);
    } else {
      return [NaN, NaN];
    }
  },
  invert(merc_x, merc_y) {
    if (isFinite(merc_x) && isFinite(merc_y)) {
      return _wgs84_mercator.inverse([merc_x, merc_y]);
    } else {
      return [NaN, NaN];
    }
  }
};
var mercator_bounds = {
  lon: [-2002637639e-2, 2002637639e-2],
  lat: [-200489661e-1, 200489661e-1]
};
var latlon_bounds = {
  lon: [-180, 180],
  lat: [-85.06, 85.06]
};
var { min: min3, max: max4 } = Math;
function clip_mercator(low, high, dimension) {
  const [vmin, vmax] = mercator_bounds[dimension];
  return [max4(low, vmin), min3(high, vmax)];
}
function in_bounds(value2, dimension) {
  const [min10, max18] = latlon_bounds[dimension];
  return min10 < value2 && value2 < max18;
}
var inplace;
(function(inplace2) {
  function project_xy2(x2, y2, merc_x, merc_y) {
    const n2 = min3(x2.length, y2.length);
    merc_x = merc_x ?? x2;
    merc_y = merc_y ?? y2;
    for (let i2 = 0; i2 < n2; i2++) {
      const xi = x2[i2];
      const yi = y2[i2];
      const [merc_xi, merc_yi] = wgs84_mercator.compute(xi, yi);
      merc_x[i2] = merc_xi;
      merc_y[i2] = merc_yi;
    }
  }
  inplace2.project_xy = project_xy2;
  function project_xsys(xs, ys, merc_xs, merc_ys) {
    const n2 = min3(xs.length, ys.length);
    merc_xs = merc_xs ?? xs;
    merc_ys = merc_ys ?? ys;
    for (let i2 = 0; i2 < n2; i2++) {
      project_xy2(xs[i2], ys[i2], merc_xs[i2], merc_ys[i2]);
    }
  }
  inplace2.project_xsys = project_xsys;
})(inplace || (inplace = {}));
function project_xy(x2, y2) {
  const n2 = min3(x2.length, y2.length);
  const ArrayType = infer_type(x2, y2);
  const merc_x = new ArrayType(n2);
  const merc_y = new ArrayType(n2);
  inplace.project_xy(x2, y2, merc_x, merc_y);
  return [merc_x, merc_y];
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/data_annotation.js
var DataAnnotationView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_initial_set_data", false);
  }
  connect_signals() {
    super.connect_signals();
    const update = () => {
      this.set_data(this.model.source);
      this._rerender();
    };
    this.connect(this.model.change, update);
    this.connect(this.model.source.streaming, update);
    this.connect(this.model.source.patching, update);
    this.connect(this.model.source.change, update);
  }
  _rerender() {
    this.request_paint();
  }
  set_data(source2) {
    const self2 = this;
    for (const prop of this.model) {
      if (!(prop instanceof VectorSpec || prop instanceof ScalarSpec)) {
        continue;
      }
      if (prop instanceof BaseCoordinateSpec) {
        const array2 = prop.array(source2);
        self2[`_${prop.attr}`] = array2;
      } else {
        const uniform = prop.uniform(source2);
        self2[`${prop.attr}`] = uniform;
      }
    }
    if (this.plot_model.use_map) {
      if (self2._x != null) {
        inplace.project_xy(self2._x, self2._y);
      }
      if (self2._xs != null) {
        inplace.project_xsys(self2._xs, self2._ys);
      }
    }
    for (const visual of this.visuals) {
      visual.update();
    }
  }
  _paint() {
    if (!this._initial_set_data) {
      this.set_data(this.model.source);
      this._initial_set_data = true;
    }
    this.map_data();
    this._paint_data(this.layer.ctx);
  }
};
__publicField(DataAnnotationView, "__name__", "DataAnnotationView");
var _DataAnnotation = class _DataAnnotation extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DataAnnotation, "__name__", "DataAnnotation");
_DataAnnotation.define(({ Ref: Ref2 }) => ({
  source: [Ref2(ColumnarDataSource), () => new ColumnDataSource()]
}));
var DataAnnotation = _DataAnnotation;

// node_modules/@bokeh/bokehjs/build/js/lib/models/graphics/marking.js
var MarkingView = class extends DOMComponentView {
  constructor() {
    super(...arguments);
    __publicField(this, "visuals");
    __publicField(this, "size");
  }
  initialize() {
    super.initialize();
    this.visuals = new Visuals(this);
  }
  request_paint() {
    this.parent.request_paint();
  }
  get canvas() {
    return this.parent.canvas;
  }
  set_data(source2, indices) {
    const self2 = this;
    for (const prop of this.model) {
      if (!(prop instanceof VectorSpec || prop instanceof ScalarSpec)) {
        continue;
      }
      const uniform = prop.uniform(source2).select(indices);
      self2[`${prop.attr}`] = uniform;
    }
  }
};
__publicField(MarkingView, "__name__", "MarkingView");
var _Marking = class _Marking extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Marking, "__name__", "Marking");
_Marking.define(({}) => ({}));
var Marking = _Marking;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/arrow_head.js
var ArrowHeadView = class extends MarkingView {
};
__publicField(ArrowHeadView, "__name__", "ArrowHeadView");
var _ArrowHead = class _ArrowHead extends Marking {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ArrowHead, "__name__", "ArrowHead");
_ArrowHead.define(() => ({
  size: [NumberSpec, 25]
}));
var ArrowHead = _ArrowHead;
var OpenHeadView = class extends ArrowHeadView {
  clip(ctx, i2) {
    this.visuals.line.set_vectorize(ctx, i2);
    const size_i = this.size.get(i2);
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, size_i);
    ctx.lineTo(0, 0);
    ctx.lineTo(0.5 * size_i, size_i);
  }
  paint(ctx, i2) {
    const size_i = this.size.get(i2);
    ctx.beginPath();
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0, 0);
    ctx.lineTo(-0.5 * size_i, size_i);
    this.visuals.line.apply(ctx, i2);
  }
};
__publicField(OpenHeadView, "__name__", "OpenHeadView");
var _OpenHead = class _OpenHead extends ArrowHead {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_OpenHead, "__name__", "OpenHead");
_OpenHead.prototype.default_view = OpenHeadView;
_OpenHead.mixins(LineVector);
var OpenHead = _OpenHead;
var NormalHeadView = class extends ArrowHeadView {
  clip(ctx, i2) {
    this.visuals.line.set_vectorize(ctx, i2);
    const size_i = this.size.get(i2);
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, size_i);
    ctx.lineTo(0.5 * size_i, size_i);
  }
  paint(ctx, i2) {
    const size_i = this.size.get(i2);
    ctx.beginPath();
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0, 0);
    ctx.lineTo(-0.5 * size_i, size_i);
    ctx.closePath();
    this.visuals.fill.apply(ctx, i2);
    this.visuals.line.apply(ctx, i2);
  }
};
__publicField(NormalHeadView, "__name__", "NormalHeadView");
var _NormalHead = class _NormalHead extends ArrowHead {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_NormalHead, "__name__", "NormalHead");
_NormalHead.prototype.default_view = NormalHeadView;
_NormalHead.mixins([LineVector, FillVector]);
_NormalHead.override({
  fill_color: "black"
});
var NormalHead = _NormalHead;
var VeeHeadView = class extends ArrowHeadView {
  clip(ctx, i2) {
    this.visuals.line.set_vectorize(ctx, i2);
    const size_i = this.size.get(i2);
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, -2);
    ctx.lineTo(-0.5 * size_i, size_i);
    ctx.lineTo(0, 0.5 * size_i);
    ctx.lineTo(0.5 * size_i, size_i);
  }
  paint(ctx, i2) {
    const size_i = this.size.get(i2);
    ctx.beginPath();
    ctx.moveTo(0.5 * size_i, size_i);
    ctx.lineTo(0, 0);
    ctx.lineTo(-0.5 * size_i, size_i);
    ctx.lineTo(0, 0.5 * size_i);
    ctx.closePath();
    this.visuals.fill.apply(ctx, i2);
    this.visuals.line.apply(ctx, i2);
  }
};
__publicField(VeeHeadView, "__name__", "VeeHeadView");
var _VeeHead = class _VeeHead extends ArrowHead {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VeeHead, "__name__", "VeeHead");
_VeeHead.prototype.default_view = VeeHeadView;
_VeeHead.mixins([LineVector, FillVector]);
_VeeHead.override({
  fill_color: "black"
});
var VeeHead = _VeeHead;
var TeeHeadView = class extends ArrowHeadView {
  paint(ctx, i2) {
    const size_i = this.size.get(i2);
    ctx.beginPath();
    ctx.moveTo(0.5 * size_i, 0);
    ctx.lineTo(-0.5 * size_i, 0);
    this.visuals.line.apply(ctx, i2);
  }
  clip(_ctx, _i) {
  }
};
__publicField(TeeHeadView, "__name__", "TeeHeadView");
var _TeeHead = class _TeeHead extends ArrowHead {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TeeHead, "__name__", "TeeHead");
_TeeHead.prototype.default_view = TeeHeadView;
_TeeHead.mixins(LineVector);
var TeeHead = _TeeHead;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/arrow.js
var ArrowView = class extends DataAnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "start");
    __publicField(this, "end");
    __publicField(this, "_x_start");
    __publicField(this, "_y_start");
    __publicField(this, "_x_end");
    __publicField(this, "_y_end");
    __publicField(this, "_sx_start");
    __publicField(this, "_sy_start");
    __publicField(this, "_sx_end");
    __publicField(this, "_sy_end");
    __publicField(this, "_angles");
  }
  *children() {
    yield* super.children();
    const { start: start2, end } = this;
    if (start2 != null) {
      yield start2;
    }
    if (end != null) {
      yield end;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { start: start2, end } = this.model;
    if (start2 != null) {
      this.start = await build_view(start2, { parent: this });
    }
    if (end != null) {
      this.end = await build_view(end, { parent: this });
    }
  }
  set_data(source2) {
    var _a34, _b4;
    super.set_data(source2);
    const indices = BitSet.all_set(this._x_start.length);
    (_a34 = this.start) == null ? void 0 : _a34.set_data(source2, indices);
    (_b4 = this.end) == null ? void 0 : _b4.set_data(source2, indices);
  }
  remove() {
    var _a34, _b4;
    (_a34 = this.start) == null ? void 0 : _a34.remove();
    (_b4 = this.end) == null ? void 0 : _b4.remove();
    super.remove();
  }
  map_data() {
    const { frame } = this.plot_view;
    const [sx_start, sy_start] = (() => {
      switch (this.model.start_units) {
        case "canvas": {
          return [
            new ScreenArray(this._x_start),
            new ScreenArray(this._y_start)
          ];
        }
        case "screen": {
          return [
            frame.bbox.xview.v_compute(this._x_start),
            frame.bbox.yview.v_compute(this._y_start)
          ];
        }
        case "data": {
          return [
            this.coordinates.x_scale.v_compute(this._x_start),
            this.coordinates.y_scale.v_compute(this._y_start)
          ];
        }
      }
    })();
    const [sx_end, sy_end] = (() => {
      switch (this.model.end_units) {
        case "canvas": {
          return [
            new ScreenArray(this._x_end),
            new ScreenArray(this._y_end)
          ];
        }
        case "screen": {
          return [
            frame.bbox.xview.v_compute(this._x_end),
            frame.bbox.yview.v_compute(this._y_end)
          ];
        }
        case "data": {
          return [
            this.coordinates.x_scale.v_compute(this._x_end),
            this.coordinates.y_scale.v_compute(this._y_end)
          ];
        }
      }
    })();
    this._sx_start = sx_start;
    this._sy_start = sy_start;
    this._sx_end = sx_end;
    this._sy_end = sy_end;
    const n2 = sx_start.length;
    const angles = this._angles = new ScreenArray(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      angles[i2] = Math.PI / 2 + atan2([sx_start[i2], sy_start[i2]], [sx_end[i2], sy_end[i2]]);
    }
  }
  _paint_data(ctx) {
    const { start: start2, end } = this;
    const { _sx_start, _sy_start, _sx_end, _sy_end, _angles } = this;
    const { x: x2, y: y2, width, height } = this.plot_view.frame.bbox;
    for (let i2 = 0, n2 = _sx_start.length; i2 < n2; i2++) {
      if (end != null) {
        ctx.save();
        ctx.translate(_sx_end[i2], _sy_end[i2]);
        ctx.rotate(_angles[i2]);
        end.paint(ctx, i2);
        ctx.restore();
      }
      if (start2 != null) {
        ctx.save();
        ctx.translate(_sx_start[i2], _sy_start[i2]);
        ctx.rotate(_angles[i2] + Math.PI);
        start2.paint(ctx, i2);
        ctx.restore();
      }
      if (!this.visuals.line.doit) {
        continue;
      }
      ctx.save();
      if (start2 != null || end != null) {
        ctx.beginPath();
        ctx.rect(x2, y2, width, height);
        if (end != null) {
          ctx.save();
          ctx.translate(_sx_end[i2], _sy_end[i2]);
          ctx.rotate(_angles[i2]);
          end.clip(ctx, i2);
          ctx.restore();
        }
        if (start2 != null) {
          ctx.save();
          ctx.translate(_sx_start[i2], _sy_start[i2]);
          ctx.rotate(_angles[i2] + Math.PI);
          start2.clip(ctx, i2);
          ctx.restore();
        }
        ctx.closePath();
        ctx.clip();
      }
      ctx.beginPath();
      ctx.moveTo(_sx_start[i2], _sy_start[i2]);
      ctx.lineTo(_sx_end[i2], _sy_end[i2]);
      this.visuals.line.apply(ctx, i2);
      ctx.restore();
    }
  }
};
__publicField(ArrowView, "__name__", "ArrowView");
var _Arrow = class _Arrow extends DataAnnotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Arrow, "__name__", "Arrow");
_Arrow.prototype.default_view = ArrowView;
_Arrow.mixins(LineVector);
_Arrow.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  x_start: [XCoordinateSpec, { field: "x_start" }],
  y_start: [YCoordinateSpec, { field: "y_start" }],
  start_units: [CoordinateUnits, "data"],
  start: [Nullable2(Ref2(ArrowHead)), null],
  x_end: [XCoordinateSpec, { field: "x_end" }],
  y_end: [YCoordinateSpec, { field: "y_end" }],
  end_units: [CoordinateUnits, "data"],
  end: [Nullable2(Ref2(ArrowHead)), () => new OpenHead()]
}));
var Arrow = _Arrow;

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/types.js
var { min: min4, max: max5 } = Math;
var _Sizeable = class _Sizeable {
  constructor(size2 = {}) {
    __publicField(this, "width");
    __publicField(this, "height");
    this.width = size2.width != null ? size2.width : 0;
    this.height = size2.height != null ? size2.height : 0;
  }
  bounded_to({ width, height }) {
    return new _Sizeable({
      width: this.width == Infinity && width != null ? width : this.width,
      height: this.height == Infinity && height != null ? height : this.height
    });
  }
  expanded_to({ width, height }) {
    return new _Sizeable({
      width: width != Infinity ? max5(this.width, width) : this.width,
      height: height != Infinity ? max5(this.height, height) : this.height
    });
  }
  expand_to({ width, height }) {
    this.width = max5(this.width, width);
    this.height = max5(this.height, height);
  }
  narrowed_to({ width, height }) {
    return new _Sizeable({
      width: min4(this.width, width),
      height: min4(this.height, height)
    });
  }
  narrow_to({ width, height }) {
    this.width = min4(this.width, width);
    this.height = min4(this.height, height);
  }
  grow_by({ left: left2, right: right3, top, bottom }) {
    const width = this.width + left2 + right3;
    const height = this.height + top + bottom;
    return new _Sizeable({ width, height });
  }
  shrink_by({ left: left2, right: right3, top, bottom }) {
    const width = max5(this.width - left2 - right3, 0);
    const height = max5(this.height - top - bottom, 0);
    return new _Sizeable({ width, height });
  }
  map(w_fn, h_fn) {
    return new _Sizeable({
      width: w_fn(this.width),
      height: (h_fn != null ? h_fn : w_fn)(this.height)
    });
  }
};
__publicField(_Sizeable, "__name__", "Sizeable");
var Sizeable = _Sizeable;
var SizingPolicy = Enum("fixed", "fit", "min", "max");

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/layoutable.js
var { abs, min: min5, max: max6, round: round3 } = Math;
var Layoutable = class {
  constructor() {
    __publicField(this, "absolute", false);
    __publicField(this, "position", { left: 0, top: 0 });
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "_inner_bbox", new BBox());
    __publicField(this, "_sizing", null);
    __publicField(this, "_dirty", false);
    __publicField(this, "_handlers", []);
  }
  *[Symbol.iterator]() {
  }
  get bbox() {
    return this._bbox;
  }
  get inner_bbox() {
    return this._inner_bbox;
  }
  get sizing() {
    assert(this._sizing != null);
    return this._sizing;
  }
  set dirty(dirty) {
    this._dirty = dirty;
  }
  get dirty() {
    return this._dirty;
  }
  get visible() {
    return this.sizing.visible;
  }
  set visible(visible) {
    if (this.sizing.visible != visible) {
      this.sizing.visible = visible;
      this._dirty = true;
    }
  }
  set_sizing(sizing = {}) {
    const width_policy = sizing.width_policy ?? "fit";
    const width = sizing.width;
    const min_width = sizing.min_width;
    const max_width = sizing.max_width;
    const height_policy = sizing.height_policy ?? "fit";
    const height = sizing.height;
    const min_height = sizing.min_height;
    const max_height = sizing.max_height;
    const aspect = sizing.aspect;
    const margin = sizing.margin ?? { top: 0, right: 0, bottom: 0, left: 0 };
    const visible = sizing.visible ?? true;
    const halign = sizing.halign ?? "start";
    const valign = sizing.valign ?? "start";
    this._sizing = {
      width_policy,
      min_width,
      width,
      max_width,
      height_policy,
      min_height,
      height,
      max_height,
      aspect,
      margin,
      visible,
      halign,
      valign,
      size: { width, height }
    };
    this._init();
  }
  _init() {
  }
  _set_geometry(outer, inner3) {
    this._bbox = outer;
    this._inner_bbox = inner3;
  }
  set_geometry(outer, inner3) {
    const { fixup_geometry } = this;
    if (fixup_geometry != null) {
      [outer, inner3] = fixup_geometry(outer, inner3);
    }
    this._set_geometry(outer, inner3 ?? outer);
    for (const handler of this._handlers) {
      handler(this._bbox, this._inner_bbox);
    }
  }
  on_resize(handler) {
    this._handlers.push(handler);
  }
  is_width_expanding() {
    return this.sizing.width_policy == "max";
  }
  is_height_expanding() {
    return this.sizing.height_policy == "max";
  }
  apply_aspect(viewport, { width, height }) {
    const { aspect } = this.sizing;
    if (aspect != null) {
      const { width_policy, height_policy } = this.sizing;
      const gt = (width2, height2) => {
        const policies = { max: 4, fit: 3, min: 2, fixed: 1 };
        return policies[width2] > policies[height2];
      };
      if (width_policy != "fixed" && height_policy != "fixed") {
        if (width_policy == height_policy) {
          const w_width = width;
          const w_height = round3(width / aspect);
          const h_width = round3(height * aspect);
          const h_height = height;
          const w_diff = abs(viewport.width - w_width) + abs(viewport.height - w_height);
          const h_diff = abs(viewport.width - h_width) + abs(viewport.height - h_height);
          if (w_diff <= h_diff) {
            width = w_width;
            height = w_height;
          } else {
            width = h_width;
            height = h_height;
          }
        } else if (gt(width_policy, height_policy)) {
          height = round3(width / aspect);
        } else {
          width = round3(height * aspect);
        }
      } else if (width_policy == "fixed") {
        height = round3(width / aspect);
      } else if (height_policy == "fixed") {
        width = round3(height * aspect);
      }
    }
    return { width, height };
  }
  measure(viewport_size) {
    if (this._sizing == null) {
      this.set_sizing();
    }
    if (!this.sizing.visible) {
      return { width: 0, height: 0 };
    }
    const exact_width = (width2) => {
      return this.sizing.width_policy == "fixed" && this.sizing.width != null ? this.sizing.width : width2;
    };
    const exact_height = (height2) => {
      return this.sizing.height_policy == "fixed" && this.sizing.height != null ? this.sizing.height : height2;
    };
    const viewport = new Sizeable(viewport_size).shrink_by(this.sizing.margin).map(exact_width, exact_height);
    const computed = this._measure(viewport);
    const clipped = this.clip_size(computed, viewport);
    const width = exact_width(clipped.width);
    const height = exact_height(clipped.height);
    const size2 = this.apply_aspect(viewport, { width, height });
    return { ...computed, ...size2 };
  }
  compute(viewport = {}) {
    const size_hint = this.measure({
      width: viewport.width != null && this.is_width_expanding() ? viewport.width : Infinity,
      height: viewport.height != null && this.is_height_expanding() ? viewport.height : Infinity
    });
    const { width, height } = size_hint;
    const { left: left2, top } = this.position;
    const outer = new BBox({ left: left2, top, width, height });
    let inner3 = void 0;
    if (size_hint.inner != null) {
      const { left: left3, top: top2, right: right3, bottom } = size_hint.inner;
      inner3 = new BBox({ left: left3, top: top2, right: width - right3, bottom: height - bottom });
    }
    this.set_geometry(outer, inner3);
  }
  get xview() {
    return this.bbox.xview;
  }
  get yview() {
    return this.bbox.yview;
  }
  clip_size(size2, viewport) {
    function clip(size3, vsize, min_size, max_size) {
      if (min_size == null) {
        min_size = 0;
      } else if (!isNumber(min_size)) {
        min_size = round3(min_size.percent * vsize);
      }
      if (max_size == null) {
        max_size = Infinity;
      } else if (!isNumber(max_size)) {
        max_size = round3(max_size.percent * vsize);
      }
      return max6(min_size, min5(size3, max_size));
    }
    return {
      width: clip(size2.width, viewport.width, this.sizing.min_width, this.sizing.max_width),
      height: clip(size2.height, viewport.height, this.sizing.min_height, this.sizing.max_height)
    };
  }
  has_size_changed() {
    const { _dirty } = this;
    this._dirty = false;
    return _dirty;
  }
};
__publicField(Layoutable, "__name__", "Layoutable");
var ContentLayoutable = class extends Layoutable {
  _measure(viewport) {
    const content_size = this._content_size();
    const bounds = viewport.bounded_to(this.sizing.size).bounded_to(content_size);
    const width = (() => {
      switch (this.sizing.width_policy) {
        case "fixed":
          return this.sizing.width != null ? this.sizing.width : content_size.width;
        case "min":
          return content_size.width;
        case "fit":
          return bounds.width;
        case "max":
          return max6(content_size.width, bounds.width);
      }
    })();
    const height = (() => {
      switch (this.sizing.height_policy) {
        case "fixed":
          return this.sizing.height != null ? this.sizing.height : content_size.height;
        case "min":
          return content_size.height;
        case "fit":
          return bounds.height;
        case "max":
          return max6(content_size.height, bounds.height);
      }
    })();
    return { width, height };
  }
};
__publicField(ContentLayoutable, "__name__", "ContentLayoutable");
var TextLayout = class extends ContentLayoutable {
  constructor(text2) {
    super();
    __publicField(this, "text");
    this.text = text2;
  }
  _content_size() {
    return new Sizeable(this.text.size());
  }
};
__publicField(TextLayout, "__name__", "TextLayout");
var FixedLayout = class extends ContentLayoutable {
  constructor(size2 = {}) {
    super();
    __publicField(this, "size");
    this.size = size2;
  }
  _content_size() {
    return new Sizeable(this.size);
  }
};
__publicField(FixedLayout, "__name__", "FixedLayout");

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/side_panel.js
var pi2 = Math.PI / 2;
var _angle_lookup = {
  above: {
    parallel: 0,
    normal: -pi2,
    horizontal: 0,
    vertical: -pi2
  },
  below: {
    parallel: 0,
    normal: pi2,
    horizontal: 0,
    vertical: pi2
  },
  left: {
    parallel: -pi2,
    normal: 0,
    horizontal: 0,
    vertical: -pi2
  },
  right: {
    parallel: pi2,
    normal: 0,
    horizontal: 0,
    vertical: pi2
  }
};
var _vertical_align_lookup = {
  above: {
    parallel: "bottom",
    normal: "center",
    horizontal: "bottom",
    vertical: "center"
  },
  below: {
    parallel: "top",
    normal: "center",
    horizontal: "top",
    vertical: "center"
  },
  left: {
    parallel: "bottom",
    normal: "center",
    horizontal: "center",
    vertical: "bottom"
  },
  right: {
    parallel: "bottom",
    normal: "center",
    horizontal: "center",
    vertical: "bottom"
  }
};
var _align_lookup = {
  above: {
    parallel: "center",
    normal: "left",
    horizontal: "center",
    vertical: "left"
  },
  below: {
    parallel: "center",
    normal: "left",
    horizontal: "center",
    vertical: "left"
  },
  left: {
    parallel: "center",
    normal: "right",
    horizontal: "right",
    vertical: "center"
  },
  right: {
    parallel: "center",
    normal: "left",
    horizontal: "left",
    vertical: "center"
  }
};
var _align_lookup_negative = {
  above: "right",
  below: "left",
  left: "right",
  right: "left"
};
var _align_lookup_positive = {
  above: "left",
  below: "right",
  left: "right",
  right: "left"
};
var SidePanel = class {
  constructor(side, face) {
    __publicField(this, "side");
    __publicField(this, "face");
    __publicField(this, "dimension");
    __publicField(this, "orientation");
    __publicField(this, "is_horizontal");
    __publicField(this, "is_vertical");
    __publicField(this, "normals");
    this.side = side;
    this.face = (() => {
      if (face != null && face != "auto") {
        return face;
      } else {
        switch (this.side) {
          case "left":
          case "above":
            return "front";
          case "right":
          case "below":
            return "back";
        }
      }
    })();
    this.dimension = this.side == "above" || this.side == "below" ? 0 : 1;
    this.orientation = this.dimension == 0 ? "horizontal" : "vertical";
    this.is_horizontal = this.dimension == 0;
    this.is_vertical = this.dimension == 1;
    this.normals = (() => {
      const sign = this.face == "front" ? -1 : 1;
      switch (this.side) {
        case "left":
          return [sign, 0];
        case "right":
          return [sign, 0];
        case "above":
          return [0, sign];
        case "below":
          return [0, sign];
      }
    })();
  }
  get face_adjusted_side() {
    const { side, face } = this;
    switch (side) {
      case "left":
      case "right":
        return face == "front" ? "left" : "right";
      case "above":
      case "below":
        return face == "front" ? "above" : "below";
    }
  }
  get_label_text_heuristics(orient) {
    const side = this.face_adjusted_side;
    if (isString(orient)) {
      return {
        vertical_align: _vertical_align_lookup[side][orient],
        align: _align_lookup[side][orient]
      };
    } else {
      return {
        vertical_align: "center",
        align: (orient < 0 ? _align_lookup_negative : _align_lookup_positive)[side]
      };
    }
  }
  get_label_angle_heuristic(orient) {
    if (isString(orient)) {
      const side = this.face_adjusted_side;
      return _angle_lookup[side][orient];
    } else {
      return -orient;
    }
  }
};
__publicField(SidePanel, "__name__", "SidePanel");
var SideLayout = class extends ContentLayoutable {
  constructor(panel, get_size, rotate = false) {
    super();
    __publicField(this, "panel");
    __publicField(this, "get_size");
    __publicField(this, "rotate");
    this.panel = panel;
    this.get_size = get_size;
    this.rotate = rotate;
    if (this.panel.is_horizontal) {
      this.set_sizing({ width_policy: "max", height_policy: "fixed" });
    } else {
      this.set_sizing({ width_policy: "fixed", height_policy: "max" });
    }
  }
  _content_size() {
    const { width, height } = this.get_size();
    if (!this.rotate || this.panel.is_horizontal) {
      return new Sizeable({ width, height });
    } else {
      return new Sizeable({ width: height, height: width });
    }
  }
  has_size_changed() {
    const { width, height } = this._content_size();
    if (this.panel.is_horizontal) {
      return this.bbox.height != height;
    } else {
      return this.bbox.width != width;
    }
  }
};
__publicField(SideLayout, "__name__", "SideLayout");

// node_modules/@bokeh/bokehjs/build/js/lib/models/text/base_text.js
var BaseTextView = class extends View {
};
__publicField(BaseTextView, "__name__", "BaseTextView");
var _BaseText = class _BaseText extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BaseText, "__name__", "BaseText");
_BaseText.define(({ Str: Str2 }) => ({
  text: [Str2]
}));
var BaseText = _BaseText;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/image.js
async function load_image(url2, options2) {
  return new ImageLoader(url2, options2).promise;
}
var ImageLoader = class {
  constructor(src, config = {}) {
    __publicField(this, "image", new Image());
    __publicField(this, "promise");
    __publicField(this, "_finished", false);
    const { attempts = 1, timeout = 1 } = config;
    const url2 = (() => {
      if (src instanceof ArrayBuffer) {
        const blob = new Blob([src], { type: "image/png" });
        return URL.createObjectURL(blob);
      } else {
        return src;
      }
    })();
    this.promise = new Promise((resolve, _reject) => {
      this.image.crossOrigin = "anonymous";
      let retries = 0;
      this.image.onerror = () => {
        var _a34;
        if (++retries == attempts) {
          const message = `unable to load ${url2} image after ${attempts} attempts`;
          logger.warn(message);
          if (this.image.crossOrigin != null) {
            logger.warn(`attempting to load ${url2} without a cross origin policy`);
            this.image.crossOrigin = null;
            retries = 0;
          } else {
            (_a34 = config.failed) == null ? void 0 : _a34.call(config);
            return;
          }
        }
        setTimeout(() => this.image.src = url2, timeout);
      };
      this.image.onload = () => {
        var _a34;
        this._finished = true;
        (_a34 = config.loaded) == null ? void 0 : _a34.call(config, this.image);
        resolve(this.image);
      };
      this.image.src = url2;
    });
  }
  get finished() {
    return this._finished;
  }
};
__publicField(ImageLoader, "__name__", "ImageLoader");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/text.js
var _offscreen_context = (() => {
  const canvas_el = typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(0, 0) : canvas2({ width: 0, height: 0 });
  const ctx = canvas_el.getContext("2d");
  assert(ctx != null, "can't obtain 2d context");
  return ctx;
})();
function _font_metrics(font) {
  const ctx = _offscreen_context;
  ctx.font = font;
  const cap_metrics = ctx.measureText("M");
  const x_metrics = ctx.measureText("x");
  const metrics = ctx.measureText("ÅŚg|");
  const ascent = typeof metrics.fontBoundingBoxAscent !== "undefined" ? metrics.fontBoundingBoxAscent : metrics.actualBoundingBoxAscent;
  const descent = typeof metrics.fontBoundingBoxDescent !== "undefined" ? metrics.fontBoundingBoxDescent : metrics.actualBoundingBoxDescent;
  return {
    height: ascent + descent,
    ascent,
    descent,
    cap_height: cap_metrics.actualBoundingBoxAscent,
    x_height: x_metrics.actualBoundingBoxAscent
  };
}
var _metrics_cache = /* @__PURE__ */ new Map();
function font_metrics(font) {
  let metrics = _metrics_cache.get(font);
  if (metrics == null) {
    const loaded = document.fonts.check(font);
    metrics = { font: _font_metrics(font) };
    if (loaded) {
      _metrics_cache.set(font, metrics);
    }
  }
  return metrics.font;
}
function parse_css_font_size(size2) {
  const match2 = size2.match(/^\s*(\d+(\.\d+)?)(\w+)\s*$/);
  if (match2 != null) {
    const [, value2, , unit] = match2;
    const number2 = Number(value2);
    if (isFinite(number2)) {
      return { value: number2, unit };
    }
  }
  return null;
}
function parse_css_length(size2) {
  const match2 = size2.match(/^\s*(-?\d+(\.\d+)?)(\w+)\s*$/);
  if (match2 != null) {
    const [, value2, , unit] = match2;
    const number2 = Number(value2);
    if (isFinite(number2)) {
      return { value: number2, unit };
    }
  }
  return null;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/graphics.js
var text_width = (() => {
  const canvas3 = document.createElement("canvas");
  const ctx = canvas3.getContext("2d");
  let current_font = "";
  return (text2, font) => {
    if (font != current_font) {
      current_font = font;
      ctx.font = font;
    }
    return ctx.measureText(text2).width;
  };
})();
var GraphicsBox = class {
  constructor() {
    __publicField(this, "_position", { sx: 0, sy: 0 });
    __publicField(this, "angle");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "padding");
    __publicField(this, "font_size_scale", 1);
    __publicField(this, "text_height_metric");
    __publicField(this, "align", "left");
    __publicField(this, "_base_font_size", 13);
    // the same as :host's font-size (13px)
    __publicField(this, "_x_anchor", "left");
    __publicField(this, "_y_anchor", "center");
  }
  set base_font_size(v) {
    if (v != null) {
      this._base_font_size = v;
    }
  }
  get base_font_size() {
    return this._base_font_size;
  }
  set position(p2) {
    this._position = p2;
  }
  get position() {
    return this._position;
  }
  infer_text_height() {
    return "ascent_descent";
  }
  bbox() {
    const { p0, p1, p2, p3 } = this.rect();
    const left2 = Math.min(p0.x, p1.x, p2.x, p3.x);
    const top = Math.min(p0.y, p1.y, p2.y, p3.y);
    const right3 = Math.max(p0.x, p1.x, p2.x, p3.x);
    const bottom = Math.max(p0.y, p1.y, p2.y, p3.y);
    return new BBox({ left: left2, right: right3, top, bottom });
  }
  size() {
    const { width, height } = this._size();
    const { angle } = this;
    if (angle == null || angle == 0) {
      return { width, height };
    } else {
      const c = Math.cos(Math.abs(angle));
      const s2 = Math.sin(Math.abs(angle));
      return {
        width: Math.abs(width * c + height * s2),
        height: Math.abs(width * s2 + height * c)
      };
    }
  }
  rect() {
    const rect = this._rect();
    const { angle } = this;
    if (angle == null || angle == 0) {
      return rect;
    } else {
      const { sx, sy } = this.position;
      const tr2 = new AffineTransform();
      tr2.translate(sx, sy);
      tr2.rotate(angle);
      tr2.translate(-sx, -sy);
      return tr2.apply_rect(rect);
    }
  }
  paint_rect(ctx) {
    const { p0, p1, p2, p3 } = this.rect();
    ctx.save();
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.beginPath();
    const { round: round8 } = Math;
    ctx.moveTo(round8(p0.x), round8(p0.y));
    ctx.lineTo(round8(p1.x), round8(p1.y));
    ctx.lineTo(round8(p2.x), round8(p2.y));
    ctx.lineTo(round8(p3.x), round8(p3.y));
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  paint_bbox(ctx) {
    const { x: x2, y: y2, width, height } = this.bbox();
    ctx.save();
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 1;
    ctx.beginPath();
    const { round: round8 } = Math;
    ctx.moveTo(round8(x2), round8(y2));
    ctx.lineTo(round8(x2), round8(y2 + height));
    ctx.lineTo(round8(x2 + width), round8(y2 + height));
    ctx.lineTo(round8(x2 + width), round8(y2));
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
};
__publicField(GraphicsBox, "__name__", "GraphicsBox");
var TextBox = class extends GraphicsBox {
  constructor({ text: text2 }) {
    super();
    __publicField(this, "text");
    __publicField(this, "color");
    __publicField(this, "outline_color");
    __publicField(this, "font");
    __publicField(this, "line_height");
    //padding: Padding
    __publicField(this, "_visual_align", "left");
    this.text = text2;
  }
  set visuals(v) {
    const color = v.color;
    const alpha = v.alpha;
    const outline_color = v.outline_color;
    const style2 = v.font_style;
    let size2 = v.font_size;
    const face = v.font;
    const { font_size_scale, base_font_size } = this;
    const res = parse_css_font_size(size2);
    if (res != null) {
      let { value: value2, unit } = res;
      value2 *= font_size_scale;
      if (unit == "em" && base_font_size != 0) {
        value2 *= base_font_size;
        unit = "px";
      }
      size2 = `${value2}${unit}`;
    }
    const font = `${style2} ${size2} ${face}`;
    this.font = font;
    this.color = color2css(color, alpha);
    this.outline_color = color2css(outline_color, alpha);
    this.line_height = v.line_height;
    const align = v.align;
    this._visual_align = align;
    this._x_anchor = align;
    const baseline = v.baseline;
    this._y_anchor = (() => {
      switch (baseline) {
        case "top":
          return "top";
        case "middle":
          return "center";
        case "bottom":
          return "bottom";
        default:
          return "baseline";
      }
    })();
  }
  infer_text_height() {
    if (this.text.includes("\n")) {
      return "ascent_descent";
    } else {
      let is_math_like = function(text2) {
        for (const c of new Set(text2)) {
          if ("0" <= c && c <= "9") {
            continue;
          }
          switch (c) {
            case ",":
            case ".":
            case "+":
            case "-":
            case "−":
            case "e":
              continue;
            default:
              return false;
          }
        }
        return true;
      };
      if (is_math_like(this.text)) {
        return "cap";
      } else {
        return "ascent_descent";
      }
    }
  }
  _text_line(fmetrics) {
    const metric = this.text_height_metric ?? this.infer_text_height();
    const ascent = (() => {
      switch (metric) {
        case "x":
        case "x_descent":
          return fmetrics.x_height;
        case "cap":
        case "cap_descent":
          return fmetrics.cap_height;
        case "ascent":
        case "ascent_descent":
          return fmetrics.ascent;
      }
    })();
    const descent = (() => {
      switch (metric) {
        case "x":
        case "cap":
        case "ascent":
          return 0;
        case "x_descent":
        case "cap_descent":
        case "ascent_descent":
          return fmetrics.descent;
      }
    })();
    return { height: ascent + descent, ascent, descent };
  }
  get nlines() {
    const lines = this.text.split("\n");
    return lines.length;
  }
  _size() {
    var _a34, _b4;
    const { font } = this;
    const fmetrics = font_metrics(font);
    const line_spacing = (this.line_height - 1) * fmetrics.height;
    const empty3 = this.text == "";
    const lines = this.text.split("\n");
    const nlines = lines.length;
    const widths = lines.map((line) => text_width(line, font));
    const text_line = this._text_line(fmetrics);
    const text_height = text_line.height * nlines;
    const w_scale = ((_a34 = this.width) == null ? void 0 : _a34.unit) == "%" ? this.width.value : 1;
    const h_scale = ((_b4 = this.height) == null ? void 0 : _b4.unit) == "%" ? this.height.value : 1;
    const width = max(widths) * w_scale;
    const height = empty3 ? 0 : (text_height + line_spacing * (nlines - 1)) * h_scale;
    return { width, height, metrics: fmetrics };
  }
  _computed_position(size2, metrics, nlines) {
    const { width, height } = size2;
    const { sx, sy, x_anchor = this._x_anchor, y_anchor = this._y_anchor } = this.position;
    const x2 = sx - (() => {
      if (isNumber(x_anchor)) {
        return x_anchor * width;
      } else {
        switch (x_anchor) {
          case "left":
            return 0;
          case "center":
            return 0.5 * width;
          case "right":
            return width;
        }
      }
    })();
    const y2 = sy - (() => {
      if (isNumber(y_anchor)) {
        return y_anchor * height;
      } else {
        switch (y_anchor) {
          case "top":
            return 0;
          case "center":
            return 0.5 * height;
          case "bottom":
            return height;
          case "baseline": {
            if (nlines == 1) {
              const metric = this.text_height_metric ?? this.infer_text_height();
              switch (metric) {
                case "x":
                case "x_descent":
                  return metrics.x_height;
                case "cap":
                case "cap_descent":
                  return metrics.cap_height;
                case "ascent":
                case "ascent_descent":
                  return metrics.ascent;
              }
            } else {
              return 0.5 * height;
            }
          }
        }
      }
    })();
    return { x: x2, y: y2 };
  }
  _rect() {
    const { width, height, metrics } = this._size();
    const nlines = this.text.split("\n").length;
    const { x: x2, y: y2 } = this._computed_position({ width, height }, metrics, nlines);
    const bbox = new BBox({ x: x2, y: y2, width, height });
    return bbox.rect;
  }
  paint(ctx) {
    var _a34, _b4;
    const { font } = this;
    const fmetrics = font_metrics(font);
    const line_spacing = (this.line_height - 1) * fmetrics.height;
    const lines = this.text.split("\n");
    const nlines = lines.length;
    const widths = lines.map((line) => text_width(line, font));
    const text_line = this._text_line(fmetrics);
    const text_height = text_line.height * nlines;
    const w_scale = ((_a34 = this.width) == null ? void 0 : _a34.unit) == "%" ? this.width.value : 1;
    const h_scale = ((_b4 = this.height) == null ? void 0 : _b4.unit) == "%" ? this.height.value : 1;
    const width = max(widths) * w_scale;
    const height = (text_height + line_spacing * (nlines - 1)) * h_scale;
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.outline_color;
    ctx.font = this.font;
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    const { sx, sy } = this.position;
    const { align } = this;
    const { angle } = this;
    if (angle != null && angle != 0) {
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      ctx.translate(-sx, -sy);
    }
    let { x: x2, y: y2 } = this._computed_position({ width, height }, fmetrics, nlines);
    if (align == "justify") {
      for (let i2 = 0; i2 < nlines; i2++) {
        let xij = x2;
        const line = lines[i2];
        const words = line.split(" ");
        const nwords = words.length;
        const word_widths = words.map((word) => text_width(word, font));
        const word_spacing = (width - sum(word_widths)) / (nwords - 1);
        for (let j = 0; j < nwords; j++) {
          ctx.fillText(words[j], xij, y2);
          ctx.strokeText(words[j], xij, y2);
          xij += word_widths[j] + word_spacing;
        }
        y2 += /*heights[i]*/
        text_line.height + line_spacing;
      }
    } else {
      for (let i2 = 0; i2 < nlines; i2++) {
        const xi = x2 + (() => {
          switch (align == "auto" ? this._visual_align : align) {
            case "left":
              return 0;
            case "center":
              return 0.5 * (width - widths[i2]);
            case "right":
              return width - widths[i2];
          }
        })();
        const linei = lines[i2];
        const yi = y2 + /*ascents[i]*/
        text_line.ascent;
        ctx.fillText(linei, xi, yi);
        ctx.strokeText(linei, xi, yi);
        y2 += /*heights[i]*/
        text_line.height + line_spacing;
      }
    }
    ctx.restore();
  }
};
__publicField(TextBox, "__name__", "TextBox");
var BaseExpo = class extends GraphicsBox {
  constructor(base2, expo) {
    super();
    __publicField(this, "base");
    __publicField(this, "expo");
    this.base = base2;
    this.expo = expo;
  }
  get children() {
    return [this.base, this.expo];
  }
  set base_font_size(v) {
    super.base_font_size = v;
    this.base.base_font_size = v;
    this.expo.base_font_size = v;
  }
  set position(p2) {
    this._position = p2;
    const bs = this.base.size();
    const es = this.expo.size();
    const shift = this._shift_scale() * bs.height;
    const height = Math.max(bs.height, shift + es.height);
    this.base.position = {
      sx: 0,
      x_anchor: "left",
      sy: height,
      y_anchor: "bottom"
    };
    this.expo.position = {
      sx: bs.width,
      x_anchor: "left",
      sy: shift,
      y_anchor: "bottom"
    };
  }
  get position() {
    return this._position;
  }
  set visuals(v) {
    this.expo.font_size_scale = 0.7;
    this.base.visuals = v;
    this.expo.visuals = v;
  }
  _shift_scale() {
    if (this.base instanceof TextBox && this.base.nlines == 1) {
      const { x_height, cap_height } = font_metrics(this.base.font);
      return x_height / cap_height;
    } else {
      return 2 / 3;
    }
  }
  infer_text_height() {
    return this.base.infer_text_height();
  }
  _rect() {
    const bb = this.base.bbox();
    const eb = this.expo.bbox();
    const bbox = bb.union(eb);
    const { x: x2, y: y2 } = this._computed_position();
    return bbox.translate(x2, y2).rect;
  }
  _size() {
    const bs = this.base.size();
    const es = this.expo.size();
    return {
      width: bs.width + es.width,
      height: Math.max(bs.height, this._shift_scale() * bs.height + es.height)
    };
  }
  paint(ctx) {
    ctx.save();
    const { angle } = this;
    if (angle != null && angle != 0) {
      const { sx, sy } = this.position;
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      ctx.translate(-sx, -sy);
    }
    const { x: x2, y: y2 } = this._computed_position();
    ctx.translate(x2, y2);
    this.base.paint(ctx);
    this.expo.paint(ctx);
    ctx.restore();
  }
  // paint_rect ...
  paint_bbox(ctx) {
    super.paint_bbox(ctx);
    const { x: x2, y: y2 } = this._computed_position();
    ctx.save();
    ctx.translate(x2, y2);
    for (const child of this.children) {
      child.paint_bbox(ctx);
    }
    ctx.restore();
  }
  _computed_position() {
    const { width, height } = this._size();
    const { sx, sy, x_anchor = this._x_anchor, y_anchor = this._y_anchor } = this.position;
    const x2 = sx - (() => {
      if (isNumber(x_anchor)) {
        return x_anchor * width;
      } else {
        switch (x_anchor) {
          case "left":
            return 0;
          case "center":
            return 0.5 * width;
          case "right":
            return width;
        }
      }
    })();
    const y2 = sy - (() => {
      if (isNumber(y_anchor)) {
        return y_anchor * height;
      } else {
        switch (y_anchor) {
          case "top":
            return 0;
          case "center":
            return 0.5 * height;
          case "bottom":
            return height;
          case "baseline":
            return 0.5 * height;
        }
      }
    })();
    return { x: x2, y: y2 };
  }
};
__publicField(BaseExpo, "__name__", "BaseExpo");
var GraphicsBoxes = class {
  constructor(items) {
    __publicField(this, "items");
    this.items = items;
  }
  set base_font_size(v) {
    for (const item3 of this.items) {
      item3.base_font_size = v;
    }
  }
  get length() {
    return this.items.length;
  }
  set visuals(v) {
    for (const item3 of this.items) {
      item3.visuals = v;
    }
    const metric_map = { x: 0, cap: 1, ascent: 2, x_descent: 3, cap_descent: 4, ascent_descent: 5 };
    const common = max_by(this.items.map((item3) => item3.infer_text_height()), (metric) => metric_map[metric]);
    for (const item3 of this.items) {
      item3.text_height_metric = common;
    }
  }
  set angle(a2) {
    for (const item3 of this.items) {
      item3.angle = a2;
    }
  }
  max_size() {
    let width = 0;
    let height = 0;
    for (const item3 of this.items) {
      const size2 = item3.size();
      width = Math.max(width, size2.width);
      height = Math.max(height, size2.height);
    }
    return { width, height };
  }
};
__publicField(GraphicsBoxes, "__name__", "GraphicsBoxes");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/modules.js
function is_ModuleError(error) {
  return error instanceof Error && "code" in error;
}
async function load_module(module2) {
  try {
    return await module2;
  } catch (e) {
    if (is_ModuleError(e) && e.code === "MODULE_NOT_FOUND") {
      return null;
    } else {
      throw e;
    }
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/text/providers.js
var MathJaxProvider = class {
  constructor() {
    __publicField(this, "ready", new Signal0(this, "ready"));
    __publicField(this, "status", "not_started");
  }
};
__publicField(MathJaxProvider, "__name__", "MathJaxProvider");
var BundleProvider = class extends MathJaxProvider {
  constructor() {
    super(...arguments);
    __publicField(this, "_mathjax");
  }
  get MathJax() {
    return this._mathjax;
  }
  async fetch() {
    this.status = "loading";
    try {
      const mathjax = await load_module(import("./mathjax-IBCBVOUE.js"));
      this.status = mathjax == null ? "failed" : "loaded";
      this._mathjax = mathjax;
      this.ready.emit();
    } catch (error) {
      this.status = "failed";
    }
  }
};
__publicField(BundleProvider, "__name__", "BundleProvider");
var default_provider = new BundleProvider();

// node_modules/@bokeh/bokehjs/build/js/lib/models/text/math_text.js
var MathTextView = class extends BaseTextView {
  constructor() {
    super(...arguments);
    __publicField(this, "valign");
    __publicField(this, "angle");
    __publicField(this, "_position", { sx: 0, sy: 0 });
    // Align does nothing, needed to maintain compatibility with TextBox,
    // to align you need to use TeX Macros.
    // http://docs.mathjax.org/en/latest/input/tex/macros/index.html?highlight=align
    __publicField(this, "align", "left");
    __publicField(this, "_x_anchor", "left");
    __publicField(this, "_y_anchor", "center");
    __publicField(this, "_base_font_size", 13);
    __publicField(this, "font_size_scale", 1);
    __publicField(this, "font");
    __publicField(this, "color");
    __publicField(this, "svg_image", null);
    __publicField(this, "svg_element");
    __publicField(this, "width");
    __publicField(this, "height");
  }
  graphics() {
    return this;
  }
  // Same for infer_text_height
  infer_text_height() {
    return "ascent_descent";
  }
  // the same as :host's font-size (13px)
  set base_font_size(v) {
    if (v != null) {
      this._base_font_size = v;
    }
  }
  get base_font_size() {
    return this._base_font_size;
  }
  _rect() {
    const { width, height } = this._size();
    const { x: x2, y: y2 } = this._computed_position();
    const bbox = new BBox({ x: x2, y: y2, width, height });
    return bbox.rect;
  }
  set position(p2) {
    this._position = p2;
  }
  get position() {
    return this._position;
  }
  get text() {
    return this.model.text;
  }
  get provider() {
    return default_provider;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    if (this.provider.status == "not_started") {
      await this.provider.fetch();
    }
  }
  connect_signals() {
    super.connect_signals();
    this.on_change(this.model.properties.text, () => this.load_image());
  }
  set visuals(v) {
    const color = v.color;
    const alpha = v.alpha;
    const style2 = v.font_style;
    let size2 = v.font_size;
    const face = v.font;
    const { font_size_scale, _base_font_size } = this;
    const res = parse_css_font_size(size2);
    if (res != null) {
      let { value: value2, unit } = res;
      value2 *= font_size_scale;
      if (unit == "em" && _base_font_size != 0) {
        value2 *= _base_font_size;
        unit = "px";
      }
      size2 = `${value2}${unit}`;
    }
    const font = `${style2} ${size2} ${face}`;
    this.font = font;
    this.color = color2css(color, alpha);
    const align = v.align;
    this._x_anchor = align;
    const baseline = v.baseline;
    this._y_anchor = (() => {
      switch (baseline) {
        case "top":
          return "top";
        case "middle":
          return "center";
        case "bottom":
          return "bottom";
        default:
          return "baseline";
      }
    })();
  }
  /**
   * Calculates position of element after considering
   * anchor and dimensions
   */
  _computed_position() {
    const { width, height } = this._size();
    const { sx, sy, x_anchor = this._x_anchor, y_anchor = this._y_anchor } = this.position;
    const metrics = font_metrics(this.font);
    const x2 = sx - (() => {
      if (isNumber(x_anchor)) {
        return x_anchor * width;
      } else {
        switch (x_anchor) {
          case "left":
            return 0;
          case "center":
            return 0.5 * width;
          case "right":
            return width;
        }
      }
    })();
    const y2 = sy - (() => {
      if (isNumber(y_anchor)) {
        return y_anchor * height;
      } else {
        switch (y_anchor) {
          case "top":
            if (metrics.height > height) {
              return height - (-this.valign - metrics.descent) - metrics.height;
            } else {
              return 0;
            }
          case "center":
            return 0.5 * height;
          case "bottom":
            if (metrics.height > height) {
              return height + metrics.descent + this.valign;
            } else {
              return height;
            }
          case "baseline":
            return 0.5 * height;
        }
      }
    })();
    return { x: x2, y: y2 };
  }
  /**
   * Uses the width, height and given angle to calculate the size
  */
  size() {
    const { width, height } = this._size();
    const { angle } = this;
    if (angle == null || angle == 0) {
      return { width, height };
    } else {
      const c = Math.cos(Math.abs(angle));
      const s2 = Math.sin(Math.abs(angle));
      return {
        width: Math.abs(width * c + height * s2),
        height: Math.abs(width * s2 + height * c)
      };
    }
  }
  get_image_dimensions() {
    var _a34;
    const fmetrics = font_metrics(this.font);
    const svg_styles = (_a34 = this.svg_element.getAttribute("style")) == null ? void 0 : _a34.split(";");
    if (svg_styles != null) {
      const rules_map = /* @__PURE__ */ new Map();
      svg_styles.forEach((property) => {
        const [rule, value2] = property.split(":");
        if (rule.trim() != "") {
          rules_map.set(rule.trim(), value2.trim());
        }
      });
      const v_align = parse_css_length(rules_map.get("vertical-align"));
      if ((v_align == null ? void 0 : v_align.unit) == "ex") {
        this.valign = v_align.value * fmetrics.x_height;
      } else if ((v_align == null ? void 0 : v_align.unit) == "px") {
        this.valign = v_align.value;
      }
    }
    const ex = (() => {
      const width = this.svg_element.getAttribute("width");
      const height = this.svg_element.getAttribute("height");
      return {
        width: width != null && width.endsWith("ex") ? parseFloat(width) : 1,
        height: height != null && height.endsWith("ex") ? parseFloat(height) : 1
      };
    })();
    return {
      width: fmetrics.x_height * ex.width,
      height: fmetrics.x_height * ex.height
    };
  }
  get truncated_text() {
    return this.model.text.length > 6 ? `${this.model.text.substring(0, 6)}...` : this.model.text;
  }
  _size() {
    var _a34, _b4;
    if (this.svg_image == null) {
      if (this.provider.status == "failed" || this.provider.status == "not_started") {
        return {
          width: text_width(this.truncated_text, this.font),
          height: font_metrics(this.font).height
        };
      } else {
        return { width: this._base_font_size, height: this._base_font_size };
      }
    }
    const fmetrics = font_metrics(this.font);
    let { width, height } = this.get_image_dimensions();
    height = Math.max(height, fmetrics.height);
    const w_scale = ((_a34 = this.width) == null ? void 0 : _a34.unit) == "%" ? this.width.value : 1;
    const h_scale = ((_b4 = this.height) == null ? void 0 : _b4.unit) == "%" ? this.height.value : 1;
    return { width: width * w_scale, height: height * h_scale };
  }
  bbox() {
    const { p0, p1, p2, p3 } = this.rect();
    const left2 = Math.min(p0.x, p1.x, p2.x, p3.x);
    const top = Math.min(p0.y, p1.y, p2.y, p3.y);
    const right3 = Math.max(p0.x, p1.x, p2.x, p3.x);
    const bottom = Math.max(p0.y, p1.y, p2.y, p3.y);
    return new BBox({ left: left2, right: right3, top, bottom });
  }
  rect() {
    const rect = this._rect();
    const { angle } = this;
    if (angle == null || angle == 0) {
      return rect;
    } else {
      const { sx, sy } = this.position;
      const tr2 = new AffineTransform();
      tr2.translate(sx, sy);
      tr2.rotate(angle);
      tr2.translate(-sx, -sy);
      return tr2.apply_rect(rect);
    }
  }
  paint_rect(ctx) {
    const { p0, p1, p2, p3 } = this.rect();
    ctx.save();
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.beginPath();
    const { round: round8 } = Math;
    ctx.moveTo(round8(p0.x), round8(p0.y));
    ctx.lineTo(round8(p1.x), round8(p1.y));
    ctx.lineTo(round8(p2.x), round8(p2.y));
    ctx.lineTo(round8(p3.x), round8(p3.y));
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  paint_bbox(ctx) {
    const { x: x2, y: y2, width, height } = this.bbox();
    ctx.save();
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 1;
    ctx.beginPath();
    const { round: round8 } = Math;
    ctx.moveTo(round8(x2), round8(y2));
    ctx.lineTo(round8(x2), round8(y2 + height));
    ctx.lineTo(round8(x2 + width), round8(y2 + height));
    ctx.lineTo(round8(x2 + width), round8(y2));
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  async request_image() {
    if (this.provider.MathJax == null) {
      return;
    }
    const mathjax_element = this._process_text();
    if (mathjax_element == null) {
      this._has_finished = true;
      return;
    }
    const svg_element = mathjax_element.children[0];
    this.svg_element = svg_element;
    svg_element.setAttribute("font", this.font);
    svg_element.setAttribute("stroke", this.color);
    const svg = svg_element.outerHTML;
    const src = `data:image/svg+xml;utf-8,${encodeURIComponent(svg)}`;
    this.svg_image = await load_image(src);
  }
  async load_image() {
    await this.request_image();
    this.parent.request_layout();
  }
  /**
   * Takes a Canvas' Context2d and if the image has already
   * been loaded draws the image in it otherwise draws the model's text.
  */
  paint(ctx) {
    if (this.svg_image == null) {
      if (this.provider.status == "not_started" || this.provider.status == "loading") {
        this.provider.ready.connect(() => this.load_image());
      }
      if (this.provider.status == "loaded") {
        void this.load_image();
      }
    }
    ctx.save();
    const { sx, sy } = this.position;
    const { angle } = this;
    if (angle != null && angle != 0) {
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      ctx.translate(-sx, -sy);
    }
    const { x: x2, y: y2 } = this._computed_position();
    if (this.svg_image != null) {
      const { width, height } = this.get_image_dimensions();
      ctx.drawImage(this.svg_image, x2, y2, width, height);
    } else if (this.provider.status == "failed" || this.provider.status == "not_started") {
      ctx.fillStyle = this.color;
      ctx.font = this.font;
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
      ctx.fillText(this.truncated_text, x2, y2 + font_metrics(this.font).ascent);
    }
    ctx.restore();
    if (!this._has_finished && (this.provider.status == "failed" || this.svg_image != null)) {
      this._has_finished = true;
      this.parent.notify_finished_after_paint();
    }
  }
};
__publicField(MathTextView, "__name__", "MathTextView");
var MathText = class extends BaseText {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(MathText, "__name__", "MathText");
var AsciiView = class extends MathTextView {
  // TODO: Color ascii
  get styled_text() {
    return this.text;
  }
  _process_text() {
    return void 0;
  }
  _size() {
    return {
      width: text_width(this.text, this.font),
      height: font_metrics(this.font).height
    };
  }
  paint(ctx) {
    ctx.save();
    const { sx, sy } = this.position;
    const { angle } = this;
    if (angle != null && angle != 0) {
      ctx.translate(sx, sy);
      ctx.rotate(angle);
      ctx.translate(-sx, -sy);
    }
    const { x: x2, y: y2 } = this._computed_position();
    ctx.fillStyle = this.color;
    ctx.font = this.font;
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    ctx.fillText(this.text, x2, y2 + font_metrics(this.font).ascent);
    ctx.restore();
    this._has_finished = true;
    this.parent.notify_finished_after_paint();
  }
};
__publicField(AsciiView, "__name__", "AsciiView");
var _Ascii = class _Ascii extends MathText {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Ascii, "__name__", "Ascii");
_Ascii.prototype.default_view = AsciiView;
var Ascii = _Ascii;
var MathMLView = class extends MathTextView {
  get styled_text() {
    let styled = this.text.trim();
    let matchs = styled.match(/<math(.*?[^?])?>/s);
    if (matchs == null) {
      return this.text.trim();
    }
    styled = insert_text_on_position(styled, styled.indexOf(matchs[0]) + matchs[0].length, `<mstyle displaystyle="true" mathcolor="${color2hexrgb(this.color)}" ${this.font.includes("bold") ? 'mathvariant="bold"' : ""}>`);
    matchs = styled.match(/<\/[^>]*?math.*?>/s);
    if (matchs == null) {
      return this.text.trim();
    }
    return insert_text_on_position(styled, styled.indexOf(matchs[0]), "</mstyle>");
  }
  _process_text() {
    var _a34;
    const fmetrics = font_metrics(this.font);
    return (_a34 = this.provider.MathJax) == null ? void 0 : _a34.mathml2svg(this.styled_text, {
      em: this.base_font_size,
      ex: fmetrics.x_height
    });
  }
};
__publicField(MathMLView, "__name__", "MathMLView");
var _MathML = class _MathML extends MathText {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MathML, "__name__", "MathML");
_MathML.prototype.default_view = MathMLView;
var MathML = _MathML;
var TeXView = class extends MathTextView {
  get styled_text() {
    const [r, g, b2] = color2rgba(this.color);
    return `\\color[RGB]{${r}, ${g}, ${b2}} ${this.font.includes("bold") ? `\\boldsymbol{${this.text}}` : this.text}`;
  }
  _process_text() {
    var _a34;
    const fmetrics = font_metrics(this.font);
    return (_a34 = this.provider.MathJax) == null ? void 0 : _a34.tex2svg(this.styled_text, {
      display: !this.model.inline,
      em: this.base_font_size,
      ex: fmetrics.x_height
    }, to_object(this.model.macros));
  }
};
__publicField(TeXView, "__name__", "TeXView");
var _TeX = class _TeX extends MathText {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TeX, "__name__", "TeX");
_TeX.prototype.default_view = TeXView;
_TeX.define(({ Bool: Bool2, Float: Float2, Str: Str2, Dict: Dict2, Tuple: Tuple2, Or: Or2 }) => ({
  macros: [Dict2(Or2(Str2, Tuple2(Str2, Float2))), {}],
  inline: [Bool2, false]
}));
var TeX = _TeX;

// node_modules/@bokeh/bokehjs/build/js/lib/models/text/plain_text.js
var PlainTextView = class extends BaseTextView {
  initialize() {
    super.initialize();
    this._has_finished = true;
  }
  graphics() {
    return new TextBox({ text: this.model.text });
  }
};
__publicField(PlainTextView, "__name__", "PlainTextView");
var _PlainText = class _PlainText extends BaseText {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PlainText, "__name__", "PlainText");
_PlainText.prototype.default_view = PlainTextView;
var PlainText = _PlainText;

// node_modules/@bokeh/bokehjs/build/js/lib/models/text/utils.js
var delimiters = [
  { start: "$$", end: "$$", inline: false },
  { start: "\\[", end: "\\]", inline: false },
  { start: "\\(", end: "\\)", inline: true }
];
function add_backslash(m) {
  return m.split("").map((s2) => `\\${s2}`).join("");
}
function parse_delimited_string(text2) {
  const matches = [];
  for (const delim of delimiters) {
    const start2 = add_backslash(delim.start);
    const end = add_backslash(delim.end);
    const re = new RegExp(`${start2}([^]*?)${end}`, "gm");
    for (const match2 of text2.matchAll(re)) {
      const { index: index2 } = match2;
      const [outer, inner3] = match2;
      matches.push({ index: index2, outer, inner: inner3, delim });
    }
  }
  if (matches.length > 0) {
    if (matches.length == 1) {
      const [match2] = matches;
      const start2 = match2.index;
      const end2 = match2.outer.length;
      if (start2 == 0 && end2 == text2.length) {
        const tex_string2 = match2.inner;
        return new TeX({ text: tex_string2, inline: match2.delim.inline });
      }
    }
    let tex_string = "";
    let end = 0;
    for (const match2 of sort_by(matches, (match3) => match3.index)) {
      const start2 = match2.index;
      if (end <= start2) {
        tex_string += start2 != 0 ? `\\text{${text2.slice(end, start2)}}${match2.inner}` : `${match2.inner}`;
        end = start2 + match2.outer.length;
      }
    }
    tex_string += end < text2.length ? `\\text{${text2.slice(end)}}` : "";
    return new TeX({ text: tex_string, inline: false });
  } else {
    return new PlainText({ text: text2 });
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/common/kinds.js
var Length = NonNegative(Int);
var XY2 = (type) => PartialStruct({ x: type, y: type });
var LRTB = (type) => PartialStruct({ left: type, right: type, top: type, bottom: type });
var HAnchor = Or(Align, HAlign, Percent);
var VAnchor = Or(Align, VAlign, Percent);
var Anchor2 = Or(Anchor, Tuple(HAnchor, VAnchor));
var AutoAnchor = Or(Auto, Anchor, Tuple(Or(HAnchor, Auto), Or(VAnchor, Auto)));
var TextAnchor = Or(Anchor2, Auto);
var Padding = Or(Length, Tuple(Length, Length), XY2(Length), Tuple(Length, Length, Length, Length), LRTB(Length));
var BorderRadius = Or(Length, Tuple(Length, Length, Length, Length), PartialStruct({
  top_left: Length,
  top_right: Length,
  bottom_right: Length,
  bottom_left: Length
}));
var Index = NonNegative(Int);
var Span = NonNegative(Int);
var GridChild = (child) => Tuple(Ref(child), Index, Index, Opt(Span), Opt(Span));
var GridSpacing = Or(Length, Tuple(Length, Length));
var TrackAlign = Enum("start", "center", "end", "auto");
var TrackSize = Str;
var TrackSizing = PartialStruct({ size: TrackSize, align: TrackAlign });
var TrackSizingLike = Or(TrackSize, TrackSizing);
var TracksSizing = Or(TrackSizingLike, List(TrackSizingLike), Mapping(Int, TrackSizingLike));

// node_modules/@bokeh/bokehjs/build/js/lib/models/common/resolve.js
function normalized_anchor(anchor2) {
  if (anchor2 == "auto") {
    return { x: "auto", y: "auto" };
  }
  const normalized = (() => {
    switch (anchor2) {
      case "top":
        return "top_center";
      case "bottom":
        return "bottom_center";
      case "left":
        return "center_left";
      case "center":
        return "center_center";
      case "right":
        return "center_right";
      default:
        return anchor2;
    }
  })();
  if (isString(normalized)) {
    const [y2, x2] = normalized.split("_");
    return { x: x2, y: y2 };
  } else {
    const [x2, y2] = normalized;
    return { x: x2, y: y2 };
  }
}
function anchor(anchor2) {
  const { x: x2, y: y2 } = normalized_anchor(anchor2);
  const x_anchor = (() => {
    switch (x2) {
      case "start":
      case "left":
        return 0;
      case "center":
        return 0.5;
      case "end":
      case "right":
        return 1;
      default:
        return x2;
    }
  })();
  const y_anchor = (() => {
    switch (y2) {
      case "start":
      case "top":
        return 0;
      case "center":
        return 0.5;
      case "end":
      case "bottom":
        return 1;
      default:
        return y2;
    }
  })();
  return { x: x_anchor, y: y_anchor };
}
function text_anchor(text_anchor2, align, baseline) {
  if (text_anchor2 != "auto") {
    return anchor(text_anchor2);
  } else {
    const x_anchor = (() => {
      switch (align) {
        case "left":
          return "start";
        case "center":
          return "center";
        case "right":
          return "end";
      }
    })();
    const y_anchor = (() => {
      switch (baseline) {
        case "alphabetic":
        case "ideographic":
        case "hanging":
          return "center";
        case "top":
          return "start";
        case "middle":
          return "center";
        case "bottom":
          return "end";
      }
    })();
    return anchor([x_anchor, y_anchor]);
  }
}
function padding(padding2) {
  if (isNumber(padding2)) {
    return { left: padding2, right: padding2, top: padding2, bottom: padding2 };
  } else if (isPlainObject(padding2)) {
    if ("x" in padding2 || "y" in padding2) {
      const { x: x2 = 0, y: y2 = 0 } = padding2;
      return { left: x2, right: x2, top: y2, bottom: y2 };
    } else if ("left" in padding2 || "right" in padding2 || "top" in padding2 || "bottom" in padding2) {
      const { left: left2 = 0, right: right3 = 0, top = 0, bottom = 0 } = padding2;
      return { left: left2, right: right3, top, bottom };
    } else {
      unreachable();
    }
  } else {
    if (padding2.length == 2) {
      const [x2 = 0, y2 = 0] = padding2;
      return { left: x2, right: x2, top: y2, bottom: y2 };
    } else {
      const [left2 = 0, right3 = 0, top = 0, bottom = 0] = padding2;
      return { left: left2, right: right3, top, bottom };
    }
  }
}
function border_radius(border_radius2) {
  if (isNumber(border_radius2)) {
    return {
      top_left: border_radius2,
      top_right: border_radius2,
      bottom_right: border_radius2,
      bottom_left: border_radius2
    };
  } else if (isPlainObject(border_radius2)) {
    return {
      top_left: border_radius2.top_left ?? 0,
      top_right: border_radius2.top_right ?? 0,
      bottom_right: border_radius2.bottom_right ?? 0,
      bottom_left: border_radius2.bottom_left ?? 0
    };
  } else {
    const [top_left = 0, top_right = 0, bottom_right = 0, bottom_left = 0] = border_radius2;
    return { top_left, top_right, bottom_right, bottom_left };
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/common/painting.js
function round_rect(ctx, bbox, border_radius2) {
  let { top_left, top_right, bottom_right, bottom_left } = border_radius2;
  if (top_left != 0 || top_right != 0 || bottom_right != 0 || bottom_left != 0) {
    const { left: left2, right: right3, top, bottom, width, height } = bbox;
    const scale = Math.min(width / (top_left + top_right), height / (top_right + bottom_right), width / (bottom_right + bottom_left), height / (top_left + bottom_left));
    if (scale < 1) {
      top_left *= scale;
      top_right *= scale;
      bottom_right *= scale;
      bottom_left *= scale;
    }
    ctx.moveTo(left2 + top_left, top);
    ctx.lineTo(right3 - top_right, top);
    if (top_right != 0) {
      ctx.arcTo(right3, top, right3, top + top_right, top_right);
    }
    ctx.lineTo(right3, bottom - bottom_right);
    if (bottom_right != 0) {
      ctx.arcTo(right3, bottom, right3 - bottom_right, bottom, bottom_right);
    }
    ctx.lineTo(left2 + bottom_left, bottom);
    if (bottom_left != 0) {
      ctx.arcTo(left2, bottom, left2, bottom - bottom_left, bottom_left);
    }
    ctx.lineTo(left2, top + top_left);
    if (top_left != 0) {
      ctx.arcTo(left2, top, left2 + top_left, top, top_left);
    }
    ctx.closePath();
  } else {
    const { left: left2, top, width, height } = bbox;
    ctx.rect(left2, top, width, height);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/text_annotation.js
var TextAnnotationView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_text_view");
    __publicField(this, "_text_box");
    __publicField(this, "_rect");
  }
  *children() {
    yield* super.children();
    yield this._text_view;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._init_text();
  }
  async _init_text() {
    const { text: text2 } = this.model;
    const _text = isString(text2) ? parse_delimited_string(text2) : text2;
    this._text_view = await build_view(_text, { parent: this });
  }
  update_layout() {
    const { panel } = this;
    if (panel != null) {
      this.layout = new SideLayout(panel, () => this.get_size(), false);
    } else {
      this.layout = void 0;
    }
  }
  connect_signals() {
    super.connect_signals();
    const { text: text2 } = this.model.properties;
    this.on_change(text2, async () => {
      this._text_view.remove();
      await this._init_text();
    });
    this.connect(this.model.change, () => this.request_paint());
  }
  remove() {
    this._text_view.remove();
    super.remove();
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    if (!this._text_view.has_finished()) {
      return false;
    }
    return true;
  }
  get displayed() {
    return super.displayed && this._text_view.model.text != "" && this.visuals.text.doit;
  }
  get padding() {
    return padding(this.model.padding);
  }
  get border_radius() {
    return border_radius(this.model.border_radius);
  }
  _get_size() {
    if (!this.displayed) {
      return { width: 0, height: 0 };
    }
    const graphics = this._text_view.graphics();
    graphics.angle = this.angle;
    graphics.align = "auto";
    graphics.visuals = this.visuals.text.values();
    const size2 = graphics.size();
    const { padding: padding2 } = this;
    const width = size2.width + padding2.left + padding2.right;
    const height = size2.height + padding2.top + padding2.bottom;
    return { width, height };
  }
  compute_geometry() {
    super.compute_geometry();
    const text_box = this._text_view.graphics();
    text_box.position = { sx: 0, sy: 0, x_anchor: "left", y_anchor: "top" };
    text_box.angle = 0;
    text_box.align = "auto";
    text_box.visuals = this.visuals.text.values();
    const size2 = text_box.size();
    const { sx, sy } = this.origin;
    const { anchor: anchor2, padding: padding2, border_radius: border_radius2, angle } = this;
    const width = size2.width + padding2.left + padding2.right;
    const height = size2.height + padding2.top + padding2.bottom;
    this._text_box = text_box;
    this._rect = { sx, sy, width, height, angle, anchor: anchor2, padding: padding2, border_radius: border_radius2 };
  }
  _paint() {
    const { ctx } = this.layer;
    const { sx, sy, width, height, angle, anchor: anchor2, padding: padding2, border_radius: border_radius2 } = this._rect;
    const label3 = this._text_box;
    const dx = anchor2.x * width;
    const dy = anchor2.y * height;
    ctx.translate(sx, sy);
    ctx.rotate(angle);
    ctx.translate(-dx, -dy);
    const { background_fill, background_hatch, border_line, text: text2 } = this.visuals;
    if (background_fill.doit || background_hatch.doit || border_line.doit) {
      ctx.beginPath();
      const bbox = new BBox({ x: 0, y: 0, width, height });
      round_rect(ctx, bbox, border_radius2);
      background_fill.apply(ctx);
      background_hatch.apply(ctx);
      border_line.apply(ctx);
    }
    if (text2.doit) {
      const { left: left2, top } = padding2;
      ctx.translate(left2, top);
      label3.paint(ctx);
      ctx.translate(-left2, -top);
    }
    ctx.translate(dx, dy);
    ctx.rotate(-angle);
    ctx.translate(-sx, -sy);
  }
};
__publicField(TextAnnotationView, "__name__", "TextAnnotationView");
var _TextAnnotation = class _TextAnnotation extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TextAnnotation, "__name__", "TextAnnotation");
_TextAnnotation.mixins([
  Text,
  ["border_", Line],
  ["background_", Fill],
  ["background_", Hatch]
]);
_TextAnnotation.define(({ Str: Str2, Or: Or2, Ref: Ref2 }) => ({
  text: [Or2(Str2, Ref2(BaseText)), ""],
  padding: [Padding, 0],
  border_radius: [BorderRadius, 0]
}));
_TextAnnotation.override({
  border_line_color: null,
  background_fill_color: null,
  background_hatch_color: null
});
var TextAnnotation = _TextAnnotation;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/title.js
var TitleView = class extends TextAnnotationView {
  _get_position() {
    const hmargin = this.model.offset;
    const vmargin = this.model.standoff / 2;
    const { align, vertical_align } = this.model;
    let sx, sy;
    const { bbox } = this.layout;
    switch (this.panel.side) {
      case "above":
      case "below": {
        switch (vertical_align) {
          case "top":
            sy = bbox.top + vmargin;
            break;
          case "middle":
            sy = bbox.vcenter;
            break;
          case "bottom":
            sy = bbox.bottom - vmargin;
            break;
        }
        switch (align) {
          case "left":
            sx = bbox.left + hmargin;
            break;
          case "center":
            sx = bbox.hcenter;
            break;
          case "right":
            sx = bbox.right - hmargin;
            break;
        }
        break;
      }
      case "left": {
        switch (vertical_align) {
          case "top":
            sx = bbox.left + vmargin;
            break;
          case "middle":
            sx = bbox.hcenter;
            break;
          case "bottom":
            sx = bbox.right - vmargin;
            break;
        }
        switch (align) {
          case "left":
            sy = bbox.bottom - hmargin;
            break;
          case "center":
            sy = bbox.vcenter;
            break;
          case "right":
            sy = bbox.top + hmargin;
            break;
        }
        break;
      }
      case "right": {
        switch (vertical_align) {
          case "top":
            sx = bbox.right - vmargin;
            break;
          case "middle":
            sx = bbox.hcenter;
            break;
          case "bottom":
            sx = bbox.left + vmargin;
            break;
        }
        switch (align) {
          case "left":
            sy = bbox.top + hmargin;
            break;
          case "center":
            sy = bbox.vcenter;
            break;
          case "right":
            sy = bbox.bottom - hmargin;
            break;
        }
        break;
      }
    }
    return { sx, sy };
  }
  get anchor() {
    const { align, vertical_align } = this.model;
    return text_anchor("auto", align, vertical_align);
  }
  get origin() {
    return this._get_position();
  }
  get angle() {
    return this.panel.get_label_angle_heuristic("parallel");
  }
  _get_size() {
    const offset3 = (value2) => {
      return value2 == 0 ? 0 : 2 + value2 + this.model.standoff;
    };
    const { width, height } = super._get_size();
    if (this.panel.is_horizontal) {
      return { width, height: offset3(height) };
    } else {
      return { width: offset3(width), height };
    }
  }
};
__publicField(TitleView, "__name__", "TitleView");
var _Title = class _Title extends TextAnnotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Title, "__name__", "Title");
_Title.prototype.default_view = TitleView;
_Title.define(({ Float: Float2 }) => ({
  vertical_align: [VerticalAlign, "bottom"],
  align: [TextAlign, "left"],
  offset: [Float2, 0],
  standoff: [Float2, 10]
}));
_Title.override({
  text_font_size: "13px",
  text_font_style: "bold",
  text_line_height: 1
});
var Title = _Title;

// node_modules/@bokeh/bokehjs/build/js/lib/models/canvas/cartesian_frame.js
var CartesianFrameView = class extends StyledElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "_x_target");
    __publicField(this, "_y_target");
    __publicField(this, "_x_ranges", /* @__PURE__ */ new Map());
    __publicField(this, "_y_ranges", /* @__PURE__ */ new Map());
    __publicField(this, "_x_scales", /* @__PURE__ */ new Map());
    __publicField(this, "_y_scales", /* @__PURE__ */ new Map());
    __publicField(this, "_x_scale");
    __publicField(this, "_y_scale");
    __publicField(this, "position", new InlineStyleSheet());
  }
  get bbox() {
    return this._bbox;
  }
  initialize() {
    super.initialize();
    this._configure_scales();
  }
  remove() {
    this._unregister_frame();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const { x_range, y_range, x_scale, y_scale, extra_x_ranges, extra_y_ranges, extra_x_scales, extra_y_scales } = this.model.properties;
    this.on_change([x_range, y_range, x_scale, y_scale, extra_x_ranges, extra_y_ranges, extra_x_scales, extra_y_scales], () => {
      this._configure_scales();
    });
  }
  _get_ranges(range2, extra_ranges) {
    return new Map([...entries(extra_ranges), ["default", range2]]);
  }
  _get_scales(scale, extra_scales, ranges, frame_range) {
    const in_scales = new Map([...entries(extra_scales), ["default", scale]]);
    const scales = /* @__PURE__ */ new Map();
    for (const [name, range2] of ranges) {
      const factor_range = range2 instanceof FactorRange;
      const categorical_scale = scale instanceof CategoricalScale;
      if (factor_range != categorical_scale) {
        throw new Error(`'${range2.type}' is incompatible '${scale.type}'`);
      }
      if (scale instanceof LogScale && range2 instanceof DataRange1d) {
        range2.scale_hint = "log";
      }
      const base_scale = in_scales.get(name) ?? scale;
      const derived_scale = base_scale.clone();
      derived_scale.setv({ source_range: range2, target_range: frame_range });
      scales.set(name, derived_scale);
    }
    return scales;
  }
  _configure_ranges() {
    const { bbox } = this;
    this._x_target = new Range1d({ start: bbox.left, end: bbox.right });
    this._y_target = new Range1d({ start: bbox.bottom, end: bbox.top });
  }
  _configure_scales() {
    const { x_range, y_range, extra_x_ranges, extra_y_ranges } = this.model;
    const { x_scale, y_scale, extra_x_scales, extra_y_scales } = this.model;
    assert(x_scale.properties.source_range.is_unset && x_scale.properties.target_range.is_unset);
    assert(y_scale.properties.source_range.is_unset && y_scale.properties.target_range.is_unset);
    this._configure_ranges();
    this._unregister_frame();
    this._x_ranges = this._get_ranges(x_range, extra_x_ranges);
    this._y_ranges = this._get_ranges(y_range, extra_y_ranges);
    this._register_frame();
    this._x_scales = this._get_scales(x_scale, extra_x_scales, this._x_ranges, this._x_target);
    this._y_scales = this._get_scales(y_scale, extra_y_scales, this._y_ranges, this._y_target);
    this._x_scale = this._x_scales.get("default");
    this._y_scale = this._y_scales.get("default");
    this.mark_finished();
  }
  _update_scales() {
    this._configure_ranges();
    for (const [, scale] of this._x_scales) {
      scale.target_range = this._x_target;
    }
    for (const [, scale] of this._y_scales) {
      scale.target_range = this._y_target;
    }
  }
  _register_frame() {
    for (const range2 of this.ranges.values()) {
      range2.frames.add(this);
    }
  }
  _unregister_frame() {
    for (const range2 of this.ranges.values()) {
      range2.frames.delete(this);
    }
  }
  set_geometry(bbox) {
    this._bbox = bbox;
    this._update_scales();
    this._update_position();
  }
  get x_range() {
    return this.model.x_range;
  }
  get y_range() {
    return this.model.y_range;
  }
  get x_target() {
    return this._x_target;
  }
  get y_target() {
    return this._y_target;
  }
  get x_ranges() {
    return this._x_ranges;
  }
  get y_ranges() {
    return this._y_ranges;
  }
  get ranges() {
    return /* @__PURE__ */ new Set([...this.x_ranges.values(), ...this.y_ranges.values()]);
  }
  get x_scales() {
    return this._x_scales;
  }
  get y_scales() {
    return this._y_scales;
  }
  get scales() {
    return /* @__PURE__ */ new Set([...this.x_scales.values(), ...this.y_scales.values()]);
  }
  get x_scale() {
    return this._x_scale;
  }
  get y_scale() {
    return this._y_scale;
  }
  // TODO remove this when bbox handling is unified
  resolve_symbol(node) {
    const target = this;
    const value2 = target.bbox.resolve(node.symbol);
    const { offset: offset3 } = node;
    if (isNumber(value2)) {
      return value2 + offset3;
    } else {
      const { x: x2, y: y2 } = value2;
      return { x: x2 + offset3, y: y2 + offset3 };
    }
  }
  stylesheets() {
    return [...super.stylesheets(), this.position];
  }
  rendering_target() {
    return this.parent.canvas_view.underlays_el;
  }
  /**
   * Updates the position of the associated DOM element.
   */
  _update_position() {
    const { bbox, position: position2 } = this;
    if (bbox.is_valid) {
      position2.replace(`
      :host {
        position: absolute;
        left:     ${bbox.left}px;
        top:      ${bbox.top}px;
        width:    ${bbox.width}px;
        height:   ${bbox.height}px;
      }
      `);
    } else {
      position2.replace(`
      :host {
        display: none;
      }
      `);
    }
  }
};
__publicField(CartesianFrameView, "__name__", "CartesianFrameView");
var _CartesianFrame = class _CartesianFrame extends StyledElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CartesianFrame, "__name__", "CartesianFrame");
_CartesianFrame.prototype.default_view = CartesianFrameView;
_CartesianFrame.define(({ Bool: Bool2, Float: Float2, Dict: Dict2, Ref: Ref2 }) => ({
  x_range: [Ref2(Range), () => new DataRange1d()],
  y_range: [Ref2(Range), () => new DataRange1d()],
  x_scale: [Ref2(Scale), () => new LinearScale()],
  y_scale: [Ref2(Scale), () => new LinearScale()],
  extra_x_ranges: [Dict2(Ref2(Range)), {}],
  extra_y_ranges: [Dict2(Ref2(Range)), {}],
  extra_x_scales: [Dict2(Ref2(Scale)), {}],
  extra_y_scales: [Dict2(Ref2(Scale)), {}],
  match_aspect: [Bool2, false],
  aspect_scale: [Float2, 1]
}));
var CartesianFrame = _CartesianFrame;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/guide_renderer.js
var GuideRendererView = class extends RendererView {
};
__publicField(GuideRendererView, "__name__", "GuideRendererView");
var _GuideRenderer = class _GuideRenderer extends Renderer {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GuideRenderer, "__name__", "GuideRenderer");
_GuideRenderer.override({
  level: "guide"
});
var GuideRenderer = _GuideRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/ticker.js
var Ticker = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Ticker, "__name__", "Ticker");

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/tick_formatter.js
var TickFormatter = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
  format_graphics(ticks, opts) {
    return this.doFormat(ticks, opts).map((text2) => new TextBox({ text: text2 }));
  }
  compute(tick, opts) {
    return this.doFormat([tick], opts ?? { loc: 0 })[0];
  }
  v_compute(tick, opts) {
    return this.doFormat(tick, opts ?? { loc: 0 });
  }
};
__publicField(TickFormatter, "__name__", "TickFormatter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/policies/labeling.js
var LabelingPolicy = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(LabelingPolicy, "__name__", "LabelingPolicy");
var AllLabels = class extends LabelingPolicy {
  constructor(attrs) {
    super(attrs);
  }
  filter(indices, _bboxes, _distance) {
    return indices;
  }
};
__publicField(AllLabels, "__name__", "AllLabels");
var _NoOverlap = class _NoOverlap extends LabelingPolicy {
  constructor(attrs) {
    super(attrs);
  }
  filter(indices, _bboxes, distance) {
    const { min_distance } = this;
    let k = null;
    for (const i2 of indices) {
      if (k != null && distance(k, i2) < min_distance) {
        indices.unset(i2);
      } else {
        k = i2;
      }
    }
    return indices;
  }
};
__publicField(_NoOverlap, "__name__", "NoOverlap");
_NoOverlap.define(({ Float: Float2 }) => ({
  min_distance: [Float2, 5]
}));
var NoOverlap = _NoOverlap;
var _CustomLabelingPolicy = class _CustomLabelingPolicy extends LabelingPolicy {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  get func() {
    const code2 = use_strict(this.code);
    return new GeneratorFunction("indices", "bboxes", "distance", ...this.names, code2);
  }
  filter(indices, bboxes, distance) {
    const obj = /* @__PURE__ */ Object.create(null);
    const generator = this.func.call(obj, indices, bboxes, distance, ...this.values);
    let result = generator.next();
    if ((result.done ?? false) && result.value !== void 0) {
      const { value: value2 } = result;
      if (value2 instanceof BitSet) {
        return value2;
      } else if (value2 === void 0) {
        return indices;
      } else if (isIterable(value2)) {
        return BitSet.from_indices(indices.size, value2);
      } else {
        return BitSet.all_unset(indices.size);
      }
    } else {
      const array2 = [];
      do {
        array2.push(result.value);
        result = generator.next();
      } while (!(result.done ?? false));
      return BitSet.from_indices(indices.size, array2);
    }
  }
};
__publicField(_CustomLabelingPolicy, "__name__", "CustomLabelingPolicy");
_CustomLabelingPolicy.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomLabelingPolicy = _CustomLabelingPolicy;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/axis.js
var LabelOverrides = Or(Dict(Or(Str, Ref(BaseText))), Mapping(Or(Str, Float), Or(Str, Ref(BaseText))));
var { abs: abs2 } = Math;
var AxisView = class extends GuideRendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "layout");
    __publicField(this, "_panel");
    /*private*/
    __publicField(this, "_axis_label_view", null);
    /*private*/
    __publicField(this, "_major_label_views", /* @__PURE__ */ new Map());
  }
  get panel() {
    return this._panel;
  }
  set panel(panel) {
    this._panel = new SidePanel(panel.side, this.model.face);
  }
  get bbox() {
    if (this.layout != null && this.model.fixed_location == null) {
      return this.layout.bbox;
    } else if (this.is_renderable) {
      const { extents } = this;
      const depth = Math.round(extents.tick + extents.tick_label + extents.axis_label);
      let { sx0, sy0, sx1, sy1 } = this.rule_scoords;
      const { dimension, face } = this;
      if (dimension == 0) {
        if (face == "front") {
          sy0 -= depth;
        } else {
          sy1 += depth;
        }
      } else {
        if (face == "front") {
          sx0 -= depth;
        } else {
          sx1 += depth;
        }
      }
      return BBox.from_lrtb({ left: sx0, top: sy0, right: sx1, bottom: sy1 });
    } else {
      return new BBox();
    }
  }
  *children() {
    yield* super.children();
    if (this._axis_label_view != null) {
      yield this._axis_label_view;
    }
    yield* this._major_label_views.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._init_axis_label();
    await this._init_major_labels();
  }
  async _init_axis_label() {
    const { axis_label } = this.model;
    if (axis_label != null) {
      const _axis_label = isString(axis_label) ? parse_delimited_string(axis_label) : axis_label;
      this._axis_label_view = await build_view(_axis_label, { parent: this });
    } else {
      this._axis_label_view = null;
    }
  }
  async _init_major_labels() {
    for (const [label3, label_text] of dict(this.model.major_label_overrides)) {
      const _label_text = isString(label_text) ? parse_delimited_string(label_text) : label_text;
      this._major_label_views.set(label3, await build_view(_label_text, { parent: this }));
    }
  }
  update_layout() {
    this.layout = new SideLayout(this.panel, () => this.get_size(), true);
    this.layout.on_resize(() => {
      this._coordinates = void 0;
    });
  }
  get_size() {
    const { visible, fixed_location } = this.model;
    if (visible && fixed_location == null && this.is_renderable) {
      const { extents } = this;
      const height = Math.round(extents.tick + extents.tick_label + extents.axis_label);
      return { width: 0, height };
    } else {
      return { width: 0, height: 0 };
    }
  }
  get is_renderable() {
    const [range2, cross_range] = this.ranges;
    return super.is_renderable && range2.is_valid && cross_range.is_valid && range2.span > 0 && cross_range.span > 0;
  }
  interactive_hit(sx, sy) {
    return this.bbox.contains(sx, sy);
  }
  on_hit(sx, sy) {
    const value2 = this._hit_value(sx, sy);
    if (value2 != null) {
      this.model.trigger_event(new AxisClick(this.model, value2));
      return true;
    }
    return false;
  }
  _paint() {
    const { tick_coords, extents } = this;
    const ctx = this.layer.ctx;
    this._draw_background(ctx, extents);
    this._draw_rule(ctx, extents);
    this._draw_major_ticks(ctx, extents, tick_coords);
    this._draw_minor_ticks(ctx, extents, tick_coords);
    this._draw_major_labels(ctx, extents, tick_coords);
    this._draw_axis_label(ctx, extents, tick_coords);
  }
  connect_signals() {
    super.connect_signals();
    const { axis_label, major_label_overrides } = this.model.properties;
    this.on_change(axis_label, async () => {
      var _a34;
      (_a34 = this._axis_label_view) == null ? void 0 : _a34.remove();
      await this._init_axis_label();
    });
    this.on_change(major_label_overrides, async () => {
      for (const label_view of this._major_label_views.values()) {
        label_view.remove();
      }
      await this._init_major_labels();
    });
    this.connect(this.model.change, () => this.plot_view.request_layout());
  }
  get needs_clip() {
    return this.model.fixed_location != null;
  }
  // drawing sub functions -----------------------------------------------------
  _draw_background(ctx, _extents) {
    if (!this.visuals.background_fill.doit) {
      return;
    }
    ctx.beginPath();
    const { x: x2, y: y2, width, height } = this.bbox;
    ctx.rect(x2, y2, width, height);
    this.visuals.background_fill.apply(ctx);
  }
  _draw_rule(ctx, _extents) {
    if (!this.visuals.axis_line.doit) {
      return;
    }
    const { sx0, sy0, sx1, sy1 } = this.rule_scoords;
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(sx1, sy1);
    this.visuals.axis_line.apply(ctx);
  }
  _draw_major_ticks(ctx, _extents, tick_coords) {
    const tin = this.model.major_tick_in;
    const tout = this.model.major_tick_out;
    const visuals = this.visuals.major_tick_line;
    this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);
  }
  _draw_minor_ticks(ctx, _extents, tick_coords) {
    const tin = this.model.minor_tick_in;
    const tout = this.model.minor_tick_out;
    const visuals = this.visuals.minor_tick_line;
    this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);
  }
  _draw_major_labels(ctx, extents, tick_coords) {
    const coords = tick_coords.major;
    const labels = this.compute_labels(coords[this.dimension]);
    const orient = this.model.major_label_orientation;
    const standoff = extents.tick + this.model.major_label_standoff;
    const visuals = this.visuals.major_label_text;
    this._draw_oriented_labels(ctx, labels, coords, orient, standoff, visuals);
  }
  _axis_label_extent() {
    if (this._axis_label_view == null) {
      return 0;
    }
    const axis_label_graphics = this._axis_label_view.graphics();
    const padding2 = 3;
    const orient = this.model.axis_label_orientation;
    axis_label_graphics.visuals = this.visuals.axis_label_text.values();
    axis_label_graphics.angle = this.panel.get_label_angle_heuristic(orient);
    axis_label_graphics.base_font_size = this.plot_view.base_font_size;
    const size2 = axis_label_graphics.size();
    const extent = this.dimension == 0 ? size2.height : size2.width;
    const standoff = this.model.axis_label_standoff;
    return extent > 0 ? standoff + extent + padding2 : 0;
  }
  _draw_axis_label(ctx, extents, _tick_coords) {
    if (this._axis_label_view == null) {
      return;
    }
    const [
      sx,
      sy
      /* TODO, x_anchor, y_anchor*/
    ] = (() => {
      const { bbox } = this;
      const { side, face } = this.panel;
      const [range2] = this.ranges;
      const { axis_label_align } = this.model;
      switch (side) {
        case "above":
        case "below": {
          const [sx2, x_anchor] = (() => {
            switch (axis_label_align) {
              case "start":
                return !range2.is_reversed ? [bbox.left, "left"] : [bbox.right, "right"];
              case "center":
                return [bbox.hcenter, "center"];
              case "end":
                return !range2.is_reversed ? [bbox.right, "right"] : [bbox.left, "left"];
            }
          })();
          const [sy2, y_anchor] = face == "front" ? [bbox.bottom, "bottom"] : [bbox.top, "top"];
          return [sx2, sy2, x_anchor, y_anchor];
        }
        case "left":
        case "right": {
          const [sy2, y_anchor] = (() => {
            switch (axis_label_align) {
              case "start":
                return !range2.is_reversed ? [bbox.bottom, "bottom"] : [bbox.top, "top"];
              case "center":
                return [bbox.vcenter, "center"];
              case "end":
                return !range2.is_reversed ? [bbox.top, "top"] : [bbox.bottom, "bottom"];
            }
          })();
          const [sx2, x_anchor] = face == "front" ? [bbox.right, "right"] : [bbox.left, "left"];
          return [sx2, sy2, x_anchor, y_anchor];
        }
      }
    })();
    const [nx, ny] = this.normals;
    const orient = this.model.axis_label_orientation;
    const standoff = extents.tick + extents.tick_label + this.model.axis_label_standoff;
    const { vertical_align, align } = this.panel.get_label_text_heuristics(orient);
    const position2 = {
      sx: sx + nx * standoff,
      sy: sy + ny * standoff,
      x_anchor: align,
      y_anchor: vertical_align
    };
    const axis_label_graphics = this._axis_label_view.graphics();
    axis_label_graphics.visuals = this.visuals.axis_label_text.values();
    axis_label_graphics.angle = this.panel.get_label_angle_heuristic(orient);
    axis_label_graphics.base_font_size = this.plot_view.base_font_size;
    axis_label_graphics.position = position2;
    axis_label_graphics.align = align;
    axis_label_graphics.paint(ctx);
  }
  _draw_ticks(ctx, coords, tin, tout, visuals) {
    if (!visuals.doit) {
      return;
    }
    const [sxs, sys] = this.scoords(coords);
    const [nx, ny] = this.normals;
    const [nxin, nyin] = [nx * -tin, ny * -tin];
    const [nxout, nyout] = [nx * tout, ny * tout];
    visuals.set_value(ctx);
    ctx.beginPath();
    for (let i2 = 0; i2 < sxs.length; i2++) {
      const sx0 = Math.round(sxs[i2] + nxout);
      const sy0 = Math.round(sys[i2] + nyout);
      const sx1 = Math.round(sxs[i2] + nxin);
      const sy1 = Math.round(sys[i2] + nyin);
      ctx.moveTo(sx0, sy0);
      ctx.lineTo(sx1, sy1);
    }
    ctx.stroke();
  }
  _draw_oriented_labels(ctx, labels, coords, orient, standoff, visuals) {
    if (!visuals.doit || labels.length == 0) {
      return;
    }
    const [sxs, sys] = this.scoords(coords);
    const [nx, ny] = this.normals;
    const nxd = nx * standoff;
    const nyd = ny * standoff;
    const { vertical_align, align } = this.panel.get_label_text_heuristics(orient);
    const angle = this.panel.get_label_angle_heuristic(orient);
    labels.visuals = visuals.values();
    labels.angle = angle;
    labels.base_font_size = this.plot_view.base_font_size;
    for (let i2 = 0; i2 < labels.length; i2++) {
      const label3 = labels.items[i2];
      label3.position = {
        sx: sxs[i2] + nxd,
        sy: sys[i2] + nyd,
        x_anchor: align,
        y_anchor: vertical_align
      };
      if (label3 instanceof TextBox) {
        label3.align = align;
      }
    }
    const n2 = labels.length;
    const indices = BitSet.all_set(n2);
    const { items } = labels;
    const bboxes = items.map((l) => l.bbox());
    const dist = (() => {
      const [range2] = this.ranges;
      if (!range2.is_reversed) {
        return this.dimension == 0 ? (i2, j) => bboxes[j].left - bboxes[i2].right : (i2, j) => bboxes[i2].top - bboxes[j].bottom;
      } else {
        return this.dimension == 0 ? (i2, j) => bboxes[i2].left - bboxes[j].right : (i2, j) => bboxes[j].top - bboxes[i2].bottom;
      }
    })();
    const { major_label_policy } = this.model;
    const selected = major_label_policy.filter(indices, bboxes, dist);
    const ids = [...selected.ones()];
    if (ids.length != 0) {
      const cbox = this.canvas.bbox;
      const correct_x = (k) => {
        const bbox = bboxes[k];
        if (bbox.left < 0) {
          const offset3 = -bbox.left;
          const { position: position2 } = items[k];
          items[k].position = { ...position2, sx: position2.sx + offset3 };
        } else if (bbox.right > cbox.width) {
          const offset3 = bbox.right - cbox.width;
          const { position: position2 } = items[k];
          items[k].position = { ...position2, sx: position2.sx - offset3 };
        }
      };
      const correct_y = (k) => {
        const bbox = bboxes[k];
        if (bbox.top < 0) {
          const offset3 = -bbox.top;
          const { position: position2 } = items[k];
          items[k].position = { ...position2, sy: position2.sy + offset3 };
        } else if (bbox.bottom > cbox.height) {
          const offset3 = bbox.bottom - cbox.height;
          const { position: position2 } = items[k];
          items[k].position = { ...position2, sy: position2.sy - offset3 };
        }
      };
      const i2 = ids[0];
      const j = ids[ids.length - 1];
      if (this.dimension == 0) {
        correct_x(i2);
        correct_x(j);
      } else {
        correct_y(i2);
        correct_y(j);
      }
    }
    for (const i2 of selected) {
      const label3 = items[i2];
      label3.paint(ctx);
    }
  }
  // extents sub functions -----------------------------------------------------
  /*protected*/
  _tick_extent() {
    const { major, minor } = this.tick_coords;
    const i2 = this.dimension;
    return Math.max(major[i2].length == 0 ? 0 : this.model.major_tick_out, minor[i2].length == 0 ? 0 : this.model.minor_tick_out);
  }
  _tick_label_extents() {
    const coords = this.tick_coords.major;
    const labels = this.compute_labels(coords[this.dimension]);
    const orient = this.model.major_label_orientation;
    const standoff = this.model.major_label_standoff;
    const visuals = this.visuals.major_label_text;
    return [this._oriented_labels_extent(labels, orient, standoff, visuals)];
  }
  get extents() {
    const tick_labels = this._tick_label_extents();
    return {
      tick: this._tick_extent(),
      tick_labels,
      tick_label: sum(tick_labels),
      axis_label: this._axis_label_extent()
    };
  }
  _oriented_labels_extent(labels, orient, standoff, visuals) {
    if (labels.length == 0 || !visuals.doit) {
      return 0;
    }
    const angle = this.panel.get_label_angle_heuristic(orient);
    labels.visuals = visuals.values();
    labels.angle = angle;
    labels.base_font_size = this.plot_view.base_font_size;
    const size2 = labels.max_size();
    const extent = this.dimension == 0 ? size2.height : size2.width;
    const padding2 = 3;
    return extent > 0 ? standoff + extent + padding2 : 0;
  }
  // {{{ TODO: state
  get normals() {
    return this.panel.normals;
  }
  get dimension() {
    return this.panel.dimension;
  }
  compute_labels(ticks) {
    const labels = this.model.formatter.format_graphics(ticks, this);
    const { _major_label_views } = this;
    const visited = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < ticks.length; i2++) {
      const override = _major_label_views.get(ticks[i2]);
      if (override != null) {
        visited.add(override);
        labels[i2] = override.graphics();
      }
    }
    for (const label_view of this._major_label_views.values()) {
      if (!visited.has(label_view)) {
        label_view._has_finished = true;
      }
    }
    return new GraphicsBoxes(labels);
  }
  scoords(coords) {
    const [x2, y2] = coords;
    const [sxs, sys] = this.coordinates.map_to_screen(x2, y2);
    if (this.model.fixed_location != null) {
      return [[...sxs], [...sys]];
    } else {
      const { bbox } = this;
      const { face } = this.panel;
      if (this.panel.is_vertical) {
        const sx = face == "front" ? bbox.right : bbox.left;
        return [repeat(sx, sxs.length), [...sys]];
      } else {
        const sy = face == "front" ? bbox.bottom : bbox.top;
        return [[...sxs], repeat(sy, sys.length)];
      }
    }
  }
  get ranges() {
    const i2 = this.dimension;
    const j = 1 - i2;
    const { ranges } = this.coordinates;
    return [ranges[i2], ranges[j]];
  }
  get computed_bounds() {
    const [range2] = this.ranges;
    const user_bounds = this.model.bounds;
    const range_bounds = [range2.min, range2.max];
    if (user_bounds == "auto") {
      return [range2.min, range2.max];
    } else {
      let start2;
      let end;
      const [user_start, user_end] = user_bounds;
      const [range_start, range_end] = range_bounds;
      const { min: min10, max: max18 } = Math;
      if (abs2(user_start - user_end) > abs2(range_start - range_end)) {
        start2 = max18(min10(user_start, user_end), range_start);
        end = min10(max18(user_start, user_end), range_end);
      } else {
        start2 = min10(user_start, user_end);
        end = max18(user_start, user_end);
      }
      return [start2, end];
    }
  }
  get rule_coords() {
    const i2 = this.dimension;
    const j = 1 - i2;
    const [range2] = this.ranges;
    const [start2, end] = this.computed_bounds;
    const xs = new Array(2);
    const ys = new Array(2);
    const coords = [xs, ys];
    coords[i2][0] = Math.max(start2, range2.min);
    coords[i2][1] = Math.min(end, range2.max);
    if (coords[i2][0] > coords[i2][1]) {
      coords[i2][0] = coords[i2][1] = NaN;
    }
    coords[j][0] = this.loc;
    coords[j][1] = this.loc;
    return coords;
  }
  get rule_scoords() {
    const [[sx0, sx1], [sy0, sy1]] = this.scoords(this.rule_coords);
    return {
      sx0: Math.round(sx0),
      sy0: Math.round(sy0),
      sx1: Math.round(sx1),
      sy1: Math.round(sy1)
    };
  }
  get tick_coords() {
    const i2 = this.dimension;
    const j = 1 - i2;
    const [range2] = this.ranges;
    const [start2, end] = this.computed_bounds;
    const ticks = this.model.ticker.get_ticks(start2, end, range2, this.loc);
    const majors = ticks.major;
    const minors = ticks.minor;
    const xs = [];
    const ys = [];
    const coords = [xs, ys];
    const minor_xs = [];
    const minor_ys = [];
    const minor_coords = [minor_xs, minor_ys];
    const [range_min, range_max] = [range2.min, range2.max];
    for (let ii = 0; ii < majors.length; ii++) {
      if (majors[ii] < range_min || majors[ii] > range_max) {
        continue;
      }
      coords[i2].push(majors[ii]);
      coords[j].push(this.loc);
    }
    for (let ii = 0; ii < minors.length; ii++) {
      if (minors[ii] < range_min || minors[ii] > range_max) {
        continue;
      }
      minor_coords[i2].push(minors[ii]);
      minor_coords[j].push(this.loc);
    }
    return {
      major: coords,
      minor: minor_coords
    };
  }
  get loc() {
    const { fixed_location } = this.model;
    if (fixed_location != null) {
      if (isNumber(fixed_location)) {
        return fixed_location;
      }
      const [, cross_range2] = this.ranges;
      if (cross_range2 instanceof FactorRange) {
        return cross_range2.synthetic(fixed_location);
      }
      unreachable();
    }
    const [, cross_range] = this.ranges;
    switch (this.panel.side) {
      case "left":
      case "below":
        return cross_range.start;
      case "right":
      case "above":
        return cross_range.end;
    }
  }
  get face() {
    return this.panel.face;
  }
  // }}}
  remove() {
    var _a34;
    (_a34 = this._axis_label_view) == null ? void 0 : _a34.remove();
    for (const label_view of this._major_label_views.values()) {
      label_view.remove();
    }
    super.remove();
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    if (this._axis_label_view != null) {
      if (!this._axis_label_view.has_finished()) {
        return false;
      }
    }
    for (const label_view of this._major_label_views.values()) {
      if (!label_view.has_finished()) {
        return false;
      }
    }
    return true;
  }
};
__publicField(AxisView, "__name__", "AxisView");
var _Axis = class _Axis extends GuideRenderer {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Axis, "__name__", "Axis");
_Axis.mixins([
  ["axis_", Line],
  ["major_tick_", Line],
  ["minor_tick_", Line],
  ["major_label_", Text],
  ["axis_label_", Text],
  ["background_", Fill]
]);
_Axis.define(({ Any: Any2, Int: Int2, Float: Float2, Str: Str2, Ref: Ref2, Tuple: Tuple2, Or: Or2, Nullable: Nullable2, Auto: Auto2, Enum: Enum2 }) => ({
  dimension: [Or2(Enum2(0, 1), Auto2), "auto"],
  face: [Or2(Face, Auto2), "auto"],
  bounds: [Or2(Tuple2(Float2, Float2), Auto2), "auto"],
  ticker: [Ref2(Ticker)],
  formatter: [Ref2(TickFormatter)],
  axis_label: [Nullable2(Or2(Str2, Ref2(BaseText))), null],
  axis_label_standoff: [Int2, 5],
  axis_label_orientation: [Or2(LabelOrientation, Float2), "parallel"],
  axis_label_align: [Align, "center"],
  major_label_standoff: [Int2, 5],
  major_label_orientation: [Or2(LabelOrientation, Float2), "horizontal"],
  major_label_overrides: [LabelOverrides, /* @__PURE__ */ new Map()],
  major_label_policy: [Ref2(LabelingPolicy), () => new AllLabels()],
  major_tick_in: [Float2, 2],
  major_tick_out: [Float2, 6],
  minor_tick_in: [Float2, 0],
  minor_tick_out: [Float2, 4],
  fixed_location: [Nullable2(Or2(Float2, Any2)), null]
}));
_Axis.override({
  axis_line_color: "black",
  major_tick_line_color: "black",
  minor_tick_line_color: "black",
  major_label_text_font_size: "11px",
  major_label_text_align: "center",
  // XXX: remove
  major_label_text_baseline: "alphabetic",
  // XXX: remove
  axis_label_text_font_size: "13px",
  axis_label_text_font_style: "italic",
  background_fill_color: null
});
var Axis = _Axis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/continuous_axis.js
var ContinuousAxisView = class extends AxisView {
  _hit_value(sx, sy) {
    const [range2] = this.ranges;
    const { start: start2, end, span: span2 } = range2;
    switch (this.dimension) {
      case 0: {
        const { x0, width } = this.bbox;
        return span2 * (sx - x0) / width + start2;
      }
      case 1: {
        const { y0, height } = this.bbox;
        return end - span2 * (sy - y0) / height;
      }
    }
  }
};
__publicField(ContinuousAxisView, "__name__", "ContinuousAxisView");
var ContinuousAxis = class extends Axis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(ContinuousAxis, "__name__", "ContinuousAxis");

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/basic_tick_formatter.js
function unicode_replace(input12) {
  let output2 = "";
  for (const c of input12) {
    if (c == "-") {
      output2 += "−";
    } else {
      output2 += c;
    }
  }
  return output2;
}
var _BasicTickFormatter = class _BasicTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "last_precision", 3);
  }
  get scientific_limit_low() {
    return 10 ** this.power_limit_low;
  }
  get scientific_limit_high() {
    return 10 ** this.power_limit_high;
  }
  _need_sci(ticks) {
    if (!this.use_scientific) {
      return false;
    }
    const { scientific_limit_high } = this;
    const { scientific_limit_low } = this;
    const zeroish = ticks.length < 2 ? 0 : Math.abs(ticks[1] - ticks[0]) / 1e4;
    for (const tick of ticks) {
      const tick_abs = Math.abs(tick);
      if (tick_abs <= zeroish) {
        continue;
      }
      if (tick_abs >= scientific_limit_high || tick_abs <= scientific_limit_low) {
        return true;
      }
    }
    return false;
  }
  _format_with_precision(ticks, need_sci, precision) {
    if (need_sci) {
      return ticks.map((tick) => unicode_replace(tick.toExponential(precision)));
    } else {
      return ticks.map((tick) => unicode_replace(to_fixed(tick, precision)));
    }
  }
  _auto_precision(ticks, need_sci) {
    const labels = new Array(ticks.length);
    const asc = this.last_precision <= 15;
    outer: for (let x2 = this.last_precision; asc ? x2 <= 15 : x2 >= 1; asc ? x2++ : x2--) {
      if (need_sci) {
        labels[0] = ticks[0].toExponential(x2);
        for (let i2 = 1; i2 < ticks.length; i2++) {
          if (labels[i2] == labels[i2 - 1]) {
            continue outer;
          }
        }
        this.last_precision = x2;
        break;
      } else {
        labels[0] = to_fixed(ticks[0], x2);
        for (let i2 = 1; i2 < ticks.length; i2++) {
          labels[i2] = to_fixed(ticks[i2], x2);
          if (labels[i2] == labels[i2 - 1]) {
            continue outer;
          }
        }
        this.last_precision = x2;
        break;
      }
    }
    return this.last_precision;
  }
  doFormat(ticks, _opts) {
    if (ticks.length == 0) {
      return [];
    }
    const need_sci = this._need_sci(ticks);
    const precision = this.precision == "auto" ? this._auto_precision(ticks, need_sci) : this.precision;
    return this._format_with_precision(ticks, need_sci, precision);
  }
};
__publicField(_BasicTickFormatter, "__name__", "BasicTickFormatter");
_BasicTickFormatter.define(({ Bool: Bool2, Int: Int2, Auto: Auto2, Or: Or2 }) => ({
  precision: [Or2(Int2, Auto2), "auto"],
  use_scientific: [Bool2, true],
  power_limit_high: [Int2, 5],
  power_limit_low: [Int2, -3]
}));
var BasicTickFormatter = _BasicTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/continuous_ticker.js
var _ContinuousTicker = class _ContinuousTicker extends Ticker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks(data_low, data_high, _range, cross_loc) {
    return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);
  }
  // The version of get_ticks() that does the work (and the version that
  // should be overridden in subclasses).
  get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {
    const interval = this.get_interval(data_low, data_high, desired_n_ticks);
    const start_factor = Math.floor(data_low / interval);
    const end_factor = Math.ceil(data_high / interval);
    let factors;
    if (!isFinite(start_factor) || !isFinite(end_factor)) {
      factors = [];
    } else {
      factors = range(start_factor, end_factor + 1);
    }
    const ticks = factors.map((factor) => factor * interval).filter((tick) => data_low <= tick && tick <= data_high);
    const num_minor_ticks = this.num_minor_ticks;
    const minor_ticks = [];
    if (num_minor_ticks > 0 && ticks.length > 0) {
      const minor_interval = interval / num_minor_ticks;
      const minor_offsets = range(0, num_minor_ticks).map((i2) => i2 * minor_interval);
      for (const x2 of minor_offsets.slice(1)) {
        const mt = ticks[0] - x2;
        if (data_low <= mt && mt <= data_high) {
          minor_ticks.push(mt);
        }
      }
      for (const tick of ticks) {
        for (const x2 of minor_offsets) {
          const mt = tick + x2;
          if (data_low <= mt && mt <= data_high) {
            minor_ticks.push(mt);
          }
        }
      }
    }
    return {
      major: ticks,
      minor: minor_ticks
    };
  }
  // Returns the interval size that would produce exactly the number of
  // desired ticks.  (In general we won't use exactly this interval, because
  // we want the ticks to be round numbers.)
  get_ideal_interval(data_low, data_high, desired_n_ticks) {
    const data_range = data_high - data_low;
    return data_range / desired_n_ticks;
  }
};
__publicField(_ContinuousTicker, "__name__", "ContinuousTicker");
_ContinuousTicker.define(({ Int: Int2 }) => ({
  num_minor_ticks: [Int2, 5],
  desired_num_ticks: [Int2, 6]
}));
var ContinuousTicker = _ContinuousTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/adaptive_ticker.js
var _AdaptiveTicker = class _AdaptiveTicker extends ContinuousTicker {
  constructor(attrs) {
    super(attrs);
  }
  get_min_interval() {
    return this.min_interval;
  }
  get_max_interval() {
    return this.max_interval ?? Infinity;
  }
  // These arguments control the range of possible intervals. The interval I
  // returned by get_interval() will be the one that most closely matches the
  // desired number of ticks, subject to the following constraints:
  // I = (M * B^N), where
  // M is a member of mantissas,
  // B is base,
  // and N is an integer;
  // and min_interval <= I <= max_interval.
  get extended_mantissas() {
    const prefix_mantissa = nth(this.mantissas, -1) / this.base;
    const suffix_mantissa = nth(this.mantissas, 0) * this.base;
    return [prefix_mantissa, ...this.mantissas, suffix_mantissa];
  }
  get base_factor() {
    return this.get_min_interval() == 0 ? 1 : this.get_min_interval();
  }
  get_interval(data_low, data_high, desired_n_ticks) {
    const data_range = data_high - data_low;
    const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
    const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));
    const ideal_magnitude = this.base ** interval_exponent * this.base_factor;
    const candidate_mantissas = this.extended_mantissas;
    const errors = candidate_mantissas.map((mantissa) => {
      return Math.abs(desired_n_ticks - data_range / (mantissa * ideal_magnitude));
    });
    const best_mantissa = candidate_mantissas[argmin(errors)];
    const interval = best_mantissa * ideal_magnitude;
    return clamp(interval, this.get_min_interval(), this.get_max_interval());
  }
};
__publicField(_AdaptiveTicker, "__name__", "AdaptiveTicker");
_AdaptiveTicker.define(({ Float: Float2, List: List2, Nullable: Nullable2 }) => ({
  base: [Float2, 10],
  mantissas: [List2(Float2), [1, 2, 5]],
  min_interval: [Float2, 0],
  max_interval: [Nullable2(Float2), null]
}));
var AdaptiveTicker = _AdaptiveTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/basic_ticker.js
var BasicTicker = class extends AdaptiveTicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(BasicTicker, "__name__", "BasicTicker");

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/linear_axis.js
var LinearAxisView = class extends ContinuousAxisView {
};
__publicField(LinearAxisView, "__name__", "LinearAxisView");
var _LinearAxis = class _LinearAxis extends ContinuousAxis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LinearAxis, "__name__", "LinearAxis");
_LinearAxis.prototype.default_view = LinearAxisView;
_LinearAxis.override({
  ticker: () => new BasicTicker(),
  formatter: () => new BasicTickFormatter()
});
var LinearAxis = _LinearAxis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/categorical_ticker.js
var CategoricalTicker = class extends Ticker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks(start2, end, range2, _cross_loc) {
    const majors = this._collect(range2.factors, range2, start2, end);
    const tops = this._collect(range2.mapper.tops ?? [], range2, start2, end);
    const mids = this._collect(range2.mapper.mids ?? [], range2, start2, end);
    return { major: majors, minor: [], tops, mids };
  }
  _collect(factors, range2, start2, end) {
    const result = [];
    for (const factor of factors) {
      const coord = range2.synthetic(factor);
      if (coord > start2 && coord < end) {
        result.push(factor);
      }
    }
    return result;
  }
};
__publicField(CategoricalTicker, "__name__", "CategoricalTicker");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/composite_ticker.js
var _CompositeTicker = class _CompositeTicker extends ContinuousTicker {
  constructor(attrs) {
    super(attrs);
  }
  // The tickers should be in order of increasing interval size; specifically,
  // if S comes before T, then it should be the case that
  // S.get_max_interval() < T.get_min_interval().
  // FIXME Enforce this automatically.
  get min_intervals() {
    return this.tickers.map((ticker) => ticker.get_min_interval());
  }
  get max_intervals() {
    return this.tickers.map((ticker) => ticker.get_max_interval());
  }
  get_min_interval() {
    return this.min_intervals[0];
  }
  get_max_interval() {
    return this.max_intervals[0];
  }
  get_best_ticker(data_low, data_high, desired_n_ticks) {
    const data_range = data_high - data_low;
    if (data_range == 0) {
      return this.tickers[0];
    }
    const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
    const ticker_ndxs = [
      sorted_index(this.min_intervals, ideal_interval) - 1,
      sorted_index(this.max_intervals, ideal_interval)
    ];
    const intervals = [
      this.min_intervals[ticker_ndxs[0]],
      this.max_intervals[ticker_ndxs[1]]
    ];
    const errors = intervals.map((interval) => {
      return Math.abs(desired_n_ticks - data_range / interval);
    });
    let best_ticker;
    if (is_empty(errors.filter((e) => !isNaN(e)))) {
      best_ticker = this.tickers[0];
    } else {
      const best_index = argmin(errors);
      const best_ticker_ndx = ticker_ndxs[best_index];
      best_ticker = this.tickers[best_ticker_ndx];
    }
    return best_ticker;
  }
  get_interval(data_low, data_high, desired_n_ticks) {
    const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
    return best_ticker.get_interval(data_low, data_high, desired_n_ticks);
  }
  get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {
    const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
    return best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);
  }
};
__publicField(_CompositeTicker, "__name__", "CompositeTicker");
_CompositeTicker.define(({ NonEmptyList, Ref: Ref2 }) => ({
  tickers: [NonEmptyList(Ref2(ContinuousTicker))]
}));
var CompositeTicker = _CompositeTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/customjs_ticker.js
var _CustomJSTicker = class _CustomJSTicker extends Ticker {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  get_ticks(start2, end, range2, cross_loc) {
    const major_cb_data = { start: start2, end, range: range2, cross_loc };
    const major_ticks = this.major_ticks(major_cb_data);
    if (range2 instanceof FactorRange) {
      return { major: major_ticks, minor: [], tops: [], mids: [] };
    }
    const minor_cb_data = { major_ticks, ...major_cb_data };
    const minor_ticks = this.minor_ticks(minor_cb_data);
    return {
      major: major_ticks,
      minor: minor_ticks
    };
  }
  major_ticks(cb_data) {
    if (this.major_code == "") {
      return [];
    }
    const code2 = use_strict(this.major_code);
    const func = new Function("cb_data", ...this.names, code2);
    return func(cb_data, ...this.values);
  }
  minor_ticks(cb_data) {
    if (this.minor_code == "") {
      return [];
    }
    const code2 = use_strict(this.minor_code);
    const func = new Function("cb_data", ...this.names, code2);
    return func(cb_data, ...this.values);
  }
};
__publicField(_CustomJSTicker, "__name__", "CustomJSTicker");
_CustomJSTicker.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  major_code: [Str2, ""],
  minor_code: [Str2, ""]
}));
var CustomJSTicker = _CustomJSTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/single_interval_ticker.js
var BaseSingleIntervalTicker = class extends ContinuousTicker {
  constructor(attrs) {
    super(attrs);
  }
  get_interval(_data_low, _data_high, _n_desired_ticks) {
    return this.interval;
  }
  get_min_interval() {
    return this.interval;
  }
  get_max_interval() {
    return this.interval;
  }
};
__publicField(BaseSingleIntervalTicker, "__name__", "BaseSingleIntervalTicker");
var _SingleIntervalTicker = class _SingleIntervalTicker extends BaseSingleIntervalTicker {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "interval");
  }
};
__publicField(_SingleIntervalTicker, "__name__", "SingleIntervalTicker");
_SingleIntervalTicker.define(({ Float: Float2 }) => ({
  interval: [Float2]
}));
var SingleIntervalTicker = _SingleIntervalTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/util.js
var ONE_MILLI = 1;
var ONE_SECOND = 1e3;
var ONE_MINUTE = 60 * ONE_SECOND;
var ONE_HOUR = 60 * ONE_MINUTE;
var ONE_DAY = 24 * ONE_HOUR;
var ONE_MONTH = 30 * ONE_DAY;
var ONE_YEAR = 365 * ONE_DAY;
function copy_date(date) {
  return new Date(date.getTime());
}
function last_month_no_later_than(date) {
  const new_date = copy_date(date);
  new_date.setUTCDate(1);
  new_date.setUTCHours(0);
  new_date.setUTCMinutes(0);
  new_date.setUTCSeconds(0);
  new_date.setUTCMilliseconds(0);
  return new_date;
}
function last_year_no_later_than(date) {
  const new_date = last_month_no_later_than(date);
  new_date.setUTCMonth(0);
  return new_date;
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/days_ticker.js
function date_range_by_month(start_time, end_time) {
  const start_date = last_month_no_later_than(new Date(start_time));
  const end_date = last_month_no_later_than(new Date(end_time));
  end_date.setUTCMonth(end_date.getUTCMonth() + 1);
  const dates = [];
  const date = start_date;
  while (true) {
    dates.push(copy_date(date));
    date.setUTCMonth(date.getUTCMonth() + 1);
    if (date > end_date) {
      break;
    }
  }
  return dates;
}
var _DaysTicker = class _DaysTicker extends BaseSingleIntervalTicker {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "interval");
  }
  initialize() {
    super.initialize();
    const days = this.days;
    if (days.length > 1) {
      this.interval = (days[1] - days[0]) * ONE_DAY;
    } else {
      this.interval = 31 * ONE_DAY;
    }
  }
  get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {
    const month_dates = date_range_by_month(data_low, data_high);
    const days = this.days;
    const days_of_month = (month_date, interval) => {
      const current_month = month_date.getUTCMonth();
      const dates = [];
      for (const day of days) {
        const day_date = copy_date(month_date);
        day_date.setUTCDate(day);
        const future_date = new Date(day_date.getTime() + interval / 2);
        if (future_date.getUTCMonth() == current_month) {
          dates.push(day_date);
        }
      }
      return dates;
    };
    const day_dates = concat(month_dates.map((date) => days_of_month(date, this.interval)));
    const all_ticks = day_dates.map((day_date) => day_date.getTime());
    const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);
    return {
      major: ticks_in_range,
      minor: []
    };
  }
};
__publicField(_DaysTicker, "__name__", "DaysTicker");
_DaysTicker.define(({ Int: Int2, List: List2 }) => ({
  days: [List2(Int2), []]
}));
_DaysTicker.override({
  num_minor_ticks: 0
});
var DaysTicker = _DaysTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/months_ticker.js
function date_range_by_year(start_time, end_time) {
  const start_date = last_year_no_later_than(new Date(start_time));
  const end_date = last_year_no_later_than(new Date(end_time));
  end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);
  const dates = [];
  const date = start_date;
  while (true) {
    dates.push(copy_date(date));
    date.setUTCFullYear(date.getUTCFullYear() + 1);
    if (date > end_date) {
      break;
    }
  }
  return dates;
}
var _MonthsTicker = class _MonthsTicker extends BaseSingleIntervalTicker {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "interval");
  }
  initialize() {
    super.initialize();
    const months = this.months;
    if (months.length > 1) {
      this.interval = (months[1] - months[0]) * ONE_MONTH;
    } else {
      this.interval = 12 * ONE_MONTH;
    }
  }
  get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {
    const year_dates = date_range_by_year(data_low, data_high);
    const months = this.months;
    const months_of_year = (year_date) => {
      return months.map((month) => {
        const month_date = copy_date(year_date);
        month_date.setUTCMonth(month);
        return month_date;
      });
    };
    const month_dates = concat(year_dates.map(months_of_year));
    const all_ticks = month_dates.map((month_date) => month_date.getTime());
    const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);
    return {
      major: ticks_in_range,
      minor: []
    };
  }
};
__publicField(_MonthsTicker, "__name__", "MonthsTicker");
_MonthsTicker.define(({ Int: Int2, List: List2 }) => ({
  months: [List2(Int2), []]
}));
var MonthsTicker = _MonthsTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/years_ticker.js
var YearsTicker = class extends BaseSingleIntervalTicker {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "interval", ONE_YEAR);
    __publicField(this, "basic_ticker", new BasicTicker({ num_minor_ticks: 0 }));
  }
  get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {
    const start_year = last_year_no_later_than(new Date(data_low)).getUTCFullYear();
    const end_year = last_year_no_later_than(new Date(data_high)).getUTCFullYear();
    const years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;
    const all_ticks = years.map((year) => Date.UTC(year, 0, 1));
    const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);
    return {
      major: ticks_in_range,
      minor: []
    };
  }
};
__publicField(YearsTicker, "__name__", "YearsTicker");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/datetime_ticker.js
var _DatetimeTicker = class _DatetimeTicker extends CompositeTicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatetimeTicker, "__name__", "DatetimeTicker");
_DatetimeTicker.override({
  num_minor_ticks: 0,
  tickers: () => [
    // Sub-second.
    new AdaptiveTicker({
      mantissas: [1, 2, 5],
      base: 10,
      min_interval: 0,
      max_interval: 500 * ONE_MILLI,
      num_minor_ticks: 0
    }),
    // Seconds, minutes.
    new AdaptiveTicker({
      mantissas: [1, 2, 5, 10, 15, 20, 30],
      base: 60,
      min_interval: ONE_SECOND,
      max_interval: 30 * ONE_MINUTE,
      num_minor_ticks: 0
    }),
    // Hours.
    new AdaptiveTicker({
      mantissas: [1, 2, 4, 6, 8, 12],
      base: 24,
      min_interval: ONE_HOUR,
      max_interval: 12 * ONE_HOUR,
      num_minor_ticks: 0
    }),
    // Days.
    new DaysTicker({ days: range(1, 32) }),
    new DaysTicker({ days: range(1, 31, 3) }),
    new DaysTicker({ days: [1, 8, 15, 22] }),
    new DaysTicker({ days: [1, 15] }),
    // Months.
    new MonthsTicker({ months: range(0, 12, 1) }),
    new MonthsTicker({ months: range(0, 12, 2) }),
    new MonthsTicker({ months: range(0, 12, 4) }),
    new MonthsTicker({ months: range(0, 12, 6) }),
    // Years
    new YearsTicker({})
  ]
});
var DatetimeTicker = _DatetimeTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/fixed_ticker.js
var _FixedTicker = class _FixedTicker extends ContinuousTicker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks_no_defaults(_data_low, _data_high, _cross_loc, _desired_n_ticks) {
    return {
      major: [...this.ticks],
      minor: [...this.minor_ticks]
    };
  }
  // XXX: whatever, because FixedTicker needs to fulfill the interface somehow
  get_interval(_data_low, _data_high, _desired_n_ticks) {
    return 0;
  }
  get_min_interval() {
    return 0;
  }
  get_max_interval() {
    return 0;
  }
};
__publicField(_FixedTicker, "__name__", "FixedTicker");
_FixedTicker.define(({ Float: Float2, Arrayable: Arrayable2 }) => ({
  ticks: [Arrayable2(Float2), []],
  minor_ticks: [Arrayable2(Float2), []]
}));
var FixedTicker = _FixedTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/log_ticker.js
var _LogTicker = class _LogTicker extends AdaptiveTicker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {
    const num_minor_ticks = this.num_minor_ticks;
    const minor_ticks = [];
    const base2 = this.base;
    const log_low = Math.log(data_low) / Math.log(base2);
    const log_high = Math.log(data_high) / Math.log(base2);
    const log_interval = log_high - log_low;
    let ticks;
    if (!isFinite(log_interval) || log_interval == 0) {
      ticks = [];
    } else if (log_interval < 2) {
      const interval = this.get_interval(data_low, data_high, desired_n_ticks);
      const start_factor = Math.floor(data_low / interval);
      const end_factor = Math.ceil(data_high / interval);
      ticks = range(start_factor, end_factor + 1).filter((factor) => factor != 0).map((factor) => factor * interval).filter((tick) => data_low <= tick && tick <= data_high);
      if (num_minor_ticks > 0 && ticks.length > 0) {
        const minor_interval = interval / num_minor_ticks;
        const minor_offsets = range(0, num_minor_ticks).map((i2) => i2 * minor_interval);
        for (const x2 of minor_offsets.slice(1)) {
          minor_ticks.push(ticks[0] - x2);
        }
        for (const tick of ticks) {
          for (const x2 of minor_offsets) {
            minor_ticks.push(tick + x2);
          }
        }
      }
    } else {
      const startlog = Math.ceil(log_low * 0.999999);
      const endlog = Math.floor(log_high * 1.000001);
      const interval = Math.ceil((endlog - startlog) / 9);
      ticks = range(startlog - 1, endlog + 1, interval).map((i2) => base2 ** i2);
      if (num_minor_ticks > 0 && ticks.length > 0) {
        const minor_interval = base2 ** interval / num_minor_ticks;
        const minor_offsets = range(1, num_minor_ticks + 1).map((i2) => i2 * minor_interval);
        for (const x2 of minor_offsets) {
          minor_ticks.push(ticks[0] / x2);
        }
        minor_ticks.push(ticks[0]);
        for (const tick of ticks) {
          for (const x2 of minor_offsets) {
            minor_ticks.push(tick * x2);
          }
        }
      }
    }
    return {
      major: ticks.filter((tick) => data_low <= tick && tick <= data_high),
      minor: minor_ticks.filter((tick) => data_low <= tick && tick <= data_high)
    };
  }
};
__publicField(_LogTicker, "__name__", "LogTicker");
_LogTicker.override({
  mantissas: [1, 5]
});
var LogTicker = _LogTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/mercator_ticker.js
var _MercatorTicker = class _MercatorTicker extends BasicTicker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {
    if (this.dimension == null) {
      throw new Error(`${this}.dimension wasn't configured`);
    }
    [data_low, data_high] = clip_mercator(data_low, data_high, this.dimension);
    if (this.dimension == "lon") {
      return this._get_ticks_lon(data_low, data_high, cross_loc, desired_n_ticks);
    } else {
      return this._get_ticks_lat(data_low, data_high, cross_loc, desired_n_ticks);
    }
  }
  _get_ticks_lon(data_low, data_high, cross_loc, desired_n_ticks) {
    const [proj_low] = wgs84_mercator.invert(data_low, cross_loc);
    const [proj_high, proj_cross_loc] = wgs84_mercator.invert(data_high, cross_loc);
    const proj_ticks = super.get_ticks_no_defaults(proj_low, proj_high, cross_loc, desired_n_ticks);
    const major = [];
    for (const tick of proj_ticks.major) {
      if (in_bounds(tick, "lon")) {
        const [lon] = wgs84_mercator.compute(tick, proj_cross_loc);
        major.push(lon);
      }
    }
    const minor = [];
    for (const tick of proj_ticks.minor) {
      if (in_bounds(tick, "lon")) {
        const [lon] = wgs84_mercator.compute(tick, proj_cross_loc);
        minor.push(lon);
      }
    }
    return { major, minor };
  }
  _get_ticks_lat(data_low, data_high, cross_loc, desired_n_ticks) {
    const [, proj_low] = wgs84_mercator.invert(cross_loc, data_low);
    const [proj_cross_loc, proj_high] = wgs84_mercator.invert(cross_loc, data_high);
    const proj_ticks = super.get_ticks_no_defaults(proj_low, proj_high, cross_loc, desired_n_ticks);
    const major = [];
    for (const tick of proj_ticks.major) {
      if (in_bounds(tick, "lat")) {
        const [, lat] = wgs84_mercator.compute(proj_cross_loc, tick);
        major.push(lat);
      }
    }
    const minor = [];
    for (const tick of proj_ticks.minor) {
      if (in_bounds(tick, "lat")) {
        const [, lat] = wgs84_mercator.compute(proj_cross_loc, tick);
        minor.push(lat);
      }
    }
    return { major, minor };
  }
};
__publicField(_MercatorTicker, "__name__", "MercatorTicker");
_MercatorTicker.define(({ Nullable: Nullable2 }) => ({
  dimension: [Nullable2(LatLon), null]
}));
var MercatorTicker = _MercatorTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/mapper.js
var Mapper = class extends Transform {
  constructor(attrs) {
    super(attrs);
  }
  compute(_x) {
    throw new Error("mapping single values is not supported");
  }
};
__publicField(Mapper, "__name__", "Mapper");

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/color_mapper.js
function _convert_color(color) {
  return encode_rgba(color2rgba(color));
}
function _convert_palette(palette) {
  const new_palette = new Uint32Array(palette.length);
  for (let i2 = 0, end = palette.length; i2 < end; i2++) {
    new_palette[i2] = _convert_color(palette[i2]);
  }
  return new_palette;
}
var _ColorMapper = class _ColorMapper extends Mapper {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "metrics_change");
  }
  initialize() {
    super.initialize();
    this.metrics_change = new Signal0(this, "metrics_change");
  }
  v_compute(xs) {
    const values2 = new Array(xs.length);
    this._v_compute(xs, values2, this.palette, this._colors((c) => c));
    return values2;
  }
  get rgba_mapper() {
    const self2 = this;
    const palette = _convert_palette(this.palette);
    const colors = this._colors(_convert_color);
    return {
      v_compute(xs) {
        const length_divisor = is_NDArray(xs) && xs.dimension == 3 ? xs.shape[2] : 1;
        const values2 = new ColorArray(xs.length / length_divisor);
        self2._v_compute_uint32(xs, values2, palette, colors);
        return new Uint8ClampedArray(to_big_endian(values2).buffer);
      }
    };
  }
  _colors(conv) {
    return { nan_color: conv(this.nan_color) };
  }
  _v_compute_uint32(xs, values2, palette, colors) {
    this._v_compute(xs, values2, palette, colors);
  }
};
__publicField(_ColorMapper, "__name__", "ColorMapper");
_ColorMapper.define(({ Color: Color2, List: List2 }) => ({
  palette: [List2(Color2)],
  nan_color: [Color2, "gray"]
}));
var ColorMapper = _ColorMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/data_renderer.js
var _a29, _b;
var DataRendererView = class extends (_b = RendererView, _a29 = auto_ranged, _b) {
  constructor() {
    super(...arguments);
    __publicField(this, _a29, true);
  }
  get xscale() {
    return this.coordinates.x_scale;
  }
  get yscale() {
    return this.coordinates.y_scale;
  }
  bounds() {
    return this.glyph_view.bounds();
  }
  log_bounds() {
    return this.glyph_view.log_bounds();
  }
};
__publicField(DataRendererView, "__name__", "DataRendererView");
var _DataRenderer = class _DataRenderer extends Renderer {
  constructor(attrs) {
    super(attrs);
  }
  get selection_manager() {
    return this.get_selection_manager();
  }
};
__publicField(_DataRenderer, "__name__", "DataRenderer");
_DataRenderer.override({
  level: "glyph"
});
var DataRenderer = _DataRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/ragged_array.js
var _a30;
var _RaggedArray = class _RaggedArray {
  constructor(offsets, data3) {
    __publicField(this, "offsets");
    __publicField(this, "data");
    this.offsets = offsets;
    this.data = data3;
  }
  [(_a30 = Symbol.toStringTag, equals)](that, cmp) {
    return cmp.arrays(this.offsets, that.offsets) && cmp.arrays(this.data, that.data);
  }
  get length() {
    return this.offsets.length;
  }
  clone() {
    return new _RaggedArray(this.offsets.slice(), this.data.slice());
  }
  static from(items, ctor) {
    const n2 = items.length;
    let offset3 = 0;
    const offsets = (() => {
      const offsets2 = new Uint32Array(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        const length = items[i2].length;
        offsets2[i2] = offset3;
        offset3 += length;
      }
      if (offset3 < 256) {
        return new Uint8Array(offsets2);
      } else if (offset3 < 65536) {
        return new Uint16Array(offsets2);
      } else {
        return offsets2;
      }
    })();
    const array2 = new ctor(offset3);
    for (let i2 = 0; i2 < n2; i2++) {
      array2.set(items[i2], offsets[i2]);
    }
    return new _RaggedArray(offsets, array2);
  }
  *[Symbol.iterator]() {
    const { offsets, length } = this;
    for (let i2 = 0; i2 < length; i2++) {
      yield this.data.subarray(offsets[i2], offsets[i2 + 1]);
    }
  }
  _check_bounds(i2) {
    assert(0 <= i2 && i2 < this.length, `Out of bounds: 0 <= ${i2} < ${this.length}`);
  }
  get(i2) {
    this._check_bounds(i2);
    const { offsets } = this;
    return this.data.subarray(offsets[i2], offsets[i2 + 1]);
  }
  set(i2, array2) {
    this._check_bounds(i2);
    this.data.set(array2, this.offsets[i2]);
  }
};
__publicField(_RaggedArray, "__name__", "RaggedArray");
__publicField(_RaggedArray, _a30, "RaggedArray");
var RaggedArray = _RaggedArray;

// node_modules/flatqueue/index.js
var FlatQueue = class {
  constructor() {
    this.ids = [];
    this.values = [];
    this.length = 0;
  }
  clear() {
    this.length = 0;
  }
  push(id, value2) {
    let pos = this.length++;
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const parentValue = this.values[parent];
      if (value2 >= parentValue) break;
      this.ids[pos] = this.ids[parent];
      this.values[pos] = parentValue;
      pos = parent;
    }
    this.ids[pos] = id;
    this.values[pos] = value2;
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.ids[0];
    this.length--;
    if (this.length > 0) {
      const id = this.ids[0] = this.ids[this.length];
      const value2 = this.values[0] = this.values[this.length];
      const halfLength = this.length >> 1;
      let pos = 0;
      while (pos < halfLength) {
        let left2 = (pos << 1) + 1;
        const right3 = left2 + 1;
        let bestIndex = this.ids[left2];
        let bestValue = this.values[left2];
        const rightValue = this.values[right3];
        if (right3 < this.length && rightValue < bestValue) {
          left2 = right3;
          bestIndex = this.ids[right3];
          bestValue = rightValue;
        }
        if (bestValue >= value2) break;
        this.ids[pos] = bestIndex;
        this.values[pos] = bestValue;
        pos = left2;
      }
      this.ids[pos] = id;
      this.values[pos] = value2;
    }
    return top;
  }
  peek() {
    if (this.length === 0) return void 0;
    return this.ids[0];
  }
  peekValue() {
    if (this.length === 0) return void 0;
    return this.values[0];
  }
  shrink() {
    this.ids.length = this.values.length = this.length;
  }
};

// node_modules/flatbush/index.js
var ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var VERSION = 3;
var Flatbush = class _Flatbush {
  /**
   * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.
   * @param {ArrayBuffer | SharedArrayBuffer} data
   * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.
   * @returns {Flatbush} index
   */
  static from(data3, byteOffset = 0) {
    if (byteOffset % 8 !== 0) {
      throw new Error("byteOffset must be 8-byte aligned.");
    }
    if (!data3 || data3.byteLength === void 0 || data3.buffer) {
      throw new Error("Data must be an instance of ArrayBuffer or SharedArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data3, byteOffset + 0, 2);
    if (magic !== 251) {
      throw new Error("Data does not appear to be in a Flatbush format.");
    }
    const version2 = versionAndType >> 4;
    if (version2 !== VERSION) {
      throw new Error(`Got v${version2} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data3, byteOffset + 2, 1);
    const [numItems] = new Uint32Array(data3, byteOffset + 4, 1);
    return new _Flatbush(numItems, nodeSize, ArrayType, void 0, data3, byteOffset);
  }
  /**
   * Create a Flatbush index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=16] Size of the tree node (16 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).
   * @param {ArrayBuffer | SharedArrayBuffer} [data] (Only used internally)
   * @param {number} [byteOffset=0] (Only used internally)
   */
  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data3, byteOffset = 0) {
    if (numItems === void 0) throw new Error("Missing required argument: numItems.");
    if (isNaN(numItems) || numItems <= 0) throw new Error(`Unexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.byteOffset = byteOffset;
    let n2 = numItems;
    let numNodes = n2;
    this._levelBounds = [n2 * 4];
    do {
      n2 = Math.ceil(n2 / this.nodeSize);
      numNodes += n2;
      this._levelBounds.push(numNodes * 4);
    } while (n2 !== 1);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data3 && data3.byteLength !== void 0 && !data3.buffer) {
      this.data = data3;
      this._boxes = new this.ArrayType(this.data, byteOffset + 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, byteOffset + 8 + nodesByteSize, numNodes);
      this._pos = numNodes * 4;
      this.minX = this._boxes[this._pos - 4];
      this.minY = this._boxes[this._pos - 3];
      this.maxX = this._boxes[this._pos - 2];
      this.maxY = this._boxes[this._pos - 1];
    } else {
      this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
      this._pos = 0;
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      new Uint8Array(this.data, 0, 2).set([251, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
    this._queue = new FlatQueue();
  }
  /**
   * Add a given rectangle to the index.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number} A zero-based, incremental number that represents the newly added rectangle.
   */
  add(minX, minY, maxX = minX, maxY = minY) {
    const index2 = this._pos >> 2;
    const boxes = this._boxes;
    this._indices[index2] = index2;
    boxes[this._pos++] = minX;
    boxes[this._pos++] = minY;
    boxes[this._pos++] = maxX;
    boxes[this._pos++] = maxY;
    if (minX < this.minX) this.minX = minX;
    if (minY < this.minY) this.minY = minY;
    if (maxX > this.maxX) this.maxX = maxX;
    if (maxY > this.maxY) this.maxY = maxY;
    return index2;
  }
  /** Perform indexing of the added rectangles. */
  finish() {
    if (this._pos >> 2 !== this.numItems) {
      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
    }
    const boxes = this._boxes;
    if (this.numItems <= this.nodeSize) {
      boxes[this._pos++] = this.minX;
      boxes[this._pos++] = this.minY;
      boxes[this._pos++] = this.maxX;
      boxes[this._pos++] = this.maxY;
      return;
    }
    const width = this.maxX - this.minX || 1;
    const height = this.maxY - this.minY || 1;
    const hilbertValues = new Uint32Array(this.numItems);
    const hilbertMax = (1 << 16) - 1;
    for (let i2 = 0, pos = 0; i2 < this.numItems; i2++) {
      const minX = boxes[pos++];
      const minY = boxes[pos++];
      const maxX = boxes[pos++];
      const maxY = boxes[pos++];
      const x2 = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);
      const y2 = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);
      hilbertValues[i2] = hilbert(x2, y2);
    }
    sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);
    for (let i2 = 0, pos = 0; i2 < this._levelBounds.length - 1; i2++) {
      const end = this._levelBounds[i2];
      while (pos < end) {
        const nodeIndex = pos;
        let nodeMinX = boxes[pos++];
        let nodeMinY = boxes[pos++];
        let nodeMaxX = boxes[pos++];
        let nodeMaxY = boxes[pos++];
        for (let j = 1; j < this.nodeSize && pos < end; j++) {
          nodeMinX = Math.min(nodeMinX, boxes[pos++]);
          nodeMinY = Math.min(nodeMinY, boxes[pos++]);
          nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);
          nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);
        }
        this._indices[this._pos >> 2] = nodeIndex;
        boxes[this._pos++] = nodeMinX;
        boxes[this._pos++] = nodeMinY;
        boxes[this._pos++] = nodeMaxX;
        boxes[this._pos++] = nodeMaxY;
      }
    }
  }
  /**
   * Search the index by a bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.
   */
  search(minX, minY, maxX, maxY, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const queue = [];
    const results = [];
    while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        if (maxX < this._boxes[pos]) continue;
        if (maxY < this._boxes[pos + 1]) continue;
        if (minX > this._boxes[pos + 2]) continue;
        if (minY > this._boxes[pos + 3]) continue;
        const index2 = this._indices[pos >> 2] | 0;
        if (nodeIndex >= this.numItems * 4) {
          queue.push(index2);
        } else if (filterFn === void 0 || filterFn(index2)) {
          results.push(index2);
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
  /**
   * Search items in order of distance from the given point.
   * @param {number} x
   * @param {number} y
   * @param {number} [maxResults=Infinity]
   * @param {number} [maxDistance=Infinity]
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items found.
   */
  neighbors(x2, y2, maxResults = Infinity, maxDistance = Infinity, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const q2 = this._queue;
    const results = [];
    const maxDistSquared = maxDistance * maxDistance;
    outer: while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        const index2 = this._indices[pos >> 2] | 0;
        const dx = axisDist(x2, this._boxes[pos], this._boxes[pos + 2]);
        const dy = axisDist(y2, this._boxes[pos + 1], this._boxes[pos + 3]);
        const dist = dx * dx + dy * dy;
        if (dist > maxDistSquared) continue;
        if (nodeIndex >= this.numItems * 4) {
          q2.push(index2 << 1, dist);
        } else if (filterFn === void 0 || filterFn(index2)) {
          q2.push((index2 << 1) + 1, dist);
        }
      }
      while (q2.length && q2.peek() & 1) {
        const dist = q2.peekValue();
        if (dist > maxDistSquared) break outer;
        results.push(q2.pop() >> 1);
        if (results.length === maxResults) break outer;
      }
      nodeIndex = q2.length ? q2.pop() >> 1 : void 0;
    }
    q2.clear();
    return results;
  }
};
function axisDist(k, min10, max18) {
  return k < min10 ? min10 - k : k <= max18 ? 0 : k - max18;
}
function upperBound(value2, arr) {
  let i2 = 0;
  let j = arr.length - 1;
  while (i2 < j) {
    const m = i2 + j >> 1;
    if (arr[m] > value2) {
      j = m;
    } else {
      i2 = m + 1;
    }
  }
  return arr[i2];
}
function sort(values2, boxes, indices, left2, right3, nodeSize) {
  if (Math.floor(left2 / nodeSize) >= Math.floor(right3 / nodeSize)) return;
  const pivot = values2[left2 + right3 >> 1];
  let i2 = left2 - 1;
  let j = right3 + 1;
  while (true) {
    do
      i2++;
    while (values2[i2] < pivot);
    do
      j--;
    while (values2[j] > pivot);
    if (i2 >= j) break;
    swap2(values2, boxes, indices, i2, j);
  }
  sort(values2, boxes, indices, left2, j, nodeSize);
  sort(values2, boxes, indices, j + 1, right3, nodeSize);
}
function swap2(values2, boxes, indices, i2, j) {
  const temp = values2[i2];
  values2[i2] = values2[j];
  values2[j] = temp;
  const k = 4 * i2;
  const m = 4 * j;
  const a2 = boxes[k];
  const b2 = boxes[k + 1];
  const c = boxes[k + 2];
  const d = boxes[k + 3];
  boxes[k] = boxes[m];
  boxes[k + 1] = boxes[m + 1];
  boxes[k + 2] = boxes[m + 2];
  boxes[k + 3] = boxes[m + 3];
  boxes[m] = a2;
  boxes[m + 1] = b2;
  boxes[m + 2] = c;
  boxes[m + 3] = d;
  const e = indices[i2];
  indices[i2] = indices[j];
  indices[j] = e;
}
function hilbert(x2, y2) {
  let a2 = x2 ^ y2;
  let b2 = 65535 ^ a2;
  let c = 65535 ^ (x2 | y2);
  let d = x2 & (y2 ^ 65535);
  let A = a2 | b2 >> 1;
  let B = a2 >> 1 ^ a2;
  let C = c >> 1 ^ b2 & d >> 1 ^ c;
  let D = a2 & c >> 1 ^ d >> 1 ^ d;
  a2 = A;
  b2 = B;
  c = C;
  d = D;
  A = a2 & a2 >> 2 ^ b2 & b2 >> 2;
  B = a2 & b2 >> 2 ^ b2 & (a2 ^ b2) >> 2;
  C ^= a2 & c >> 2 ^ b2 & d >> 2;
  D ^= b2 & c >> 2 ^ (a2 ^ b2) & d >> 2;
  a2 = A;
  b2 = B;
  c = C;
  d = D;
  A = a2 & a2 >> 4 ^ b2 & b2 >> 4;
  B = a2 & b2 >> 4 ^ b2 & (a2 ^ b2) >> 4;
  C ^= a2 & c >> 4 ^ b2 & d >> 4;
  D ^= b2 & c >> 4 ^ (a2 ^ b2) & d >> 4;
  a2 = A;
  b2 = B;
  c = C;
  d = D;
  C ^= a2 & c >> 8 ^ b2 & d >> 8;
  D ^= b2 & c >> 8 ^ (a2 ^ b2) & d >> 8;
  a2 = C ^ C >> 1;
  b2 = D ^ D >> 1;
  let i0 = x2 ^ y2;
  let i1 = b2 | 65535 ^ (i0 | a2);
  i0 = (i0 | i0 << 8) & 16711935;
  i0 = (i0 | i0 << 4) & 252645135;
  i0 = (i0 | i0 << 2) & 858993459;
  i0 = (i0 | i0 << 1) & 1431655765;
  i1 = (i1 | i1 << 8) & 16711935;
  i1 = (i1 | i1 << 4) & 252645135;
  i1 = (i1 | i1 << 2) & 858993459;
  i1 = (i1 | i1 << 1) & 1431655765;
  return (i1 << 1 | i0) >>> 0;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/spatial.js
function upperBound2(value2, arr) {
  let i2 = 0;
  let j = arr.length - 1;
  while (i2 < j) {
    const m = i2 + j >> 1;
    if (arr[m] > value2) {
      j = m;
    } else {
      i2 = m + 1;
    }
  }
  return arr[i2];
}
var _FlatBush = class extends Flatbush {
  get boxes() {
    return this._boxes;
  }
  search_indices(minX, minY, maxX, maxY) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const queue = [];
    const results = new BitSet(this.numItems);
    while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound2(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        const index2 = this._indices[pos >> 2] | 0;
        const nodeMinX = this._boxes[pos + 0];
        const nodeMinY = this._boxes[pos + 1];
        const nodeMaxX = this._boxes[pos + 2];
        const nodeMaxY = this._boxes[pos + 3];
        if (maxX < nodeMinX || maxY < nodeMinY || minX > nodeMaxX || minY > nodeMaxY) {
          continue;
        }
        if (nodeIndex < this.numItems * 4) {
          results.set(index2);
        } else {
          queue.push(index2);
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
};
__publicField(_FlatBush, "__name__", "_FlatBush");
var SpatialIndex = class {
  constructor(size2) {
    __publicField(this, "index", null);
    if (size2 > 0) {
      this.index = new _FlatBush(size2);
    }
  }
  add_rect(x0, y0, x1, y1) {
    var _a34;
    if (!isFinite(x0 + y0 + x1 + y1)) {
      this.add_empty();
    } else {
      (_a34 = this.index) == null ? void 0 : _a34.add(x0, y0, x1, y1);
    }
  }
  add_point(x2, y2) {
    var _a34;
    if (!isFinite(x2 + y2)) {
      this.add_empty();
    } else {
      (_a34 = this.index) == null ? void 0 : _a34.add(x2, y2, x2, y2);
    }
  }
  add_empty() {
    var _a34;
    (_a34 = this.index) == null ? void 0 : _a34.add(Infinity, Infinity, -Infinity, -Infinity);
  }
  finish() {
    var _a34;
    (_a34 = this.index) == null ? void 0 : _a34.finish();
  }
  _normalize(rect) {
    let { x0, y0, x1, y1 } = rect;
    if (x0 > x1) {
      [x0, x1] = [x1, x0];
    }
    if (y0 > y1) {
      [y0, y1] = [y1, y0];
    }
    return { x0, y0, x1, y1 };
  }
  get bbox() {
    if (this.index == null) {
      return empty();
    } else {
      const { minX, minY, maxX, maxY } = this.index;
      return { x0: minX, y0: minY, x1: maxX, y1: maxY };
    }
  }
  indices(rect) {
    if (this.index == null) {
      return new BitSet(0);
    } else {
      const { x0, y0, x1, y1 } = this._normalize(rect);
      return this.index.search_indices(x0, y0, x1, y1);
    }
  }
  bounds(rect) {
    const bounds = empty();
    if (this.index == null) {
      return bounds;
    }
    const { boxes } = this.index;
    for (const i2 of this.indices(rect)) {
      const x0 = boxes[4 * i2 + 0];
      const y0 = boxes[4 * i2 + 1];
      const x1 = boxes[4 * i2 + 2];
      const y1 = boxes[4 * i2 + 3];
      if (x0 >= rect.x0 && x0 < bounds.x0) {
        bounds.x0 = x0;
      }
      if (x1 <= rect.x1 && x1 > bounds.x1) {
        bounds.x1 = x1;
      }
      if (y0 >= rect.y0 && y0 < bounds.y0) {
        bounds.y0 = y0;
      }
      if (y1 <= rect.y1 && y1 > bounds.y1) {
        bounds.y1 = y1;
      }
    }
    return bounds;
  }
};
__publicField(SpatialIndex, "__name__", "SpatialIndex");

// node_modules/@bokeh/bokehjs/build/js/lib/models/graphics/decoration.js
var DecorationView = class extends View {
  constructor() {
    super(...arguments);
    __publicField(this, "visuals");
    __publicField(this, "marking");
  }
  *children() {
    yield* super.children();
    yield this.marking;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.marking = await build_view(this.model.marking, { parent: this.parent });
  }
};
__publicField(DecorationView, "__name__", "DecorationView");
var _Decoration = class _Decoration extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Decoration, "__name__", "Decoration");
_Decoration.prototype.default_view = DecorationView;
_Decoration.define(({ Enum: Enum2, Ref: Ref2 }) => ({
  marking: [Ref2(Marking)],
  node: [Enum2("start", "middle", "end")]
}));
var Decoration = _Decoration;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/glyph.js
var { abs: abs3, ceil } = Math;
var inherit = Symbol("inherit");
var GlyphView = class extends DOMComponentView {
  constructor() {
    super(...arguments);
    __publicField(this, "visuals");
    /** @internal */
    __publicField(this, "glglyph");
    __publicField(this, "_index", null);
    __publicField(this, "_data_size", null);
    __publicField(this, "_nohit_warned", /* @__PURE__ */ new Set());
    __publicField(this, "decorations", /* @__PURE__ */ new Map());
    __publicField(this, "_base", null);
  }
  get renderer() {
    return this.parent;
  }
  get has_webgl() {
    return this.glglyph != null;
  }
  get index() {
    const { _index } = this;
    if (_index != null) {
      return _index;
    } else {
      throw new Error(`${this}.index_data() wasn't called`);
    }
  }
  get data_size() {
    const { base: base2 } = this;
    if (base2 != null) {
      return base2.data_size;
    } else {
      const { _data_size } = this;
      if (_data_size != null) {
        return _data_size;
      } else {
        throw new Error(`${this}.set_data() wasn't called`);
      }
    }
  }
  initialize() {
    super.initialize();
    this.visuals = new Visuals(this);
  }
  *children() {
    yield* super.children();
    yield* this.decorations.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await build_views(this.decorations, this.model.decorations, { parent: this.parent });
    const { webgl } = this.canvas;
    if (webgl != null && this.load_glglyph != null) {
      const cls = await this.load_glglyph();
      this.glglyph = new cls(webgl.regl_wrapper, this);
    }
  }
  request_paint() {
    this.parent.request_paint();
  }
  get canvas() {
    return this.renderer.parent.canvas_view;
  }
  paint(ctx, indices, data3) {
    if (this.glglyph != null) {
      this.glglyph.render(ctx, indices, this.base ?? this);
    } else if (this.canvas.webgl != null && settings.force_webgl) {
      throw new Error(`${this} doesn't support webgl rendering`);
    } else {
      this._paint(ctx, indices, data3);
    }
  }
  has_finished() {
    return true;
  }
  notify_finished() {
    this.renderer.notify_finished();
  }
  _bounds(bounds) {
    return bounds;
  }
  bounds() {
    return this._bounds(this.index.bbox);
  }
  log_bounds() {
    const { x0, x1 } = this.index.bounds(positive_x());
    const { y0, y1 } = this.index.bounds(positive_y());
    return this._bounds({ x0, y0, x1, y1 });
  }
  get_anchor_point(anchor2, i2, [sx, sy]) {
    switch (anchor2) {
      case "center":
      case "center_center": {
        const [x2, y2] = this.scenterxy(i2, sx, sy);
        return { x: x2, y: y2 };
      }
      default:
        return null;
    }
  }
  sdist(scale, pts, spans, pts_location = "edge", dilate = false) {
    const n2 = pts.length;
    const sdist = new ScreenArray(n2);
    const compute = scale.s_compute;
    if (pts_location == "center") {
      for (let i2 = 0; i2 < n2; i2++) {
        const pts_i = pts[i2];
        const halfspan_i = spans.get(i2) / 2;
        const spt0 = compute(pts_i - halfspan_i);
        const spt1 = compute(pts_i + halfspan_i);
        sdist[i2] = abs3(spt1 - spt0);
      }
    } else {
      for (let i2 = 0; i2 < n2; i2++) {
        const pts_i = pts[i2];
        const spt0 = compute(pts_i);
        const spt1 = compute(pts_i + spans.get(i2));
        sdist[i2] = abs3(spt1 - spt0);
      }
    }
    if (dilate) {
      inplace_map(sdist, (sd) => ceil(sd));
    }
    return sdist;
  }
  draw_legend_for_index(_ctx, _bbox, _index) {
  }
  hit_test(geometry) {
    const hit = (() => {
      var _a34, _b4, _c, _d;
      switch (geometry.type) {
        case "point":
          return (_a34 = this._hit_point) == null ? void 0 : _a34.call(this, geometry);
        case "span":
          return (_b4 = this._hit_span) == null ? void 0 : _b4.call(this, geometry);
        case "rect":
          return (_c = this._hit_rect) == null ? void 0 : _c.call(this, geometry);
        case "poly":
          return (_d = this._hit_poly) == null ? void 0 : _d.call(this, geometry);
      }
    })();
    if (hit != null) {
      return hit;
    }
    if (!this._nohit_warned.has(geometry.type)) {
      logger.debug(`'${geometry.type}' selection not available for ${this.model.type}`);
      this._nohit_warned.add(geometry.type);
    }
    return null;
  }
  _hit_rect_against_index(geometry) {
    const { sx0, sx1, sy0, sy1 } = geometry;
    const [x0, x1] = this.renderer.coordinates.x_scale.r_invert(sx0, sx1);
    const [y0, y1] = this.renderer.coordinates.y_scale.r_invert(sy0, sy1);
    const indices = [...this.index.indices({ x0, x1, y0, y1 })];
    return new Selection({ indices });
  }
  _project_xy(x2, xs, y2, ys) {
    const inherited_x = this._is_inherited(x2);
    const inherited_y = this._is_inherited(y2);
    if (!inherited_x && !inherited_y) {
      inplace.project_xy(xs, ys);
    } else if (!inherited_x || !inherited_y) {
      const [proj_x, proj_y] = project_xy(xs, ys);
      this._define_attr(x2, proj_x);
      this._define_attr(y2, proj_y);
    }
  }
  _project_data() {
  }
  *_iter_visuals() {
    for (const visual of this.visuals) {
      for (const prop of visual) {
        if (prop instanceof VectorSpec || prop instanceof ScalarSpec) {
          yield prop;
        }
      }
    }
  }
  get base() {
    return this._base;
  }
  set_base(base2) {
    if (base2 != this && base2 instanceof this.constructor) {
      this._base = base2;
    } else {
      this._base = null;
    }
  }
  _define_or_inherit_attr(attr2, fn) {
    const value2 = fn();
    if (value2 === inherit) {
      this._inherit_attr(attr2);
    } else {
      this._define_attr(attr2, value2);
    }
  }
  _define_attr(attr2, value2) {
    Object.defineProperty(this, attr2, {
      configurable: true,
      enumerable: true,
      value: value2
    });
    this._define_inherited(attr2, false);
  }
  _inherit_attr(attr2) {
    const { base: base2 } = this;
    assert(base2 != null);
    this._inherit_from(attr2, base2);
  }
  _inherit_from(attr2, base2) {
    Object.defineProperty(this, attr2, {
      configurable: true,
      enumerable: true,
      get() {
        return base2[attr2];
      }
    });
    this._define_inherited(attr2, true);
  }
  _define_inherited(attr2, value2) {
    Object.defineProperty(this, `inherited_${attr2}`, {
      configurable: true,
      enumerable: true,
      value: value2
    });
  }
  _can_inherit_from(prop, base2) {
    if (base2 == null) {
      return false;
    }
    const base_prop = base2.model.property(prop.attr);
    const value2 = prop.get_value();
    const base_value = base_prop.get_value();
    try {
      return is_equal(value2, base_value);
    } catch (error) {
      if (error instanceof EqNotImplemented) {
        return false;
      } else {
        throw error;
      }
    }
  }
  _is_inherited(prop) {
    const name = isString(prop) ? prop : prop.attr;
    return this[`inherited_${name}`];
  }
  set_visuals(source2, indices) {
    var _a34;
    for (const prop of this._iter_visuals()) {
      const { base: base2 } = this;
      if (base2 != null && this._can_inherit_from(prop, base2)) {
        this._inherit_from(prop.attr, base2);
      } else {
        const uniform = prop.uniform(source2).select(indices);
        this._define_attr(prop.attr, uniform);
      }
    }
    for (const visual of this.visuals) {
      visual.update();
    }
    (_a34 = this.glglyph) == null ? void 0 : _a34.set_visuals_changed();
  }
  _transform_array(prop, array2) {
    const { x_source, y_source } = this.renderer.coordinates;
    const range2 = prop.dimension == "x" ? x_source : y_source;
    if (range2 instanceof FactorRange) {
      if (prop instanceof CoordinateSpec) {
        array2 = range2.v_synthetic(array2);
      } else if (prop instanceof CoordinateSeqSpec) {
        for (let i2 = 0; i2 < array2.length; i2++) {
          array2[i2] = range2.v_synthetic(array2[i2]);
        }
      } else if (prop instanceof CoordinateSeqSeqSeqSpec) {
      }
    }
    let final_array;
    if (prop instanceof CoordinateSeqSpec) {
      final_array = RaggedArray.from(array2, Float64Array);
    } else if (prop instanceof CoordinateSeqSeqSeqSpec) {
      final_array = array2;
    } else {
      final_array = array2;
    }
    return final_array;
  }
  async set_data(source2, indices, indices_to_update) {
    var _a34;
    const visuals = new Set(this._iter_visuals());
    const { base: base2 } = this;
    this._data_size = indices.count;
    for (const prop of this.model) {
      if (!(prop instanceof VectorSpec || prop instanceof ScalarSpec)) {
        continue;
      }
      if (visuals.has(prop)) {
        continue;
      }
      if (base2 != null && this._can_inherit_from(prop, base2)) {
        this._inherit_from(prop.attr, base2);
        if (prop instanceof DistanceSpec || prop instanceof ScreenSizeSpec) {
          this._inherit_from(`max_${prop.attr}`, base2);
        }
      } else {
        if (prop instanceof BaseCoordinateSpec) {
          const array2 = this._transform_array(prop, indices.select(prop.array(source2)));
          this._define_attr(prop.attr, array2);
        } else {
          const uniform = prop.uniform(source2).select(indices);
          this._define_attr(prop.attr, uniform);
          if (prop instanceof DistanceSpec || prop instanceof ScreenSizeSpec) {
            const max_value = max2(uniform);
            this._define_attr(`max_${prop.attr}`, max_value);
          }
        }
      }
    }
    if (this.renderer.plot_view.model.use_map) {
      this._project_data();
    }
    this._set_data(indices_to_update ?? null);
    await this._set_lazy_data(indices_to_update ?? null);
    for (const decoration of this.decorations.values()) {
      decoration.marking.set_data(source2, indices);
    }
    (_a34 = this.glglyph) == null ? void 0 : _a34.set_data_changed();
    if (base2 == null) {
      this.index_data();
    }
  }
  _set_data(_indices) {
  }
  async _set_lazy_data(_indices) {
  }
  /**
   * Any data transformations that require visuals.
   */
  after_visuals() {
  }
  async after_lazy_visuals() {
  }
  get _index_size() {
    return this.data_size;
  }
  index_data() {
    const index2 = new SpatialIndex(this._index_size);
    this._index_data(index2);
    index2.finish();
    this._index = index2;
  }
  mask_data() {
    if (this._mask_data == null) {
      return BitSet.all_set(this.data_size);
    } else {
      return this._mask_data();
    }
  }
  map_data() {
    var _a34;
    const { x_scale, y_scale } = this.renderer.coordinates;
    const { base: base2 } = this;
    const v_compute = (prop) => {
      const scale = prop.dimension == "x" ? x_scale : y_scale;
      const array2 = this[prop.attr];
      if (array2 instanceof RaggedArray) {
        return new RaggedArray(array2.offsets, scale.v_compute(array2.data));
      } else {
        return scale.v_compute(array2);
      }
    };
    for (const prop of this.model) {
      if (prop instanceof BaseCoordinateSpec) {
        if (base2 != null && this._is_inherited(prop)) {
          this._inherit_from(`s${prop.attr}`, base2);
        } else {
          const array2 = v_compute(prop);
          this._define_attr(`s${prop.attr}`, array2);
        }
      }
    }
    this._map_data();
    (_a34 = this.glglyph) == null ? void 0 : _a34.set_data_mapped();
  }
  // This is where specs not included in coords are computed, e.g. radius.
  _map_data() {
  }
  get bbox() {
    if (this.base == null) {
      const { x0, y0, x1, y1 } = this.index.bbox;
      const { x_scale, y_scale } = this.renderer.coordinates;
      const [sx0, sx1] = x_scale.r_compute(x0, x1);
      const [sy0, sy1] = y_scale.r_compute(y0, y1);
      return BBox.from_rect({ x0: sx0, y0: sy0, x1: sx1, y1: sy1 });
    } else {
      return void 0;
    }
  }
};
__publicField(GlyphView, "__name__", "GlyphView");
var _Glyph = class _Glyph extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Glyph, "__name__", "Glyph");
_Glyph.define(({ List: List2, Ref: Ref2 }) => ({
  decorations: [List2(Ref2(Decoration)), []]
}));
var Glyph = _Glyph;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/xy_glyph.js
var XYGlyphView = class extends GlyphView {
  _project_data() {
    this._project_xy("x", this.x, "y", this.y);
  }
  _index_data(index2) {
    const { x: x2, y: y2, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x_i = x2[i2];
      const y_i = y2[i2];
      index2.add_point(x_i, y_i);
    }
  }
  scenterxy(i2) {
    return [this.sx[i2], this.sy[i2]];
  }
};
__publicField(XYGlyphView, "__name__", "XYGlyphView");
var _XYGlyph = class _XYGlyph extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_XYGlyph, "__name__", "XYGlyph");
_XYGlyph.define(() => ({
  x: [XCoordinateSpec, { field: "x" }],
  y: [YCoordinateSpec, { field: "y" }]
}));
var XYGlyph = _XYGlyph;

// node_modules/@bokeh/bokehjs/build/js/lib/core/hittest.js
function point_in_poly(x2, y2, px2, py) {
  let inside = false;
  let x1 = px2[px2.length - 1];
  let y1 = py[py.length - 1];
  for (let i2 = 0; i2 < px2.length; i2++) {
    const x22 = px2[i2];
    const y22 = py[i2];
    if (y1 < y2 != y22 < y2) {
      if (x1 + (y2 - y1) / (y22 - y1) * (x22 - x1) < x2) {
        inside = !inside;
      }
    }
    x1 = x22;
    y1 = y22;
  }
  return inside;
}
function point_in_ellipse(x2, y2, angle, b2, a2, x0, y0) {
  const A = (Math.cos(angle) / a2) ** 2 + (Math.sin(angle) / b2) ** 2;
  const B = 2 * Math.cos(angle) * Math.sin(angle) * ((1 / a2) ** 2 - (1 / b2) ** 2);
  const C = (Math.cos(angle) / b2) ** 2 + (Math.sin(angle) / a2) ** 2;
  const eqn = A * (x2 - x0) ** 2 + B * (x2 - x0) * (y2 - y0) + C * (y2 - y0) ** 2;
  const inside = eqn <= 1;
  return inside;
}
function dist_2_pts(p0, p1) {
  return (p0.x - p1.x) ** 2 + (p0.y - p1.y) ** 2;
}
function dist_to_segment_squared(p2, v, w) {
  const l2 = dist_2_pts(v, w);
  if (l2 == 0) {
    return dist_2_pts(p2, v);
  }
  const t = ((p2.x - v.x) * (w.x - v.x) + (p2.y - v.y) * (w.y - v.y)) / l2;
  if (t < 0) {
    return dist_2_pts(p2, v);
  }
  if (t > 1) {
    return dist_2_pts(p2, w);
  }
  const q2 = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
  return dist_2_pts(p2, q2);
}
function dist_to_segment(p2, v, w) {
  return Math.sqrt(dist_to_segment_squared(p2, v, w));
}
function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {
  const den = (l1_y1 - l1_y0) * (l0_x1 - l0_x0) - (l1_x1 - l1_x0) * (l0_y1 - l0_y0);
  if (den == 0) {
    return { hit: false, x: null, y: null };
  } else {
    let a2 = l0_y0 - l1_y0;
    let b2 = l0_x0 - l1_x0;
    const num1 = (l1_x1 - l1_x0) * a2 - (l1_y1 - l1_y0) * b2;
    const num2 = (l0_x1 - l0_x0) * a2 - (l0_y1 - l0_y0) * b2;
    a2 = num1 / den;
    b2 = num2 / den;
    const x2 = l0_x0 + a2 * (l0_x1 - l0_x0);
    const y2 = l0_y0 + a2 * (l0_y1 - l0_y0);
    return { hit: a2 > 0 && a2 < 1 && (b2 > 0 && b2 < 1), x: x2, y: y2 };
  }
}
function vertex_overlap(x0, y0, x1, y1) {
  for (let i2 = 0; i2 < x0.length; i2++) {
    if (point_in_poly(x0[i2], y0[i2], x1, y1)) {
      return true;
    }
  }
  for (let i2 = 0; i2 < x1.length; i2++) {
    if (point_in_poly(x1[i2], y1[i2], x0, y0)) {
      return true;
    }
  }
  return false;
}
function edge_intersection(x0, y0, x1, y1) {
  for (let i2 = 0; i2 < x0.length - 1; i2++) {
    for (let j = 0; j < x1.length - 1; j++) {
      if (check_2_segments_intersect(x0[i2], y0[i2], x0[i2 + 1], y0[i2 + 1], x1[j], y1[j], x1[j + 1], y1[j + 1]).hit) {
        return true;
      }
    }
    if (check_2_segments_intersect(x0[i2], y0[i2], x0[i2 + 1], y0[i2 + 1], x1[x1.length - 1], y1[x1.length - 1], x1[0], y1[0]).hit) {
      return true;
    }
  }
  if (check_2_segments_intersect(x0[x0.length - 1], y0[x0.length - 1], x0[0], y0[0], x1[x1.length - 1], y1[x1.length - 1], x1[0], y1[0]).hit) {
    return true;
  }
  return false;
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/utils.js
function generic_line_scalar_legend(visuals, ctx, { x0, x1, y0, y1 }) {
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x0, (y0 + y1) / 2);
  ctx.lineTo(x1, (y0 + y1) / 2);
  visuals.line.apply(ctx);
  ctx.restore();
}
function generic_line_vector_legend(visuals, ctx, { x0, x1, y0, y1 }, i2) {
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x0, (y0 + y1) / 2);
  ctx.lineTo(x1, (y0 + y1) / 2);
  visuals.line.apply(ctx, i2);
  ctx.restore();
}
function generic_area_scalar_legend(visuals, ctx, { x0, x1, y0, y1 }) {
  var _a34, _b4;
  const w = Math.abs(x1 - x0);
  const dw = w * 0.1;
  const h7 = Math.abs(y1 - y0);
  const dh = h7 * 0.1;
  const sx0 = x0 + dw;
  const sx1 = x1 - dw;
  const sy0 = y0 + dh;
  const sy1 = y1 - dh;
  ctx.beginPath();
  ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);
  visuals.fill.apply(ctx);
  (_a34 = visuals.hatch) == null ? void 0 : _a34.apply(ctx);
  (_b4 = visuals.line) == null ? void 0 : _b4.apply(ctx);
}
function generic_area_vector_legend(visuals, ctx, { x0, x1, y0, y1 }, i2) {
  var _a34, _b4;
  const w = Math.abs(x1 - x0);
  const dw = w * 0.1;
  const h7 = Math.abs(y1 - y0);
  const dh = h7 * 0.1;
  const sx0 = x0 + dw;
  const sx1 = x1 - dw;
  const sy0 = y0 + dh;
  const sy1 = y1 - dh;
  ctx.beginPath();
  ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);
  visuals.fill.apply(ctx, i2);
  (_a34 = visuals.hatch) == null ? void 0 : _a34.apply(ctx, i2);
  (_b4 = visuals.line) == null ? void 0 : _b4.apply(ctx, i2);
}
function line_interpolation(renderer, geometry, x2, y2, x3, y3) {
  const { sx, sy } = geometry;
  let x0, x1;
  let y0, y1;
  if (geometry.type == "point") {
    [y0, y1] = renderer.yscale.r_invert(sy - 1, sy + 1);
    [x0, x1] = renderer.xscale.r_invert(sx - 1, sx + 1);
  } else {
    if (geometry.direction == "v") {
      [y0, y1] = renderer.yscale.r_invert(sy, sy);
      [x0, x1] = [Math.min(x2 - 1, x3 - 1), Math.max(x2 + 1, x3 + 1)];
    } else {
      [x0, x1] = renderer.xscale.r_invert(sx, sx);
      [y0, y1] = [Math.min(y2 - 1, y3 - 1), Math.max(y2 + 1, y3 + 1)];
    }
  }
  const { x: x4, y: y4 } = check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);
  return [x4, y4];
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/line.js
var LineView = class extends XYGlyphView {
  async load_glglyph() {
    const { LineGL } = await import("./line_gl-CYNBD7YX.js");
    return LineGL;
  }
  _paint(ctx, indices, data3) {
    const { sx, sy } = { ...this, ...data3 };
    const nonselection = this.parent.nonselection_glyph == this;
    let iprev = null;
    const gap = (i2) => iprev != null && i2 - iprev != 1;
    let move = true;
    ctx.beginPath();
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      if (nonselection && !move && iprev != null && i2 - iprev > 1 && isFinite(sx[iprev + 1] + sy[iprev + 1])) {
        ctx.lineTo(sx[iprev + 1], sy[iprev + 1]);
      }
      if (!isFinite(sx_i + sy_i)) {
        move = true;
      } else {
        if (move || gap(i2)) {
          if (nonselection && i2 > 0 && isFinite(sx[i2 - 1] + sy[i2 - 1])) {
            ctx.moveTo(sx[i2 - 1], sy[i2 - 1]);
            ctx.lineTo(sx_i, sy_i);
          } else {
            ctx.moveTo(sx_i, sy_i);
          }
          move = false;
        } else {
          ctx.lineTo(sx_i, sy_i);
        }
        iprev = i2;
      }
    }
    if (nonselection && !move && iprev != null) {
      const n2 = sx.length;
      if (iprev < n2 - 1 && isFinite(sx[iprev + 1] + sy[iprev + 1])) {
        ctx.lineTo(sx[iprev + 1], sy[iprev + 1]);
      }
    }
    this.visuals.line.set_value(ctx);
    ctx.stroke();
  }
  _hit_point(geometry) {
    const result = new Selection();
    const point = { x: geometry.sx, y: geometry.sy };
    let shortest = 9999;
    const threshold = Math.max(2, this.line_width.value / 2);
    for (let i2 = 0, end = this.sx.length - 1; i2 < end; i2++) {
      const p0 = { x: this.sx[i2], y: this.sy[i2] };
      const p1 = { x: this.sx[i2 + 1], y: this.sy[i2 + 1] };
      const dist = dist_to_segment(point, p0, p1);
      if (dist < threshold && dist < shortest) {
        shortest = dist;
        result.add_to_selected_glyphs(this.model);
        result.view = this;
        result.line_indices = [i2];
      }
    }
    return result;
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    let val;
    let values2;
    if (geometry.direction == "v") {
      val = this.renderer.yscale.invert(sy);
      values2 = this.y;
    } else {
      val = this.renderer.xscale.invert(sx);
      values2 = this.x;
    }
    const indices = [];
    for (let i2 = 0, end = values2.length - 1; i2 < end; i2++) {
      const curr = values2[i2];
      const next = values2[i2 + 1];
      if (curr <= val && val <= next || next <= val && val <= curr) {
        indices.push(i2);
      }
    }
    const result = new Selection();
    if (indices.length != 0) {
      result.add_to_selected_glyphs(this.model);
      result.view = this;
      result.line_indices = indices;
    }
    return result;
  }
  get_interpolation_hit(i2, geometry) {
    const [x2, y2, x3, y3] = [this.x[i2], this.y[i2], this.x[i2 + 1], this.y[i2 + 1]];
    return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);
  }
  draw_legend_for_index(ctx, bbox, _index) {
    generic_line_scalar_legend(this.visuals, ctx, bbox);
  }
};
__publicField(LineView, "__name__", "LineView");
var _Line = class _Line extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Line, "__name__", "Line");
_Line.prototype.default_view = LineView;
_Line.mixins(LineScalar);
var Line3 = _Line;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/patch.js
var PatchView = class extends XYGlyphView {
  _paint(ctx, indices, data3) {
    const { sx, sy } = { ...this, ...data3 };
    let move = true;
    ctx.beginPath();
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      if (!isFinite(sx_i + sy_i)) {
        ctx.closePath();
        move = true;
      } else {
        if (move) {
          ctx.moveTo(sx_i, sy_i);
          move = false;
        } else {
          ctx.lineTo(sx_i, sy_i);
        }
      }
    }
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    this.visuals.hatch.apply(ctx);
    this.visuals.line.apply(ctx);
  }
  draw_legend_for_index(ctx, bbox, _index) {
    generic_area_scalar_legend(this.visuals, ctx, bbox);
  }
  _hit_point(geometry) {
    const result = new Selection();
    if (point_in_poly(geometry.sx, geometry.sy, this.sx, this.sy)) {
      result.add_to_selected_glyphs(this.model);
      result.view = this;
    }
    return result;
  }
};
__publicField(PatchView, "__name__", "PatchView");
var _Patch = class _Patch extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Patch, "__name__", "Patch");
_Patch.prototype.default_view = PatchView;
_Patch.mixins([LineScalar, FillScalar, HatchScalar]);
var Patch = _Patch;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/area.js
var AreaView = class extends GlyphView {
  draw_legend_for_index(ctx, bbox, _index) {
    generic_area_scalar_legend(this.visuals, ctx, bbox);
  }
};
__publicField(AreaView, "__name__", "AreaView");
var _Area = class _Area extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Area, "__name__", "Area");
_Area.mixins([FillScalar, HatchScalar]);
var Area = _Area;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/flip_step_mode.js
function flip_step_mode(mode) {
  switch (mode) {
    case "before":
      return "after";
    case "after":
      return "before";
    case "center":
      return "center";
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/harea_step.js
var HAreaStepView = class extends AreaView {
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { x1, x2, y: y2 } = this;
    for (let i2 = 0; i2 < this.data_size; i2++) {
      const x1_i = x1[i2];
      const x2_i = x2[i2];
      const y_i = y2[i2];
      index2.add_rect(min10(x1_i, x2_i), y_i, max18(x1_i, x2_i), y_i);
    }
  }
  _step_path(ctx, mode, sx, sy, from_i, to_i) {
    let prev_x = sx[from_i];
    let prev_y = sy[from_i];
    const idx_dir = from_i < to_i ? 1 : -1;
    for (let i2 = from_i + idx_dir; i2 != to_i; i2 += idx_dir) {
      switch (mode) {
        case "before": {
          ctx.lineTo(sx[i2], prev_y);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
        case "after": {
          ctx.lineTo(prev_x, sy[i2]);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
        case "center": {
          const mid_y = (prev_y + sy[i2]) / 2;
          ctx.lineTo(prev_x, mid_y);
          ctx.lineTo(sx[i2], mid_y);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
      }
      prev_x = sx[i2];
      prev_y = sy[i2];
    }
  }
  _paint(ctx, _indices, data3) {
    const { sx1, sx2, sy } = { ...this, ...data3 };
    const forward_mode = this.model.step_mode;
    const backward_mode = flip_step_mode(this.model.step_mode);
    ctx.beginPath();
    ctx.moveTo(sx1[0], sy[0]);
    this._step_path(ctx, forward_mode, sx1, sy, 0, sy.length);
    this._step_path(ctx, backward_mode, sx2, sy, sy.length, -1);
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    this.visuals.hatch.apply(ctx);
  }
  scenterxy(i2) {
    const scx = (this.sx1[i2] + this.sx2[i2]) / 2;
    const scy = this.sy[i2];
    return [scx, scy];
  }
  _line_selection_for(i2) {
    return new Selection({ line_indices: [i2], selected_glyphs: [this.model], view: this });
  }
  _hit_point_before(geometry) {
    const { sy, sx1, sx2 } = this;
    for (let i2 = 1; i2 < this.data_size; i2++) {
      const px2 = [sx1[i2], sx1[i2], sx2[i2], sx2[i2]];
      const py = [sy[i2 - 1], sy[i2], sy[i2], sy[i2 - 1]];
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point_after(geometry) {
    const { sy, sx1, sx2 } = this;
    for (let i2 = 0; i2 < this.data_size - 1; i2++) {
      const px2 = [sx1[i2], sx1[i2], sx2[i2], sx2[i2]];
      const py = [sy[i2], sy[i2 + 1], sy[i2 + 1], sy[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point_center(geometry) {
    const { sy, sx1, sx2 } = this;
    for (let i2 = 0; i2 < this.data_size; i2++) {
      const mid_prev_y = (sy[i2 - 1] + sy[i2]) / 2;
      const mid_next_y = (sy[i2] + sy[i2 + 1]) / 2;
      const px2 = [sx1[i2], sx1[i2], sx2[i2], sx2[i2]];
      const py = (() => {
        if (i2 == 0) {
          return [sy[i2], mid_next_y, mid_next_y, sy[i2]];
        } else if (i2 == this.data_size - 1) {
          return [mid_prev_y, sy[i2], sy[i2], mid_prev_y];
        } else {
          return [mid_prev_y, mid_next_y, mid_next_y, mid_prev_y];
        }
      })();
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point(geometry) {
    switch (this.model.step_mode) {
      case "before":
        return this._hit_point_before(geometry);
      case "after":
        return this._hit_point_after(geometry);
      case "center":
        return this._hit_point_center(geometry);
    }
  }
};
__publicField(HAreaStepView, "__name__", "HAreaStepView");
var _HAreaStep = class _HAreaStep extends Area {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HAreaStep, "__name__", "HAreaStep");
_HAreaStep.prototype.default_view = HAreaStepView;
_HAreaStep.define(({}) => ({
  x1: [XCoordinateSpec, { field: "x1" }],
  x2: [XCoordinateSpec, { field: "x2" }],
  y: [YCoordinateSpec, { field: "y" }],
  step_mode: [StepMode, "before"]
}));
var HAreaStep = _HAreaStep;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/harea.js
var HAreaView = class extends AreaView {
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x1_i = this.x1[i2];
      const x2_i = this.x2[i2];
      const y_i = this.y[i2];
      index2.add_rect(min10(x1_i, x2_i), y_i, max18(x1_i, x2_i), y_i);
    }
  }
  _paint(ctx, _indices, data3) {
    const { sx1, sx2, sy } = { ...this, ...data3 };
    ctx.beginPath();
    for (let i2 = 0, end = sx1.length; i2 < end; i2++) {
      ctx.lineTo(sx1[i2], sy[i2]);
    }
    for (let i2 = sx2.length - 1; i2 >= 0; i2--) {
      ctx.lineTo(sx2[i2], sy[i2]);
    }
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    this.visuals.hatch.apply(ctx);
  }
  _hit_point(geometry) {
    const L = this.sy.length;
    const result = new Selection();
    for (let i2 = 0, end = L - 1; i2 < end; i2++) {
      const sx = [this.sx1[i2], this.sx1[i2 + 1], this.sx2[i2 + 1], this.sx2[i2]];
      const sy = [this.sy[i2], this.sy[i2 + 1], this.sy[i2 + 1], this.sy[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, sx, sy)) {
        result.add_to_selected_glyphs(this.model);
        result.view = this;
        result.line_indices = [i2];
        break;
      }
    }
    return result;
  }
  scenterxy(i2) {
    const scx = (this.sx1[i2] + this.sx2[i2]) / 2;
    const scy = this.sy[i2];
    return [scx, scy];
  }
};
__publicField(HAreaView, "__name__", "HAreaView");
var _HArea = class _HArea extends Area {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HArea, "__name__", "HArea");
_HArea.prototype.default_view = HAreaView;
_HArea.define(({}) => ({
  x1: [XCoordinateSpec, { field: "x1" }],
  x2: [XCoordinateSpec, { field: "x2" }],
  y: [YCoordinateSpec, { field: "y" }]
}));
var HArea = _HArea;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/varea_step.js
var VAreaStepView = class extends AreaView {
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { x: x2, y1, y2 } = this;
    for (let i2 = 0; i2 < this.data_size; i2++) {
      const x_i = x2[i2];
      const y1_i = y1[i2];
      const y2_i = y2[i2];
      index2.add_rect(x_i, min10(y1_i, y2_i), x_i, max18(y1_i, y2_i));
    }
  }
  _step_path(ctx, mode, sx, sy, from_i, to_i) {
    let prev_x = sx[from_i];
    let prev_y = sy[from_i];
    const idx_dir = from_i < to_i ? 1 : -1;
    for (let i2 = from_i + idx_dir; i2 != to_i; i2 += idx_dir) {
      switch (mode) {
        case "before": {
          ctx.lineTo(prev_x, sy[i2]);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
        case "after": {
          ctx.lineTo(sx[i2], prev_y);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
        case "center": {
          const mid_x = (prev_x + sx[i2]) / 2;
          ctx.lineTo(mid_x, prev_y);
          ctx.lineTo(mid_x, sy[i2]);
          ctx.lineTo(sx[i2], sy[i2]);
          break;
        }
      }
      prev_x = sx[i2];
      prev_y = sy[i2];
    }
  }
  _paint(ctx, _indices, data3) {
    const { sx, sy1, sy2 } = { ...this, ...data3 };
    const forward_mode = this.model.step_mode;
    const backward_mode = flip_step_mode(this.model.step_mode);
    ctx.beginPath();
    ctx.moveTo(sx[0], sy1[0]);
    this._step_path(ctx, forward_mode, sx, sy1, 0, sx.length);
    this._step_path(ctx, backward_mode, sx, sy2, sx.length, -1);
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    this.visuals.hatch.apply(ctx);
  }
  scenterxy(i2) {
    const scx = this.sx[i2];
    const scy = (this.sy1[i2] + this.sy2[i2]) / 2;
    return [scx, scy];
  }
  _line_selection_for(i2) {
    return new Selection({ line_indices: [i2], selected_glyphs: [this.model], view: this });
  }
  _hit_point_before(geometry) {
    const { sx, sy1, sy2 } = this;
    for (let i2 = 1; i2 < this.data_size; i2++) {
      const px2 = [sx[i2 - 1], sx[i2], sx[i2], sx[i2 - 1]];
      const py = [sy1[i2], sy1[i2], sy2[i2], sy2[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point_after(geometry) {
    const { sx, sy1, sy2 } = this;
    for (let i2 = 0; i2 < this.data_size - 1; i2++) {
      const px2 = [sx[i2], sx[i2 + 1], sx[i2 + 1], sx[i2]];
      const py = [sy1[i2], sy1[i2], sy2[i2], sy2[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point_center(geometry) {
    const { sx, sy1, sy2 } = this;
    for (let i2 = 0; i2 < this.data_size; i2++) {
      const mid_prev_x = (sx[i2 - 1] + sx[i2]) / 2;
      const mid_next_x = (sx[i2] + sx[i2 + 1]) / 2;
      const px2 = (() => {
        if (i2 == 0) {
          return [sx[i2], mid_next_x, mid_next_x, sx[i2]];
        } else if (i2 == this.data_size - 1) {
          return [mid_prev_x, sx[i2], sx[i2], mid_prev_x];
        } else {
          return [mid_prev_x, mid_next_x, mid_next_x, mid_prev_x];
        }
      })();
      const py = [sy1[i2], sy1[i2], sy2[i2], sy2[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, px2, py)) {
        return this._line_selection_for(i2);
      }
    }
    return new Selection();
  }
  _hit_point(geometry) {
    switch (this.model.step_mode) {
      case "before":
        return this._hit_point_before(geometry);
      case "after":
        return this._hit_point_after(geometry);
      case "center":
        return this._hit_point_center(geometry);
    }
  }
};
__publicField(VAreaStepView, "__name__", "VAreaStepView");
var _VAreaStep = class _VAreaStep extends Area {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VAreaStep, "__name__", "VAreaStep");
_VAreaStep.prototype.default_view = VAreaStepView;
_VAreaStep.define(({}) => ({
  x: [XCoordinateSpec, { field: "x" }],
  y1: [YCoordinateSpec, { field: "y1" }],
  y2: [YCoordinateSpec, { field: "y2" }],
  step_mode: [StepMode, "before"]
}));
var VAreaStep = _VAreaStep;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/varea.js
var VAreaView = class extends AreaView {
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x2 = this.x[i2];
      const y1 = this.y1[i2];
      const y2 = this.y2[i2];
      index2.add_rect(x2, min10(y1, y2), x2, max18(y1, y2));
    }
  }
  _paint(ctx, _indices, data3) {
    const { sx, sy1, sy2 } = { ...this, ...data3 };
    ctx.beginPath();
    for (let i2 = 0, end = sy1.length; i2 < end; i2++) {
      ctx.lineTo(sx[i2], sy1[i2]);
    }
    for (let i2 = sy2.length - 1; i2 >= 0; i2--) {
      ctx.lineTo(sx[i2], sy2[i2]);
    }
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    this.visuals.hatch.apply(ctx);
  }
  scenterxy(i2) {
    const scx = this.sx[i2];
    const scy = (this.sy1[i2] + this.sy2[i2]) / 2;
    return [scx, scy];
  }
  _hit_point(geometry) {
    const L = this.sx.length;
    const result = new Selection();
    for (let i2 = 0, end = L - 1; i2 < end; i2++) {
      const sx = [this.sx[i2], this.sx[i2 + 1], this.sx[i2 + 1], this.sx[i2]];
      const sy = [this.sy1[i2], this.sy1[i2 + 1], this.sy2[i2 + 1], this.sy2[i2]];
      if (point_in_poly(geometry.sx, geometry.sy, sx, sy)) {
        result.add_to_selected_glyphs(this.model);
        result.view = this;
        result.line_indices = [i2];
        break;
      }
    }
    return result;
  }
};
__publicField(VAreaView, "__name__", "VAreaView");
var _VArea = class _VArea extends Area {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VArea, "__name__", "VArea");
_VArea.prototype.default_view = VAreaView;
_VArea.define(({}) => ({
  x: [XCoordinateSpec, { field: "x" }],
  y1: [YCoordinateSpec, { field: "y1" }],
  y2: [YCoordinateSpec, { field: "y2" }]
}));
var VArea = _VArea;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/filter.js
var Filter = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Filter, "__name__", "Filter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/all_indices.js
var AllIndices = class extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  compute_indices(source2) {
    const size2 = source2.get_length() ?? 1;
    return BitSet.all_set(size2);
  }
};
__publicField(AllIndices, "__name__", "AllIndices");

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/composite_filter.js
var _CompositeFilter = class _CompositeFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  connect_signals() {
    super.connect_signals();
    const emit_changed = () => {
      this.change.emit();
    };
    const connect_operands = (operands2) => {
      for (const operand of operands2) {
        this.connect(operand.change, emit_changed);
      }
    };
    const disconnect_operands = (operands2) => {
      for (const operand of operands2) {
        this.disconnect(operand.change, emit_changed);
      }
    };
    let operands = (() => {
      const { operands: operands2 } = this.properties;
      return operands2.is_unset ? [] : operands2.get_value();
    })();
    connect_operands(operands);
    this.on_change(this.properties.operands, () => {
      disconnect_operands(operands);
      operands = this.operands;
      connect_operands(operands);
    });
  }
  compute_indices(source2) {
    const { operands } = this;
    if (operands.length == 0) {
      const size2 = source2.get_length() ?? 1;
      return BitSet.all_set(size2);
    } else {
      const [index2, ...rest] = operands.map((op) => op.compute_indices(source2));
      for (const op of rest) {
        this._inplace_op(index2, op);
      }
      return index2;
    }
  }
};
__publicField(_CompositeFilter, "__name__", "CompositeFilter");
_CompositeFilter.define(({ List: List2, Ref: Ref2 }) => ({
  operands: [List2(Ref2(Filter))]
}));
var CompositeFilter = _CompositeFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/intersection_filter.js
var IntersectionFilter = class extends CompositeFilter {
  constructor(attrs) {
    super(attrs);
  }
  _inplace_op(index2, op) {
    index2.intersect(op);
  }
};
__publicField(IntersectionFilter, "__name__", "IntersectionFilter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/cds_view.js
var CDSViewView = class extends View {
  initialize() {
    super.initialize();
    this.compute_indices();
  }
  connect_signals() {
    super.connect_signals();
    const compute_indices = () => {
      this.compute_indices();
    };
    const connect_filter = (filter3) => {
      this.connect(filter3.change, compute_indices);
    };
    const disconnect_filter = (filter3) => {
      this.disconnect(filter3.change, compute_indices);
    };
    let { filter: filter2 } = this.model;
    connect_filter(filter2);
    this.on_change(this.model.properties.filter, () => {
      disconnect_filter(filter2);
      filter2 = this.model.filter;
      connect_filter(filter2);
      compute_indices();
    });
    const connect_data_source = (data_source2) => {
      this.connect(data_source2.change, compute_indices);
      this.connect(data_source2.streaming, compute_indices);
      this.connect(data_source2.patching, compute_indices);
      this.connect(data_source2.properties.data.change, compute_indices);
    };
    const disconnect_data_source = (data_source2) => {
      this.disconnect(data_source2.change, compute_indices);
      this.disconnect(data_source2.streaming, compute_indices);
      this.disconnect(data_source2.patching, compute_indices);
      this.disconnect(data_source2.properties.data.change, compute_indices);
    };
    let data_source = this.parent.data_source.get_value();
    connect_data_source(data_source);
    this.on_change(this.parent.data_source, () => {
      disconnect_data_source(data_source);
      data_source = this.parent.data_source.get_value();
      connect_data_source(data_source);
      compute_indices();
    });
  }
  compute_indices() {
    const source2 = this.parent.data_source.get_value();
    const size2 = source2.get_length() ?? 1;
    const indices = BitSet.all_set(size2);
    const filtered = this.model.filter.compute_indices(source2);
    indices.intersect(filtered);
    this.model.indices = indices;
    this.model._indices_map_to_subset();
  }
};
__publicField(CDSViewView, "__name__", "CDSViewView");
var _CDSView = class _CDSView extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_indices");
  }
  _indices_map_to_subset() {
    this._indices = [...this.indices];
    this.indices_map = /* @__PURE__ */ new Map();
    const { _indices, indices_map } = this;
    const n2 = _indices.length;
    for (let i2 = 0; i2 < n2; i2++) {
      indices_map.set(_indices[i2], i2);
    }
  }
  convert_selection_from_subset(selection_subset) {
    return selection_subset.map((i2) => this._indices[i2]);
  }
  convert_selection_to_subset(selection_full) {
    return selection_full.map((i2) => this.indices_map.get(i2));
  }
  convert_indices_from_subset(indices) {
    return indices.map((i2) => this._indices[i2]);
  }
  /** @deprecated */
  get filters() {
    const { filter: filter2 } = this;
    if (filter2 instanceof IntersectionFilter) {
      return filter2.operands;
    } else if (filter2 instanceof AllIndices) {
      return [];
    } else {
      return [filter2];
    }
  }
  /** @deprecated */
  set filters(filters) {
    if (filters.length == 0) {
      this.filter = new AllIndices();
    } else if (filters.length == 1) {
      this.filter = filters[0];
    } else {
      this.filter = new IntersectionFilter({ operands: filters });
    }
  }
};
__publicField(_CDSView, "__name__", "CDSView");
_CDSView.prototype.default_view = CDSViewView;
_CDSView.define(({ Ref: Ref2 }) => ({
  filter: [Ref2(Filter), () => new AllIndices()]
}));
_CDSView.internal(({ Int: Int2, Mapping: Mapping2, Ref: Ref2, Nullable: Nullable2 }) => ({
  indices: [Ref2(BitSet)],
  indices_map: [Mapping2(Int2, Int2), /* @__PURE__ */ new Map()],
  masked: [Nullable2(Ref2(BitSet)), null]
}));
var CDSView = _CDSView;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/glyph_renderer.js
var selection_defaults = {
  fill: {},
  line: {}
};
var decimated_defaults = {
  fill: { fill_alpha: 0.3, fill_color: "grey" },
  line: { line_alpha: 0.3, line_color: "grey" }
};
var nonselection_defaults = {
  fill: { fill_alpha: 0.2 },
  line: {}
};
var muted_defaults = {
  fill: { fill_alpha: 0.2 },
  line: {}
};
var GlyphRendererView = class extends DataRendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "cds_view");
    __publicField(this, "glyph");
    __publicField(this, "selection_glyph");
    __publicField(this, "nonselection_glyph");
    __publicField(this, "hover_glyph");
    __publicField(this, "muted_glyph");
    __publicField(this, "decimated_glyph");
    __publicField(this, "all_indices");
    __publicField(this, "decimated");
    __publicField(this, "last_dtrender");
    __publicField(this, "_previous_inspected");
  }
  get glyph_view() {
    return this.glyph;
  }
  *children() {
    yield* super.children();
    yield this.cds_view;
    yield this.glyph;
    yield this.selection_glyph;
    yield this.nonselection_glyph;
    if (this.hover_glyph != null) {
      yield this.hover_glyph;
    }
    yield this.muted_glyph;
    yield this.decimated_glyph;
  }
  get data_source() {
    return this.model.properties.data_source;
  }
  async lazy_initialize() {
    var _a34;
    await super.lazy_initialize();
    this.cds_view = await build_view(this.model.view, { parent: this });
    const base_glyph = this.model.glyph;
    this.glyph = await this.build_glyph_view(base_glyph);
    const has_fill = "fill" in this.glyph.visuals;
    const has_line = "line" in this.glyph.visuals;
    const glyph_attrs = { ...base_glyph.attributes };
    delete glyph_attrs.id;
    function mk_glyph(defaults3) {
      const attrs = clone(glyph_attrs);
      if (has_fill) {
        extend(attrs, defaults3.fill);
      }
      if (has_line) {
        extend(attrs, defaults3.line);
      }
      return new base_glyph.constructor(attrs);
    }
    function glyph_from_mode(defaults3, glyph) {
      if (glyph instanceof Glyph) {
        return glyph;
      } else if (glyph == "auto") {
        return mk_glyph(defaults3);
      }
      return mk_glyph({ fill: {}, line: {} });
    }
    let { selection_glyph, nonselection_glyph, hover_glyph, muted_glyph } = this.model;
    selection_glyph = glyph_from_mode(selection_defaults, selection_glyph);
    this.selection_glyph = await this.build_glyph_view(selection_glyph);
    nonselection_glyph = glyph_from_mode(nonselection_defaults, nonselection_glyph);
    this.nonselection_glyph = await this.build_glyph_view(nonselection_glyph);
    if (hover_glyph != null) {
      this.hover_glyph = await this.build_glyph_view(hover_glyph);
    }
    muted_glyph = glyph_from_mode(muted_defaults, muted_glyph);
    this.muted_glyph = await this.build_glyph_view(muted_glyph);
    const decimated_glyph = glyph_from_mode(decimated_defaults, "auto");
    this.decimated_glyph = await this.build_glyph_view(decimated_glyph);
    this.selection_glyph.set_base(this.glyph);
    this.nonselection_glyph.set_base(this.glyph);
    (_a34 = this.hover_glyph) == null ? void 0 : _a34.set_base(this.glyph);
    this.muted_glyph.set_base(this.glyph);
    this.decimated_glyph.set_base(this.glyph);
    await this.set_data();
  }
  async build_glyph_view(glyph) {
    return build_view(glyph, { parent: this });
  }
  remove() {
    var _a34;
    this.cds_view.remove();
    this.glyph.remove();
    this.selection_glyph.remove();
    this.nonselection_glyph.remove();
    (_a34 = this.hover_glyph) == null ? void 0 : _a34.remove();
    this.muted_glyph.remove();
    this.decimated_glyph.remove();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const render2 = () => this.request_paint();
    const update = () => this.update_data();
    this.connect(this.model.change, render2);
    this.connect(this.glyph.model.change, update);
    this.connect(this.selection_glyph.model.change, update);
    this.connect(this.nonselection_glyph.model.change, update);
    if (this.hover_glyph != null) {
      this.connect(this.hover_glyph.model.change, update);
    }
    this.connect(this.muted_glyph.model.change, update);
    this.connect(this.decimated_glyph.model.change, update);
    this.connect(this.model.data_source.change, update);
    this.connect(this.model.data_source.streaming, update);
    this.connect(this.model.data_source.patching, (indices) => this.update_data(indices));
    this.connect(this.model.data_source.selected.change, render2);
    this.connect(this.model.data_source._select, render2);
    if (this.hover_glyph != null) {
      this.connect(this.model.data_source.inspect, () => {
        const { inspected } = this.model.data_source;
        const current_inspected = {
          indices: inspected.indices,
          line_indices: inspected.line_indices,
          multiline_indices: inspected.multiline_indices,
          image_indices: inspected.image_indices,
          selected_glyphs: inspected.selected_glyphs
        };
        if (!is_equal(this._previous_inspected, current_inspected)) {
          this._previous_inspected = current_inspected;
          render2();
        }
      });
    }
    this.connect(this.model.properties.view.change, async () => {
      this.cds_view.remove();
      this.cds_view = await build_view(this.model.view, { parent: this });
      await update();
    });
    this.connect(this.model.view.properties.indices.change, update);
    this.connect(this.model.view.properties.masked.change, async () => await this.set_visuals());
    this.connect(this.model.properties.visible.change, () => this.plot_view.invalidate_dataranges = true);
    const { x_ranges, y_ranges } = this.plot_view.frame;
    for (const [, range2] of x_ranges) {
      if (range2 instanceof FactorRange) {
        this.connect(range2.invalidate_synthetic, update);
      }
    }
    for (const [, range2] of y_ranges) {
      if (range2 instanceof FactorRange) {
        this.connect(range2.invalidate_synthetic, update);
      }
    }
    const { transformchange, exprchange } = this.model.glyph;
    this.connect(transformchange, update);
    this.connect(exprchange, update);
  }
  _update_masked_indices() {
    const masked = this.glyph.mask_data();
    this.model.view.masked = masked;
    return masked;
  }
  async update_data(indices) {
    await this.set_data(indices);
    this.request_paint();
  }
  // in case of partial updates like patching, the list of indices that actually
  // changed may be passed as the "indices" parameter to afford any optional optimizations
  async set_data(indices) {
    var _a34;
    const source2 = this.model.data_source;
    this.all_indices = this.model.view.indices;
    const { all_indices } = this;
    await this.glyph.set_data(source2, all_indices, indices);
    await this.decimated_glyph.set_data(source2, all_indices, indices);
    await this.selection_glyph.set_data(source2, all_indices, indices);
    await this.nonselection_glyph.set_data(source2, all_indices, indices);
    await ((_a34 = this.hover_glyph) == null ? void 0 : _a34.set_data(source2, all_indices, indices));
    await this.muted_glyph.set_data(source2, all_indices, indices);
    await this.set_visuals();
    this._update_masked_indices();
    const { lod_factor } = this.plot_model;
    const n2 = this.all_indices.count;
    this.decimated = new BitSet(n2);
    for (let i2 = 0; i2 < n2; i2 += lod_factor) {
      this.decimated.set(i2);
    }
    this.plot_view.invalidate_dataranges = true;
  }
  async set_visuals() {
    var _a34, _b4, _c;
    const source2 = this.model.data_source;
    const { all_indices } = this;
    this.glyph.set_visuals(source2, all_indices);
    this.glyph.after_visuals();
    await this.glyph.after_lazy_visuals();
    this.decimated_glyph.set_visuals(source2, all_indices);
    this.decimated_glyph.after_visuals();
    await this.decimated_glyph.after_lazy_visuals();
    this.selection_glyph.set_visuals(source2, all_indices);
    this.selection_glyph.after_visuals();
    await this.selection_glyph.after_lazy_visuals();
    this.nonselection_glyph.set_visuals(source2, all_indices);
    this.nonselection_glyph.after_visuals();
    await this.nonselection_glyph.after_lazy_visuals();
    (_a34 = this.hover_glyph) == null ? void 0 : _a34.set_visuals(source2, all_indices);
    (_b4 = this.hover_glyph) == null ? void 0 : _b4.after_visuals();
    await ((_c = this.hover_glyph) == null ? void 0 : _c.after_lazy_visuals());
    this.muted_glyph.set_visuals(source2, all_indices);
    this.muted_glyph.after_visuals();
    await this.muted_glyph.after_lazy_visuals();
  }
  map_data() {
    var _a34;
    this.glyph.map_data();
    this.decimated_glyph.map_data();
    this.selection_glyph.map_data();
    this.nonselection_glyph.map_data();
    (_a34 = this.hover_glyph) == null ? void 0 : _a34.map_data();
    this.muted_glyph.map_data();
  }
  get bbox() {
    return this.glyph.bbox;
  }
  get has_webgl() {
    return this.glyph.has_webgl;
  }
  _paint() {
    const { has_webgl } = this;
    this.map_data();
    const all_indices = [...this.all_indices];
    let indices = [...this._update_masked_indices()];
    const { ctx } = this.layer;
    ctx.save();
    const { selected } = this.model.data_source;
    const selected_full_indices = (() => {
      if (selected.is_empty()) {
        return [];
      } else {
        if (this.glyph instanceof LineView && selected.selected_glyph === this.glyph.model) {
          return this.model.view.convert_indices_from_subset(indices);
        } else {
          return selected.indices;
        }
      }
    })();
    const { inspected } = this.model.data_source;
    this._previous_inspected = {
      indices: inspected.indices,
      line_indices: inspected.line_indices,
      multiline_indices: inspected.multiline_indices,
      image_indices: inspected.image_indices,
      selected_glyphs: inspected.selected_glyphs
    };
    const inspected_full_indices = new Set((() => {
      if (inspected.is_empty()) {
        return [];
      } else {
        if (inspected.selected_glyph != null) {
          return this.model.view.convert_indices_from_subset(indices);
        } else if (inspected.indices.length > 0) {
          return inspected.indices;
        } else {
          return Object.keys(inspected.multiline_indices).map((i2) => parseInt(i2));
        }
      }
    })());
    const inspected_subset_indices = filter(indices, (i2) => inspected_full_indices.has(all_indices[i2]));
    const { lod_threshold } = this.plot_model;
    let glyph;
    let nonselection_glyph;
    let selection_glyph;
    if ((this.model.document != null ? this.model.document.interactive_duration() > 0 : false) && !has_webgl && lod_threshold != null && all_indices.length > lod_threshold) {
      indices = [...this.decimated];
      glyph = this.decimated_glyph;
      nonselection_glyph = this.decimated_glyph;
      selection_glyph = this.selection_glyph;
    } else {
      glyph = this.model.muted ? this.muted_glyph : this.glyph;
      nonselection_glyph = this.nonselection_glyph;
      selection_glyph = this.selection_glyph;
    }
    if (this.hover_glyph != null && inspected_subset_indices.length != 0) {
      const set = new Set(indices);
      for (const i2 of inspected_subset_indices) {
        set.delete(i2);
      }
      indices = [...set];
    }
    if (selected_full_indices.length == 0) {
      if (this.glyph instanceof LineView) {
        if (this.hover_glyph != null && inspected_subset_indices.length != 0) {
          this.hover_glyph.paint(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices));
        } else {
          glyph.paint(ctx, all_indices);
        }
      } else if (this.glyph instanceof PatchView || this.glyph instanceof HAreaView || this.glyph instanceof VAreaView || this.glyph instanceof VAreaStepView || this.glyph instanceof HAreaStepView) {
        if (inspected.selected_glyphs.length == 0 || this.hover_glyph == null) {
          glyph.paint(ctx, all_indices);
        } else {
          for (const sglyph of inspected.selected_glyphs) {
            if (sglyph == this.glyph.model) {
              this.hover_glyph.paint(ctx, all_indices);
            }
          }
        }
      } else {
        glyph.paint(ctx, indices);
        if (this.hover_glyph != null && inspected_subset_indices.length != 0) {
          this.hover_glyph.paint(ctx, inspected_subset_indices);
        }
      }
    } else {
      const selected_mask = new Set(selected_full_indices);
      const selected_subset_indices = new Array();
      const nonselected_subset_indices = new Array();
      if (this.glyph instanceof LineView) {
        for (const i2 of all_indices) {
          if (selected_mask.has(i2)) {
            selected_subset_indices.push(i2);
          } else {
            nonselected_subset_indices.push(i2);
          }
        }
      } else {
        for (const i2 of indices) {
          if (selected_mask.has(all_indices[i2])) {
            selected_subset_indices.push(i2);
          } else {
            nonselected_subset_indices.push(i2);
          }
        }
      }
      nonselection_glyph.paint(ctx, nonselected_subset_indices);
      selection_glyph.paint(ctx, selected_subset_indices);
      if (this.hover_glyph != null) {
        if (this.glyph instanceof LineView) {
          this.hover_glyph.paint(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices));
        } else {
          this.hover_glyph.paint(ctx, inspected_subset_indices);
        }
      }
    }
    ctx.restore();
  }
  get_reference_point(field, value2) {
    if (field != null) {
      const array2 = this.model.data_source.get_column(field);
      if (array2 != null) {
        for (const [key, index2] of this.model.view.indices_map) {
          if (array2[key] == value2) {
            return index2;
          }
        }
      }
    }
    return 0;
  }
  draw_legend(ctx, x0, x1, y0, y1, field, label3, index2) {
    if (this.glyph.data_size == 0) {
      return;
    }
    const subset_index = (() => {
      if (index2 == null) {
        return this.get_reference_point(field, label3);
      } else {
        const { indices_map } = this.model.view;
        return indices_map.get(index2);
      }
    })();
    if (subset_index != null) {
      this.glyph.draw_legend_for_index(ctx, { x0, x1, y0, y1 }, subset_index);
    }
  }
  hit_test(geometry) {
    if (!this.model.visible) {
      return null;
    }
    const hit_test_result = this.glyph.hit_test(geometry);
    if (hit_test_result == null) {
      return null;
    }
    return this.model.view.convert_selection_from_subset(hit_test_result);
  }
};
__publicField(GlyphRendererView, "__name__", "GlyphRendererView");
var _GlyphRenderer = class _GlyphRenderer extends DataRenderer {
  constructor(attrs) {
    super(attrs);
  }
  get_selection_manager() {
    return this.data_source.selection_manager;
  }
  add_decoration(marking, node) {
    const decoration = new Decoration({ marking, node });
    const glyphs = [
      this.glyph,
      this.selection_glyph,
      this.nonselection_glyph,
      this.hover_glyph,
      this.muted_glyph
    ];
    for (const glyph of glyphs) {
      if (glyph instanceof Glyph) {
        glyph.decorations = [...glyph.decorations, decoration];
      }
    }
    return decoration;
  }
};
__publicField(_GlyphRenderer, "__name__", "GlyphRenderer");
_GlyphRenderer.prototype.default_view = GlyphRendererView;
_GlyphRenderer.define(({ Bool: Bool2, Auto: Auto2, Or: Or2, Ref: Ref2, Null: Null2, Nullable: Nullable2 }) => ({
  data_source: [Ref2(ColumnarDataSource)],
  view: [Ref2(CDSView), () => new CDSView()],
  glyph: [Ref2(Glyph)],
  hover_glyph: [Nullable2(Ref2(Glyph)), null],
  nonselection_glyph: [Or2(Ref2(Glyph), Auto2, Null2), "auto"],
  selection_glyph: [Or2(Ref2(Glyph), Auto2, Null2), "auto"],
  muted_glyph: [Or2(Ref2(Glyph), Auto2, Null2), "auto"],
  muted: [Bool2, false]
}));
var GlyphRenderer = _GlyphRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/continuous_color_mapper.js
var _ContinuousColorMapper = class _ContinuousColorMapper extends ColorMapper {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "MatricsType");
    __publicField(this, "_scan_data", null);
  }
  connect_signals() {
    super.connect_signals();
    const connect_renderers = () => {
      for (const [renderer] of this.domain) {
        this.connect(renderer.view.change, () => this.update_data());
        this.connect(renderer.data_source.selected.change, () => this.update_data());
      }
    };
    const { high, low, high_color, low_color, palette, nan_color } = this.properties;
    this.on_change([high, low, high_color, low_color, palette, nan_color], () => this.update_data());
    this.connect(this.properties.domain.change, () => connect_renderers());
    connect_renderers();
  }
  update_data() {
    const { domain, palette } = this;
    const all_data = [...this._collect(domain)];
    this._scan_data = this.scan(all_data, palette.length);
    this.metrics_change.emit();
    this.change.emit();
  }
  get metrics() {
    if (this._scan_data == null) {
      this.update_data();
    }
    return this._scan_data;
  }
  *_collect(domain) {
    for (const [renderer, fields] of domain) {
      for (const field of isArray(fields) ? fields : [fields]) {
        if (renderer.view.properties.indices.is_unset) {
          continue;
        }
        const column = renderer.data_source.get_column(field);
        if (column == null) {
          continue;
        }
        let array2 = renderer.view.indices.select(column);
        const masked = renderer.view.masked;
        const selected = renderer.data_source.selected.indices;
        let subset;
        if (masked != null && selected.length > 0) {
          subset = intersection([...masked], selected);
        } else if (masked != null) {
          subset = [...masked];
        } else if (selected.length > 0) {
          subset = selected;
        }
        if (subset != null) {
          array2 = map(subset, (i2) => array2[i2]);
        }
        if (array2.length > 0 && !isNumber(array2[0])) {
          for (const subarray of array2) {
            yield* subarray;
          }
        } else {
          yield* array2;
        }
      }
    }
  }
  _v_compute(data3, values2, palette, colors) {
    const { nan_color } = colors;
    let { low_color, high_color } = colors;
    if (low_color == null) {
      low_color = palette[0];
    }
    if (high_color == null) {
      high_color = palette[palette.length - 1];
    }
    const { domain } = this;
    const all_data = !is_empty(domain) ? [...this._collect(domain)] : data3;
    this._scan_data = this.scan(all_data, palette.length);
    this.metrics_change.emit();
    for (let i2 = 0, end = data3.length; i2 < end; i2++) {
      const d = data3[i2];
      if (isNaN(d)) {
        values2[i2] = nan_color;
      } else {
        values2[i2] = this.cmap(d, palette, low_color, high_color);
      }
    }
  }
  _colors(conv) {
    return {
      ...super._colors(conv),
      low_color: this.low_color != null ? conv(this.low_color) : void 0,
      high_color: this.high_color != null ? conv(this.high_color) : void 0
    };
  }
  cmap(value2, palette, low_color, high_color) {
    const index2 = this.value_to_index(value2, palette.length);
    if (index2 < 0) {
      return low_color;
    } else if (index2 >= palette.length) {
      return high_color;
    } else {
      return palette[index2];
    }
  }
};
__publicField(_ContinuousColorMapper, "__name__", "ContinuousColorMapper");
_ContinuousColorMapper.define(({ Float: Float2, Str: Str2, Ref: Ref2, Color: Color2, Or: Or2, Tuple: Tuple2, List: List2, Nullable: Nullable2 }) => {
  return {
    high: [Nullable2(Float2), null],
    low: [Nullable2(Float2), null],
    high_color: [Nullable2(Color2), null],
    low_color: [Nullable2(Color2), null],
    domain: [List2(Tuple2(Ref2(GlyphRenderer), Or2(Str2, List2(Str2)))), []]
  };
});
var ContinuousColorMapper = _ContinuousColorMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/scanning_color_mapper.js
var ScanningColorMapper = class extends ContinuousColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  index_to_value(index2) {
    const scan_data = this._scan_data;
    return scan_data.binning[index2];
  }
  value_to_index(value2, palette_length) {
    const scan_data = this._scan_data;
    if (value2 < scan_data.binning[0]) {
      return -1;
    } else if (value2 > scan_data.binning[scan_data.binning.length - 1]) {
      return palette_length;
    } else {
      return left_edge_index(value2, scan_data.binning);
    }
  }
};
__publicField(ScanningColorMapper, "__name__", "ScanningColorMapper");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tickers/binned_ticker.js
var _BinnedTicker = class _BinnedTicker extends Ticker {
  constructor(attrs) {
    super(attrs);
  }
  get_ticks(data_low, data_high, _range, _cross_loc) {
    const { binning } = this.mapper.metrics;
    const k_low = Math.max(0, left_edge_index(data_low, binning));
    const k_high = Math.min(left_edge_index(data_high, binning) + 1, binning.length - 1);
    const _major = [];
    for (let k = k_low; k <= k_high; k++) {
      _major.push(binning[k]);
    }
    const { num_major_ticks } = this;
    const major = [];
    const n2 = num_major_ticks == "auto" ? _major.length : num_major_ticks;
    const step = Math.max(1, Math.floor(_major.length / n2));
    for (let i2 = 0; i2 < _major.length; i2 += step) {
      major.push(_major[i2]);
    }
    return {
      major,
      minor: []
    };
  }
};
__publicField(_BinnedTicker, "__name__", "BinnedTicker");
_BinnedTicker.define(({ Float: Float2, Ref: Ref2, Or: Or2, Auto: Auto2 }) => ({
  mapper: [Ref2(ScanningColorMapper)],
  num_major_ticks: [Or2(Float2, Auto2), 8]
}));
var BinnedTicker = _BinnedTicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/categorical_tick_formatter.js
var CategoricalTickFormatter = class extends TickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(ticks, _opts) {
    return copy(ticks);
  }
};
__publicField(CategoricalTickFormatter, "__name__", "CategoricalTickFormatter");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/templating.js
var Numbro = __toESM(require_numbro());
var import_sprintf_js = __toESM(require_sprintf());
var import_timezone = __toESM(require_timezone());
var { abs: abs4 } = Math;
var DEFAULT_FORMATTERS = {
  raw: (value2, _format, _special_vars) => `${value2}`,
  basic: (value2, format7, special_vars) => basic_formatter(value2, format7, special_vars),
  numeral: (value2, format7, _special_vars) => Numbro.format(value2, format7),
  datetime: (value2, format7, _special_vars) => (0, import_timezone.default)(value2, format7),
  printf: (value2, format7, _special_vars) => sprintf(format7, value2)
};
function sprintf(format7, ...args) {
  return (0, import_sprintf_js.sprintf)(format7, ...args);
}
function basic_formatter(value2, _format, _special_vars) {
  if (isNumber(value2)) {
    const format7 = (() => {
      if (Number.isInteger(value2)) {
        return "%d";
      } else if (0.1 < abs4(value2) && abs4(value2) < 1e3) {
        return "%0.3f";
      } else {
        return "%0.3e";
      }
    })();
    return sprintf(format7, value2);
  } else {
    return `${value2}`;
  }
}
function get_formatter(spec, format7, formatters) {
  if (format7 == null) {
    return DEFAULT_FORMATTERS.basic;
  }
  if (formatters != null) {
    const formatter = dict(formatters).get(spec);
    if (formatter != null) {
      if (isString(formatter)) {
        if (formatter in DEFAULT_FORMATTERS) {
          return DEFAULT_FORMATTERS[formatter];
        } else {
          throw new Error(`Unknown tooltip field formatter type '${formatter}'`);
        }
      }
      return function(value2, format8, special_vars) {
        return formatter.format(value2, format8, special_vars);
      };
    }
  }
  return DEFAULT_FORMATTERS.numeral;
}
var MISSING = "???";
function _get_special_value(name, special_vars) {
  if (name in special_vars) {
    return special_vars[name];
  } else {
    logger.warn(`unknown special variable '$${name}'`);
    return MISSING;
  }
}
function _get_column_value(name, data_source, ind) {
  const column = data_source.get_column(name);
  if (column == null) {
    return null;
  }
  if (ind == null) {
    return null;
  }
  if (isNumber(ind)) {
    return column[ind];
  }
  const data3 = column[ind.index];
  if (isTypedArray(data3) || isArray(data3)) {
    if (isArray(data3[0])) {
      const row2 = data3[ind.j];
      return row2[ind.i];
    } else if (is_NDArray(data3) && data3.dimension == 3) {
      return data3.slice(ind.flat_index * data3.shape[2], (ind.flat_index + 1) * data3.shape[2]);
    } else {
      return data3[ind.flat_index];
    }
  } else {
    return data3;
  }
}
function get_value(type, name, data_source, i2, special_vars) {
  switch (type) {
    case "$":
      return _get_special_value(name, special_vars);
    case "@":
      return _get_column_value(name, data_source, i2);
  }
}
function replace_placeholders(content2, data_source, i2, formatters, special_vars = {}, encode) {
  let str;
  let has_html;
  if (isString(content2)) {
    str = content2;
    has_html = false;
  } else {
    str = content2.html;
    has_html = true;
  }
  str = str.replace(/@\$name/g, (_match) => `@{${special_vars.name}}`);
  str = process_placeholders(str, (type, name, format7, _2, spec) => {
    const value2 = get_value(type, name, data_source, i2, special_vars);
    if (format7 == "safe") {
      has_html = true;
      if (value2 == null) {
        return MISSING;
      } else if (isNumber(value2) && isNaN(value2)) {
        return "NaN";
      } else {
        return `${value2}`;
      }
    } else {
      const result = (() => {
        if (value2 == null) {
          return MISSING;
        } else if (isNumber(value2) && isNaN(value2)) {
          return "NaN";
        } else {
          const formatter = get_formatter(spec, format7, formatters);
          return `${formatter(value2, format7 ?? "", special_vars)}`;
        }
      })();
      return encode != null ? encode(result) : result;
    }
  });
  if (!has_html) {
    return str;
  } else {
    const parser = new DOMParser();
    const document2 = parser.parseFromString(str, "text/html");
    return [...document2.body.childNodes];
  }
}
var regex = /((?:[$@][\p{Letter}\p{Number}_]+)|(?:[$@]\{(?:[^{}]+)\}))(?:\{([^{}]+)\})?/gu;
function process_placeholders(text2, fn) {
  let i2 = 0;
  return text2.replace(regex, (_match, spec, format7) => {
    const type = spec[0];
    const name = spec.substring(1).replace(/^{/, "").replace(/}$/, "").trim();
    return fn(type, name, format7, i2++, spec) ?? MISSING;
  });
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/datetime_tick_formatter.js
var import_timezone2 = __toESM(require_timezone());
var resolution_order = [
  "microseconds",
  "milliseconds",
  "seconds",
  "minsec",
  "minutes",
  "hourmin",
  "hours",
  "days",
  "months",
  "years"
];
var tm_index_for_resolution = {
  microseconds: 0,
  milliseconds: 0,
  seconds: 5,
  minsec: 4,
  minutes: 4,
  hourmin: 3,
  hours: 3,
  days: 0,
  months: 0,
  years: 0
};
function _get_resolution(resolution_secs, span_secs) {
  const adjusted_ms = resolution_secs * 1.1 * 1e3;
  const span_ms = span_secs * 1e3;
  if (adjusted_ms < ONE_MILLI) {
    return "microseconds";
  }
  if (adjusted_ms < ONE_SECOND) {
    return "milliseconds";
  }
  if (adjusted_ms < ONE_MINUTE) {
    return span_ms >= ONE_MINUTE ? "minsec" : "seconds";
  }
  if (adjusted_ms < ONE_HOUR) {
    return span_ms >= ONE_HOUR ? "hourmin" : "minutes";
  }
  if (adjusted_ms < ONE_DAY) {
    return "hours";
  }
  if (adjusted_ms < ONE_MONTH) {
    return "days";
  }
  if (adjusted_ms < ONE_YEAR) {
    return "months";
  }
  return "years";
}
function _mktime(t) {
  return (0, import_timezone2.default)(t, "%Y %m %d %H %M %S").split(/\s+/).map((e) => parseInt(e, 10));
}
function _strftime(t, format7) {
  const microsecond_replacement_string = sprintf("$1%06d", _us(t));
  format7 = format7.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);
  if (format7.indexOf("%") == -1) {
    return format7;
  }
  return (0, import_timezone2.default)(t, format7);
}
function _us(t) {
  let us = Math.round(t / 1e3 % 1 * 1e6);
  if (t < 0) {
    us = (1e6 + us) % 1e6;
  }
  return us;
}
var _DatetimeTickFormatter = class _DatetimeTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(ticks, _opts, _resolution) {
    if (ticks.length == 0) {
      return [];
    }
    const span2 = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1e3;
    const r = span2 / (ticks.length - 1);
    const resolution = is_undefined(_resolution) ? _get_resolution(r, span2) : _resolution;
    let base_labels = [];
    for (const tick of ticks) {
      const base_label = this._compute_label(tick, resolution);
      base_labels.push(base_label);
    }
    if (this.hide_repeats) {
      base_labels = this._hide_repeating_labels(base_labels);
    }
    if (this.context == null) {
      return base_labels;
    }
    const context_labels = this._compute_context_labels(ticks, resolution);
    return this._build_full_labels(base_labels, context_labels);
  }
  _compute_label(t, resolution) {
    const s0 = _strftime(t, this[resolution]);
    const tm = _mktime(t);
    const resolution_index = resolution_order.indexOf(resolution);
    let final_resolution = resolution;
    let s2 = s0;
    if (this.boundary_scaling) {
      let hybrid_handled = false;
      let next_index = resolution_index;
      let next_resolution = resolution;
      while (tm[tm_index_for_resolution[resolution_order[next_index]]] == 0) {
        next_index += 1;
        if (next_index == resolution_order.length) {
          break;
        }
        if ((resolution == "minsec" || resolution == "hourmin") && !hybrid_handled) {
          if (resolution == "minsec" && tm[4] == 0 && tm[5] != 0 || resolution == "hourmin" && tm[3] == 0 && tm[4] != 0) {
            next_resolution = resolution_order[resolution_index - 1];
            s2 = _strftime(t, this[next_resolution]);
            break;
          } else {
            hybrid_handled = true;
          }
        }
        next_resolution = resolution_order[next_index];
        s2 = _strftime(t, this[next_resolution]);
      }
      final_resolution = next_resolution;
    }
    const { strip_leading_zeros } = this;
    if (isBoolean(strip_leading_zeros) && strip_leading_zeros || isArray(strip_leading_zeros) && strip_leading_zeros.includes(final_resolution)) {
      const ss = s2.replace(/^0+/g, "");
      if (ss != s2 && !Number.isInteger(Number(ss[0]))) {
        return `0${ss}`;
      }
      return ss;
    }
    return s2;
  }
  _compute_context_labels(ticks, resolution) {
    const { context } = this;
    assert(context != null);
    const context_labels = [];
    if (isString(context)) {
      for (const tick of ticks) {
        context_labels.push(_strftime(tick, context));
      }
    } else {
      context_labels.push(...context.doFormat(ticks, { loc: 0 }, resolution));
    }
    const which = this.context_which;
    const N = context_labels.length;
    for (let i2 = 0; i2 < context_labels.length; i2++) {
      if (which == "start" && i2 != 0 || which == "end" && i2 != N - 1 || which == "center" && i2 != Math.floor(N / 2)) {
        context_labels[i2] = "";
      }
    }
    return context_labels;
  }
  _build_full_labels(base_labels, context_labels) {
    const loc = this.context_location;
    const full_labels = [];
    if (context_labels.every((v) => v === "")) {
      return base_labels;
    }
    for (let i2 = 0; i2 < base_labels.length; i2++) {
      const label3 = base_labels[i2];
      const context = context_labels[i2];
      const full_label = (() => {
        switch (loc) {
          case "above":
            return `${context}
${label3}`;
          case "below":
            return `${label3}
${context}`;
          case "left":
            return context == "" ? label3 : `${context} ${label3}`;
          case "right":
            return context == "" ? label3 : `${label3} ${context}`;
        }
      })();
      full_labels.push(full_label);
    }
    return full_labels;
  }
  _hide_repeating_labels(labels) {
    if (labels.length <= 1) {
      return labels;
    }
    const labels_h = [labels[0]];
    let index_first_entry = 0;
    for (let i2 = 1; i2 < labels.length; i2++) {
      if (labels[index_first_entry] == labels[i2]) {
        labels_h.push("");
      } else {
        labels_h.push(labels[i2]);
        index_first_entry = i2;
      }
    }
    return labels_h;
  }
};
__publicField(_DatetimeTickFormatter, "__name__", "DatetimeTickFormatter");
_DatetimeTickFormatter.define(({ Bool: Bool2, Nullable: Nullable2, Or: Or2, Ref: Ref2, Str: Str2, Arrayable: Arrayable2 }) => ({
  microseconds: [Str2, "%fus"],
  milliseconds: [Str2, "%3Nms"],
  seconds: [Str2, "%Ss"],
  minsec: [Str2, ":%M:%S"],
  minutes: [Str2, ":%M"],
  hourmin: [Str2, "%H:%M"],
  hours: [Str2, "%Hh"],
  days: [Str2, "%m/%d"],
  months: [Str2, "%m/%Y"],
  years: [Str2, "%Y"],
  strip_leading_zeros: [Or2(Bool2, Arrayable2(ResolutionType)), false],
  boundary_scaling: [Bool2, true],
  hide_repeats: [Bool2, false],
  context: [Nullable2(Or2(Str2, Ref2(_DatetimeTickFormatter))), null],
  context_which: [ContextWhich, "start"],
  context_location: [Location, "below"]
}));
var DatetimeTickFormatter = _DatetimeTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/customjs_tick_formatter.js
var _CustomJSTickFormatter = class _CustomJSTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  /*protected*/
  _make_func() {
    const code2 = use_strict(this.code);
    return new Function("tick", "index", "ticks", ...this.names, code2);
  }
  doFormat(ticks, _opts) {
    const cache = {};
    const func = this._make_func().bind(cache);
    return ticks.map((tick, index2, ticks2) => `${func(tick, index2, ticks2, ...this.values)}`);
  }
};
__publicField(_CustomJSTickFormatter, "__name__", "CustomJSTickFormatter");
_CustomJSTickFormatter.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomJSTickFormatter = _CustomJSTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/log_tick_formatter.js
var { abs: abs5, log: log3, round: round4 } = Math;
var _LogTickFormatter = class _LogTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "basic_formatter");
  }
  initialize() {
    super.initialize();
    this.basic_formatter = new BasicTickFormatter();
  }
  format_graphics(ticks, opts) {
    var _a34;
    if (ticks.length == 0) {
      return [];
    }
    const base2 = ((_a34 = this.ticker) == null ? void 0 : _a34.base) ?? 10;
    const expos = this._exponents(ticks, base2);
    if (expos == null) {
      return this.basic_formatter.format_graphics(ticks, opts);
    } else {
      return expos.map((expo) => {
        if (abs5(expo) < this.min_exponent) {
          const b2 = new TextBox({ text: unicode_replace(`${base2 ** expo}`) });
          const e = new TextBox({ text: "" });
          return new BaseExpo(b2, e);
        } else {
          const b2 = new TextBox({ text: unicode_replace(`${base2}`) });
          const e = new TextBox({ text: unicode_replace(`${expo}`) });
          return new BaseExpo(b2, e);
        }
      });
    }
  }
  _exponents(ticks, base2) {
    let last_exponent = null;
    const exponents = [];
    for (const tick of ticks) {
      const exponent = round4(log3(tick) / log3(base2));
      if (last_exponent != exponent) {
        last_exponent = exponent;
        exponents.push(exponent);
      } else {
        return null;
      }
    }
    return exponents;
  }
  doFormat(ticks, opts) {
    var _a34;
    if (ticks.length == 0) {
      return [];
    }
    const base2 = ((_a34 = this.ticker) == null ? void 0 : _a34.base) ?? 10;
    const expos = this._exponents(ticks, base2);
    if (expos == null) {
      return this.basic_formatter.doFormat(ticks, opts);
    } else {
      return expos.map((expo) => {
        if (abs5(expo) < this.min_exponent) {
          return unicode_replace(`${base2 ** expo}`);
        } else {
          return unicode_replace(`${base2}^${expo}`);
        }
      });
    }
  }
};
__publicField(_LogTickFormatter, "__name__", "LogTickFormatter");
_LogTickFormatter.define(({ Int: Int2, Ref: Ref2, Nullable: Nullable2 }) => ({
  ticker: [Nullable2(Ref2(LogTicker)), null],
  min_exponent: [Int2, 0]
}));
var LogTickFormatter = _LogTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/mercator_tick_formatter.js
var _MercatorTickFormatter = class _MercatorTickFormatter extends BasicTickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(ticks, opts) {
    if (this.dimension == null) {
      throw new Error("MercatorTickFormatter.dimension not configured");
    }
    if (ticks.length == 0) {
      return [];
    }
    const n2 = ticks.length;
    const proj_ticks = new Array(n2);
    if (this.dimension == "lon") {
      for (let i2 = 0; i2 < n2; i2++) {
        const [lon] = wgs84_mercator.invert(ticks[i2], opts.loc);
        proj_ticks[i2] = lon;
      }
    } else {
      for (let i2 = 0; i2 < n2; i2++) {
        const [, lat] = wgs84_mercator.invert(opts.loc, ticks[i2]);
        proj_ticks[i2] = lat;
      }
    }
    return super.doFormat(proj_ticks, opts);
  }
};
__publicField(_MercatorTickFormatter, "__name__", "MercatorTickFormatter");
_MercatorTickFormatter.define(({ Nullable: Nullable2 }) => ({
  dimension: [Nullable2(LatLon), null]
}));
var MercatorTickFormatter = _MercatorTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/numeral_tick_formatter.js
var Numbro2 = __toESM(require_numbro());
var _NumeralTickFormatter = class _NumeralTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  get _rounding_fn() {
    switch (this.rounding) {
      case "round":
      case "nearest":
        return Math.round;
      case "floor":
      case "rounddown":
        return Math.floor;
      case "ceil":
      case "roundup":
        return Math.ceil;
    }
  }
  doFormat(ticks, _opts) {
    const { format: format7, language, _rounding_fn } = this;
    return ticks.map((tick) => Numbro2.format(tick, format7, language, _rounding_fn));
  }
};
__publicField(_NumeralTickFormatter, "__name__", "NumeralTickFormatter");
_NumeralTickFormatter.define(({ Str: Str2 }) => ({
  // TODO (bev) all of these could be tightened up
  format: [Str2, "0,0"],
  language: [Str2, "en"],
  rounding: [RoundingFunction, "round"]
}));
var NumeralTickFormatter = _NumeralTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/formatters/printf_tick_formatter.js
var _PrintfTickFormatter = class _PrintfTickFormatter extends TickFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(ticks, _opts) {
    return ticks.map((tick) => sprintf(this.format, tick));
  }
};
__publicField(_PrintfTickFormatter, "__name__", "PrintfTickFormatter");
_PrintfTickFormatter.define(({ Str: Str2 }) => ({
  format: [Str2, "%s"]
}));
var PrintfTickFormatter = _PrintfTickFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/scales/linear_interpolation_scale.js
var _LinearInterpolationScale = class _LinearInterpolationScale extends Scale {
  constructor(attrs) {
    super(attrs);
  }
  initialize() {
    super.initialize();
    const { source_range, target_range } = this.properties;
    if (!source_range.is_unset && !target_range.is_unset) {
      this.linear_scale = new LinearScale({
        source_range: source_range.get_value(),
        target_range: target_range.get_value()
      });
    }
  }
  connect_signals() {
    super.connect_signals();
    const { source_range, target_range } = this.properties;
    this.on_change([source_range, target_range], () => {
      this.linear_scale = new LinearScale({
        source_range: this.source_range,
        target_range: this.target_range
      });
    });
  }
  get s_compute() {
    throw new Error("not implemented");
  }
  get s_invert() {
    throw new Error("not implemented");
  }
  compute(x2) {
    return x2;
  }
  v_compute(vs) {
    const { binning } = this;
    const { start: start2, end } = this.source_range;
    const min_val = start2;
    const max_val = end;
    const n2 = binning.length;
    const step = (end - start2) / (n2 - 1);
    const mapping = new Float64Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      mapping[i2] = start2 + i2 * step;
    }
    const vvs = map(vs, (v) => {
      if (v < min_val) {
        return min_val;
      }
      if (v > max_val) {
        return max_val;
      }
      const k = left_edge_index(v, binning);
      if (k == -1) {
        return min_val;
      }
      if (k >= n2 - 1) {
        return max_val;
      }
      const b0 = binning[k];
      const b1 = binning[k + 1];
      const c = (v - b0) / (b1 - b0);
      const m0 = mapping[k];
      const m1 = mapping[k + 1];
      return m0 + c * (m1 - m0);
    });
    return this.linear_scale.v_compute(vvs);
  }
  invert(xprime) {
    return xprime;
  }
  v_invert(xprimes) {
    return new Float64Array(xprimes);
  }
};
__publicField(_LinearInterpolationScale, "__name__", "LinearInterpolationScale");
_LinearInterpolationScale.internal(({ Float: Float2, Arrayable: Arrayable2, Ref: Ref2 }) => ({
  binning: [Arrayable2(Float2)],
  linear_scale: [Ref2(LinearScale)]
}));
var LinearInterpolationScale = _LinearInterpolationScale;

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/alignments.js
var { max: max7, round: round5 } = Math;
var Stack = class extends Layoutable {
  constructor() {
    super(...arguments);
    __publicField(this, "children", []);
  }
  *[Symbol.iterator]() {
    yield* this.children;
  }
};
__publicField(Stack, "__name__", "Stack");
var HStack = class extends Stack {
  _measure(_viewport) {
    let width = 0;
    let height = 0;
    for (const child of this.children) {
      const size_hint = child.measure({ width: 0, height: 0 });
      width += size_hint.width;
      height = max7(height, size_hint.height);
    }
    return { width, height };
  }
  _set_geometry(outer, inner3) {
    super._set_geometry(outer, inner3);
    if (outer.is_empty) {
      for (const child of this.children) {
        child.set_geometry(new BBox());
      }
    } else {
      const top = this.absolute ? outer.top : 0;
      let left2 = this.absolute ? outer.left : 0;
      const { height } = outer;
      for (const child of this.children) {
        const { width } = child.measure({ width: 0, height: 0 });
        child.set_geometry(new BBox({ left: left2, width, top, height }));
        left2 += width;
      }
    }
  }
};
__publicField(HStack, "__name__", "HStack");
var VStack = class extends Stack {
  _measure(_viewport) {
    let width = 0;
    let height = 0;
    for (const child of this.children) {
      const size_hint = child.measure({ width: 0, height: 0 });
      width = max7(width, size_hint.width);
      height += size_hint.height;
    }
    return { width, height };
  }
  _set_geometry(outer, inner3) {
    super._set_geometry(outer, inner3);
    if (outer.is_empty) {
      for (const child of this.children) {
        child.set_geometry(new BBox());
      }
    } else {
      const left2 = this.absolute ? outer.left : 0;
      let top = this.absolute ? outer.top : 0;
      const { width } = outer;
      for (const child of this.children) {
        const { height } = child.measure({ width: 0, height: 0 });
        child.set_geometry(new BBox({ top, height, left: left2, width }));
        top += height;
      }
    }
  }
};
__publicField(VStack, "__name__", "VStack");
var NodeLayout = class extends Layoutable {
  constructor() {
    super(...arguments);
    __publicField(this, "children", []);
  }
  *[Symbol.iterator]() {
    yield* this.children;
  }
  _measure(viewport) {
    const { width_policy, height_policy } = this.sizing;
    const { min: min10, max: max18 } = Math;
    let max_width = 0;
    let max_height = 0;
    for (const layout of this.children) {
      const { width: width2, height: height2 } = layout.measure(viewport);
      max_width = max18(max_width, width2);
      max_height = max18(max_height, height2);
    }
    const width = (() => {
      const { width: width2 } = this.sizing;
      if (viewport.width == Infinity) {
        return width_policy == "fixed" ? width2 ?? max_width : max_width;
      } else {
        switch (width_policy) {
          case "fixed":
            return width2 ?? max_width;
          case "min":
            return (
              /*width != null ? min(viewport.width, width) :*/
              max_width
            );
          case "fit":
            return width2 != null ? min10(viewport.width, width2) : viewport.width;
          case "max":
            return width2 != null ? max18(viewport.width, width2) : viewport.width;
        }
      }
    })();
    const height = (() => {
      const { height: height2 } = this.sizing;
      if (viewport.height == Infinity) {
        return height_policy == "fixed" ? height2 ?? max_height : max_height;
      } else {
        switch (height_policy) {
          case "fixed":
            return height2 ?? max_height;
          case "min":
            return (
              /*height != null ? min(viewport.height, height) :*/
              max_height
            );
          case "fit":
            return height2 != null ? min10(viewport.height, height2) : viewport.height;
          case "max":
            return height2 != null ? max18(viewport.height, height2) : viewport.height;
        }
      }
    })();
    return { width, height };
  }
  _set_geometry(outer, inner3) {
    super._set_geometry(outer, inner3);
    if (outer.is_empty) {
      for (const child of this.children) {
        child.set_geometry(new BBox());
      }
    } else {
      const bbox = this.absolute ? outer : outer.relative();
      const { left: left2, right: right3, top, bottom } = bbox;
      const vcenter = round5(bbox.vcenter);
      const hcenter = round5(bbox.hcenter);
      for (const layout of this.children) {
        const { margin, halign = "start", valign = "start" } = layout.sizing;
        const { width, height, inner: inner4 } = layout.measure(outer);
        const bbox2 = (() => {
          const anchor2 = `${valign}_${halign}`;
          switch (anchor2) {
            case "start_start":
              return new BBox({ left: left2 + margin.left, top: top + margin.top, width, height });
            case "start_center":
              return new BBox({ hcenter, top: top + margin.top, width, height });
            case "start_end":
              return new BBox({ right: right3 - margin.right, top: top + margin.top, width, height });
            case "center_start":
              return new BBox({ left: left2 + margin.left, vcenter, width, height });
            case "center_center":
              return new BBox({ hcenter, vcenter, width, height });
            case "center_end":
              return new BBox({ right: right3 - margin.right, vcenter, width, height });
            case "end_start":
              return new BBox({ left: left2 + margin.left, bottom: bottom - margin.bottom, width, height });
            case "end_center":
              return new BBox({ hcenter, bottom: bottom - margin.bottom, width, height });
            case "end_end":
              return new BBox({ right: right3 - margin.right, bottom: bottom - margin.bottom, width, height });
          }
        })();
        const inner_bbox = inner4 == null ? bbox2 : new BBox({
          left: bbox2.left + inner4.left,
          top: bbox2.top + inner4.top,
          right: bbox2.right - inner4.right,
          bottom: bbox2.bottom - inner4.bottom
        });
        layout.set_geometry(bbox2, inner_bbox);
      }
    }
  }
};
__publicField(NodeLayout, "__name__", "NodeLayout");

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/grid.js
var { max: max8, round: round6 } = Math;
var DefaultMap = class {
  constructor(def) {
    __publicField(this, "def");
    __publicField(this, "_map", /* @__PURE__ */ new Map());
    this.def = def;
  }
  get(key) {
    let value2 = this._map.get(key);
    if (value2 === void 0) {
      value2 = this.def();
      this._map.set(key, value2);
    }
    return value2;
  }
  apply(key, fn) {
    const value2 = this.get(key);
    this._map.set(key, fn(value2));
  }
};
__publicField(DefaultMap, "__name__", "DefaultMap");
var _Container = class _Container {
  constructor() {
    __publicField(this, "_items", []);
    __publicField(this, "_nrows", 0);
    __publicField(this, "_ncols", 0);
  }
  get size() {
    return this._items.length;
  }
  get nrows() {
    return this._nrows;
  }
  get ncols() {
    return this._ncols;
  }
  add(span2, data3) {
    const { r1, c1 } = span2;
    this._nrows = max8(this._nrows, r1 + 1);
    this._ncols = max8(this._ncols, c1 + 1);
    this._items.push({ span: span2, data: data3 });
  }
  at(r, c) {
    const selected = this._items.filter(({ span: span2 }) => {
      return span2.r0 <= r && r <= span2.r1 && span2.c0 <= c && c <= span2.c1;
    });
    return selected.map(({ data: data3 }) => data3);
  }
  row(r) {
    const selected = this._items.filter(({ span: span2 }) => span2.r0 <= r && r <= span2.r1);
    return selected.map(({ data: data3 }) => data3);
  }
  col(c) {
    const selected = this._items.filter(({ span: span2 }) => span2.c0 <= c && c <= span2.c1);
    return selected.map(({ data: data3 }) => data3);
  }
  *[Symbol.iterator]() {
    yield* this._items;
  }
  foreach(fn) {
    for (const { span: span2, data: data3 } of this._items) {
      fn(span2, data3);
    }
  }
  map(fn) {
    const result = new _Container();
    for (const { span: span2, data: data3 } of this._items) {
      result.add(span2, fn(span2, data3));
    }
    return result;
  }
};
__publicField(_Container, "__name__", "Container");
var Container = _Container;
var Grid = class extends Layoutable {
  constructor(items = []) {
    super();
    __publicField(this, "items");
    __publicField(this, "rows", "auto");
    __publicField(this, "cols", "auto");
    __publicField(this, "spacing", 0);
    __publicField(this, "_state");
    this.items = items;
  }
  *[Symbol.iterator]() {
    for (const { layout } of this.items) {
      yield layout;
    }
  }
  is_width_expanding() {
    if (super.is_width_expanding()) {
      return true;
    }
    if (this.sizing.width_policy == "fixed") {
      return false;
    }
    const { cols } = this._state;
    return some(cols, (col2) => col2.policy == "max");
  }
  is_height_expanding() {
    if (super.is_height_expanding()) {
      return true;
    }
    if (this.sizing.height_policy == "fixed") {
      return false;
    }
    const { rows } = this._state;
    return some(rows, (row2) => row2.policy == "max");
  }
  _init() {
    super._init();
    const items = new Container();
    for (const { layout, row: row2, col: col2, row_span = 1, col_span = 1 } of this.items) {
      if (layout.sizing.visible) {
        const r0 = row2;
        const c0 = col2;
        const r1 = row2 + row_span - 1;
        const c1 = col2 + col_span - 1;
        items.add({ r0, c0, r1, c1 }, layout);
      }
    }
    const { nrows, ncols } = items;
    const rows = new Array(nrows);
    for (let y2 = 0; y2 < nrows; y2++) {
      const row2 = (() => {
        const sizing = isPlainObject(this.rows) ? this.rows[y2] ?? this.rows["*"] : this.rows;
        if (sizing == null) {
          return { policy: "auto" };
        } else if (isNumber(sizing)) {
          return { policy: "fixed", height: sizing };
        } else if (isString(sizing)) {
          return { policy: sizing };
        } else {
          return sizing;
        }
      })();
      const align = row2.align ?? "auto";
      if (row2.policy == "fixed") {
        rows[y2] = { policy: "fixed", height: row2.height, align };
      } else if (row2.policy == "min") {
        rows[y2] = { policy: "min", align };
      } else if (row2.policy == "fit" || row2.policy == "max") {
        rows[y2] = { policy: row2.policy, flex: row2.flex ?? 1, align };
      } else {
        if (some(items.row(y2), (layout) => layout.is_height_expanding())) {
          rows[y2] = { policy: "max", flex: 1, align };
        } else {
          rows[y2] = { policy: "min", align };
        }
      }
    }
    const cols = new Array(ncols);
    for (let x2 = 0; x2 < ncols; x2++) {
      const col2 = (() => {
        const sizing = isPlainObject(this.cols) ? this.cols[x2] ?? this.cols["*"] : this.cols;
        if (sizing == null) {
          return { policy: "auto" };
        } else if (isNumber(sizing)) {
          return { policy: "fixed", width: sizing };
        } else if (isString(sizing)) {
          return { policy: sizing };
        } else {
          return sizing;
        }
      })();
      const align = col2.align ?? "auto";
      if (col2.policy == "fixed") {
        cols[x2] = { policy: "fixed", width: col2.width, align };
      } else if (col2.policy == "min") {
        cols[x2] = { policy: "min", align };
      } else if (col2.policy == "fit" || col2.policy == "max") {
        cols[x2] = { policy: col2.policy, flex: col2.flex ?? 1, align };
      } else {
        if (some(items.col(x2), (layout) => layout.is_width_expanding())) {
          cols[x2] = { policy: "max", flex: 1, align };
        } else {
          cols[x2] = { policy: "min", align };
        }
      }
    }
    const [rspacing, cspacing] = isNumber(this.spacing) ? [this.spacing, this.spacing] : this.spacing;
    this._state = { items, nrows, ncols, rows, cols, rspacing, cspacing };
  }
  _measure_totals(row_heights, col_widths) {
    const { nrows, ncols, rspacing, cspacing } = this._state;
    return {
      height: sum(row_heights) + (nrows - 1) * rspacing,
      width: sum(col_widths) + (ncols - 1) * cspacing
    };
  }
  _measure_cells(cell_viewport) {
    const { items, nrows, ncols, rows, cols, rspacing, cspacing } = this._state;
    const row_heights = new Array(nrows);
    for (let r = 0; r < nrows; r++) {
      const row2 = rows[r];
      row_heights[r] = row2.policy == "fixed" ? row2.height : 0;
    }
    const col_widths = new Array(ncols);
    for (let c = 0; c < ncols; c++) {
      const col2 = cols[c];
      col_widths[c] = col2.policy == "fixed" ? col2.width : 0;
    }
    const size_hints = new Container();
    items.foreach((span2, layout) => {
      const { r0, c0, r1, c1 } = span2;
      const rspace = (r1 - r0) * rspacing;
      const cspace = (c1 - c0) * cspacing;
      let height = 0;
      for (let r = r0; r <= r1; r++) {
        height += cell_viewport(r, c0).height;
      }
      height += rspace;
      let width = 0;
      for (let c = c0; c <= c1; c++) {
        width += cell_viewport(r0, c).width;
      }
      width += cspace;
      const size_hint = layout.measure({ width, height });
      size_hints.add(span2, { layout, size_hint });
      const size3 = new Sizeable(size_hint).grow_by(layout.sizing.margin);
      size3.height -= rspace;
      size3.width -= cspace;
      const radjustable = [];
      for (let r = r0; r <= r1; r++) {
        const row2 = rows[r];
        if (row2.policy == "fixed") {
          size3.height -= row2.height;
        } else {
          radjustable.push(r);
        }
      }
      if (size3.height > 0) {
        const rheight = round6(size3.height / radjustable.length);
        for (const r of radjustable) {
          row_heights[r] = max8(row_heights[r], rheight);
        }
      }
      const cadjustable = [];
      for (let c = c0; c <= c1; c++) {
        const col2 = cols[c];
        if (col2.policy == "fixed") {
          size3.width -= col2.width;
        } else {
          cadjustable.push(c);
        }
      }
      if (size3.width > 0) {
        const cwidth = round6(size3.width / cadjustable.length);
        for (const c of cadjustable) {
          col_widths[c] = max8(col_widths[c], cwidth);
        }
      }
    });
    const size2 = this._measure_totals(row_heights, col_widths);
    return { size: size2, row_heights, col_widths, size_hints };
  }
  _measure_grid(viewport) {
    const { nrows, ncols, rows, cols, rspacing, cspacing } = this._state;
    const preferred = this._measure_cells((y2, x2) => {
      const row2 = rows[y2];
      const col2 = cols[x2];
      return {
        width: col2.policy == "fixed" ? col2.width : Infinity,
        height: row2.policy == "fixed" ? row2.height : Infinity
      };
    });
    let available_height;
    if (this.sizing.height_policy == "fixed" && this.sizing.height != null) {
      available_height = this.sizing.height;
    } else if (viewport.height != Infinity && this.is_height_expanding()) {
      available_height = viewport.height;
    } else {
      available_height = preferred.size.height;
    }
    let height_flex = 0;
    for (let y2 = 0; y2 < nrows; y2++) {
      const row2 = rows[y2];
      if (row2.policy == "fit" || row2.policy == "max") {
        height_flex += row2.flex;
      } else {
        available_height -= preferred.row_heights[y2];
      }
    }
    available_height -= (nrows - 1) * rspacing;
    if (height_flex != 0 && available_height > 0) {
      for (let y2 = 0; y2 < nrows; y2++) {
        const row2 = rows[y2];
        if (row2.policy == "fit" || row2.policy == "max") {
          const height = round6(available_height * (row2.flex / height_flex));
          available_height -= height;
          preferred.row_heights[y2] = height;
          height_flex -= row2.flex;
        }
      }
    } else if (available_height < 0) {
      let nadjustable = 0;
      for (let y2 = 0; y2 < nrows; y2++) {
        const row2 = rows[y2];
        if (row2.policy != "fixed") {
          nadjustable++;
        }
      }
      let overflow_height = -available_height;
      for (let y2 = 0; y2 < nrows; y2++) {
        const row2 = rows[y2];
        if (row2.policy != "fixed") {
          const height = preferred.row_heights[y2];
          const cutoff = round6(overflow_height / nadjustable);
          preferred.row_heights[y2] = max8(height - cutoff, 0);
          overflow_height -= cutoff > height ? height : cutoff;
          nadjustable--;
        }
      }
    }
    let available_width;
    if (this.sizing.width_policy == "fixed" && this.sizing.width != null) {
      available_width = this.sizing.width;
    } else if (viewport.width != Infinity && this.is_width_expanding()) {
      available_width = viewport.width;
    } else {
      available_width = preferred.size.width;
    }
    let width_flex = 0;
    for (let x2 = 0; x2 < ncols; x2++) {
      const col2 = cols[x2];
      if (col2.policy == "fit" || col2.policy == "max") {
        width_flex += col2.flex;
      } else {
        available_width -= preferred.col_widths[x2];
      }
    }
    available_width -= (ncols - 1) * cspacing;
    if (width_flex != 0 && available_width > 0) {
      for (let x2 = 0; x2 < ncols; x2++) {
        const col2 = cols[x2];
        if (col2.policy == "fit" || col2.policy == "max") {
          const width = round6(available_width * (col2.flex / width_flex));
          available_width -= width;
          preferred.col_widths[x2] = width;
          width_flex -= col2.flex;
        }
      }
    } else if (available_width < 0) {
      let nadjustable = 0;
      for (let x2 = 0; x2 < ncols; x2++) {
        const col2 = cols[x2];
        if (col2.policy != "fixed") {
          nadjustable++;
        }
      }
      let overflow_width = -available_width;
      for (let x2 = 0; x2 < ncols; x2++) {
        const col2 = cols[x2];
        if (col2.policy != "fixed") {
          const width = preferred.col_widths[x2];
          const cutoff = round6(overflow_width / nadjustable);
          preferred.col_widths[x2] = max8(width - cutoff, 0);
          overflow_width -= cutoff > width ? width : cutoff;
          nadjustable--;
        }
      }
    }
    const { row_heights, col_widths, size_hints } = this._measure_cells((y2, x2) => {
      return {
        width: preferred.col_widths[x2],
        height: preferred.row_heights[y2]
      };
    });
    const size2 = this._measure_totals(row_heights, col_widths);
    return { size: size2, row_heights, col_widths, size_hints };
  }
  _measure(viewport) {
    const { size: size2 } = this._measure_grid(viewport);
    return size2;
  }
  _set_geometry(outer, inner3) {
    super._set_geometry(outer, inner3);
    const { nrows, ncols, rspacing, cspacing } = this._state;
    const { row_heights, col_widths, size_hints } = this._measure_grid(outer);
    const rows = this._state.rows.map((row2, r) => {
      return { ...row2, top: 0, height: row_heights[r], get bottom() {
        return this.top + this.height;
      } };
    });
    const cols = this._state.cols.map((col2, c) => {
      return { ...col2, left: 0, width: col_widths[c], get right() {
        return this.left + this.width;
      } };
    });
    const items = size_hints.map((_2, item3) => {
      return { ...item3, outer: new BBox(), inner: new BBox() };
    });
    for (let r = 0, top = !this.absolute ? this.position.top : outer.top; r < nrows; r++) {
      const row2 = rows[r];
      row2.top = top;
      top += row2.height + rspacing;
    }
    for (let c = 0, left2 = !this.absolute ? this.position.left : outer.left; c < ncols; c++) {
      const col2 = cols[c];
      col2.left = left2;
      left2 += col2.width + cspacing;
    }
    function span_width(c0, c1) {
      let width = (c1 - c0) * cspacing;
      for (let c = c0; c <= c1; c++) {
        width += cols[c].width;
      }
      return width;
    }
    function span_height(r0, r1) {
      let height = (r1 - r0) * rspacing;
      for (let r = r0; r <= r1; r++) {
        height += rows[r].height;
      }
      return height;
    }
    items.foreach(({ r0, c0, r1, c1 }, item3) => {
      const { layout, size_hint } = item3;
      const { sizing } = layout;
      const { width, height } = size_hint;
      const span2 = {
        width: span_width(c0, c1),
        height: span_height(r0, r1)
      };
      const halign = c0 == c1 && cols[c0].align != "auto" ? cols[c0].align : sizing.halign;
      const valign = r0 == r1 && rows[r0].align != "auto" ? rows[r0].align : sizing.valign;
      let left2 = cols[c0].left;
      if (halign == "start") {
        left2 += sizing.margin.left;
      } else if (halign == "center") {
        left2 += round6((span2.width - width) / 2);
      } else if (halign == "end") {
        left2 += span2.width - sizing.margin.right - width;
      }
      let top = rows[r0].top;
      if (valign == "start") {
        top += sizing.margin.top;
      } else if (valign == "center") {
        top += round6((span2.height - height) / 2);
      } else if (valign == "end") {
        top += span2.height - sizing.margin.bottom - height;
      }
      item3.outer = new BBox({ left: left2, top, width, height });
    });
    const row_aligns = rows.map(() => {
      return {
        start: new DefaultMap(() => 0),
        end: new DefaultMap(() => 0)
      };
    });
    const col_aligns = cols.map(() => {
      return {
        start: new DefaultMap(() => 0),
        end: new DefaultMap(() => 0)
      };
    });
    items.foreach(({ r0, c0, r1, c1 }, { size_hint, outer: outer2 }) => {
      const { inner: inner4 } = size_hint;
      if (inner4 != null) {
        row_aligns[r0].start.apply(outer2.top, (v) => max8(v, inner4.top));
        row_aligns[r1].end.apply(rows[r1].bottom - outer2.bottom, (v) => max8(v, inner4.bottom));
        col_aligns[c0].start.apply(outer2.left, (v) => max8(v, inner4.left));
        col_aligns[c1].end.apply(cols[c1].right - outer2.right, (v) => max8(v, inner4.right));
      }
    });
    items.foreach(({ r0, c0, r1, c1 }, item3) => {
      const { size_hint, outer: outer2 } = item3;
      const inner_bbox = (extents) => {
        const outer_bbox = this.absolute ? outer2 : outer2.relative();
        const left2 = outer_bbox.left + extents.left;
        const top = outer_bbox.top + extents.top;
        const right3 = outer_bbox.right - extents.right;
        const bottom = outer_bbox.bottom - extents.bottom;
        return new BBox({ left: left2, top, right: right3, bottom });
      };
      if (size_hint.inner != null) {
        let inner4 = inner_bbox(size_hint.inner);
        const top = row_aligns[r0].start.get(outer2.top);
        const bottom = row_aligns[r1].end.get(rows[r1].bottom - outer2.bottom);
        const left2 = col_aligns[c0].start.get(outer2.left);
        const right3 = col_aligns[c1].end.get(cols[c1].right - outer2.right);
        try {
          inner4 = inner_bbox({ top, bottom, left: left2, right: right3 });
        } catch {
        }
        item3.inner = inner4;
      } else {
        item3.inner = outer2;
      }
    });
    items.foreach((_2, { layout, outer: outer2, inner: inner4 }) => {
      layout.set_geometry(outer2, inner4);
    });
  }
};
__publicField(Grid, "__name__", "Grid");
var Row = class extends Grid {
  constructor(items) {
    super();
    this.items = items.map((item3, i2) => ({ layout: item3, row: 0, col: i2 }));
    this.rows = "fit";
  }
};
__publicField(Row, "__name__", "Row");
var Column = class extends Grid {
  constructor(items) {
    super();
    this.items = items.map((item3, i2) => ({ layout: item3, row: i2, col: 0 }));
    this.cols = "fit";
  }
};
__publicField(Column, "__name__", "Column");

// node_modules/@bokeh/bokehjs/build/js/lib/core/layout/border.js
var BorderLayout = class extends Layoutable {
  constructor() {
    super(...arguments);
    __publicField(this, "top_panel");
    __publicField(this, "bottom_panel");
    __publicField(this, "left_panel");
    __publicField(this, "right_panel");
    __publicField(this, "center_panel");
    __publicField(this, "inner_top_panel");
    __publicField(this, "inner_bottom_panel");
    __publicField(this, "inner_left_panel");
    __publicField(this, "inner_right_panel");
    __publicField(this, "aligns", { left: true, right: true, top: true, bottom: true });
    __publicField(this, "min_border", { left: 0, top: 0, right: 0, bottom: 0 });
    __publicField(this, "padding", { left: 0, top: 0, right: 0, bottom: 0 });
    __publicField(this, "center_border_width", 0);
  }
  *[Symbol.iterator]() {
    yield this.top_panel;
    yield this.bottom_panel;
    yield this.left_panel;
    yield this.right_panel;
    yield this.center_panel;
  }
  _measure(viewport) {
    viewport = new Sizeable({
      width: this.sizing.width_policy == "fixed" || viewport.width == Infinity ? this.sizing.width : viewport.width,
      height: this.sizing.height_policy == "fixed" || viewport.height == Infinity ? this.sizing.height : viewport.height
    });
    const left_hint = this.left_panel.measure({ width: 0, height: viewport.height });
    const left2 = Math.max(left_hint.width, this.min_border.left) + this.padding.left;
    const right_hint = this.right_panel.measure({ width: 0, height: viewport.height });
    const right3 = Math.max(right_hint.width, this.min_border.right) + this.padding.right;
    const top_hint = this.top_panel.measure({ width: viewport.width, height: 0 });
    const top = Math.max(top_hint.height, this.min_border.top) + this.padding.top;
    const bottom_hint = this.bottom_panel.measure({ width: viewport.width, height: 0 });
    const bottom = Math.max(bottom_hint.height, this.min_border.bottom) + this.padding.bottom;
    const center_viewport = new Sizeable(viewport).shrink_by({ left: left2, right: right3, top, bottom });
    const center = this.center_panel.measure(center_viewport);
    const width = left2 + center.width + right3;
    const height = top + center.height + bottom;
    const align = (() => {
      const { width_policy, height_policy } = this.center_panel.sizing;
      return {
        ...this.aligns,
        fixed_width: width_policy == "fixed",
        fixed_height: height_policy == "fixed"
      };
    })();
    return { width, height, inner: { left: left2, right: right3, top, bottom }, align };
  }
  _set_geometry(outer, inner3) {
    var _a34, _b4, _c, _d;
    super._set_geometry(outer, inner3);
    if (this.sizing.visible) {
      this.center_panel.set_geometry(inner3);
      const left_hint = this.left_panel.measure({ width: 0, height: outer.height });
      const right_hint = this.right_panel.measure({ width: 0, height: outer.height });
      const top_hint = this.top_panel.measure({ width: outer.width, height: 0 });
      const bottom_hint = this.bottom_panel.measure({ width: outer.width, height: 0 });
      const { left: left2, top, right: right3, bottom } = inner3;
      this.top_panel.set_geometry(new BBox({ left: left2, right: right3, bottom: top, height: top_hint.height }));
      this.bottom_panel.set_geometry(new BBox({ left: left2, right: right3, top: bottom, height: bottom_hint.height }));
      this.left_panel.set_geometry(new BBox({ top, bottom, right: left2, width: left_hint.width }));
      this.right_panel.set_geometry(new BBox({ top, bottom, left: right3, width: right_hint.width }));
      const adjusted_inner = inner3.shrink_by(this.center_border_width);
      if (this.inner_top_panel != null) {
        const { left: left3, right: right4, top: top2, width } = adjusted_inner;
        const inner_top_hint = this.inner_top_panel.measure({ width, height: 0 });
        this.inner_top_panel.set_geometry(new BBox({ left: left3, right: right4, top: top2, height: inner_top_hint.height }));
      }
      if (this.inner_bottom_panel != null) {
        const { left: left3, right: right4, bottom: bottom2, width } = adjusted_inner;
        const inner_bottom_hint = this.inner_bottom_panel.measure({ width, height: 0 });
        this.inner_bottom_panel.set_geometry(new BBox({ left: left3, right: right4, bottom: bottom2, height: inner_bottom_hint.height }));
      }
      if (this.inner_left_panel != null) {
        const { top: top2, bottom: bottom2, left: left3, height } = adjusted_inner;
        const inner_left_hint = this.inner_left_panel.measure({ width: 0, height });
        this.inner_left_panel.set_geometry(new BBox({ top: top2, bottom: bottom2, left: left3, width: inner_left_hint.width }));
      }
      if (this.inner_right_panel != null) {
        const { top: top2, bottom: bottom2, right: right4, height } = adjusted_inner;
        const inner_right_hint = this.inner_right_panel.measure({ width: 0, height });
        this.inner_right_panel.set_geometry(new BBox({ top: top2, bottom: bottom2, right: right4, width: inner_right_hint.width }));
      }
    } else {
      this.center_panel.set_geometry(new BBox());
      this.top_panel.set_geometry(new BBox());
      this.bottom_panel.set_geometry(new BBox());
      this.left_panel.set_geometry(new BBox());
      this.right_panel.set_geometry(new BBox());
      (_a34 = this.inner_top_panel) == null ? void 0 : _a34.set_geometry(new BBox());
      (_b4 = this.inner_bottom_panel) == null ? void 0 : _b4.set_geometry(new BBox());
      (_c = this.inner_left_panel) == null ? void 0 : _c.set_geometry(new BBox());
      (_d = this.inner_right_panel) == null ? void 0 : _d.set_geometry(new BBox());
    }
  }
};
__publicField(BorderLayout, "__name__", "BorderLayout");

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/base_color_bar.js
var MINOR_DIM = 25;
var MAJOR_DIM_MIN_SCALAR = 0.3;
var MAJOR_DIM_MAX_SCALAR = 0.8;
var BaseColorBarView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_frame");
    __publicField(this, "_frame_view");
    __publicField(this, "_axis");
    __publicField(this, "_axis_view");
    __publicField(this, "_title");
    __publicField(this, "_title_view");
    __publicField(this, "_ticker");
    __publicField(this, "_formatter");
    __publicField(this, "_inner_layout");
    __publicField(this, "_major_range");
    __publicField(this, "_major_scale");
    __publicField(this, "_minor_range");
    __publicField(this, "_minor_scale");
    __publicField(this, "_orientation");
  }
  get orientation() {
    return this._orientation;
  }
  *children() {
    yield* super.children();
    yield this._axis_view;
    yield this._title_view;
  }
  initialize() {
    super.initialize();
    const { ticker, formatter } = this.model;
    this._ticker = ticker != "auto" ? ticker : this._create_ticker();
    this._formatter = formatter != "auto" ? formatter : this._create_formatter();
    this._major_range = this._create_major_range();
    this._major_scale = this._create_major_scale();
    this._minor_range = new Range1d({ start: 0, end: 1 });
    this._minor_scale = new LinearScale();
    this._frame = new CartesianFrame({
      x_scale: this._major_scale,
      y_scale: this._minor_scale,
      x_range: this._major_range,
      y_range: this._minor_range
    });
    this._axis = this._create_axis();
    this._apply_axis_properties();
    this._title = new Title();
    this._apply_title_properties();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const self2 = this;
    const parent = {
      get parent() {
        return self2.parent;
      },
      get root() {
        return self2.root;
      },
      get frame() {
        return self2._frame_view;
      },
      get frame_view() {
        return self2._frame_view;
      },
      get canvas_view() {
        return self2.parent.canvas_view;
      },
      request_layout() {
        self2.layout.dirty = true;
        self2.parent.request_layout();
      },
      request_paint() {
        self2.parent.request_paint(self2);
      },
      notify_finished_after_paint() {
        self2.parent.notify_finished_after_paint();
      }
    };
    this._frame_view = await build_view(this._frame, { parent });
    this._axis_view = await build_view(this._axis, { parent });
    this._title_view = await build_view(this._title, { parent });
  }
  remove() {
    this._title_view.remove();
    this._axis_view.remove();
    super.remove();
  }
  _apply_axis_properties() {
    const attrs = {
      ticker: this._ticker,
      formatter: this._formatter,
      major_label_standoff: this.model.label_standoff,
      axis_line_color: null,
      major_tick_in: this.model.major_tick_in,
      major_tick_out: this.model.major_tick_out,
      minor_tick_in: this.model.minor_tick_in,
      minor_tick_out: this.model.minor_tick_out,
      major_label_overrides: this.model.major_label_overrides,
      major_label_policy: this.model.major_label_policy,
      // TODO: this needs strict typing
      ...attrs_of(this.model, "major_label_", Text, true),
      ...attrs_of(this.model, "major_tick_", Line, true),
      ...attrs_of(this.model, "minor_tick_", Line, true)
    };
    this._axis.setv(attrs);
  }
  _apply_title_properties() {
    const attrs = {
      text: this.model.title ?? "",
      standoff: this.model.title_standoff,
      // TODO: this needs strict typing
      ...attrs_of(this.model, "title_", Text, false)
    };
    this._title.setv(attrs);
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => {
      this._apply_title_properties();
      this._apply_axis_properties();
    });
    this.connect(this._ticker.change, () => this.request_paint());
    this.connect(this._formatter.change, () => this.request_paint());
  }
  _update_frame() {
    const [x_scale, y_scale, x_range, y_range] = (() => {
      if (this.orientation == "horizontal") {
        return [this._major_scale, this._minor_scale, this._major_range, this._minor_range];
      } else {
        return [this._minor_scale, this._major_scale, this._minor_range, this._major_range];
      }
    })();
    this._frame.setv({ x_scale, y_scale, x_range, y_range });
  }
  update_layout() {
    const { location, width: w, height: h7, padding: padding2, margin } = this.model;
    const [valign, halign] = (() => {
      if (isString(location)) {
        switch (location) {
          case "top_left":
            return ["start", "start"];
          case "top":
          case "top_center":
            return ["start", "center"];
          case "top_right":
            return ["start", "end"];
          case "bottom_left":
            return ["end", "start"];
          case "bottom":
          case "bottom_center":
            return ["end", "center"];
          case "bottom_right":
            return ["end", "end"];
          case "left":
          case "center_left":
            return ["center", "start"];
          case "center":
          case "center_center":
            return ["center", "center"];
          case "right":
          case "center_right":
            return ["center", "end"];
        }
      } else {
        return ["end", "start"];
      }
    })();
    const orientation = this._orientation = (() => {
      const { orientation: orientation2 } = this.model;
      if (orientation2 == "auto") {
        if (this.panel != null) {
          return this.panel.is_horizontal ? "horizontal" : "vertical";
        } else {
          if (halign == "start" || halign == "end" || /*halign == "center" &&*/
          valign == "center") {
            return "vertical";
          } else {
            return "horizontal";
          }
        }
      } else {
        return orientation2;
      }
    })();
    this._update_frame();
    const center_panel = new NodeLayout();
    const top_panel = new VStack();
    const bottom_panel = new VStack();
    const left_panel = new HStack();
    const right_panel = new HStack();
    center_panel.absolute = true;
    top_panel.absolute = true;
    bottom_panel.absolute = true;
    left_panel.absolute = true;
    right_panel.absolute = true;
    center_panel.on_resize((bbox) => this._frame_view.set_geometry(bbox));
    const layout = new BorderLayout();
    this._inner_layout = layout;
    layout.absolute = true;
    layout.center_panel = center_panel;
    layout.top_panel = top_panel;
    layout.bottom_panel = bottom_panel;
    layout.left_panel = left_panel;
    layout.right_panel = right_panel;
    const padding_box = { left: padding2, right: padding2, top: padding2, bottom: padding2 };
    const margin_box = (() => {
      if (this.panel == null) {
        if (isString(location)) {
          return { left: margin, right: margin, top: margin, bottom: margin };
        } else {
          const [left2, bottom] = location;
          return { left: left2, right: margin, top: margin, bottom };
        }
      } else {
        if (isString(location)) {
          layout.fixup_geometry = (outer, inner3) => {
            const origin = outer;
            if (orientation == "horizontal") {
              const { top, width, height } = outer;
              if (halign == "end") {
                const { right: right3 } = this.layout.bbox;
                outer = new BBox({ right: right3, top, width, height });
              } else if (halign == "center") {
                const { hcenter } = this.layout.bbox;
                outer = new BBox({ hcenter: Math.round(hcenter), top, width, height });
              }
            } else {
              const { left: left2, width, height } = outer;
              if (valign == "end") {
                const { bottom } = this.layout.bbox;
                outer = new BBox({ left: left2, bottom, width, height });
              } else if (valign == "center") {
                const { vcenter } = this.layout.bbox;
                outer = new BBox({ left: left2, vcenter: Math.round(vcenter), width, height });
              }
            }
            if (inner3 != null) {
              const dh = outer.left - origin.left;
              const dv = outer.top - origin.top;
              const { left: left2, top, width, height } = inner3;
              inner3 = new BBox({ left: left2 + dh, top: top + dv, width, height });
            }
            return [outer, inner3];
          };
          return void 0;
        } else {
          const [left2, bottom] = location;
          layout.fixup_geometry = (outer, inner3) => {
            const origin = outer;
            const grid = this.layout.bbox;
            const { width, height } = outer;
            outer = new BBox({ left: grid.left + left2, bottom: grid.bottom - bottom, width, height });
            if (inner3 != null) {
              const dh = outer.left - origin.left;
              const dv = outer.top - origin.top;
              const { left: left3, top, width: width2, height: height2 } = inner3;
              inner3 = new BBox({ left: left3 + dh, top: top + dv, width: width2, height: height2 });
            }
            return [outer, inner3];
          };
          return { left: left2, right: 0, top: 0, bottom };
        }
      }
    })();
    layout.padding = padding_box;
    let major_policy;
    let major_size;
    let min_major_size;
    let max_major_size;
    if (this.panel != null) {
      major_policy = "max";
      major_size = void 0;
      min_major_size = void 0;
      max_major_size = void 0;
    } else {
      if ((orientation == "horizontal" ? w : h7) == "auto") {
        major_policy = "fixed";
        const major_size_factor = this._get_major_size_factor();
        if (major_size_factor != null) {
          major_size = major_size_factor * MINOR_DIM;
        }
        min_major_size = { percent: MAJOR_DIM_MIN_SCALAR };
        max_major_size = { percent: MAJOR_DIM_MAX_SCALAR };
      } else {
        major_policy = "fit";
        major_size = void 0;
      }
    }
    if (orientation == "horizontal") {
      const width = w == "auto" ? void 0 : w;
      const height = h7 == "auto" ? MINOR_DIM : h7;
      layout.set_sizing({
        width_policy: major_policy,
        height_policy: "min",
        width: major_size,
        min_width: min_major_size,
        max_width: max_major_size,
        halign,
        valign,
        margin: margin_box
      });
      layout.center_panel.set_sizing({ width_policy: w == "auto" ? "fit" : "fixed", height_policy: "fixed", width, height });
    } else {
      const width = w == "auto" ? MINOR_DIM : w;
      const height = h7 == "auto" ? void 0 : h7;
      layout.set_sizing({
        width_policy: "min",
        height_policy: major_policy,
        height: major_size,
        min_height: min_major_size,
        max_height: max_major_size,
        halign,
        valign,
        margin: margin_box
      });
      layout.center_panel.set_sizing({ width_policy: "fixed", height_policy: h7 == "auto" ? "fit" : "fixed", width, height });
    }
    top_panel.set_sizing({ width_policy: "fit", height_policy: "min" });
    bottom_panel.set_sizing({ width_policy: "fit", height_policy: "min" });
    left_panel.set_sizing({ width_policy: "min", height_policy: "fit" });
    right_panel.set_sizing({ width_policy: "min", height_policy: "fit" });
    const { _title_view } = this;
    if (orientation == "horizontal") {
      _title_view.panel = new SidePanel("above");
      _title_view.update_layout();
      top_panel.children.push(_title_view.layout);
    } else {
      _title_view.panel = new SidePanel("left");
      _title_view.update_layout();
      left_panel.children.push(_title_view.layout);
    }
    const { panel } = this;
    const side = (() => {
      if (panel != null && orientation == panel.orientation) {
        return panel.side;
      } else {
        return orientation == "horizontal" ? "below" : "right";
      }
    })();
    const stack = (() => {
      switch (side) {
        case "above":
          return top_panel;
        case "below":
          return bottom_panel;
        case "left":
          return left_panel;
        case "right":
          return right_panel;
      }
    })();
    const { _axis_view } = this;
    _axis_view.panel = new SidePanel(side);
    _axis_view.update_layout();
    if (_axis_view.layout != null) {
      stack.children.push(_axis_view.layout);
    }
    if (this.panel != null) {
      const outer = new Grid([{ layout, row: 0, col: 0 }]);
      outer.absolute = true;
      if (orientation == "horizontal") {
        outer.set_sizing({ width_policy: "max", height_policy: "min" });
      } else {
        outer.set_sizing({ width_policy: "min", height_policy: "max" });
      }
      this.layout = outer;
    } else {
      this.layout = this._inner_layout;
    }
    const { visible } = this.model;
    this.layout.sizing.visible = visible;
  }
  _create_axis() {
    return new LinearAxis();
  }
  _create_formatter() {
    return new BasicTickFormatter();
  }
  _create_major_range() {
    return new Range1d({ start: 0, end: 1 });
  }
  _create_major_scale() {
    return new LinearScale();
  }
  _create_ticker() {
    return new BasicTicker();
  }
  _get_major_size_factor() {
    return null;
  }
  _paint() {
    const { ctx } = this.layer;
    ctx.save();
    this._paint_bbox(ctx, this._inner_layout.bbox);
    this._paint_colors(ctx, this._inner_layout.center_panel.bbox);
    this._title_view.paint();
    this._axis_view.paint();
    ctx.restore();
  }
  _paint_bbox(ctx, bbox) {
    const { x: x2, y: y2 } = bbox;
    let { width, height } = bbox;
    if (x2 + width >= this.parent.canvas_view.bbox.width) {
      width -= 1;
    }
    if (y2 + height >= this.parent.canvas_view.bbox.height) {
      height -= 1;
    }
    ctx.save();
    if (this.visuals.background_fill.doit) {
      this.visuals.background_fill.set_value(ctx);
      ctx.fillRect(x2, y2, width, height);
    }
    if (this.visuals.border_line.doit) {
      this.visuals.border_line.set_value(ctx);
      ctx.strokeRect(x2, y2, width, height);
    }
    ctx.restore();
  }
};
__publicField(BaseColorBarView, "__name__", "BaseColorBarView");
var _BaseColorBar = class _BaseColorBar extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BaseColorBar, "__name__", "BaseColorBar");
_BaseColorBar.mixins([
  ["major_label_", Text],
  ["title_", Text],
  ["major_tick_", Line],
  ["minor_tick_", Line],
  ["border_", Line],
  ["bar_", Line],
  ["background_", Fill]
]);
_BaseColorBar.define(({ Alpha, Float: Float2, Str: Str2, Tuple: Tuple2, Or: Or2, Ref: Ref2, Auto: Auto2, Nullable: Nullable2 }) => ({
  location: [Or2(Anchor, Tuple2(Float2, Float2)), "top_right"],
  orientation: [Or2(Orientation, Auto2), "auto"],
  title: [Nullable2(Or2(Str2, Ref2(BaseText))), null],
  title_standoff: [Float2, 2],
  width: [Or2(Float2, Auto2), "auto"],
  height: [Or2(Float2, Auto2), "auto"],
  scale_alpha: [Alpha, 1],
  ticker: [Or2(Ref2(Ticker), Auto2), "auto"],
  formatter: [Or2(Ref2(TickFormatter), Auto2), "auto"],
  major_label_overrides: [LabelOverrides, /* @__PURE__ */ new Map()],
  major_label_policy: [Ref2(LabelingPolicy), () => new NoOverlap()],
  label_standoff: [Float2, 5],
  margin: [Float2, 30],
  padding: [Float2, 10],
  major_tick_in: [Float2, 5],
  major_tick_out: [Float2, 0],
  minor_tick_in: [Float2, 0],
  minor_tick_out: [Float2, 0]
}));
_BaseColorBar.override({
  background_fill_color: "#ffffff",
  background_fill_alpha: 0.95,
  bar_line_color: null,
  border_line_color: null,
  major_label_text_font_size: "11px",
  major_tick_line_color: "#ffffff",
  minor_tick_line_color: null,
  title_text_font_size: "13px",
  title_text_font_style: "italic"
});
var BaseColorBar = _BaseColorBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/upper_lower.js
var UpperLowerView = class extends DataAnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_lower");
    __publicField(this, "_upper");
    __publicField(this, "_base");
    __publicField(this, "_lower_sx");
    __publicField(this, "_lower_sy");
    __publicField(this, "_upper_sx");
    __publicField(this, "_upper_sy");
  }
  map_data() {
    const { frame } = this.plot_view;
    const dim = this.model.dimension;
    const xscale = this.coordinates.x_scale;
    const yscale = this.coordinates.y_scale;
    const limit_scale = dim == "height" ? yscale : xscale;
    const base_scale = dim == "height" ? xscale : yscale;
    const limit_view = dim == "height" ? frame.bbox.yview : frame.bbox.xview;
    const base_view = dim == "height" ? frame.bbox.xview : frame.bbox.yview;
    const _lower_sx = (() => {
      switch (this.model.properties.lower.units) {
        case "canvas":
          return new ScreenArray(this._lower);
        case "screen":
          return limit_view.v_compute(this._lower);
        case "data":
          return limit_scale.v_compute(this._lower);
      }
    })();
    const _upper_sx = (() => {
      switch (this.model.properties.upper.units) {
        case "canvas":
          return new ScreenArray(this._upper);
        case "screen":
          return limit_view.v_compute(this._upper);
        case "data":
          return limit_scale.v_compute(this._upper);
      }
    })();
    const _base_sx = (() => {
      switch (this.model.properties.base.units) {
        case "canvas":
          return new ScreenArray(this._base);
        case "screen":
          return base_view.v_compute(this._base);
        case "data":
          return base_scale.v_compute(this._base);
      }
    })();
    const [i2, j] = dim == "height" ? [1, 0] : [0, 1];
    const _lower = [_lower_sx, _base_sx];
    const _upper = [_upper_sx, _base_sx];
    this._lower_sx = _lower[i2];
    this._lower_sy = _lower[j];
    this._upper_sx = _upper[i2];
    this._upper_sy = _upper[j];
  }
};
__publicField(UpperLowerView, "__name__", "UpperLowerView");
var XOrYCoordinateSpec = class extends CoordinateSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "_value", unset);
  }
  get dimension() {
    return this.obj.dimension == "width" ? "x" : "y";
  }
  // XXX: a hack to make a coordinate & unit spec
  get units() {
    return this._value === unset ? "data" : this._value.units ?? "data";
  }
};
__publicField(XOrYCoordinateSpec, "__name__", "XOrYCoordinateSpec");
var _UpperLower = class _UpperLower extends DataAnnotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_UpperLower, "__name__", "UpperLower");
_UpperLower.define(() => ({
  dimension: [Dimension, "height"],
  lower: [XOrYCoordinateSpec, { field: "lower" }],
  upper: [XOrYCoordinateSpec, { field: "upper" }],
  base: [XOrYCoordinateSpec, { field: "base" }]
}));
var UpperLower = _UpperLower;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/band.js
var BandView = class extends UpperLowerView {
  _paint_data(ctx) {
    ctx.beginPath();
    ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
    for (let i2 = 0, end = this._lower_sx.length; i2 < end; i2++) {
      ctx.lineTo(this._lower_sx[i2], this._lower_sy[i2]);
    }
    for (let i2 = this._upper_sx.length - 1; i2 >= 0; i2--) {
      ctx.lineTo(this._upper_sx[i2], this._upper_sy[i2]);
    }
    ctx.closePath();
    this.visuals.fill.apply(ctx);
    ctx.beginPath();
    ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);
    for (let i2 = 0, end = this._lower_sx.length; i2 < end; i2++) {
      ctx.lineTo(this._lower_sx[i2], this._lower_sy[i2]);
    }
    this.visuals.line.apply(ctx);
    ctx.beginPath();
    ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);
    for (let i2 = 0, end = this._upper_sx.length; i2 < end; i2++) {
      ctx.lineTo(this._upper_sx[i2], this._upper_sy[i2]);
    }
    this.visuals.line.apply(ctx);
  }
};
__publicField(BandView, "__name__", "BandView");
var _Band = class _Band extends UpperLower {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Band, "__name__", "Band");
_Band.prototype.default_view = BandView;
_Band.mixins([Line, Fill]);
_Band.override({
  fill_color: "#fff9ba",
  fill_alpha: 0.4,
  line_color: "#cccccc",
  line_alpha: 0.3
});
var Band = _Band;

// node_modules/@bokeh/bokehjs/build/js/lib/models/common/box_kinds.js
var Corner = Enum("top_left", "top_right", "bottom_left", "bottom_right");
var Edge = Enum("left", "right", "top", "bottom");
var HitTarget = Enum(...Corner, ...Edge, "area");
var Resizable = Enum("none", "left", "right", "top", "bottom", "x", "y", "all");
var Movable = Enum("none", "x", "y", "both");
var Limit = Nullable(Or(Float, Ref(Node2)));

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/box_annotation.js
var EDGE_TOLERANCE = 2.5;
var { abs: abs6 } = Math;
var _BoxInteractionHandles = class _BoxInteractionHandles extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BoxInteractionHandles, "__name__", "BoxInteractionHandles");
_BoxInteractionHandles.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  all: [Ref2(AreaVisuals)],
  move: [Nullable2(Ref2(AreaVisuals)), null],
  resize: [Nullable2(Ref2(AreaVisuals)), null],
  sides: [Nullable2(Ref2(AreaVisuals)), null],
  corners: [Nullable2(Ref2(AreaVisuals)), null],
  left: [Nullable2(Ref2(AreaVisuals)), null],
  right: [Nullable2(Ref2(AreaVisuals)), null],
  top: [Nullable2(Ref2(AreaVisuals)), null],
  bottom: [Nullable2(Ref2(AreaVisuals)), null],
  top_left: [Nullable2(Ref2(AreaVisuals)), null],
  top_right: [Nullable2(Ref2(AreaVisuals)), null],
  bottom_left: [Nullable2(Ref2(AreaVisuals)), null],
  bottom_right: [Nullable2(Ref2(AreaVisuals)), null]
}));
var BoxInteractionHandles = _BoxInteractionHandles;
var DEFAULT_HANDLES = () => {
  return new BoxInteractionHandles({
    all: new AreaVisuals({
      fill_color: "white",
      fill_alpha: 1,
      line_color: "black",
      line_alpha: 1,
      hover_fill_color: "lightgray",
      hover_fill_alpha: 1
    })
  });
};
var _a31, _b2;
var BoxAnnotationView = class extends (_b2 = AnnotationView, _a31 = auto_ranged, _b2) {
  constructor() {
    super(...arguments);
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "_handles");
    __publicField(this, "_handles_views", {});
    __publicField(this, _a31, true);
    __publicField(this, "_pan_state", null);
    __publicField(this, "_pinch_state", null);
    __publicField(this, "_is_hovered", false);
  }
  get bbox() {
    return this._bbox;
  }
  initialize() {
    super.initialize();
    this._update_handles();
  }
  _update_handles() {
    const { editable, use_handles, handles } = this.model;
    if (editable && use_handles) {
      let attrs_of2 = function(source2) {
        return {
          ...attrs_of(source2, "", Line, true),
          ...attrs_of(source2, "", Fill, true),
          ...attrs_of(source2, "", Hatch, true),
          ...attrs_of(source2, "hover_", Line, true),
          ...attrs_of(source2, "hover_", Fill, true),
          ...attrs_of(source2, "hover_", Hatch, true)
        };
      };
      const { movable, resizable } = this;
      const common = {
        visible: true,
        resizable: "none",
        left_units: "canvas",
        right_units: "canvas",
        top_units: "canvas",
        bottom_units: "canvas",
        level: this.model.level
      };
      const h7 = handles;
      const attrs = {
        area: attrs_of2(h7.move ?? h7.all),
        left: attrs_of2(h7.left ?? h7.sides ?? h7.resize ?? h7.all),
        right: attrs_of2(h7.right ?? h7.sides ?? h7.resize ?? h7.all),
        top: attrs_of2(h7.top ?? h7.sides ?? h7.resize ?? h7.all),
        bottom: attrs_of2(h7.bottom ?? h7.sides ?? h7.resize ?? h7.all),
        top_left: attrs_of2(h7.top_left ?? h7.corners ?? h7.resize ?? h7.all),
        top_right: attrs_of2(h7.top_right ?? h7.corners ?? h7.resize ?? h7.all),
        bottom_left: attrs_of2(h7.bottom_left ?? h7.corners ?? h7.resize ?? h7.all),
        bottom_right: attrs_of2(h7.bottom_right ?? h7.corners ?? h7.resize ?? h7.all)
      };
      const { tl_cursor, tr_cursor, bl_cursor, br_cursor, ew_cursor, ns_cursor } = this.model;
      this._handles = {
        area: movable ? new BoxAnnotation({ ...common, ...attrs.area, movable: this.model.movable }) : null,
        left: resizable.left ? new BoxAnnotation({ ...common, ...attrs.left, in_cursor: ew_cursor }) : null,
        right: resizable.right ? new BoxAnnotation({ ...common, ...attrs.right, in_cursor: ew_cursor }) : null,
        top: resizable.top ? new BoxAnnotation({ ...common, ...attrs.top, in_cursor: ns_cursor }) : null,
        bottom: resizable.bottom ? new BoxAnnotation({ ...common, ...attrs.bottom, in_cursor: ns_cursor }) : null,
        top_left: resizable.top_left ? new BoxAnnotation({ ...common, ...attrs.top_left, in_cursor: tl_cursor }) : null,
        top_right: resizable.top_right ? new BoxAnnotation({ ...common, ...attrs.top_right, in_cursor: tr_cursor }) : null,
        bottom_left: resizable.bottom_left ? new BoxAnnotation({ ...common, ...attrs.bottom_left, in_cursor: bl_cursor }) : null,
        bottom_right: resizable.bottom_right ? new BoxAnnotation({ ...common, ...attrs.bottom_right, in_cursor: br_cursor }) : null
      };
    } else {
      this._handles = {
        area: null,
        left: null,
        right: null,
        top: null,
        bottom: null,
        top_left: null,
        top_right: null,
        bottom_left: null,
        bottom_right: null
      };
    }
  }
  get computed_renderers() {
    return [...super.computed_renderers, ...values(this._handles).filter((handle2) => handle2 != null)];
  }
  connect_signals() {
    super.connect_signals();
    const { editable, use_handles, handles, resizable, movable } = this.model.properties;
    this.on_change([editable, use_handles, handles, resizable, movable], async () => {
      this._update_handles();
      await this._update_renderers();
    });
    this.connect(this.model.change, () => this.request_paint());
  }
  async _build_renderers() {
    const build_result = await super._build_renderers();
    const get2 = (handle2) => {
      return handle2 != null ? this._renderer_views.get(handle2) : void 0;
    };
    this._handles_views = {
      area: get2(this._handles.area),
      left: get2(this._handles.left),
      right: get2(this._handles.right),
      top: get2(this._handles.top),
      bottom: get2(this._handles.bottom),
      top_left: get2(this._handles.top_left),
      top_right: get2(this._handles.top_right),
      bottom_left: get2(this._handles.bottom_left),
      bottom_right: get2(this._handles.bottom_right)
    };
    return build_result;
  }
  bounds() {
    const { left: left2, left_units, right: right3, right_units, top, top_units, bottom, bottom_units } = this.model;
    const left_ok = left_units == "data" && !(left2 instanceof Coordinate);
    const right_ok = right_units == "data" && !(right3 instanceof Coordinate);
    const top_ok = top_units == "data" && !(top instanceof Coordinate);
    const bottom_ok = bottom_units == "data" && !(bottom instanceof Coordinate);
    const [x0, x1] = (() => {
      if (left_ok && right_ok) {
        return left2 <= right3 ? [left2, right3] : [right3, left2];
      } else if (left_ok) {
        return [left2, left2];
      } else if (right_ok) {
        return [right3, right3];
      } else {
        return [NaN, NaN];
      }
    })();
    const [y0, y1] = (() => {
      if (top_ok && bottom_ok) {
        return top <= bottom ? [top, bottom] : [bottom, top];
      } else if (top_ok) {
        return [top, top];
      } else if (bottom_ok) {
        return [bottom, bottom];
      } else {
        return [NaN, NaN];
      }
    })();
    return { x0, x1, y0, y1 };
  }
  log_bounds() {
    return empty();
  }
  get mappers() {
    function mapper(units, scale, view, canvas3) {
      switch (units) {
        case "canvas":
          return canvas3;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    }
    const overlay = this.model;
    const { x_scale, y_scale } = this.coordinates;
    const { x_view, y_view } = this.plot_view.frame.bbox;
    const { x_screen, y_screen } = this.plot_view.canvas.bbox;
    const lrtb = {
      left: mapper(overlay.left_units, x_scale, x_view, x_screen),
      right: mapper(overlay.right_units, x_scale, x_view, x_screen),
      top: mapper(overlay.top_units, y_scale, y_view, y_screen),
      bottom: mapper(overlay.bottom_units, y_scale, y_view, y_screen)
    };
    return lrtb;
  }
  get border_radius() {
    return border_radius(this.model.border_radius);
  }
  compute_geometry() {
    super.compute_geometry();
    const bbox = (() => {
      const compute = (dim, value2, mapper) => {
        return value2 instanceof Coordinate ? this.resolve_as_scalar(value2, dim) : mapper.compute(value2);
      };
      const { left: left2, right: right3, top, bottom } = this.model;
      const { mappers } = this;
      return BBox.from_lrtb({
        left: compute("x", left2, mappers.left),
        right: compute("x", right3, mappers.right),
        top: compute("y", top, mappers.top),
        bottom: compute("y", bottom, mappers.bottom)
      });
    })();
    this._bbox = bbox;
    const width = 10;
    const height = 10;
    function update(renderer, bbox2) {
      const { left: left2, right: right3, top, bottom } = bbox2;
      renderer == null ? void 0 : renderer.setv({ left: left2, right: right3, top, bottom }, { silent: true });
    }
    update(this._handles.area, new BBox({ ...bbox.center, width, height, origin: "center" }));
    update(this._handles.left, new BBox({ ...bbox.center_left, width, height, origin: "center" }));
    update(this._handles.right, new BBox({ ...bbox.center_right, width, height, origin: "center" }));
    update(this._handles.top, new BBox({ ...bbox.top_center, width, height, origin: "center" }));
    update(this._handles.bottom, new BBox({ ...bbox.bottom_center, width, height, origin: "center" }));
    update(this._handles.top_left, new BBox({ ...bbox.top_left, width, height, origin: "center" }));
    update(this._handles.top_right, new BBox({ ...bbox.top_right, width, height, origin: "center" }));
    update(this._handles.bottom_left, new BBox({ ...bbox.bottom_left, width, height, origin: "center" }));
    update(this._handles.bottom_right, new BBox({ ...bbox.bottom_right, width, height, origin: "center" }));
  }
  _paint() {
    if (!this.bbox.is_valid) {
      return;
    }
    const { _is_hovered, visuals } = this;
    const fill = _is_hovered && visuals.hover_fill.doit ? visuals.hover_fill : visuals.fill;
    const hatch = _is_hovered && visuals.hover_hatch.doit ? visuals.hover_hatch : visuals.hatch;
    const line = _is_hovered && visuals.hover_line.doit ? visuals.hover_line : visuals.line;
    const { ctx } = this.layer;
    ctx.save();
    const { inverted } = this.model;
    if (!inverted) {
      ctx.beginPath();
      round_rect(ctx, this.bbox, this.border_radius);
      fill.apply(ctx);
      hatch.apply(ctx);
      line.apply(ctx);
    } else {
      ctx.beginPath();
      const parent = this.layout ?? this.plot_view.frame;
      const { x: x2, y: y2, width, height } = parent.bbox;
      ctx.rect(x2, y2, width, height);
      round_rect(ctx, this.bbox, this.border_radius);
      fill.apply(ctx, "evenodd");
      hatch.apply(ctx, "evenodd");
      ctx.beginPath();
      round_rect(ctx, this.bbox, this.border_radius);
      line.apply(ctx);
    }
    ctx.restore();
  }
  interactive_bbox() {
    const tolerance = this.model.line_width + EDGE_TOLERANCE;
    return this.bbox.grow_by(tolerance);
  }
  interactive_hit(sx, sy) {
    if (!this.model.visible) {
      return false;
    }
    const bbox = this.interactive_bbox();
    return bbox.contains(sx, sy);
  }
  _hit_test(sx, sy) {
    const { left: left2, right: right3, bottom, top } = this.bbox;
    const tolerance = Math.max(EDGE_TOLERANCE, this.model.line_width / 2);
    const dl2 = abs6(left2 - sx);
    const dr = abs6(right3 - sx);
    const dt2 = abs6(top - sy);
    const db = abs6(bottom - sy);
    const hits = {
      left: dl2 < tolerance && dl2 < dr,
      right: dr < tolerance && dr < dl2,
      top: dt2 < tolerance && dt2 < db,
      bottom: db < tolerance && db < dt2
    };
    const hittable = this._hittable();
    const hits_handle = (hit_target, condition) => {
      if (!hittable[hit_target]) {
        return false;
      }
      const handle2 = this._handles_views[hit_target];
      if (handle2 != null) {
        return handle2.bbox.contains(sx, sy);
      } else {
        return condition;
      }
    };
    if (hits_handle("top_left", hits.top && hits.left)) {
      return "top_left";
    }
    if (hits_handle("top_right", hits.top && hits.right)) {
      return "top_right";
    }
    if (hits_handle("bottom_left", hits.bottom && hits.left)) {
      return "bottom_left";
    }
    if (hits_handle("bottom_right", hits.bottom && hits.right)) {
      return "bottom_right";
    }
    if (hits_handle("left", hits.left)) {
      return "left";
    }
    if (hits_handle("right", hits.right)) {
      return "right";
    }
    if (hits_handle("top", hits.top)) {
      return "top";
    }
    if (hits_handle("bottom", hits.bottom)) {
      return "bottom";
    }
    if (hits_handle("area", this.bbox.contains(sx, sy))) {
      return "area";
    }
    return null;
  }
  get resizable() {
    const { resizable } = this.model;
    const left2 = resizable == "left" || resizable == "x" || resizable == "all";
    const right3 = resizable == "right" || resizable == "x" || resizable == "all";
    const top = resizable == "top" || resizable == "y" || resizable == "all";
    const bottom = resizable == "bottom" || resizable == "y" || resizable == "all";
    return {
      left: left2,
      right: right3,
      top,
      bottom,
      top_left: top && left2,
      top_right: top && right3,
      bottom_left: bottom && left2,
      bottom_right: bottom && right3
    };
  }
  get movable() {
    return this.model.movable != "none";
  }
  _hittable() {
    const { left: left2, right: right3, top, bottom } = this.resizable;
    return {
      top_left: top && left2,
      top_right: top && right3,
      bottom_left: bottom && left2,
      bottom_right: bottom && right3,
      left: left2,
      right: right3,
      top,
      bottom,
      area: this.movable
    };
  }
  _can_hit(target) {
    const { left: left2, right: right3, top, bottom } = this.resizable;
    switch (target) {
      case "top_left":
        return top && left2;
      case "top_right":
        return top && right3;
      case "bottom_left":
        return bottom && left2;
      case "bottom_right":
        return bottom && right3;
      case "left":
        return left2;
      case "right":
        return right3;
      case "top":
        return top;
      case "bottom":
        return bottom;
      case "area":
        return this.movable;
    }
  }
  on_pan_start(ev) {
    if (this.model.visible && this.model.editable) {
      const { sx, sy } = ev;
      const target = this._hit_test(sx, sy);
      if (target != null && this._can_hit(target)) {
        this._pan_state = {
          bbox: this.bbox.clone(),
          target
        };
        this.model.pan.emit(["pan:start", ev.modifiers]);
        return true;
      }
    }
    return false;
  }
  on_pan(ev) {
    assert(this._pan_state != null);
    const { mappers } = this;
    const resolve = (dim, limit2, mapper) => {
      if (limit2 instanceof Coordinate) {
        return this.resolve_as_scalar(limit2, dim);
      } else if (limit2 == null) {
        return NaN;
      } else {
        return mapper.compute(limit2);
      }
    };
    const slimits = BBox.from_lrtb({
      left: resolve("x", this.model.left_limit, mappers.left),
      right: resolve("x", this.model.right_limit, mappers.right),
      top: resolve("y", this.model.top_limit, mappers.top),
      bottom: resolve("y", this.model.bottom_limit, mappers.bottom)
    });
    const [dl2, dr, dt2, db] = (() => {
      const { dx, dy } = ev;
      const { target } = this._pan_state;
      const { symmetric } = this.model;
      const [Dx, Dy] = symmetric ? [-dx, -dy] : [0, 0];
      switch (target) {
        case "top_left":
          return [dx, Dx, dy, Dy];
        case "top_right":
          return [Dx, dx, dy, Dy];
        case "bottom_left":
          return [dx, Dx, Dy, dy];
        case "bottom_right":
          return [Dx, dx, Dy, dy];
        case "left":
          return [dx, Dx, 0, 0];
        case "right":
          return [Dx, dx, 0, 0];
        case "top":
          return [0, 0, dy, Dy];
        case "bottom":
          return [0, 0, Dy, dy];
        case "area": {
          switch (this.model.movable) {
            case "both":
              return [dx, dx, dy, dy];
            case "x":
              return [dx, dx, 0, 0];
            case "y":
              return [0, 0, dy, dy];
            case "none":
              return [0, 0, 0, 0];
          }
        }
      }
    })();
    const slrtb = (() => {
      const min10 = (a2, b2) => min([a2, b2]);
      const sgn = (v) => v < 0 ? -1 : v > 0 ? 1 : 0;
      const { bbox } = this._pan_state;
      let { left: left3, right: right4, left_sign, right_sign } = (() => {
        const left4 = bbox.left + dl2;
        const right5 = bbox.right + dr;
        const left_sign2 = sgn(dl2);
        const right_sign2 = sgn(dr);
        if (left4 <= right5) {
          return { left: left4, right: right5, left_sign: left_sign2, right_sign: right_sign2 };
        } else {
          return { left: right5, right: left4, left_sign: right_sign2, right_sign: left_sign2 };
        }
      })();
      let { top: top2, bottom: bottom2, top_sign, bottom_sign } = (() => {
        const top3 = bbox.top + dt2;
        const bottom3 = bbox.bottom + db;
        const top_sign2 = sgn(dt2);
        const bottom_sign2 = sgn(db);
        if (top3 <= bottom3) {
          return { top: top3, bottom: bottom3, top_sign: top_sign2, bottom_sign: bottom_sign2 };
        } else {
          return { top: bottom3, bottom: top3, top_sign: bottom_sign2, bottom_sign: top_sign2 };
        }
      })();
      const Dl = left3 - slimits.left;
      const Dr = slimits.right - right4;
      const Dx = min10(Dl < 0 ? Dl : NaN, Dr < 0 ? Dr : NaN);
      if (isFinite(Dx) && Dx < 0) {
        left3 += -left_sign * -Dx;
        right4 += -right_sign * -Dx;
      }
      const Dt = top2 - slimits.top;
      const Db = slimits.bottom - bottom2;
      const Dy = min10(Dt < 0 ? Dt : NaN, Db < 0 ? Db : NaN);
      if (isFinite(Dy) && Dy < 0) {
        top2 += -top_sign * -Dy;
        bottom2 += -bottom_sign * -Dy;
      }
      return BBox.from_lrtb({ left: left3, right: right4, top: top2, bottom: bottom2 });
    })();
    const { min_width, min_height, max_width, max_height } = this.model;
    const { left: left2, right: right3, top, bottom } = this.model;
    const lrtb = {
      left: mappers.left.invert(slrtb.left),
      right: mappers.right.invert(slrtb.right),
      top: mappers.top.invert(slrtb.top),
      bottom: mappers.bottom.invert(slrtb.bottom)
    };
    if (0 < min_width || max_width < Infinity) {
      if (dl2 != 0 && dr == 0) {
        const min_left = lrtb.right - max_width;
        const max_left = lrtb.right - min_width;
        lrtb.left = clamp(lrtb.left, min_left, max_left);
      } else if (dl2 == 0 && dr != 0) {
        const min_right = lrtb.left + min_width;
        const max_right = lrtb.left + max_width;
        lrtb.right = clamp(lrtb.right, min_right, max_right);
      }
    }
    if (0 < min_height || max_height < Infinity) {
      if (dt2 != 0 && db == 0) {
        const min_top = lrtb.bottom + max_height;
        const max_top = lrtb.bottom + min_height;
        lrtb.top = clamp(lrtb.top, min_top, max_top);
      } else if (dt2 == 0 && db != 0) {
        const min_bottom = lrtb.top - min_height;
        const max_bottom = lrtb.top - max_height;
        lrtb.bottom = clamp(lrtb.bottom, min_bottom, max_bottom);
      }
    }
    const computed_lrtb = (() => {
      return {
        left: left2 instanceof Coordinate ? left2 : lrtb.left,
        right: right3 instanceof Coordinate ? right3 : lrtb.right,
        top: top instanceof Coordinate ? top : lrtb.top,
        bottom: bottom instanceof Coordinate ? bottom : lrtb.bottom
      };
    })();
    this.model.update(computed_lrtb);
    this.model.pan.emit(["pan", ev.modifiers]);
  }
  on_pan_end(ev) {
    this._pan_state = null;
    this.model.pan.emit(["pan:end", ev.modifiers]);
  }
  on_pinch_start(ev) {
    if (this.model.visible && this.model.editable && this.model.resizable != "none") {
      const { sx, sy } = ev;
      if (this.bbox.contains(sx, sy)) {
        this._pinch_state = {
          bbox: this.bbox.clone()
        };
        this.model.pan.emit(["pan:start", ev.modifiers]);
        return true;
      }
    }
    return false;
  }
  on_pinch(ev) {
    assert(this._pinch_state != null);
    const slrtb = (() => {
      const { scale } = ev;
      const { bbox } = this._pinch_state;
      const { left: left2, top, right: right3, bottom, width, height } = bbox;
      const dw = width * (scale - 1);
      const dh = height * (scale - 1);
      const { resizable } = this;
      const dl2 = resizable.left ? -dw / 2 : 0;
      const dr = resizable.right ? dw / 2 : 0;
      const dt2 = resizable.top ? -dh / 2 : 0;
      const db = resizable.bottom ? dh / 2 : 0;
      return BBox.from_lrtb({
        left: left2 + dl2,
        right: right3 + dr,
        top: top + dt2,
        bottom: bottom + db
      });
    })();
    const lrtb = (() => {
      const { left: left2, right: right3, top, bottom } = this.model;
      const { mappers } = this;
      return {
        left: left2 instanceof Coordinate ? left2 : mappers.left.invert(slrtb.left),
        right: right3 instanceof Coordinate ? right3 : mappers.right.invert(slrtb.right),
        top: top instanceof Coordinate ? top : mappers.top.invert(slrtb.top),
        bottom: bottom instanceof Coordinate ? bottom : mappers.bottom.invert(slrtb.bottom)
      };
    })();
    this.model.update(lrtb);
    this.model.pan.emit(["pan", ev.modifiers]);
  }
  on_pinch_end(ev) {
    this._pinch_state = null;
    this.model.pan.emit(["pan:end", ev.modifiers]);
  }
  get _has_hover() {
    const { hover_line, hover_fill, hover_hatch } = this.visuals;
    return hover_line.doit || hover_fill.doit || hover_hatch.doit;
  }
  on_enter(_ev) {
    const { _has_hover } = this;
    if (_has_hover) {
      this._is_hovered = true;
      this.request_paint();
    }
    return _has_hover;
  }
  on_move(_ev) {
  }
  on_leave(_ev) {
    if (this._has_hover) {
      this._is_hovered = false;
      this.request_paint();
    }
  }
  cursor(sx, sy) {
    var _a34;
    const target = ((_a34 = this._pan_state) == null ? void 0 : _a34.target) ?? this._hit_test(sx, sy);
    if (target == null || !this._can_hit(target)) {
      return null;
    }
    const { tl_cursor, tr_cursor, bl_cursor, br_cursor, ew_cursor, ns_cursor, in_cursor } = this.model;
    switch (target) {
      case "top_left":
        return this._handles.top_left == null ? tl_cursor : null;
      case "top_right":
        return this._handles.top_right == null ? tr_cursor : null;
      case "bottom_left":
        return this._handles.bottom_left == null ? bl_cursor : null;
      case "bottom_right":
        return this._handles.bottom_right == null ? br_cursor : null;
      case "left":
        return this._handles.left == null ? ew_cursor : null;
      case "right":
        return this._handles.right == null ? ew_cursor : null;
      case "top":
        return this._handles.top == null ? ns_cursor : null;
      case "bottom":
        return this._handles.bottom == null ? ns_cursor : null;
      case "area": {
        if (this._handles.area == null) {
          switch (this.model.movable) {
            case "both":
              return in_cursor;
            case "x":
              return ew_cursor;
            case "y":
              return ns_cursor;
            case "none":
              return null;
          }
        } else {
          return null;
        }
      }
    }
  }
};
__publicField(BoxAnnotationView, "__name__", "BoxAnnotationView");
var _BoxAnnotation = class _BoxAnnotation extends Annotation {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "pan", new Signal(this, "pan"));
    __publicField(this, "nodes", /* @__PURE__ */ (() => {
      const known = /* @__PURE__ */ new Map();
      const node = (symbol2) => {
        let node2 = known.get(symbol2);
        if (node2 === void 0) {
          known.set(symbol2, node2 = new Node2({ target: this, symbol: symbol2 }));
        }
        return node2;
      };
      return {
        get left() {
          return node("left");
        },
        get right() {
          return node("right");
        },
        get top() {
          return node("top");
        },
        get bottom() {
          return node("bottom");
        },
        get top_left() {
          return node("top_left");
        },
        get top_center() {
          return node("top_center");
        },
        get top_right() {
          return node("top_right");
        },
        get center_left() {
          return node("center_left");
        },
        get center() {
          return node("center");
        },
        get center_right() {
          return node("center_right");
        },
        get bottom_left() {
          return node("bottom_left");
        },
        get bottom_center() {
          return node("bottom_center");
        },
        get bottom_right() {
          return node("bottom_right");
        },
        get width() {
          return node("width");
        },
        get height() {
          return node("height");
        }
      };
    })());
  }
  clone(attrs) {
    return super.clone(attrs);
  }
  update({ left: left2, right: right3, top, bottom }) {
    this.setv({ left: left2, right: right3, top, bottom, visible: true });
  }
  clear() {
    this.visible = false;
  }
};
__publicField(_BoxAnnotation, "__name__", "BoxAnnotation");
_BoxAnnotation.prototype.default_view = BoxAnnotationView;
_BoxAnnotation.mixins([
  Line,
  Fill,
  Hatch,
  ["hover_", Line],
  ["hover_", Fill],
  ["hover_", Hatch]
]);
_BoxAnnotation.define(({ Bool: Bool2, Float: Float2, Ref: Ref2, Or: Or2, NonNegative: NonNegative2, Positive }) => ({
  top: [Or2(Float2, Ref2(Coordinate)), () => new Node2({ target: "frame", symbol: "top" })],
  bottom: [Or2(Float2, Ref2(Coordinate)), () => new Node2({ target: "frame", symbol: "bottom" })],
  left: [Or2(Float2, Ref2(Coordinate)), () => new Node2({ target: "frame", symbol: "left" })],
  right: [Or2(Float2, Ref2(Coordinate)), () => new Node2({ target: "frame", symbol: "right" })],
  top_units: [CoordinateUnits, "data"],
  bottom_units: [CoordinateUnits, "data"],
  left_units: [CoordinateUnits, "data"],
  right_units: [CoordinateUnits, "data"],
  top_limit: [Limit, null],
  bottom_limit: [Limit, null],
  left_limit: [Limit, null],
  right_limit: [Limit, null],
  min_width: [NonNegative2(Float2), 0],
  min_height: [NonNegative2(Float2), 0],
  max_width: [Positive(Float2), Infinity],
  max_height: [Positive(Float2), Infinity],
  border_radius: [BorderRadius, 0],
  editable: [Bool2, false],
  resizable: [Resizable, "all"],
  movable: [Movable, "both"],
  symmetric: [Bool2, false],
  use_handles: [Bool2, false],
  handles: [Ref2(BoxInteractionHandles), DEFAULT_HANDLES],
  inverted: [Bool2, false]
}));
_BoxAnnotation.internal(({ Str: Str2 }) => ({
  tl_cursor: [Str2, "nwse-resize"],
  tr_cursor: [Str2, "nesw-resize"],
  bl_cursor: [Str2, "nesw-resize"],
  br_cursor: [Str2, "nwse-resize"],
  ew_cursor: [Str2, "ew-resize"],
  ns_cursor: [Str2, "ns-resize"],
  in_cursor: [Str2, "move"]
}));
_BoxAnnotation.override({
  fill_color: "#fff9ba",
  fill_alpha: 0.4,
  line_color: "#cccccc",
  line_alpha: 0.3,
  hover_fill_color: null,
  hover_fill_alpha: 0.4,
  hover_line_color: null,
  hover_line_alpha: 0.3
});
var BoxAnnotation = _BoxAnnotation;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/categorical_axis.js
var CategoricalAxisView = class extends AxisView {
  _hit_value(sx, sy) {
    const [range2] = this.ranges;
    const { start: start2, end, span: span2 } = range2;
    switch (this.dimension) {
      case 0: {
        const { x0, width } = this.bbox;
        return range2.factor(span2 * (sx - x0) / width + start2);
      }
      case 1: {
        const { y0, height } = this.bbox;
        return range2.factor(end - span2 * (sy - y0) / height);
      }
    }
  }
  _paint() {
    const { tick_coords, extents } = this;
    const ctx = this.layer.ctx;
    super._paint();
    this._draw_group_separators(ctx, extents, tick_coords);
  }
  _draw_group_separators(ctx, _extents, _tick_coords) {
    const [range2] = this.ranges;
    const [start2, end] = this.computed_bounds;
    const { factors } = range2;
    const { tops } = range2.mapper;
    if (tops == null || tops.length < 2 || !this.visuals.separator_line.doit) {
      return;
    }
    const dim = this.dimension;
    const alt = 1 - dim;
    const coords = [[], []];
    let ind = 0;
    for (let i2 = 0; i2 < tops.length - 1; i2++) {
      let first, last2;
      for (let j = ind; j < factors.length; j++) {
        if (factors[j][0] == tops[i2 + 1]) {
          [first, last2] = [factors[j - 1], factors[j]];
          ind = j;
          break;
        }
      }
      const pt = (range2.synthetic(first) + range2.synthetic(last2)) / 2;
      if (pt > start2 && pt < end) {
        coords[dim].push(pt);
        coords[alt].push(this.loc);
      }
    }
    const tex = this.extents.tick_label;
    this._draw_ticks(ctx, coords, -3, tex - 6, this.visuals.separator_line);
  }
  _draw_major_labels(ctx, extents, _tick_coords) {
    const info = this._get_factor_info();
    let standoff = extents.tick + this.model.major_label_standoff;
    for (let i2 = 0; i2 < info.length; i2++) {
      const [labels, coords, orient, visuals] = info[i2];
      this._draw_oriented_labels(ctx, labels, coords, orient, standoff, visuals);
      standoff += extents.tick_labels[i2];
    }
  }
  _tick_label_extents() {
    const info = this._get_factor_info();
    const extents = [];
    for (const [labels, , orient, visuals] of info) {
      const extent = this._oriented_labels_extent(labels, orient, this.model.major_label_standoff, visuals);
      extents.push(extent);
    }
    return extents;
  }
  _get_factor_info() {
    const [range2] = this.ranges;
    const [start2, end] = this.computed_bounds;
    const loc = this.loc;
    const ticks = this.model.ticker.get_ticks(start2, end, range2, loc);
    const coords = this.tick_coords;
    const info = [];
    const map4 = (labels) => {
      return new GraphicsBoxes(labels.map((label3) => isString(label3) ? new TextBox({ text: label3 }) : label3));
    };
    const format7 = (ticks2) => {
      return map4(this.model.formatter.doFormat(ticks2, this));
    };
    switch (range2.mapper.levels) {
      case 1: {
        const major = ticks.major;
        const labels = format7(major);
        info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);
        break;
      }
      case 2: {
        const major = ticks.major.map((x2) => x2[1]);
        const labels = format7(major);
        info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);
        info.push([map4(ticks.tops), coords.tops, this.model.group_label_orientation, this.visuals.group_text]);
        break;
      }
      case 3: {
        const major = ticks.major.map((x2) => x2[2]);
        const labels = format7(major);
        const mid_labels = ticks.mids.map((x2) => x2[1]);
        info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);
        info.push([map4(mid_labels), coords.mids, this.model.subgroup_label_orientation, this.visuals.subgroup_text]);
        info.push([map4(ticks.tops), coords.tops, this.model.group_label_orientation, this.visuals.group_text]);
        break;
      }
    }
    return info;
  }
  get tick_coords() {
    const i2 = this.dimension;
    const j = 1 - i2;
    const [range2] = this.ranges;
    const [start2, end] = this.computed_bounds;
    const ticks = this.model.ticker.get_ticks(start2, end, range2, this.loc);
    const coords = {
      major: [[], []],
      mids: [[], []],
      tops: [[], []],
      minor: [[], []]
    };
    coords.major[i2] = ticks.major;
    coords.major[j] = ticks.major.map(() => this.loc);
    const { levels } = range2.mapper;
    if (levels == 3) {
      coords.mids[i2] = ticks.mids;
      coords.mids[j] = ticks.mids.map(() => this.loc);
    }
    if (levels > 1) {
      coords.tops[i2] = ticks.tops;
      coords.tops[j] = ticks.tops.map(() => this.loc);
    }
    return coords;
  }
};
__publicField(CategoricalAxisView, "__name__", "CategoricalAxisView");
var _CategoricalAxis = class _CategoricalAxis extends Axis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CategoricalAxis, "__name__", "CategoricalAxis");
_CategoricalAxis.prototype.default_view = CategoricalAxisView;
_CategoricalAxis.mixins([
  ["separator_", Line],
  ["group_", Text],
  ["subgroup_", Text]
]);
_CategoricalAxis.define(({ Float: Float2, Or: Or2 }) => ({
  group_label_orientation: [Or2(LabelOrientation, Float2), "parallel"],
  subgroup_label_orientation: [Or2(LabelOrientation, Float2), "parallel"]
}));
_CategoricalAxis.override({
  ticker: () => new CategoricalTicker(),
  formatter: () => new CategoricalTickFormatter(),
  separator_line_color: "lightgrey",
  separator_line_width: 2,
  group_text_font_style: "bold",
  group_text_font_size: "11px",
  group_text_color: "grey",
  subgroup_text_font_style: "bold",
  subgroup_text_font_size: "11px"
});
var CategoricalAxis = _CategoricalAxis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/datetime_axis.js
var DatetimeAxisView = class extends ContinuousAxisView {
};
__publicField(DatetimeAxisView, "__name__", "DatetimeAxisView");
var _DatetimeAxis = class _DatetimeAxis extends ContinuousAxis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatetimeAxis, "__name__", "DatetimeAxis");
_DatetimeAxis.prototype.default_view = DatetimeAxisView;
_DatetimeAxis.override({
  ticker: () => new DatetimeTicker(),
  formatter: () => new DatetimeTickFormatter()
});
var DatetimeAxis = _DatetimeAxis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/log_axis.js
var LogAxisView = class extends ContinuousAxisView {
  _hit_value(sx, sy) {
    const [range2] = this.ranges;
    const { start: start2, end } = range2;
    const { log10 } = Math;
    switch (this.dimension) {
      case 0: {
        const { x0, width } = this.bbox;
        return log10(end / start2) * (sx - x0) / width + log10(start2);
      }
      case 1: {
        const { y0, height } = this.bbox;
        return log10(end) - log10(end / start2) * (sy - y0) / height;
      }
    }
  }
};
__publicField(LogAxisView, "__name__", "LogAxisView");
var _LogAxis = class _LogAxis extends ContinuousAxis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LogAxis, "__name__", "LogAxis");
_LogAxis.prototype.default_view = LogAxisView;
_LogAxis.override({
  ticker: () => new LogTicker(),
  formatter: () => new LogTickFormatter()
});
var LogAxis = _LogAxis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/axes/mercator_axis.js
var MercatorAxisView = class extends LinearAxisView {
};
__publicField(MercatorAxisView, "__name__", "MercatorAxisView");
var _MercatorAxis = class _MercatorAxis extends LinearAxis {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MercatorAxis, "__name__", "MercatorAxis");
_MercatorAxis.prototype.default_view = MercatorAxisView;
_MercatorAxis.override({
  ticker: () => new MercatorTicker({ dimension: "lat" }),
  formatter: () => new MercatorTickFormatter({ dimension: "lat" })
});
var MercatorAxis = _MercatorAxis;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/categorical_mapper.js
function _cat_equals(a2, b2) {
  if (a2.length != b2.length) {
    return false;
  }
  const n2 = a2.length;
  for (let i2 = 0; i2 < n2; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function cat_v_compute(data3, factors, targets, values2, start2, end, extra_value) {
  let i2 = 0;
  for (const item3 of data3) {
    let key;
    if (!isArray(item3)) {
      key = index_of(factors, item3);
    } else {
      const d = item3.slice(start2, end ?? void 0);
      if (d.length == 1) {
        key = index_of(factors, d[0]);
      } else {
        key = find_index(factors, (x2) => _cat_equals(x2, d));
      }
    }
    const value2 = key in targets ? targets[key] : extra_value;
    values2[i2++] = value2;
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/categorical_color_mapper.js
var _CategoricalColorMapper = class _CategoricalColorMapper extends ColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(data3, values2, palette, { nan_color }) {
    cat_v_compute(data3, this.factors, palette, values2, this.start, this.end, nan_color);
  }
};
__publicField(_CategoricalColorMapper, "__name__", "CategoricalColorMapper");
_CategoricalColorMapper.define(({ Float: Float2, Nullable: Nullable2 }) => ({
  factors: [FactorSeq],
  start: [Float2, 0],
  end: [Nullable2(Float2), null]
}));
var CategoricalColorMapper = _CategoricalColorMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/categorical_marker_mapper.js
var _CategoricalMarkerMapper = class _CategoricalMarkerMapper extends Mapper {
  constructor(attrs) {
    super(attrs);
  }
  v_compute(xs) {
    const values2 = new Array(xs.length);
    cat_v_compute(xs, this.factors, this.markers, values2, this.start, this.end, this.default_value);
    return values2;
  }
};
__publicField(_CategoricalMarkerMapper, "__name__", "CategoricalMarkerMapper");
_CategoricalMarkerMapper.define(({ Float: Float2, List: List2, Nullable: Nullable2 }) => ({
  factors: [FactorSeq],
  markers: [List2(MarkerType)],
  start: [Float2, 0],
  end: [Nullable2(Float2), null],
  default_value: [MarkerType, "circle"]
}));
var CategoricalMarkerMapper = _CategoricalMarkerMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/categorical_pattern_mapper.js
var _CategoricalPatternMapper = class _CategoricalPatternMapper extends Mapper {
  constructor(attrs) {
    super(attrs);
  }
  v_compute(xs) {
    const values2 = new Array(xs.length);
    cat_v_compute(xs, this.factors, this.patterns, values2, this.start, this.end, this.default_value);
    return values2;
  }
};
__publicField(_CategoricalPatternMapper, "__name__", "CategoricalPatternMapper");
_CategoricalPatternMapper.define(({ Float: Float2, List: List2, Nullable: Nullable2 }) => ({
  factors: [FactorSeq],
  patterns: [List2(HatchPatternType)],
  start: [Float2, 0],
  end: [Nullable2(Float2), null],
  default_value: [HatchPatternType, " "]
}));
var CategoricalPatternMapper = _CategoricalPatternMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/linear_color_mapper.js
var LinearColorMapper = class extends ContinuousColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  scan(data3, n2) {
    const low = this.low != null ? this.low : min(data3);
    const high = this.high != null ? this.high : max(data3);
    const norm_factor = 1 / (high - low);
    const normed_interval = 1 / n2;
    return { max: high, min: low, norm_factor, normed_interval };
  }
  index_to_value(index2) {
    const scan_data = this._scan_data;
    return scan_data.min + scan_data.normed_interval * index2 / scan_data.norm_factor;
  }
  value_to_index(value2, palette_length) {
    const scan_data = this._scan_data;
    if (value2 == scan_data.max) {
      return palette_length - 1;
    }
    const normed_value = (value2 - scan_data.min) * scan_data.norm_factor;
    const index2 = Math.floor(normed_value / scan_data.normed_interval);
    return clamp(index2, -1, palette_length);
  }
};
__publicField(LinearColorMapper, "__name__", "LinearColorMapper");

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/log_color_mapper.js
var LogColorMapper = class extends ContinuousColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  scan(data3, n2) {
    const low = this.low != null ? this.low : min(data3);
    const high = this.high != null ? this.high : max(data3);
    const scale = n2 / Math.log(high / low);
    return { max: high, min: low, scale };
  }
  index_to_value(index2) {
    const scan_data = this._scan_data;
    return scan_data.min * Math.exp(index2 / scan_data.scale);
  }
  value_to_index(value2, palette_length) {
    const scan_data = this._scan_data;
    if (value2 == scan_data.max) {
      return palette_length - 1;
    } else if (value2 > scan_data.max) {
      return palette_length;
    } else if (value2 < scan_data.min) {
      return -1;
    }
    const log4 = Math.log(value2 / scan_data.min);
    const index2 = Math.floor(log4 * scan_data.scale);
    return clamp(index2, -1, palette_length);
  }
};
__publicField(LogColorMapper, "__name__", "LogColorMapper");

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/eqhist_color_mapper.js
var _EqHistColorMapper = class _EqHistColorMapper extends ScanningColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  // Public for unit tests
  /*protected*/
  scan(data3, n2) {
    const low = this.low != null ? this.low : min(data3);
    const high = this.high != null ? this.high : max(data3);
    const nbins = this.bins;
    const eq_bin_edges = linspace(low, high, nbins + 1);
    const full_hist = bin_counts(data3, eq_bin_edges);
    let nhist = 0;
    for (let i2 = 0; i2 < nbins; i2++) {
      if (full_hist[i2] != 0) {
        nhist++;
      }
    }
    const hist = new Array(nhist + 1);
    const eq_bin_centers = new Array(nhist + 1);
    for (let i2 = 0, j = 1; i2 < nbins; i2++) {
      if (full_hist[i2] != 0) {
        hist[j] = full_hist[i2];
        eq_bin_centers[j] = (eq_bin_edges[i2] + eq_bin_edges[i2 + 1]) / 2;
        j++;
      }
    }
    hist[0] = 0;
    eq_bin_centers[0] = 2 * eq_bin_centers[1] - eq_bin_centers[nhist];
    const cdf = cumsum(hist);
    const lo = cdf[1];
    const diff = cdf[nhist] - lo;
    for (let i2 = 1; i2 <= nhist; i2++) {
      cdf[i2] = (cdf[i2] - lo) / diff;
    }
    cdf[0] = -1;
    let { rescale_discrete_levels } = this;
    let lower_span = 0;
    if (rescale_discrete_levels) {
      const discrete_levels = nhist;
      const m = -0.5 / 98;
      const c = 1.5 - 2 * m;
      const multiple = m * discrete_levels + c;
      if (multiple > 1) {
        lower_span = 1 - multiple;
      } else {
        rescale_discrete_levels = false;
      }
    }
    const cdf_bins = linspace(lower_span, 1, n2 + 1);
    const binning = interpolate(cdf_bins, cdf, eq_bin_centers);
    let force_low_cutoff = false;
    if (rescale_discrete_levels) {
      const low_cutoff_index = sorted_index(binning, low);
      if (low < binning[low_cutoff_index] && low_cutoff_index > 0) {
        binning[low_cutoff_index - 1] = low;
      }
      force_low_cutoff = true;
    } else {
      binning[0] = low;
    }
    binning[binning.length - 1] = high;
    return { min: low, max: high, binning, force_low_cutoff };
  }
};
__publicField(_EqHistColorMapper, "__name__", "EqHistColorMapper");
_EqHistColorMapper.define(({ Bool: Bool2, Int: Int2 }) => ({
  bins: [Int2, 256 * 256],
  rescale_discrete_levels: [Bool2, false]
}));
var EqHistColorMapper = _EqHistColorMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/stack_color_mapper.js
var StackColorMapper = class extends ColorMapper {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(StackColorMapper, "__name__", "StackColorMapper");

// node_modules/@bokeh/bokehjs/build/js/lib/models/mappers/weighted_stack_color_mapper.js
var _WeightedStackColorMapper = class _WeightedStackColorMapper extends StackColorMapper {
  constructor(attrs) {
    super(attrs);
  }
  // Weighted mix of colors.
  _mix_colors(colors_rgba, nan_color, weights, total_weight) {
    if (isNaN(total_weight)) {
      return nan_color;
    }
    let r = 0, g = 0, b2 = 0, a2 = 0;
    const n2 = weights.length;
    if (total_weight != 0) {
      for (let i2 = 0; i2 < n2; i2++) {
        if (isNaN(weights[i2])) {
          continue;
        }
        const weight = weights[i2] / total_weight;
        r += colors_rgba[i2 * 4] * weight;
        g += colors_rgba[i2 * 4 + 1] * weight;
        b2 += colors_rgba[i2 * 4 + 2] * weight;
        a2 += colors_rgba[i2 * 4 + 3] * weight;
      }
    } else {
      let count = 0;
      for (let i2 = 0; i2 < n2; i2++) {
        if (weights[i2] == 0) {
          r += colors_rgba[i2 * 4];
          g += colors_rgba[i2 * 4 + 1];
          b2 += colors_rgba[i2 * 4 + 2];
          a2 += colors_rgba[i2 * 4 + 3];
          count++;
        }
      }
      r /= count;
      g /= count;
      b2 /= count;
      a2 /= count;
    }
    return encode_rgba([byte(r), byte(g), byte(b2), byte(a2)]);
  }
  _v_compute(_data, _values, _palette, _colors) {
    unreachable();
  }
  _v_compute_uint32(data3, values2, palette, colors) {
    const n2 = values2.length;
    const ncolor = palette.length;
    const nstack = data3.length / n2;
    assert(nstack == ncolor, `Expected ${nstack} not ${ncolor} colors in palette`);
    const palette_as_rgba = new RGBAArray(ncolor * 4);
    for (let i2 = 0; i2 < ncolor; i2++) {
      const [r, g, b2, a2] = decode_rgba(palette[i2]);
      palette_as_rgba[i2 * 4] = r;
      palette_as_rgba[i2 * 4 + 1] = g;
      palette_as_rgba[i2 * 4 + 2] = b2;
      palette_as_rgba[i2 * 4 + 3] = a2;
    }
    const color_baseline = this.color_baseline;
    const baseline = color_baseline == null ? min(data3) : color_baseline;
    const { nan_color } = colors;
    const totals = new Array(n2);
    const weights = new Array(ncolor);
    for (let i2 = 0; i2 < n2; i2++) {
      let total = NaN;
      for (let icol = 0; icol < ncolor; icol++) {
        const index2 = i2 * ncolor + icol;
        const val = baseline == 0 ? data3[index2] : Math.max(data3[index2] - baseline, 0);
        weights[icol] = val;
        if (!isNaN(val)) {
          if (isNaN(total)) {
            total = val;
          } else {
            total += val;
          }
        }
      }
      values2[i2] = this._mix_colors(palette_as_rgba, nan_color, weights, total);
      totals[i2] = total + baseline * ncolor;
    }
    const alpha_palette = _convert_palette(this.alpha_mapper.palette);
    const alphas = new Uint32Array(n2);
    this.alpha_mapper._v_compute(totals, alphas, alpha_palette, colors);
    for (let i2 = 0; i2 < n2; i2++) {
      const alpha = byte((values2[i2] & 255) * (alphas[i2] & 255) / 255);
      values2[i2] = values2[i2] & 4294967040 | alpha;
    }
  }
};
__publicField(_WeightedStackColorMapper, "__name__", "WeightedStackColorMapper");
_WeightedStackColorMapper.define(({ List: List2, Nullable: Nullable2, Float: Float2, Ref: Ref2, Str: Str2 }) => ({
  alpha_mapper: [Ref2(ContinuousColorMapper)],
  color_baseline: [Nullable2(Float2), null],
  stack_labels: [Nullable2(List2(Str2)), null]
}));
var WeightedStackColorMapper = _WeightedStackColorMapper;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/color_bar.js
var ColorBarView = class extends BaseColorBarView {
  constructor() {
    super(...arguments);
    __publicField(this, "_image");
    // Indices of displayed colors corresponding to low and high display cutoffs.
    __publicField(this, "_index_low");
    __publicField(this, "_index_high");
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.color_mapper.change, async () => {
      this._title_view.remove();
      this._axis_view.remove();
      this.initialize();
      await this.lazy_initialize();
      this.plot_view.invalidate_layout();
    });
    this.connect(this.model.color_mapper.metrics_change, () => this._metrics_changed());
    this.connect(this.model.properties.display_low.change, () => this._metrics_changed());
    this.connect(this.model.properties.display_high.change, () => this._metrics_changed());
  }
  get color_mapper() {
    let mapper = this.model.color_mapper;
    if (mapper instanceof WeightedStackColorMapper) {
      mapper = mapper.alpha_mapper;
    }
    return mapper;
  }
  update_layout() {
    super.update_layout();
    this._set_canvas_image();
  }
  _create_axis() {
    const { color_mapper } = this;
    if (color_mapper instanceof CategoricalColorMapper) {
      return new CategoricalAxis();
    } else if (color_mapper instanceof LogColorMapper) {
      return new LogAxis();
    } else {
      return new LinearAxis();
    }
  }
  _create_formatter() {
    const { color_mapper } = this;
    if (this._ticker instanceof LogTicker) {
      return new LogTickFormatter();
    } else if (color_mapper instanceof CategoricalColorMapper) {
      return new CategoricalTickFormatter();
    } else {
      return new BasicTickFormatter();
    }
  }
  _create_major_range() {
    const { color_mapper } = this;
    if (color_mapper instanceof CategoricalColorMapper) {
      return new FactorRange({ factors: color_mapper.factors });
    } else if (color_mapper instanceof ContinuousColorMapper) {
      const { min: min10, max: max18 } = this._continuous_metrics(color_mapper);
      return new Range1d({ start: min10, end: max18 });
    } else {
      unreachable();
    }
  }
  _create_major_scale() {
    const { color_mapper } = this;
    if (color_mapper instanceof LinearColorMapper) {
      return new LinearScale();
    } else if (color_mapper instanceof LogColorMapper) {
      return new LogScale();
    } else if (color_mapper instanceof ScanningColorMapper) {
      return new LinearInterpolationScale({ binning: this._scanning_binning(color_mapper) });
    } else if (color_mapper instanceof CategoricalColorMapper) {
      return new CategoricalScale();
    } else {
      unreachable();
    }
  }
  _create_ticker() {
    const { color_mapper } = this;
    if (color_mapper instanceof LogColorMapper) {
      return new LogTicker();
    } else if (color_mapper instanceof ScanningColorMapper) {
      return new BinnedTicker({ mapper: color_mapper });
    } else if (color_mapper instanceof CategoricalColorMapper) {
      return new CategoricalTicker();
    } else {
      return new BasicTicker();
    }
  }
  // Return min and max metrics of ContinuousColorMapper, modified to account
  // for low and high display cutoffs.
  _continuous_metrics(color_mapper) {
    const { display_low, display_high } = this.model;
    let { min: min10, max: max18 } = color_mapper.metrics;
    if (display_high != null && display_low != null && display_high < display_low) {
      this._index_low = 0;
      this._index_high = -1;
      return { min: NaN, max: NaN };
    }
    this._index_high = null;
    if (display_high != null) {
      const palette_length = color_mapper.palette.length;
      const index_high = color_mapper.value_to_index(display_high, palette_length);
      if (index_high < palette_length - 1) {
        this._index_high = index_high;
        max18 = color_mapper.index_to_value(index_high + 1);
      }
    }
    this._index_low = null;
    if (display_low != null) {
      const index_low = color_mapper.value_to_index(display_low, color_mapper.palette.length);
      if (index_low > 0) {
        this._index_low = index_low;
        min10 = color_mapper.index_to_value(index_low);
      }
    }
    return { min: min10, max: max18 };
  }
  _get_major_size_factor() {
    return this.color_mapper.palette.length;
  }
  _metrics_changed() {
    const range2 = this._major_range;
    const scale = this._major_scale;
    const { color_mapper } = this;
    if (color_mapper instanceof ScanningColorMapper && scale instanceof LinearInterpolationScale) {
      const binning = this._scanning_binning(color_mapper);
      scale.binning = binning;
      const vertical2 = this.orientation == "vertical";
      const frame_scale = vertical2 ? this._frame_view.y_scale : this._frame_view.x_scale;
      if (frame_scale instanceof LinearInterpolationScale) {
        frame_scale.binning = binning;
        const frame_range = vertical2 ? this._frame_view.y_range : this._frame_view.x_range;
        if (frame_range instanceof Range1d) {
          frame_range.start = binning[0];
          frame_range.end = binning[binning.length - 1];
        }
      }
    } else if (color_mapper instanceof ContinuousColorMapper && range2 instanceof Range1d) {
      const { min: min10, max: max18 } = this._continuous_metrics(color_mapper);
      range2.setv({ start: min10, end: max18 });
    }
    this._set_canvas_image();
    this.plot_view.request_layout();
  }
  _paint_colors(ctx, bbox) {
    const { x: x2, y: y2, width, height } = bbox;
    ctx.save();
    ctx.globalAlpha = this.model.scale_alpha;
    if (this._image != null) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(this._image, x2, y2, width, height);
    }
    if (this.visuals.bar_line.doit) {
      this.visuals.bar_line.set_value(ctx);
      ctx.strokeRect(x2, y2, width, height);
    }
    ctx.restore();
  }
  // Return binning array of ScanningColorMapper, modified to account for low
  // and high display cutoffs.
  _scanning_binning(color_mapper) {
    let { binning, force_low_cutoff } = color_mapper.metrics;
    const { display_high } = this.model;
    let { display_low } = this.model;
    if (force_low_cutoff && (display_low == null || color_mapper.metrics.min > display_low)) {
      display_low = color_mapper.metrics.min;
    }
    if (display_high != null && display_low != null && display_high < display_low) {
      this._index_low = 0;
      this._index_high = -1;
      return [NaN];
    }
    this._index_high = null;
    if (display_high != null) {
      const index_high = color_mapper.value_to_index(display_high, binning.length);
      if (index_high < binning.length - 1) {
        this._index_high = index_high;
      }
    }
    this._index_low = null;
    if (display_low != null) {
      const index_low = color_mapper.value_to_index(display_low, binning.length);
      if (index_low > 0) {
        this._index_low = index_low;
      }
    }
    if (this._index_low != null || this._index_high != null) {
      const start2 = this._index_low != null ? this._index_low : 0;
      const end = this._index_high != null ? this._index_high + 1 : binning.length - 1;
      const n2 = end - start2 + 1;
      if (n2 > 0) {
        const new_binning = new Array(n2);
        for (let i2 = 0; i2 < n2; i2++) {
          new_binning[i2] = binning[i2 + start2];
        }
        binning = new_binning;
      } else {
        binning = [NaN];
      }
    }
    return binning;
  }
  _set_canvas_image() {
    const { orientation } = this;
    let { palette } = this.color_mapper;
    if (this._index_high != null || this._index_low != null) {
      palette = palette.slice(this._index_low != null ? this._index_low : 0, this._index_high != null ? this._index_high + 1 : palette.length);
    }
    if (palette.length < 1) {
      this._image = null;
      return;
    }
    if (orientation == "vertical") {
      palette = reversed(palette);
    }
    const [w, h7] = (() => {
      if (orientation == "vertical") {
        return [1, palette.length];
      } else {
        return [palette.length, 1];
      }
    })();
    const canvas3 = this._image = document.createElement("canvas");
    canvas3.width = w;
    canvas3.height = h7;
    const image_ctx = canvas3.getContext("2d");
    const image_data = image_ctx.getImageData(0, 0, w, h7);
    const cmap = new LinearColorMapper({ palette }).rgba_mapper;
    const buf8 = cmap.v_compute(range(0, palette.length));
    image_data.data.set(buf8);
    image_ctx.putImageData(image_data, 0, 0);
  }
};
__publicField(ColorBarView, "__name__", "ColorBarView");
var _ColorBar = class _ColorBar extends BaseColorBar {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ColorBar, "__name__", "ColorBar");
_ColorBar.prototype.default_view = ColorBarView;
_ColorBar.define(({ Nullable: Nullable2, Float: Float2, Ref: Ref2 }) => ({
  color_mapper: [Ref2(ColorMapper)],
  display_low: [Nullable2(Float2), null],
  display_high: [Nullable2(Float2), null]
}));
var ColorBar = _ColorBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/contour_color_bar.js
var ContourColorBarView = class extends BaseColorBarView {
  constructor() {
    super(...arguments);
    __publicField(this, "_fill_view");
    __publicField(this, "_line_view");
  }
  *children() {
    yield* super.children();
    yield this._fill_view;
    yield this._line_view;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { fill_renderer, line_renderer } = this.model;
    this._fill_view = await build_view(fill_renderer, { parent: this.parent });
    this._line_view = await build_view(line_renderer, { parent: this.parent });
  }
  remove() {
    this._fill_view.remove();
    this._line_view.remove();
    super.remove();
  }
  _create_major_range() {
    const levels = this.model.levels;
    if (levels.length > 0) {
      return new Range1d({ start: levels[0], end: levels[levels.length - 1] });
    } else {
      return new Range1d({ start: 0, end: 1 });
    }
  }
  _paint_colors(ctx, bbox) {
    const vertical2 = this.orientation == "vertical";
    const levels = this.model.levels;
    const scale = this._major_scale;
    scale.source_range = this._major_range;
    if (vertical2) {
      scale.target_range = new Range1d({ start: bbox.bottom, end: bbox.top });
    } else {
      scale.target_range = new Range1d({ start: bbox.left, end: bbox.right });
    }
    const scaled_levels = scale.v_compute(levels);
    const multi_polygons = this._fill_view.glyph;
    const nfill = multi_polygons.data_size;
    if (nfill > 0) {
      assert(levels.length == nfill + 1, "Inconsistent number of filled contour levels");
      ctx.save();
      for (let i2 = 0; i2 < nfill; i2++) {
        ctx.beginPath();
        if (vertical2) {
          ctx.rect(bbox.left, scaled_levels[i2], bbox.width, scaled_levels[i2 + 1] - scaled_levels[i2]);
        } else {
          ctx.rect(scaled_levels[i2], bbox.top, scaled_levels[i2 + 1] - scaled_levels[i2], bbox.height);
        }
        multi_polygons.visuals.fill.apply(ctx, i2);
        multi_polygons.visuals.hatch.apply(ctx, i2);
      }
      ctx.restore();
    }
    const multi_line = this._line_view.glyph;
    const nline = multi_line.data_size;
    if (nline > 0) {
      assert(levels.length == nline, "Inconsistent number of line contour levels");
      ctx.save();
      for (let i2 = 0; i2 < nline; i2++) {
        ctx.beginPath();
        if (vertical2) {
          ctx.moveTo(bbox.left, scaled_levels[i2]);
          ctx.lineTo(bbox.right, scaled_levels[i2]);
        } else {
          ctx.moveTo(scaled_levels[i2], bbox.bottom);
          ctx.lineTo(scaled_levels[i2], bbox.top);
        }
        multi_line.visuals.line.set_vectorize(ctx, i2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
};
__publicField(ContourColorBarView, "__name__", "ContourColorBarView");
var _ContourColorBar = class _ContourColorBar extends BaseColorBar {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ContourColorBar, "__name__", "ContourColorBar");
_ContourColorBar.prototype.default_view = ContourColorBarView;
_ContourColorBar.define(({ List: List2, Float: Float2, Ref: Ref2 }) => ({
  fill_renderer: [Ref2(GlyphRenderer)],
  line_renderer: [Ref2(GlyphRenderer)],
  levels: [List2(Float2), []]
}));
var ContourColorBar = _ContourColorBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/label.js
function xy(x2, y2) {
  return { x: x2, y: y2 };
}
var LabelView = class extends TextAnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_pan_state", null);
  }
  get mappers() {
    function mapper(units, scale, view, canvas3) {
      switch (units) {
        case "canvas":
          return canvas3;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    }
    const overlay = this.model;
    const parent = this.layout ?? this.plot_view.frame;
    const { x_scale, y_scale } = this.coordinates;
    const { x_view, y_view } = parent.bbox;
    const { x_screen, y_screen } = this.plot_view.canvas.bbox;
    const xy2 = {
      x: mapper(overlay.x_units, x_scale, x_view, x_screen),
      y: mapper(overlay.y_units, y_scale, y_view, y_screen)
    };
    return xy2;
  }
  get anchor() {
    const { align, baseline } = this.visuals.text.values();
    return text_anchor(this.model.anchor, align, baseline);
  }
  get angle() {
    const { angle, angle_units, direction } = this.model;
    return compute_angle(angle, angle_units, direction);
  }
  get origin() {
    const { mappers } = this;
    const { x: x2, y: y2, x_offset, y_offset } = this.model;
    const compute = (dim, value2, mapper) => {
      return value2 instanceof Coordinate ? this.resolve_as_scalar(value2, dim) : mapper.compute(value2);
    };
    const sx = compute("x", x2, mappers.x) + x_offset;
    const sy = compute("y", y2, mappers.y) - y_offset;
    return { sx, sy };
  }
  interactive_hit(sx, sy) {
    if (!this.model.visible || !this.model.editable) {
      return false;
    }
    return this._hit_test(sx, sy) == "area";
  }
  _hit_test(cx, cy) {
    const { sx, sy, anchor: anchor2, angle, width, height } = this._rect;
    const { x: x2, y: y2 } = rotate_around(xy(cx, cy), xy(sx, sy), -angle);
    const left2 = sx - anchor2.x * width;
    const top = sy - anchor2.y * height;
    const right3 = left2 + width;
    const bottom = top + height;
    if (left2 <= x2 && x2 <= right3 && top <= y2 && y2 <= bottom) {
      return "area";
    } else {
      return null;
    }
  }
  _can_hit(_target) {
    return true;
  }
  on_pan_start(ev) {
    if (this.model.visible && this.model.editable) {
      const { sx, sy } = ev;
      const target = this._hit_test(sx, sy);
      if (target != null && this._can_hit(target)) {
        this._pan_state = {
          angle: this.angle,
          base: { sx, sy },
          target,
          action: "rotate"
        };
        this.model.pan.emit(["pan:start", ev.modifiers]);
        return true;
      }
    }
    return false;
  }
  on_pan(ev) {
    assert(this._pan_state != null);
    const { dx, dy } = ev;
    const { angle, base: base2 } = this._pan_state;
    const { origin } = this;
    const angle0 = atan2([origin.sx, origin.sy], [base2.sx, base2.sy]);
    const angle1 = atan2([origin.sx, origin.sy], [base2.sx + dx, base2.sy + dy]);
    const da = angle1 - angle0;
    const na = angle + da;
    const nna = na % (2 * Math.PI);
    const { angle_units, direction } = this.model;
    this.model.angle = invert_angle(nna, angle_units, direction);
    this.model.pan.emit(["pan", ev.modifiers]);
  }
  on_pan_end(ev) {
    this._pan_state = null;
    this.model.pan.emit(["pan:end", ev.modifiers]);
  }
  cursor(sx, sy) {
    var _a34;
    const target = ((_a34 = this._pan_state) == null ? void 0 : _a34.target) ?? this._hit_test(sx, sy);
    if (target == null || !this._can_hit(target)) {
      return null;
    }
    return "var(--bokeh-cursor-rotate)";
  }
};
__publicField(LabelView, "__name__", "LabelView");
var _Label = class _Label extends TextAnnotation {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "pan", new Signal(this, "pan"));
  }
};
__publicField(_Label, "__name__", "Label");
_Label.prototype.default_view = LabelView;
_Label.define(({ Bool: Bool2, Float: Float2, Angle, Or: Or2, Ref: Ref2 }) => ({
  anchor: [TextAnchor, "auto"],
  x: [Or2(Float2, Ref2(Coordinate))],
  y: [Or2(Float2, Ref2(Coordinate))],
  x_units: [CoordinateUnits, "data"],
  y_units: [CoordinateUnits, "data"],
  x_offset: [Float2, 0],
  y_offset: [Float2, 0],
  angle: [Angle, 0],
  angle_units: [AngleUnits, "rad"],
  direction: [Direction, "anticlock"],
  editable: [Bool2, false]
}));
var Label = _Label;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/label_set.js
var LabelSetView = class extends DataAnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_x");
    __publicField(this, "_y");
    __publicField(this, "sx");
    __publicField(this, "sy");
    __publicField(this, "text");
    __publicField(this, "angle");
    __publicField(this, "x_offset");
    __publicField(this, "y_offset");
  }
  map_data() {
    const { x_scale, y_scale } = this.coordinates;
    const panel = this.layout != null ? this.layout : this.plot_view.frame;
    this.sx = (() => {
      switch (this.model.x_units) {
        case "canvas":
          return new ScreenArray(this._x);
        case "screen":
          return panel.bbox.xview.v_compute(this._x);
        case "data":
          return x_scale.v_compute(this._x);
      }
    })();
    this.sy = (() => {
      switch (this.model.y_units) {
        case "canvas":
          return new ScreenArray(this._y);
        case "screen":
          return panel.bbox.yview.v_compute(this._y);
        case "data":
          return y_scale.v_compute(this._y);
      }
    })();
  }
  _paint_data() {
    const { ctx } = this.layer;
    for (let i2 = 0, end = this.text.length; i2 < end; i2++) {
      const x_offset_i = this.x_offset.get(i2);
      const y_offset_i = this.y_offset.get(i2);
      const sx_i = this.sx[i2] + x_offset_i;
      const sy_i = this.sy[i2] - y_offset_i;
      const angle_i = this.angle.get(i2);
      const text_i = this.text.get(i2);
      if (!isFinite(sx_i + sy_i + angle_i) || text_i == null) {
        continue;
      }
      this._paint_text(ctx, i2, `${text_i}`, sx_i, sy_i, angle_i);
    }
  }
  _paint_text(ctx, i2, text2, sx, sy, angle) {
    const graphics = new TextBox({ text: text2 });
    graphics.angle = angle;
    graphics.position = { sx, sy };
    graphics.visuals = this.visuals.text.values(i2);
    const { background_fill, border_line } = this.visuals;
    if (background_fill.doit || border_line.doit) {
      const { p0, p1, p2, p3 } = graphics.rect();
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      this.visuals.background_fill.apply(ctx, i2);
      this.visuals.border_line.apply(ctx, i2);
    }
    if (this.visuals.text.doit) {
      graphics.paint(ctx);
    }
  }
};
__publicField(LabelSetView, "__name__", "LabelSetView");
var _LabelSet = class _LabelSet extends DataAnnotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LabelSet, "__name__", "LabelSet");
_LabelSet.prototype.default_view = LabelSetView;
_LabelSet.mixins([
  TextVector,
  ["border_", LineVector],
  ["background_", FillVector]
]);
_LabelSet.define(() => ({
  x: [XCoordinateSpec, { field: "x" }],
  y: [YCoordinateSpec, { field: "y" }],
  x_units: [CoordinateUnits, "data"],
  y_units: [CoordinateUnits, "data"],
  text: [NullStringSpec, { field: "text" }],
  angle: [AngleSpec, 0],
  x_offset: [NumberSpec, { value: 0 }],
  y_offset: [NumberSpec, { value: 0 }]
}));
_LabelSet.override({
  background_fill_color: null,
  border_line_color: null
});
var LabelSet = _LabelSet;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/legend_item.js
var _LegendItem = class _LegendItem extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "legend");
  }
  /*protected*/
  _check_data_sources_on_renderers() {
    const field = this.get_field_from_label_prop();
    if (field != null) {
      if (this.renderers.length < 1) {
        return false;
      }
      const source2 = this.renderers[0].data_source;
      for (const r of this.renderers) {
        if (r.data_source != source2) {
          return false;
        }
      }
    }
    return true;
  }
  /*protected*/
  _check_field_label_on_data_source() {
    const field = this.get_field_from_label_prop();
    if (field != null) {
      if (this.renderers.length < 1) {
        return false;
      }
      const source2 = this.renderers[0].data_source;
      if (!includes(source2.columns(), field)) {
        return false;
      }
    }
    return true;
  }
  initialize() {
    super.initialize();
    this.legend = null;
    this.connect(this.change, () => {
      var _a34;
      return (_a34 = this.legend) == null ? void 0 : _a34.item_change.emit();
    });
    const data_source_validation = this._check_data_sources_on_renderers();
    if (!data_source_validation) {
      logger.error("Non matching data sources on legend item renderers");
    }
    const field_validation = this._check_field_label_on_data_source();
    if (!field_validation) {
      logger.error(`Bad column name on label: ${this.label}`);
    }
  }
  get_field_from_label_prop() {
    const { label: label3 } = this;
    return isField(label3) ? label3.field : null;
  }
  get_labels_list_from_label_prop() {
    if (!this.visible) {
      return [];
    }
    const { index: index2 } = this;
    if (index2 != null && this.renderers.every((r) => !r.view.indices_map.has(index2))) {
      return [];
    }
    if (isValue(this.label)) {
      const { value: value2 } = this.label;
      return value2 != null ? [value2] : [];
    }
    const field = this.get_field_from_label_prop();
    if (field != null) {
      let source2;
      if (this.renderers.length != 0) {
        source2 = this.renderers[0].data_source;
      } else {
        return ["No source found"];
      }
      if (source2 instanceof ColumnarDataSource) {
        const data3 = source2.get_column(field);
        if (data3 != null) {
          return uniq(Array.from(data3));
        } else {
          return ["Invalid field"];
        }
      }
    }
    return [];
  }
};
__publicField(_LegendItem, "__name__", "LegendItem");
_LegendItem.define(({ Bool: Bool2, Int: Int2, List: List2, Ref: Ref2, Nullable: Nullable2 }) => ({
  label: [NullStringSpec, null],
  renderers: [List2(Ref2(GlyphRenderer)), []],
  index: [Nullable2(Int2), null],
  visible: [Bool2, true]
}));
var LegendItem = _LegendItem;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/legend.js
var { max: max9, ceil: ceil2 } = Math;
var LegendEntry = class extends ContentLayoutable {
  constructor(item3, label3, text2, settings2) {
    super();
    __publicField(this, "item");
    __publicField(this, "label");
    __publicField(this, "text");
    __publicField(this, "settings");
    this.item = item3;
    this.label = label3;
    this.text = text2;
    this.settings = settings2;
  }
  get field() {
    return this.item.get_field_from_label_prop();
  }
  _content_size() {
    const text2 = this.text.size();
    const { glyph_width, glyph_height, label_standoff, label_width, label_height } = this.settings;
    const width = glyph_width + label_standoff + max9(text2.width, label_width);
    const height = max9(glyph_height, text2.height, label_height);
    return new Sizeable({ width, height });
  }
};
__publicField(LegendEntry, "__name__", "LegendEntry");
var LegendView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "grid");
    __publicField(this, "border_box");
    __publicField(this, "title_panel");
  }
  _get_size() {
    const { width, height } = this.bbox;
    const { margin } = this.model;
    return {
      width: width + 2 * margin,
      height: height + 2 * margin
    };
  }
  update_layout() {
    this.update_geometry();
    const { panel } = this;
    if (panel != null) {
      this.layout = new SideLayout(panel, () => this.get_size());
    } else {
      this.layout = void 0;
    }
  }
  connect_signals() {
    super.connect_signals();
    const repaint = () => this.request_paint();
    this.connect(this.model.change, repaint);
    this.connect(this.model.item_change, repaint);
  }
  get bbox() {
    return this._bbox;
  }
  get padding() {
    return this.model.border_line_color != null ? this.model.padding : 0;
  }
  update_geometry() {
    super.update_geometry();
    const { spacing, orientation } = this.model;
    const vertical2 = orientation == "vertical";
    const { padding: padding2 } = this;
    const left2 = padding2;
    const top = padding2;
    const { title: title3 } = this.model;
    const title_box = new TextBox({ text: title3 ?? "" });
    title_box.position = { sx: 0, sy: 0, x_anchor: "left", y_anchor: "top" };
    title_box.visuals = this.visuals.title_text.values();
    const _title_panel = new SidePanel(this.model.title_location);
    title_box.angle = _title_panel.get_label_angle_heuristic("parallel");
    const entries2 = [];
    for (const item3 of this.model.items) {
      item3.legend = this.model;
      const labels = item3.get_labels_list_from_label_prop();
      for (const label3 of labels) {
        const text_box = new TextBox({ text: `${label3}` });
        text_box.position = { sx: 0, sy: 0, x_anchor: "left", y_anchor: "center" };
        text_box.visuals = this.visuals.label_text.values();
        const layout = new LegendEntry(item3, label3, text_box, this.model);
        layout.set_sizing({ visible: item3.visible });
        entries2.push({ layout, row: 0, col: 0 });
      }
    }
    const { ncols, nrows } = (() => {
      let { ncols: ncols2, nrows: nrows2 } = this.model;
      const n2 = entries2.length;
      if (vertical2) {
        if (nrows2 != "auto") {
        } else if (ncols2 != "auto") {
          nrows2 = ceil2(n2 / ncols2);
        } else {
          nrows2 = Infinity;
        }
        ncols2 = Infinity;
      } else {
        if (ncols2 != "auto") {
        } else if (nrows2 != "auto") {
          ncols2 = ceil2(n2 / nrows2);
        } else {
          ncols2 = Infinity;
        }
        nrows2 = Infinity;
      }
      return { ncols: ncols2, nrows: nrows2 };
    })();
    let row2 = 0;
    let col2 = 0;
    for (const entry2 of entries2) {
      entry2.row = row2;
      entry2.col = col2;
      if (vertical2) {
        row2 += 1;
        if (row2 >= nrows) {
          row2 = 0;
          col2 += 1;
        }
      } else {
        col2 += 1;
        if (col2 >= ncols) {
          col2 = 0;
          row2 += 1;
        }
      }
    }
    const grid = new Grid(entries2);
    this.grid = grid;
    grid.spacing = spacing;
    grid.set_sizing();
    const title_panel = new TextLayout(title_box);
    this.title_panel = title_panel;
    const title_visible = title_box.text != "" && this.visuals.title_text.doit;
    title_panel.set_sizing({ visible: title_visible });
    const border_box = (() => {
      if (!title_visible) {
        return new Column([grid]);
      }
      switch (this.model.title_location) {
        case "above":
          return new Column([title_panel, grid]);
        case "below":
          return new Column([grid, title_panel]);
        case "left":
          return new Row([title_panel, grid]);
        case "right":
          return new Row([grid, title_panel]);
      }
    })();
    this.border_box = border_box;
    border_box.position = { left: left2, top };
    border_box.spacing = this.model.title_standoff;
    border_box.set_sizing();
    border_box.compute();
    const width = padding2 + border_box.bbox.width + padding2;
    const height = padding2 + border_box.bbox.height + padding2;
    this._bbox = new BBox({ left: 0, top: 0, width, height });
  }
  compute_geometry() {
    super.compute_geometry();
    const { margin, location } = this.model;
    const { width, height } = this.bbox;
    const panel = this.layout != null ? this.layout : this.plot_view.frame;
    const [hr2, vr] = panel.bbox.ranges;
    let sx, sy;
    if (isString(location)) {
      switch (location) {
        case "top_left":
          sx = hr2.start + margin;
          sy = vr.start + margin;
          break;
        case "top":
        case "top_center":
          sx = (hr2.end + hr2.start) / 2 - width / 2;
          sy = vr.start + margin;
          break;
        case "top_right":
          sx = hr2.end - margin - width;
          sy = vr.start + margin;
          break;
        case "bottom_right":
          sx = hr2.end - margin - width;
          sy = vr.end - margin - height;
          break;
        case "bottom":
        case "bottom_center":
          sx = (hr2.end + hr2.start) / 2 - width / 2;
          sy = vr.end - margin - height;
          break;
        case "bottom_left":
          sx = hr2.start + margin;
          sy = vr.end - margin - height;
          break;
        case "left":
        case "center_left":
          sx = hr2.start + margin;
          sy = (vr.end + vr.start) / 2 - height / 2;
          break;
        case "center":
        case "center_center":
          sx = (hr2.end + hr2.start) / 2 - width / 2;
          sy = (vr.end + vr.start) / 2 - height / 2;
          break;
        case "right":
        case "center_right":
          sx = hr2.end - margin - width;
          sy = (vr.end + vr.start) / 2 - height / 2;
          break;
      }
    } else {
      const [vx, vy] = location;
      sx = panel.bbox.xview.compute(vx);
      sy = panel.bbox.yview.compute(vy) - height;
    }
    this._bbox = new BBox({ left: sx, top: sy, width, height });
  }
  interactive_hit(sx, sy) {
    return this.bbox.contains(sx, sy);
  }
  _hit_test(sx, sy) {
    const { left: left2, top } = this.bbox;
    sx -= left2 + this.grid.bbox.left;
    sy -= top + this.grid.bbox.top;
    for (const entry2 of this.grid) {
      if (entry2.bbox.contains(sx, sy)) {
        return { type: "entry", entry: entry2 };
      }
    }
    return null;
  }
  cursor(sx, sy) {
    if (this.model.click_policy == "none" && !dict(this.model.js_event_callbacks).has("legend_item_click")) {
      return null;
    }
    if (this._hit_test(sx, sy) != null) {
      return "pointer";
    }
    return null;
  }
  on_hit(sx, sy) {
    const fn = (() => {
      switch (this.model.click_policy) {
        case "hide":
          return (r) => r.visible = !r.visible;
        case "mute":
          return (r) => r.muted = !r.muted;
        case "none":
          return (_2) => {
          };
      }
    })();
    const target = this._hit_test(sx, sy);
    if (target != null) {
      const { item: item3 } = target.entry;
      this.model.trigger_event(new LegendItemClick(this.model, item3));
      for (const renderer of item3.renderers) {
        fn(renderer);
      }
      return true;
    }
    return false;
  }
  _paint() {
    if (this.model.items.length == 0) {
      return;
    }
    if (!some(this.model.items, (item3) => item3.visible)) {
      return;
    }
    const { ctx } = this.layer;
    ctx.save();
    this._draw_legend_box(ctx);
    this._draw_legend_items(ctx);
    this._draw_title(ctx);
    ctx.restore();
  }
  _draw_legend_box(ctx) {
    const { x: x2, y: y2, width, height } = this.bbox;
    ctx.beginPath();
    ctx.rect(x2, y2, width, height);
    this.visuals.background_fill.apply(ctx);
    this.visuals.border_line.apply(ctx);
  }
  _draw_title(ctx) {
    const { title: title3 } = this.model;
    if (title3 == null || title3.length == 0 || !this.visuals.title_text.doit) {
      return;
    }
    const { left: left2, top } = this.bbox;
    ctx.save();
    ctx.translate(left2, top);
    ctx.translate(this.title_panel.bbox.left, this.title_panel.bbox.top);
    switch (this.model.title_location) {
      case "left": {
        ctx.translate(0, this.title_panel.bbox.height);
        break;
      }
      case "right": {
        ctx.translate(this.title_panel.bbox.width, 0);
        break;
      }
      case "above":
      case "below": {
        break;
      }
    }
    this.title_panel.text.paint(ctx);
    ctx.restore();
  }
  _draw_legend_items(ctx) {
    const is_active = (() => {
      switch (this.model.click_policy) {
        case "none":
          return (_item) => true;
        case "hide":
          return (item3) => every(item3.renderers, (r) => r.visible);
        case "mute":
          return (item3) => every(item3.renderers, (r) => !r.muted);
      }
    })();
    const has_item_background = (_i, row2, col2) => {
      if (!this.visuals.item_background_fill.doit) {
        return false;
      }
      switch (this.model.item_background_policy) {
        case "every":
          return true;
        case "even":
          return row2 % 2 == 0 == (col2 % 2 == 0);
        case "odd":
          return row2 % 2 == 0 != (col2 % 2 == 0);
        case "none":
          return false;
      }
    };
    const { left: left2, top } = this.bbox;
    ctx.translate(left2, top);
    ctx.translate(this.grid.bbox.left, this.grid.bbox.top);
    for (const [{ layout: entry2, row: row2, col: col2 }, i2] of enumerate(this.grid.items)) {
      const { bbox, text: text2, item: item3, label: label3, field, settings: settings2 } = entry2;
      const { glyph_width, glyph_height, label_standoff } = settings2;
      const { left: left3, top: top2, width, height } = bbox;
      ctx.translate(left3, top2);
      if (has_item_background(i2, row2, col2)) {
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        this.visuals.item_background_fill.apply(ctx);
      }
      const vcenter = height / 2;
      const x0 = 0;
      const y0 = vcenter - glyph_height / 2;
      const x1 = x0 + glyph_width;
      const y1 = y0 + glyph_height;
      for (const renderer of item3.renderers) {
        const view = this.plot_view.views.find_one(renderer);
        view == null ? void 0 : view.draw_legend(ctx, x0, x1, y0, y1, field, label3, item3.index);
      }
      ctx.translate(x1 + label_standoff, vcenter);
      text2.paint(ctx);
      ctx.translate(-x1 - label_standoff, -vcenter);
      if (!is_active(item3)) {
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        this.visuals.inactive_fill.set_value(ctx);
        ctx.fill();
      }
      ctx.translate(-left3, -top2);
    }
    ctx.translate(-this.grid.bbox.left, -this.grid.bbox.top);
    ctx.translate(-left2, -top);
  }
};
__publicField(LegendView, "__name__", "LegendView");
var _Legend = class _Legend extends Annotation {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "item_change");
  }
  initialize() {
    super.initialize();
    this.item_change = new Signal0(this, "item_change");
  }
};
__publicField(_Legend, "__name__", "Legend");
_Legend.prototype.default_view = LegendView;
_Legend.mixins([
  ["label_", Text],
  ["title_", Text],
  ["inactive_", Fill],
  ["border_", Line],
  ["background_", Fill],
  ["item_background_", Fill]
]);
_Legend.define(({ Float: Float2, Int: Int2, Str: Str2, List: List2, Tuple: Tuple2, Or: Or2, Ref: Ref2, Nullable: Nullable2, Positive, Auto: Auto2 }) => ({
  orientation: [Orientation, "vertical"],
  ncols: [Or2(Positive(Int2), Auto2), "auto"],
  nrows: [Or2(Positive(Int2), Auto2), "auto"],
  location: [Or2(LegendLocation, Tuple2(Float2, Float2)), "top_right"],
  title: [Nullable2(Str2), null],
  title_location: [Location, "above"],
  title_standoff: [Float2, 5],
  label_standoff: [Float2, 5],
  glyph_height: [Float2, 20],
  glyph_width: [Float2, 20],
  label_height: [Float2, 20],
  label_width: [Float2, 20],
  margin: [Float2, 10],
  padding: [Float2, 10],
  spacing: [Float2, 3],
  items: [List2(Ref2(LegendItem)), []],
  click_policy: [LegendClickPolicy, "none"],
  item_background_policy: [AlternationPolicy, "none"]
}));
_Legend.override({
  border_line_color: "#e5e5e5",
  border_line_alpha: 0.5,
  border_line_width: 1,
  background_fill_color: "#ffffff",
  background_fill_alpha: 0.95,
  item_background_fill_color: "#f1f1f1",
  item_background_fill_alpha: 0.8,
  inactive_fill_color: "white",
  inactive_fill_alpha: 0.7,
  label_text_font_size: "13px",
  label_text_baseline: "middle",
  title_text_font_size: "13px",
  title_text_font_style: "italic"
});
var Legend = _Legend;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/poly_annotation.js
var _Polygon = class _Polygon {
  constructor(xs = [], ys = []) {
    __publicField(this, "xs");
    __publicField(this, "ys");
    this.xs = xs;
    this.ys = ys;
    assert(xs.length == ys.length);
  }
  clone() {
    return new _Polygon(this.xs.slice(), this.ys.slice());
  }
  [Symbol.iterator]() {
    return this.nodes();
  }
  *nodes() {
    const { xs, ys, n: n2 } = this;
    for (let i2 = 0; i2 < n2; i2++) {
      yield [xs[i2], ys[i2], i2];
    }
  }
  *edges() {
    const { xs, ys, n: n2 } = this;
    for (let i2 = 1; i2 < n2; i2++) {
      const p0 = { x: xs[i2 - 1], y: ys[i2 - 1] };
      const p1 = { x: xs[i2], y: ys[i2] };
      yield [p0, p1, i2 - 1];
    }
    if (n2 >= 3) {
      const p0 = { x: xs[n2 - 1], y: ys[n2 - 1] };
      const p1 = { x: xs[0], y: ys[0] };
      yield [p0, p1, n2 - 1];
    }
  }
  contains(x2, y2) {
    return point_in_poly(x2, y2, this.xs, this.ys);
  }
  get bbox() {
    const [x0, x1, y0, y1] = minmax2(this.xs, this.ys);
    return new BBox({ x0, x1, y0, y1 });
  }
  get n() {
    return this.xs.length;
  }
  translate(dx, dy, ...i2) {
    const poly = this.clone();
    const { xs, ys, n: n2 } = poly;
    if (i2.length != 0) {
      for (const j of i2) {
        const k = j % n2;
        xs[k] += dx;
        ys[k] += dy;
      }
    } else {
      for (let i3 = 0; i3 < n2; i3++) {
        xs[i3] += dx;
        ys[i3] += dy;
      }
    }
    return poly;
  }
};
__publicField(_Polygon, "__name__", "Polygon");
var Polygon = _Polygon;
var _a32, _b3;
var PolyAnnotationView = class extends (_b3 = AnnotationView, _a32 = auto_ranged, _b3) {
  constructor() {
    super(...arguments);
    __publicField(this, "poly", new Polygon());
    __publicField(this, _a32, true);
    __publicField(this, "_pan_state", null);
    __publicField(this, "_is_hovered", false);
  }
  get bbox() {
    return this.poly.bbox;
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.request_paint());
  }
  bounds() {
    const { xs_units, ys_units } = this.model;
    if (xs_units == "data" && ys_units == "data") {
      const { xs, ys } = this.model;
      const [x0, x1, y0, y1] = minmax2(xs, ys);
      return { x0, x1, y0, y1 };
    } else {
      return empty();
    }
  }
  log_bounds() {
    return empty();
  }
  _mappers() {
    const mapper = (units, scale, view, canvas4) => {
      switch (units) {
        case "canvas":
          return canvas4;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    };
    const overlay = this.model;
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = frame;
    const { x_view, y_view } = frame.bbox;
    const { x_screen, y_screen } = canvas3.bbox;
    return {
      x: mapper(overlay.xs_units, x_scale, x_view, x_screen),
      y: mapper(overlay.ys_units, y_scale, y_view, y_screen)
    };
  }
  _paint() {
    const { xs, ys } = this.model;
    assert(xs.length == ys.length);
    this.poly = (() => {
      const { x: x2, y: y2 } = this._mappers();
      return new Polygon(x2.v_compute(xs), y2.v_compute(ys));
    })();
    const { ctx } = this.layer;
    ctx.beginPath();
    for (const [sx, sy] of this.poly) {
      ctx.lineTo(sx, sy);
    }
    const { _is_hovered, visuals } = this;
    const fill = _is_hovered && visuals.hover_fill.doit ? visuals.hover_fill : visuals.fill;
    const hatch = _is_hovered && visuals.hover_hatch.doit ? visuals.hover_hatch : visuals.hatch;
    const line = _is_hovered && visuals.hover_line.doit ? visuals.hover_line : visuals.line;
    if (this.poly.n >= 3) {
      ctx.closePath();
      fill.apply(ctx);
      hatch.apply(ctx);
    }
    line.apply(ctx);
  }
  interactive_hit(sx, sy) {
    if (!this.model.visible || !this.model.editable) {
      return false;
    }
    return this.poly.contains(sx, sy);
  }
  _hit_test(sx, sy) {
    const { abs: abs11 } = Math;
    const EDGE_TOLERANCE3 = 2.5;
    const tolerance = Math.max(EDGE_TOLERANCE3, this.model.line_width / 2);
    for (const [px2, py, i2] of this.poly) {
      if (abs11(px2 - sx) < tolerance && abs11(py - sy) < tolerance) {
        return { type: "node", i: i2 };
      }
    }
    const spt = { x: sx, y: sy };
    let j = null;
    let dist = Infinity;
    for (const [p0, p1, i2] of this.poly.edges()) {
      const d = dist_to_segment(spt, p0, p1);
      if (d < tolerance && d < dist) {
        dist = d;
        j = i2;
      }
    }
    if (j != null) {
      return { type: "edge", i: j };
    }
    if (this.poly.contains(sx, sy)) {
      return { type: "area" };
    }
    return null;
  }
  _can_hit(_target) {
    return true;
  }
  on_pan_start(ev) {
    if (this.model.visible && this.model.editable) {
      const { sx, sy } = ev;
      const target = this._hit_test(sx, sy);
      if (target != null && this._can_hit(target)) {
        this._pan_state = {
          poly: this.poly.clone(),
          target
        };
        this.model.pan.emit(["pan:start", ev.modifiers]);
        return true;
      }
    }
    return false;
  }
  on_pan(ev) {
    assert(this._pan_state != null);
    const spoly = (() => {
      const { poly, target } = this._pan_state;
      const { dx, dy } = ev;
      switch (target.type) {
        case "node": {
          const { i: i2 } = target;
          return poly.translate(dx, dy, i2);
        }
        case "edge": {
          const { i: i2 } = target;
          return poly.translate(dx, dy, i2, i2 + 1);
        }
        case "area": {
          return poly.translate(dx, dy);
        }
      }
    })();
    const { x: x2, y: y2 } = this._mappers();
    const xs = x2.v_invert(spoly.xs);
    const ys = y2.v_invert(spoly.ys);
    this.model.update({ xs, ys });
    this.model.pan.emit(["pan", ev.modifiers]);
  }
  on_pan_end(ev) {
    this._pan_state = null;
    this.model.pan.emit(["pan:end", ev.modifiers]);
  }
  get _has_hover() {
    const { hover_line, hover_fill, hover_hatch } = this.visuals;
    return hover_line.doit || hover_fill.doit || hover_hatch.doit;
  }
  on_enter(_ev) {
    const { _has_hover } = this;
    if (_has_hover) {
      this._is_hovered = true;
      this.request_paint();
    }
    return _has_hover;
  }
  on_move(_ev) {
  }
  on_leave(_ev) {
    if (this._has_hover) {
      this._is_hovered = false;
      this.request_paint();
    }
  }
  cursor(sx, sy) {
    var _a34;
    const target = ((_a34 = this._pan_state) == null ? void 0 : _a34.target) ?? this._hit_test(sx, sy);
    if (target == null || !this._can_hit(target)) {
      return null;
    }
    switch (target.type) {
      case "node":
        return "move";
      case "edge":
        return "move";
      case "area":
        return "move";
    }
  }
};
__publicField(PolyAnnotationView, "__name__", "PolyAnnotationView");
var _PolyAnnotation = class _PolyAnnotation extends Annotation {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "pan", new Signal(this, "pan"));
  }
  update({ xs, ys }) {
    this.setv({ xs: xs.slice(), ys: ys.slice(), visible: true });
  }
  clear() {
    this.setv({ xs: [], ys: [], visible: false });
  }
};
__publicField(_PolyAnnotation, "__name__", "PolyAnnotation");
_PolyAnnotation.prototype.default_view = PolyAnnotationView;
_PolyAnnotation.mixins([
  Line,
  Fill,
  Hatch,
  ["hover_", Line],
  ["hover_", Fill],
  ["hover_", Hatch]
]);
_PolyAnnotation.define(({ Bool: Bool2, Float: Float2, Arrayable: Arrayable2 }) => ({
  xs: [Arrayable2(Float2), []],
  ys: [Arrayable2(Float2), []],
  xs_units: [CoordinateUnits, "data"],
  ys_units: [CoordinateUnits, "data"],
  editable: [Bool2, false]
}));
_PolyAnnotation.override({
  fill_color: "#fff9ba",
  fill_alpha: 0.4,
  line_color: "#cccccc",
  line_alpha: 0.3,
  hover_fill_color: null,
  hover_fill_alpha: 0.4,
  hover_line_color: null,
  hover_line_alpha: 0.3
});
var PolyAnnotation = _PolyAnnotation;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/dimensional.js
var { min: min6 } = Math;
var _Dimensional = class _Dimensional extends Model {
  constructor(attrs) {
    super(attrs);
  }
  compute(value2, unit, exact) {
    const basis = (() => {
      const { include, exclude } = this;
      const basis2 = entries(this.get_basis()).map(([name, [factor, tex_name, long_name]]) => ({ name, factor, tex_name, long_name })).filter(({ name }) => (include == null || include.includes(name)) && !exclude.includes(name));
      return sort_by(basis2, ({ factor }) => factor);
    })();
    const { ticks } = this;
    const found_unit = basis.find(({ name }) => name == unit);
    assert(found_unit != null);
    const value_in_unit = value2 * found_unit.factor;
    const [new_unit, new_value] = (() => {
      const index2 = bisect_right_by(basis, value_in_unit, ({ factor }) => factor);
      if (index2 > 0) {
        const { name: new_unit2, factor } = basis[index2 - 1];
        const new_value2 = value_in_unit / factor;
        return [new_unit2, new_value2];
      } else {
        return [unit, value_in_unit];
      }
    })();
    exact = exact ?? ticks.length == 0;
    const preferred_value = (() => {
      if (exact) {
        return new_value;
      } else {
        const index2 = bisect_right(ticks, new_value);
        return ticks[min6(index2, ticks.length - 1)];
      }
    })();
    const preferred_value_raw = preferred_value * (value_in_unit / new_value);
    const scale_factor = preferred_value_raw / value2 / found_unit.factor;
    return {
      new_value: preferred_value,
      new_unit,
      scale_factor,
      exact
    };
  }
};
__publicField(_Dimensional, "__name__", "Dimensional");
_Dimensional.define(({ Nullable: Nullable2, List: List2, Str: Str2, Float: Float2 }) => ({
  ticks: [List2(Float2)],
  include: [Nullable2(List2(Str2)), null],
  exclude: [List2(Str2), []]
}));
var Dimensional = _Dimensional;
var _CustomDimensional = class _CustomDimensional extends Dimensional {
  constructor(attrs) {
    super(attrs);
  }
  get_basis() {
    return this.basis;
  }
};
__publicField(_CustomDimensional, "__name__", "CustomDimensional");
_CustomDimensional.define(({ Dict: Dict2, Tuple: Tuple2, Float: Float2, Str: Str2, Or: Or2 }) => ({
  basis: [Dict2(Or2(Tuple2(Float2, Str2), Tuple2(Float2, Str2, Str2)))]
}));
var CustomDimensional = _CustomDimensional;
var _Metric = class _Metric extends Dimensional {
  constructor(attrs) {
    super(attrs);
  }
  get_basis() {
    const { base_unit, full_unit } = this;
    const basis = {};
    for (const [prefix, factor, tex_prefix, long_prefix] of _Metric._metric_basis) {
      const name = `${prefix}${base_unit}`;
      const tex_name = `${tex_prefix}${base_unit}`;
      const long_name = full_unit != null ? `${long_prefix}${full_unit}` : void 0;
      basis[name] = [factor, tex_name, long_name];
    }
    return basis;
  }
};
__publicField(_Metric, "__name__", "Metric");
_Metric.define(({ Str: Str2, Nullable: Nullable2 }) => ({
  base_unit: [Str2],
  full_unit: [Nullable2(Str2), null]
}));
_Metric.override({
  ticks: [1, 2, 5, 10, 15, 20, 25, 50, 75, 100, 125, 150, 200, 250, 500, 750]
});
__publicField(_Metric, "_metric_basis", [
  ["Q", 1e30, "Q", "quetta"],
  ["R", 1e27, "R", "ronna"],
  ["Y", 1e24, "Y", "yotta"],
  ["Z", 1e21, "Z", "zetta"],
  ["E", 1e18, "E", "exa"],
  ["P", 1e15, "P", "peta"],
  ["T", 1e12, "T", "tera"],
  ["G", 1e9, "G", "giga"],
  ["M", 1e6, "M", "mega"],
  ["k", 1e3, "k", "kilo"],
  ["h", 100, "h", "hecto"],
  ["", 1, "", ""],
  ["d", 0.1, "d", "deci"],
  ["c", 0.01, "c", "centi"],
  ["m", 1e-3, "m", "milli"],
  ["µ", 1e-6, "\\mu", "micro"],
  ["n", 1e-9, "n", "nano"],
  ["p", 1e-12, "p", "pico"],
  ["f", 1e-15, "f", "femto"],
  ["a", 1e-18, "a", "atto"],
  ["z", 1e-21, "z", "zepto"],
  ["y", 1e-24, "y", "yocto"],
  ["r", 1e-27, "r", "ronto"],
  ["q", 1e-30, "q", "quecto"]
]);
var Metric = _Metric;
var ReciprocalMetric = class extends Metric {
  constructor(attrs) {
    super(attrs);
  }
  get_basis() {
    const basis = super.get_basis();
    const reciprocal_basis = {};
    for (const [name, [factor, tex_name]] of entries(basis)) {
      reciprocal_basis[`${name}⁻1`] = [factor ** -1, `${tex_name}^{-1}`];
    }
    return reciprocal_basis;
  }
};
__publicField(ReciprocalMetric, "__name__", "ReciprocalMetric");
var _MetricLength = class _MetricLength extends Metric {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MetricLength, "__name__", "MetricLength");
_MetricLength.override({
  base_unit: "m",
  exclude: ["dm", "hm"]
});
var MetricLength = _MetricLength;
var _ReciprocalMetricLength = class _ReciprocalMetricLength extends ReciprocalMetric {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ReciprocalMetricLength, "__name__", "ReciprocalMetricLength");
_ReciprocalMetricLength.override({
  base_unit: "m",
  exclude: ["dm", "hm"]
});
var ReciprocalMetricLength = _ReciprocalMetricLength;
var _ImperialLength = class _ImperialLength extends CustomDimensional {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ImperialLength, "__name__", "ImperialLength");
_ImperialLength.override({
  basis: {
    in: [1 / 12, "in", "inch"],
    ft: [1, "ft", "foot"],
    yd: [3, "yd", "yard"],
    ch: [66, "ch", "chain"],
    fur: [660, "fur", "furlong"],
    mi: [5280, "mi", "mile"],
    lea: [15840, "lea", "league"]
  },
  ticks: [1, 3, 6, 12, 60]
});
var ImperialLength = _ImperialLength;
var _Angular = class _Angular extends CustomDimensional {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Angular, "__name__", "Angular");
_Angular.override({
  basis: {
    "°": [1, "^\\circ", "degree"],
    "'": [1 / 60, "^\\prime", "minute"],
    "''": [1 / 3600, "^{\\prime\\prime}", "second"]
  },
  ticks: [1, 3, 6, 12, 60, 120, 240, 360]
});
var Angular = _Angular;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/scale_bar.js
var { round: round7 } = Math;
var Position = Or(Anchor, Tuple(Or(Float, Factor, HAlign), Or(Float, Factor, VAlign)));
var PositionUnits = Enum("data", "screen", "view", "percent");
var LengthUnits = Enum("screen", "data", "percent");
var LengthSizing = Enum("adaptive", "exact");
var ScaleBarView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_bbox", new BBox());
    __publicField(this, "label_layout");
    __publicField(this, "title_layout");
    __publicField(this, "axis_layout");
    __publicField(this, "box_layout");
    __publicField(this, "axis");
    __publicField(this, "axis_view");
    __publicField(this, "axis_scale");
    __publicField(this, "cross_scale");
    __publicField(this, "range");
  }
  get bbox() {
    return this._bbox;
  }
  _get_size() {
    const { width, height } = this.bbox;
    const { margin } = this.model;
    return {
      width: width + 2 * margin,
      height: height + 2 * margin
    };
  }
  initialize() {
    super.initialize();
    const { ticker } = this.model;
    this.axis = new LinearAxis({
      ticker,
      ...attrs_of(this.model, "bar_", Line, "axis_")
    });
    this.range = (() => {
      const { range: range2, orientation } = this.model;
      if (range2 == "auto") {
        const { frame } = this.parent;
        switch (orientation) {
          case "horizontal":
            return frame.x_range;
          case "vertical":
            return frame.y_range;
        }
      } else {
        return range2;
      }
    })();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const coordinates = (() => {
      const axis_source = new Range1d();
      const axis_target = new Range1d();
      const cross_source = new Range1d();
      const cross_target = new Range1d();
      this.axis_scale = new LinearScale({ source_range: axis_source, target_range: axis_target });
      this.cross_scale = new LinearScale({ source_range: cross_source, target_range: cross_target });
      if (this.model.orientation == "horizontal") {
        return new CoordinateTransform(this.axis_scale, this.cross_scale);
      } else {
        return new CoordinateTransform(this.cross_scale, this.axis_scale);
      }
    })();
    this.axis_view = await build_view(this.axis, { parent: this.plot_view });
    this.axis_view.coordinates = coordinates;
    this.axis_view.panel = new SidePanel(this.model.orientation == "horizontal" ? "below" : "right");
    this.axis_view.update_layout();
  }
  remove() {
    this.axis_view.remove();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => {
      this.request_paint();
    });
    this.connect(this.range.change, () => {
      this.request_paint();
    });
  }
  update_layout() {
    this.update_geometry();
    const { panel } = this;
    if (panel != null) {
      this.layout = new SideLayout(panel, () => this.get_size());
    } else {
      this.layout = void 0;
    }
  }
  update_geometry() {
    super.update_geometry();
  }
  get horizontal() {
    return this.model.orientation == "horizontal";
  }
  text_layout(args) {
    const { text: text2, location, align, visuals } = args;
    const { orientation } = this.model;
    const text_box = new TextBox({ text: text2 });
    const text_panel = new SidePanel(location);
    text_box.visuals = visuals.values();
    const text_orientation = (() => {
      switch (location) {
        case "above":
        case "below":
          return "horizontal";
        default:
          return orientation;
      }
    })();
    text_box.angle = text_panel.get_label_angle_heuristic(text_orientation);
    text_box.base_font_size = this.plot_view.base_font_size;
    text_box.position = {
      sx: 0,
      sy: 0,
      x_anchor: "left",
      y_anchor: "top"
    };
    text_box.align = "auto";
    const text_layout = new TextLayout(text_box);
    text_layout.absolute = true;
    const horizontal2 = orientation == "horizontal";
    const halign = horizontal2 ? align : void 0;
    const valign = !horizontal2 ? align : void 0;
    text_layout.set_sizing({
      width_policy: "min",
      height_policy: "min",
      visible: text2 != "" && visuals.doit,
      halign,
      valign
    });
    return text_layout;
  }
  compute_geometry() {
    super.compute_geometry();
    const { orientation, length_sizing, padding: padding2, margin } = this.model;
    const { border_line, bar_line } = this.visuals;
    const bar_width = bar_line.line_width.get_value();
    const border_width = border_line.line_width.get_value();
    const { frame } = this.parent;
    const frame_span = orientation == "horizontal" ? frame.bbox.width : frame.bbox.height;
    const bar_length_percent = (() => {
      const { bar_length, bar_length_units } = this.model;
      switch (bar_length_units) {
        case "screen": {
          if (0 <= bar_length && bar_length <= 1) {
            return bar_length;
          } else {
            return clamp(bar_length / frame_span, 0, 1);
          }
        }
        case "data": {
          const scale = orientation == "horizontal" ? this.coordinates.x_scale : this.coordinates.y_scale;
          assert(scale instanceof LinearScale || scale instanceof CategoricalScale);
          const [sv0, sv1] = scale.r_compute(0, bar_length);
          const sdist = Math.abs(sv1 - sv0);
          return sdist / frame_span;
        }
        case "percent": {
          return clamp(bar_length, 0, 1);
        }
      }
    })();
    const { new_value, new_unit, scale_factor, exact } = (() => {
      const { unit, dimensional } = this.model;
      const value2 = this.range.span * bar_length_percent;
      return dimensional.compute(value2, unit, length_sizing == "exact");
    })();
    const init_bar_length_px = frame_span * bar_length_percent;
    const bar_length_px = round7(init_bar_length_px * scale_factor);
    const label_text = (() => {
      const { label: label3 } = this.model;
      return process_placeholders(label3, (_2, name, format7) => {
        switch (name) {
          case "value": {
            if (exact) {
              if (format7 != null) {
                return sprintf(format7, new_value);
              } else {
                return new_value.toFixed(2);
              }
            } else {
              return `${new_value}`;
            }
          }
          case "unit": {
            switch (format7 ?? "short") {
              case "short":
                return new_unit;
            }
          }
          default: {
            return null;
          }
        }
      });
    })();
    this.label_layout = this.text_layout({
      text: label_text,
      location: this.model.label_location,
      align: this.model.label_align,
      visuals: this.visuals.label_text
    });
    this.title_layout = this.text_layout({
      text: this.model.title,
      location: this.model.title_location,
      align: this.model.title_align,
      visuals: this.visuals.title_text
    });
    const bar_size = (() => {
      if (orientation == "horizontal") {
        return { width: bar_length_px, height: bar_width };
      } else {
        return { width: bar_width, height: bar_length_px };
      }
    })();
    const axis_layout = this.axis_view.layout;
    assert(axis_layout != null);
    this.axis_layout = axis_layout;
    axis_layout.absolute = true;
    if (orientation == "horizontal") {
      axis_layout.set_sizing({
        width_policy: "fixed",
        width: bar_size.width,
        height_policy: "min",
        valign: "center"
      });
    } else {
      axis_layout.set_sizing({
        width_policy: "min",
        height_policy: "fixed",
        height: bar_size.height,
        halign: "center"
      });
    }
    this.box_layout = (() => {
      const panels = {
        above: [],
        below: [],
        left: [],
        right: []
      };
      function spacer(location, spacing) {
        const layout = new FixedLayout();
        layout.absolute = true;
        layout.set_sizing((() => {
          if (location == "left" || location == "right") {
            return { width_policy: "fixed", width: spacing };
          } else {
            return { height_policy: "fixed", height: spacing };
          }
        })());
        return layout;
      }
      function insert(layout, location, spacing) {
        if (layout.visible) {
          panels[location].push(spacer(location, spacing), layout);
        }
      }
      insert(this.label_layout, this.model.label_location, this.model.label_standoff);
      insert(this.title_layout, this.model.title_location, this.model.title_standoff);
      const row2 = panels.above.length;
      const col2 = panels.left.length;
      const items = [
        { layout: axis_layout, row: row2, col: col2 }
      ];
      for (const [layout, i2] of enumerate(panels.above)) {
        items.push({ layout, row: row2 - i2 - 1, col: col2 });
      }
      for (const [layout, i2] of enumerate(panels.below)) {
        items.push({ layout, row: row2 + i2 + 1, col: col2 });
      }
      for (const [layout, i2] of enumerate(panels.left)) {
        items.push({ layout, row: row2, col: col2 - i2 - 1 });
      }
      for (const [layout, i2] of enumerate(panels.right)) {
        items.push({ layout, row: row2, col: col2 + i2 + 1 });
      }
      return new Grid(items);
    })();
    const { box_layout } = this;
    box_layout.absolute = true;
    box_layout.position = { left: padding2, top: padding2 };
    box_layout.set_sizing();
    box_layout.compute();
    const [axis_range, cross_range] = (() => {
      const { x_range, y_range } = this.axis_view.bbox;
      if (orientation == "horizontal") {
        return [x_range, y_range];
      } else {
        return [y_range, x_range];
      }
    })();
    this.axis_scale.source_range.end = new_value;
    this.axis_scale.target_range.setv(axis_range);
    this.cross_scale.source_range.end = 1;
    this.cross_scale.target_range.setv(cross_range);
    const position2 = (() => {
      const { location: position3 } = this.model;
      if (isString(position3)) {
        const normalized = (() => {
          switch (position3) {
            case "top":
              return "top_center";
            case "bottom":
              return "bottom_center";
            case "left":
              return "center_left";
            case "center":
              return "center_center";
            case "right":
              return "center_right";
            default:
              return position3;
          }
        })();
        const [v_loc, h_loc] = normalized.split("_");
        return { x: h_loc, y: v_loc };
      } else {
        const [x_loc, y_loc] = position3;
        return { x: x_loc, y: y_loc };
      }
    })();
    const { x: x2, y: y2 } = (() => {
      const { bbox } = this.layout ?? this.plot_view.frame;
      const inset = bbox.shrink_by(margin);
      const x_pos = (() => {
        const { x: x3 } = position2;
        switch (x3) {
          case "left":
            return inset.left;
          case "center":
            return inset.x_center;
          case "right":
            return inset.right;
        }
        const x_mapper = (() => {
          switch (this.model.x_units) {
            case "data":
              return this.coordinates.x_scale;
            case "screen":
              return bbox.x_screen;
            case "view":
              return bbox.x_view;
            case "percent":
              return bbox.x_percent;
          }
        })();
        return x_mapper.compute(
          // @ts-ignore(TS2345): Argument of type 'number | ...' is not assignable to parameter of type 'number'.
          x3
        );
      })();
      const y_pos = (() => {
        const { y: y3 } = position2;
        switch (y3) {
          case "top":
            return inset.top;
          case "center":
            return inset.y_center;
          case "bottom":
            return inset.bottom;
        }
        const y_mapper = (() => {
          switch (this.model.y_units) {
            case "data":
              return this.coordinates.y_scale;
            case "screen":
              return bbox.y_screen;
            case "view":
              return bbox.y_view;
            case "percent":
              return bbox.y_percent;
          }
        })();
        return y_mapper.compute(
          // @ts-ignore(TS2345): Argument of type 'number | ...' is not assignable to parameter of type 'number'.
          y3
        );
      })();
      return { x: x_pos, y: y_pos };
    })();
    const anchor2 = (() => {
      const anchor3 = anchor(this.model.anchor);
      const x_anchor = (() => {
        if (anchor3.x == "auto") {
          switch (position2.x) {
            case "left":
              return 0;
            case "center":
              return 0.5;
            case "right":
              return 1;
            default:
              return 0.5;
          }
        } else {
          return anchor3.x;
        }
      })();
      const y_anchor = (() => {
        if (anchor3.y == "auto") {
          switch (position2.y) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            case "bottom":
              return 1;
            default:
              return 0.5;
          }
        } else {
          return anchor3.y;
        }
      })();
      return { x: x_anchor, y: y_anchor };
    })();
    const width = border_width + padding2 + box_layout.bbox.width + padding2 + border_width;
    const height = border_width + padding2 + box_layout.bbox.height + padding2 + border_width;
    const sx = x2 - anchor2.x * width;
    const sy = y2 - anchor2.y * height;
    this._bbox = new BBox({ left: sx, top: sy, width, height });
  }
  _draw_box(ctx) {
    const { width, height } = this.bbox;
    ctx.beginPath();
    ctx.rect(0, 0, width, height);
    this.visuals.background_fill.apply(ctx);
    this.visuals.background_hatch.apply(ctx);
    this.visuals.border_line.apply(ctx);
  }
  _draw_axis(_ctx) {
    this.axis_view.paint();
  }
  _draw_text(ctx, layout, location) {
    const { bbox } = layout;
    const [x_offset, y_offset] = (() => {
      const { orientation } = this.model;
      const horizontal2 = orientation == "horizontal";
      switch (location) {
        case "left":
          return horizontal2 ? [0, 0] : [0, bbox.height];
        case "right":
          return horizontal2 ? [0, 0] : [bbox.width, 0];
        case "above":
          return [0, 0];
        case "below":
          return [0, 0];
      }
    })();
    const { left: left2, top } = bbox.translate(x_offset, y_offset);
    ctx.translate(left2, top);
    layout.text.paint(ctx);
    ctx.translate(-left2, -top);
  }
  _draw_label(ctx) {
    this._draw_text(ctx, this.label_layout, this.model.label_location);
  }
  _draw_title(ctx) {
    this._draw_text(ctx, this.title_layout, this.model.title_location);
  }
  _paint() {
    const { ctx } = this.layer;
    const { left: left2, top } = this.bbox;
    ctx.translate(left2, top);
    if (this.box_layout.visible) {
      this._draw_box(ctx);
    }
    if (this.axis_layout.visible) {
      this._draw_axis(ctx);
    }
    if (this.label_layout.visible) {
      this._draw_label(ctx);
    }
    if (this.title_layout.visible) {
      this._draw_title(ctx);
    }
    ctx.translate(-left2, -top);
  }
};
__publicField(ScaleBarView, "__name__", "ScaleBarView");
var _ScaleBar = class _ScaleBar extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ScaleBar, "__name__", "ScaleBar");
_ScaleBar.prototype.default_view = ScaleBarView;
_ScaleBar.mixins([
  ["background_", Fill],
  ["background_", Hatch],
  ["bar_", Line],
  ["border_", Line],
  ["label_", Text],
  ["title_", Text]
]);
_ScaleBar.define(({ NonNegative: NonNegative2, Float: Float2, Str: Str2, Ref: Ref2, Or: Or2, Auto: Auto2 }) => ({
  anchor: [AutoAnchor, "auto"],
  bar_length: [NonNegative2(Float2), 0.2],
  bar_length_units: [LengthUnits, "screen"],
  dimensional: [Ref2(Dimensional), () => new MetricLength()],
  label: [Str2, "@{value} @{unit}"],
  label_align: [Align, "center"],
  label_location: [Location, "below"],
  label_standoff: [Float2, 5],
  length_sizing: [LengthSizing, "adaptive"],
  location: [Position, "top_right"],
  margin: [Float2, 10],
  orientation: [Orientation, "horizontal"],
  padding: [Float2, 10],
  range: [Or2(Ref2(Range), Auto2), "auto"],
  ticker: [Ref2(Ticker), () => new FixedTicker({ ticks: [] })],
  title: [Str2, ""],
  title_align: [Align, "center"],
  title_location: [Location, "above"],
  title_standoff: [Float2, 5],
  unit: [Str2, "m"],
  x_units: [PositionUnits, "data"],
  y_units: [PositionUnits, "data"]
}));
_ScaleBar.override({
  background_fill_alpha: 0.95,
  background_fill_color: "#ffffff",
  bar_line_width: 2,
  border_line_alpha: 0.5,
  border_line_color: "#e5e5e5",
  border_line_width: 1,
  label_text_baseline: "middle",
  label_text_font_size: "13px",
  title_text_font_size: "13px",
  title_text_font_style: "italic"
});
var ScaleBar = _ScaleBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/slope.js
var SlopeView = class extends AnnotationView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.request_paint());
  }
  _paint() {
    const { gradient, y_intercept } = this.model;
    if (gradient == null || y_intercept == null) {
      return;
    }
    const { frame } = this.plot_view;
    const xscale = this.coordinates.x_scale;
    const yscale = this.coordinates.y_scale;
    const [sx0, sx1, sy0, sy1] = (() => {
      if (gradient == 0) {
        const sy_start = yscale.compute(y_intercept);
        const sy_end = sy_start;
        const sx_start = frame.bbox.left;
        const sx_end = frame.bbox.right;
        return [sx_start, sx_end, sy_start, sy_end];
      } else {
        const sy_start = frame.bbox.top;
        const sy_end = frame.bbox.bottom;
        const y_start = yscale.invert(sy_start);
        const y_end = yscale.invert(sy_end);
        const x_start = (y_start - y_intercept) / gradient;
        const x_end = (y_end - y_intercept) / gradient;
        const sx_start = xscale.compute(x_start);
        const sx_end = xscale.compute(x_end);
        if (sx_start <= sx_end) {
          return [sx_start, sx_end, sy_start, sy_end];
        } else {
          return [sx_end, sx_start, sy_end, sy_start];
        }
      }
    })();
    const { ctx } = this.layer;
    ctx.save();
    if (this.visuals.above_fill.doit || this.visuals.above_hatch.doit) {
      const { left: left2, right: right3, top, bottom } = frame.bbox;
      ctx.beginPath();
      ctx.moveTo(sx0, sy0);
      ctx.lineTo(sx0, sy0);
      ctx.lineTo(sx1, sy1);
      ctx.lineTo(sx1, sy1);
      if (sy0 <= sy1) {
        if (sx1 < right3) {
          ctx.lineTo(right3, bottom);
        }
        ctx.lineTo(right3, top);
        ctx.lineTo(left2, top);
      } else {
        ctx.lineTo(right3, top);
        ctx.lineTo(left2, top);
        if (sx0 > left2) {
          ctx.lineTo(left2, bottom);
        }
      }
      ctx.closePath();
      this.visuals.above_fill.apply(ctx);
      this.visuals.above_hatch.apply(ctx);
    }
    if (this.visuals.below_fill.doit || this.visuals.below_hatch.doit) {
      const { left: left2, right: right3, top, bottom } = frame.bbox;
      ctx.beginPath();
      ctx.moveTo(sx0, sy0);
      ctx.lineTo(sx0, sy0);
      ctx.lineTo(sx1, sy1);
      if (sy0 <= sy1) {
        ctx.lineTo(right3, bottom);
        ctx.lineTo(left2, bottom);
        if (sx0 > left2) {
          ctx.lineTo(left2, top);
        }
      } else {
        if (sx1 < right3) {
          ctx.lineTo(right3, top);
        }
        ctx.lineTo(right3, bottom);
        ctx.lineTo(left2, bottom);
      }
      ctx.closePath();
      this.visuals.below_fill.apply(ctx);
      this.visuals.below_hatch.apply(ctx);
    }
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(sx1, sy1);
    this.visuals.line.apply(ctx);
    ctx.restore();
  }
};
__publicField(SlopeView, "__name__", "SlopeView");
var _Slope = class _Slope extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Slope, "__name__", "Slope");
_Slope.prototype.default_view = SlopeView;
_Slope.mixins([
  Line,
  ["above_", Fill],
  ["above_", Hatch],
  ["below_", Fill],
  ["below_", Hatch]
]);
_Slope.define(({ Float: Float2, Nullable: Nullable2 }) => ({
  gradient: [Nullable2(Float2), null],
  y_intercept: [Nullable2(Float2), null]
}));
_Slope.override({
  line_color: "black",
  above_fill_color: null,
  above_fill_alpha: 0.4,
  below_fill_color: null,
  below_fill_alpha: 0.4
});
var Slope = _Slope;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/span.js
var EDGE_TOLERANCE2 = 2.5;
var _Line2 = class _Line2 {
  constructor(p0, p1) {
    __publicField(this, "p0");
    __publicField(this, "p1");
    this.p0 = p0;
    this.p1 = p1;
  }
  clone() {
    return new _Line2({ ...this.p0 }, { ...this.p1 });
  }
  hit_test(pt, tolerance = EDGE_TOLERANCE2) {
    return dist_to_segment(pt, this.p0, this.p1) < tolerance;
  }
  translate(dx, dy) {
    const { p0, p1 } = this;
    const dp0 = { x: p0.x + dx, y: p0.y + dy };
    const dp1 = { x: p1.x + dx, y: p1.y + dy };
    return new _Line2(dp0, dp1);
  }
};
__publicField(_Line2, "__name__", "Line");
var Line4 = _Line2;
var SpanView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "line");
    __publicField(this, "_pan_state", null);
    __publicField(this, "_is_hovered", false);
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.plot_view.request_paint(this));
  }
  _paint() {
    const { location, location_units } = this.model;
    if (location == null) {
      return;
    }
    function compute(value2, units, scale, view, canvas4) {
      switch (units) {
        case "canvas":
          return canvas4.compute(value2);
        case "screen":
          return view.compute(value2);
        case "data":
          return scale.compute(value2);
      }
    }
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = this.coordinates;
    let height, sleft, stop, width;
    if (this.model.dimension == "width") {
      stop = compute(location, location_units, y_scale, frame.bbox.yview, canvas3.bbox.y_screen);
      sleft = frame.bbox.left;
      width = frame.bbox.width;
      height = this.model.line_width;
    } else {
      stop = frame.bbox.top;
      sleft = compute(location, location_units, x_scale, frame.bbox.xview, canvas3.bbox.y_screen);
      width = this.model.line_width;
      height = frame.bbox.height;
    }
    const p0 = { x: sleft, y: stop };
    const p1 = { x: sleft + width, y: stop + height };
    this.line = new Line4(p0, p1);
    const { _is_hovered, visuals } = this;
    const line = _is_hovered && visuals.hover_line.doit ? visuals.hover_line : visuals.line;
    const { ctx } = this.layer;
    ctx.save();
    ctx.beginPath();
    this.visuals.line.set_value(ctx);
    ctx.moveTo(sleft, stop);
    if (this.model.dimension == "width") {
      ctx.lineTo(sleft + width, stop);
    } else {
      ctx.lineTo(sleft, stop + height);
    }
    line.apply(ctx);
    ctx.restore();
  }
  interactive_hit(sx, sy) {
    if (!this.model.visible || !this.model.editable) {
      return false;
    }
    return this._hit_test(sx, sy) != null;
  }
  _hit_test(sx, sy) {
    const tolerance = Math.max(EDGE_TOLERANCE2, this.model.line_width / 2);
    return this.line.hit_test({ x: sx, y: sy }, tolerance) ? "edge" : null;
  }
  _can_hit(_target) {
    return true;
  }
  on_pan_start(ev) {
    if (this.model.visible && this.model.editable) {
      const { sx, sy } = ev;
      const target = this._hit_test(sx, sy);
      if (target != null && this._can_hit(target)) {
        this._pan_state = {
          line: this.line.clone(),
          target
        };
        this.model.pan.emit(["pan:start", ev.modifiers]);
        return true;
      }
    }
    return false;
  }
  on_pan(ev) {
    assert(this._pan_state != null);
    function invert(sv, units, scale, view, canvas3) {
      switch (units) {
        case "canvas":
          return canvas3.invert(sv);
        case "screen":
          return view.invert(sv);
        case "data":
          return scale.invert(sv);
      }
    }
    const sloc = (() => {
      const { dx, dy } = ev;
      const { line } = this._pan_state;
      if (this.model.dimension == "width") {
        return line.translate(0, dy).p0.y;
      } else {
        return line.translate(dx, 0).p0.x;
      }
    })();
    const loc = (() => {
      const { location_units } = this.model;
      const { frame, canvas: canvas3 } = this.plot_view;
      const { x_scale, y_scale } = this.coordinates;
      if (this.model.dimension == "width") {
        return invert(sloc, location_units, y_scale, frame.bbox.yview, canvas3.bbox.y_screen);
      } else {
        return invert(sloc, location_units, x_scale, frame.bbox.xview, canvas3.bbox.y_screen);
      }
    })();
    this.model.location = loc;
    this.model.pan.emit(["pan", ev.modifiers]);
  }
  on_pan_end(ev) {
    this._pan_state = null;
    this.model.pan.emit(["pan:end", ev.modifiers]);
  }
  get _has_hover() {
    const { hover_line } = this.visuals;
    return hover_line.doit;
  }
  on_enter(_ev) {
    const { _has_hover } = this;
    if (_has_hover) {
      this._is_hovered = true;
      this.request_paint();
    }
    return _has_hover;
  }
  on_move(_ev) {
  }
  on_leave(_ev) {
    if (this._has_hover) {
      this._is_hovered = false;
      this.request_paint();
    }
  }
  cursor(sx, sy) {
    var _a34;
    const target = ((_a34 = this._pan_state) == null ? void 0 : _a34.target) ?? this._hit_test(sx, sy);
    if (target == null || !this._can_hit(target)) {
      return null;
    }
    return this.model.dimension == "width" ? "ns-resize" : "ew-resize";
  }
};
__publicField(SpanView, "__name__", "SpanView");
var _Span = class _Span extends Annotation {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "pan", new Signal(this, "pan"));
  }
};
__publicField(_Span, "__name__", "Span");
_Span.prototype.default_view = SpanView;
_Span.mixins([
  Line,
  ["hover_", Line]
]);
_Span.define(({ Bool: Bool2, Float: Float2, Nullable: Nullable2 }) => ({
  location: [Nullable2(Float2), null],
  location_units: [CoordinateUnits, "data"],
  dimension: [Dimension, "width"],
  editable: [Bool2, false]
}));
_Span.override({
  line_color: "black",
  hover_line_color: null,
  hover_line_alpha: 0.3
});
var Span2 = _Span;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/tool.js
var ToolView = class extends View {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.active.change, () => {
      if (this.model.active) {
        this.activate();
      } else {
        this.deactivate();
      }
    });
  }
  get overlays() {
    return [];
  }
  // activate is triggered by toolbar ui actions
  activate() {
  }
  // deactivate is triggered by toolbar ui actions
  deactivate() {
  }
};
__publicField(ToolView, "__name__", "ToolView");
var _Tool = class _Tool extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name");
    __publicField(this, "tool_icon");
    // GestureTool {{{
    __publicField(this, "event_type");
    // }}}
    __publicField(this, "button_view");
    /** @prototype */
    __publicField(this, "_known_aliases");
  }
  get event_role() {
    const { event_type } = this;
    return isString(event_type) ? event_type : "multi";
  }
  get event_types() {
    const { event_type } = this;
    return event_type == null ? [] : isString(event_type) ? [event_type] : event_type;
  }
  get tooltip() {
    return this.description ?? this.tool_name;
  }
  get computed_icon() {
    const { icon: icon3, tool_icon: tool_icon2 } = this;
    return icon3 ?? (tool_icon2 != null ? `.${tool_icon2}` : void 0);
  }
  get menu() {
    return null;
  }
  supports_auto() {
    return false;
  }
  // utility function to get limits along both dimensions, given
  // optional dimensional constraints
  _get_dim_limits([sx0, sy0], [sx1, sy1], frame, dims) {
    const hr2 = frame.bbox.h_range;
    let sxlim;
    if (dims == "width" || dims == "both") {
      sxlim = [min([sx0, sx1]), max([sx0, sx1])];
      sxlim = [max([sxlim[0], hr2.start]), min([sxlim[1], hr2.end])];
    } else {
      sxlim = [hr2.start, hr2.end];
    }
    const vr = frame.bbox.v_range;
    let sylim;
    if (dims == "height" || dims == "both") {
      sylim = [min([sy0, sy1]), max([sy0, sy1])];
      sylim = [max([sylim[0], vr.start]), min([sylim[1], vr.end])];
    } else {
      sylim = [vr.start, vr.end];
    }
    return [sxlim, sylim];
  }
  // utility function to return a tool name, modified
  // by the active dimensions. Used by tools that have dimensions
  _get_dim_tooltip(dims) {
    const { description: description2, tool_name } = this;
    if (description2 != null) {
      return description2;
    } else if (dims == "both") {
      return tool_name;
    } else if (dims == "auto") {
      return `${tool_name} (either x, y or both dimensions)`;
    } else {
      return `${tool_name} (${dims == "width" ? "x" : "y"}-axis)`;
    }
  }
  static register_alias(name, fn) {
    this.prototype._known_aliases.set(name, fn);
  }
  static from_string(name) {
    const fn = this.prototype._known_aliases.get(name);
    if (fn != null) {
      return fn();
    } else {
      const names4 = [...this.prototype._known_aliases.keys()];
      throw new Error(`unexpected tool name '${name}', possible tools are ${names4.join(", ")}`);
    }
  }
};
__publicField(_Tool, "__name__", "Tool");
_Tool.prototype._known_aliases = /* @__PURE__ */ new Map();
_Tool.define(({ Bool: Bool2, Str: Str2, Regex: Regex2, Nullable: Nullable2, Or: Or2 }) => ({
  icon: [Nullable2(Or2(ToolIcon, Regex2(/^--/), Regex2(/^\./), Regex2(/^data:image/))), null],
  description: [Nullable2(Str2), null],
  visible: [Bool2, true]
}));
_Tool.internal(({ Bool: Bool2 }) => ({
  active: [Bool2, false],
  disabled: [Bool2, false]
}));
var Tool = _Tool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/tool_proxy.js
var _ToolProxy = class _ToolProxy extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "do");
  }
  // Operates all the tools given only one button
  get underlying() {
    return this.tools[0];
  }
  tool_button() {
    const button2 = this.tools[0].tool_button();
    button2.tool = this;
    return button2;
  }
  get event_type() {
    return this.tools[0].event_type;
  }
  get event_role() {
    return this.tools[0].event_role;
  }
  get event_types() {
    return this.tools[0].event_types;
  }
  get default_order() {
    return this.tools[0].default_order;
  }
  get tooltip() {
    return this.tools[0].tooltip;
  }
  get tool_name() {
    return this.tools[0].tool_name;
  }
  get computed_icon() {
    return this.tools[0].computed_icon;
  }
  get toggleable() {
    const tool = this.tools[0];
    return "toggleable" in tool && tool.toggleable;
  }
  get visible() {
    const tool = this.tools[0];
    return tool.visible;
  }
  initialize() {
    super.initialize();
    this.do = new Signal0(this, "do");
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.do, () => this.doit());
    this.connect(this.properties.active.change, () => this.set_active());
    for (const tool of this.tools) {
      this.connect(tool.properties.active.change, () => {
        this.active = tool.active;
      });
    }
  }
  doit() {
    for (const tool of this.tools) {
      tool.do.emit();
    }
  }
  set_active() {
    for (const tool of this.tools) {
      tool.active = this.active;
    }
  }
  get menu() {
    const { menu: menu5 } = this.tools[0];
    if (menu5 == null) {
      return null;
    }
    const items = [];
    for (const [item3, i2] of enumerate(menu5)) {
      if (item3 == null) {
        items.push(null);
      } else {
        const handler = () => {
          var _a34, _b4, _c;
          for (const tool of this.tools) {
            (_c = (_b4 = (_a34 = tool.menu) == null ? void 0 : _a34[i2]) == null ? void 0 : _b4.handler) == null ? void 0 : _c.call(_b4);
          }
        };
        items.push({ ...item3, handler });
      }
    }
    return items;
  }
  supports_auto() {
    return this.tools[0].supports_auto();
  }
};
__publicField(_ToolProxy, "__name__", "ToolProxy");
_ToolProxy.define(({ Bool: Bool2, List: List2, Ref: Ref2 }) => ({
  tools: [List2(Ref2(Tool)), []],
  active: [Bool2, (self2) => some2(self2.tools, (tool) => tool.active)],
  disabled: [Bool2, false]
}));
var ToolProxy = _ToolProxy;

// node_modules/@bokeh/bokehjs/build/js/lib/core/ui_gestures.js
var _UIGestures = class _UIGestures {
  constructor(hit_area, handlers, options2 = {}) {
    __publicField(this, "hit_area");
    __publicField(this, "handlers");
    __publicField(this, "must_be_target");
    __publicField(this, "phase", "idle");
    __publicField(this, "pointers", /* @__PURE__ */ new Map());
    __publicField(this, "press_timer", null);
    __publicField(this, "tap_timestamp", -Infinity);
    __publicField(this, "last_scale", null);
    __publicField(this, "last_rotation", null);
    this.hit_area = hit_area;
    this.handlers = handlers;
    this.must_be_target = options2.must_be_target ?? false;
    this._pointer_over = this._pointer_over.bind(this);
    this._pointer_out = this._pointer_out.bind(this);
    this._pointer_down = this._pointer_down.bind(this);
    this._pointer_move = this._pointer_move.bind(this);
    this._pointer_up = this._pointer_up.bind(this);
    this._pointer_cancel = this._pointer_cancel.bind(this);
  }
  connect_signals() {
    this.hit_area.addEventListener("pointerover", this._pointer_over);
    this.hit_area.addEventListener("pointerout", this._pointer_out);
    this.hit_area.addEventListener("pointerdown", this._pointer_down);
    this.hit_area.addEventListener("pointermove", this._pointer_move);
    this.hit_area.addEventListener("pointerup", this._pointer_up);
    this.hit_area.addEventListener("pointercancel", this._pointer_cancel);
  }
  disconnect_signals() {
    this.hit_area.removeEventListener("pointerover", this._pointer_over);
    this.hit_area.removeEventListener("pointerout", this._pointer_out);
    this.hit_area.removeEventListener("pointerdown", this._pointer_down);
    this.hit_area.removeEventListener("pointermove", this._pointer_move);
    this.hit_area.removeEventListener("pointerup", this._pointer_up);
    this.hit_area.removeEventListener("pointercancel", this._pointer_cancel);
  }
  remove() {
    this.disconnect_signals();
  }
  _self_is_target(event2) {
    return event2.composedPath()[0] == this.hit_area;
  }
  _is_event_target(event2) {
    return !this.must_be_target || this._self_is_target(event2);
  }
  reset() {
    this._cancel_timeout();
    this.phase = "idle";
    this.pointers.clear();
    this.press_timer = null;
    this.tap_timestamp = -Infinity;
    this.last_scale = null;
    this.last_rotation = null;
  }
  /*rad*/
  get _is_multi_gesture() {
    return this.pointers.size >= 2;
  }
  _within_threshold(ptr) {
    const { dx, dy } = this._movement(ptr);
    return dx ** 2 + dy ** 2 <= _UIGestures.move_threshold ** 2;
  }
  get _any_movement() {
    return [...this.pointers.values()].some((ptr) => !this._within_threshold(ptr));
  }
  _start_timeout() {
    assert(this.press_timer == null);
    this.press_timer = setTimeout(() => this._pointer_timeout(), _UIGestures.press_threshold);
  }
  _cancel_timeout() {
    const { press_timer } = this;
    if (press_timer != null) {
      clearTimeout(press_timer);
      this.press_timer = null;
    }
  }
  _pointer_timeout() {
    assert(this.phase == "started");
    assert(!this._is_multi_gesture);
    this.phase = "pressing";
    this.press_timer = null;
    const [pointer] = this.pointers.values();
    this.on_press(pointer.init);
  }
  _pointer_over(event2) {
    if (!this._is_event_target(event2)) {
      return;
    }
    if (event2.isPrimary) {
      this.on_enter(event2);
    }
  }
  _pointer_out(event2) {
    if (!this._is_event_target(event2)) {
      return;
    }
    if (event2.isPrimary) {
      this.on_leave(event2);
    }
  }
  _pointer_down(event2) {
    if (!this._is_event_target(event2)) {
      return;
    }
    if (this._is_multi_gesture) {
      return;
    }
    if (this.pointers.has(event2.pointerId)) {
      return;
    }
    if (event2.isPrimary && event2.pointerType == "mouse" && event2.buttons != MouseButton.Left) {
      return;
    }
    if (!this.hit_area.isConnected) {
      return;
    }
    this.pointers.set(event2.pointerId, { init: event2, last: event2 });
    this.hit_area.setPointerCapture(event2.pointerId);
    switch (this.phase) {
      case "idle": {
        this.phase = "started";
        this._start_timeout();
        break;
      }
      case "started": {
        this._cancel_timeout();
        break;
      }
      case "pressing":
      case "panning":
      case "pinching":
      case "rotating":
      case "transitional":
        break;
    }
  }
  _pointer_move(event2) {
    if (!this._is_event_target(event2)) {
      return;
    }
    if (event2.isPrimary) {
      this.on_move(event2);
    }
    const pointer = this.pointers.get(event2.pointerId);
    if (pointer == null) {
      return;
    }
    pointer.last = event2;
    switch (this.phase) {
      case "idle": {
        this.reset();
        unreachable();
      }
      case "started":
      case "transitional": {
        if (!this._any_movement) {
          return;
        }
        this._cancel_timeout();
        if (!this._is_multi_gesture) {
          this.phase = "panning";
          const [ptr] = this.pointers.values();
          const { dx, dy } = this._movement(ptr);
          this.on_pan_start(ptr.init, 0, 0);
          this.on_pan(ptr.last, dx, dy);
        } else {
          const [ptr0, ptr1] = this.pointers.values();
          const scale = this._scale(ptr0, ptr1);
          const rotation = this._rotation(ptr0, ptr1);
          if (Math.abs(scale - 1) > _UIGestures.pinch_threshold) {
            this.phase = "pinching";
            this.on_pinch_start(ptr0.init, ptr1.init, 1);
            this.on_pinch(ptr0.last, ptr1.last, scale);
            this.last_scale = scale;
          } else if (Math.abs(rotation) > _UIGestures.rotate_threshold) {
            this.phase = "rotating";
            this.on_rotate_start(ptr0.init, ptr1.init, 0);
            this.on_rotate(ptr1.last, ptr1.last, rotation);
            this.last_rotation = rotation;
          }
        }
        break;
      }
      case "pressing": {
        break;
      }
      case "panning": {
        const [ptr] = this.pointers.values();
        const { dx, dy } = this._movement(ptr);
        this.on_pan(event2, dx, dy);
        break;
      }
      case "pinching": {
        const [ptr0, ptr1] = this.pointers.values();
        const scale = this._scale(ptr0, ptr1);
        if (scale != this.last_scale) {
          this.on_pinch(ptr0.last, ptr1.last, scale);
          this.last_scale = scale;
        }
        break;
      }
      case "rotating": {
        const [ptr0, ptr1] = this.pointers.values();
        const rotation = this._rotation(ptr0, ptr1);
        if (rotation != this.last_rotation) {
          this.on_rotate(ptr0.last, ptr1.last, rotation);
          this.last_rotation = rotation;
        }
        break;
      }
    }
  }
  _pointer_up(event2) {
    if (!this._is_event_target(event2)) {
      return;
    }
    const pointer = this.pointers.get(event2.pointerId);
    if (pointer == null) {
      return;
    }
    pointer.last = event2;
    this._cancel_timeout();
    switch (this.phase) {
      case "idle": {
        this.reset();
        unreachable();
      }
      case "started": {
        const [ptr] = this.pointers.values();
        const { tap_timestamp } = this;
        if (ptr.last.timeStamp - tap_timestamp < _UIGestures.doubletap_threshold) {
          this.tap_timestamp = -Infinity;
          this.on_doubletap(ptr.last);
        } else {
          this.tap_timestamp = ptr.last.timeStamp;
          this.on_tap(ptr.last);
        }
        this.phase = "idle";
        break;
      }
      case "transitional": {
        this.phase = "idle";
        break;
      }
      case "pressing": {
        const [ptr] = this.pointers.values();
        this.on_pressup(ptr.last);
        this.phase = "idle";
        break;
      }
      case "panning": {
        const [ptr] = this.pointers.values();
        const { dx, dy } = this._movement(ptr);
        this.on_pan_end(event2, dx, dy);
        this.phase = "idle";
        break;
      }
      case "pinching": {
        const [ptr0, ptr1] = this.pointers.values();
        const scale = this._scale(ptr0, ptr1);
        this.on_pinch_end(ptr0.last, ptr1.last, scale);
        this.phase = "transitional";
        this.last_scale = null;
        break;
      }
      case "rotating": {
        const [ptr0, ptr1] = this.pointers.values();
        const rotation = this._rotation(ptr0, ptr1);
        this.on_rotate_end(ptr0.last, ptr1.last, rotation);
        this.phase = "transitional";
        this.last_rotation = null;
        break;
      }
    }
    this.pointers.delete(event2.pointerId);
    if (this.phase == "transitional") {
      const [ptr] = this.pointers.values();
      ptr.init = ptr.last;
    }
  }
  _pointer_cancel(event2) {
    if (!this.pointers.has(event2.pointerId)) {
      return;
    }
    this._cancel_timeout();
    switch (this.phase) {
      case "idle": {
        this.reset();
        unreachable();
      }
      case "started":
      case "pressing":
      case "transitional": {
        this.phase = "idle";
        break;
      }
      case "panning": {
        const [ptr] = this.pointers.values();
        const { dx, dy } = this._movement(ptr);
        this.on_pan_end(event2, dx, dy);
        this.phase = "idle";
        break;
      }
      case "pinching": {
        const [ptr0, ptr1] = this.pointers.values();
        const scale = this._scale(ptr0, ptr1);
        this.on_pinch_end(ptr0.last, ptr1.last, scale);
        this.phase = "transitional";
        this.last_scale = null;
        break;
      }
      case "rotating": {
        const [ptr0, ptr1] = this.pointers.values();
        const rotation = this._rotation(ptr0, ptr1);
        this.on_rotate_end(ptr0.last, ptr1.last, rotation);
        this.phase = "transitional";
        this.last_rotation = null;
        break;
      }
    }
    this.pointers.delete(event2.pointerId);
    if (this.phase == "transitional") {
      const [ptr] = this.pointers.values();
      ptr.init = ptr.last;
    }
  }
  on_tap(ev) {
    const { on_tap } = this.handlers;
    if (on_tap != null) {
      on_tap(this._tap_event("tap", ev));
    }
  }
  on_doubletap(ev) {
    const { on_doubletap } = this.handlers;
    if (on_doubletap != null) {
      on_doubletap(this._tap_event("double_tap", ev));
    }
  }
  on_press(ev) {
    const { on_press } = this.handlers;
    if (on_press != null) {
      on_press(this._tap_event("press", ev));
    }
  }
  on_pressup(ev) {
    const { on_pressup } = this.handlers;
    if (on_pressup != null) {
      on_pressup(this._tap_event("press_up", ev));
    }
  }
  on_enter(ev) {
    const { on_enter } = this.handlers;
    if (on_enter != null) {
      on_enter(this._move_event("enter", ev));
    }
  }
  on_move(ev) {
    const { on_move } = this.handlers;
    if (on_move != null) {
      on_move(this._move_event("move", ev));
    }
  }
  on_leave(ev) {
    const { on_leave } = this.handlers;
    if (on_leave != null) {
      on_leave(this._move_event("leave", ev));
    }
  }
  on_pan_start(ev, dx, dy) {
    const { on_pan_start } = this.handlers;
    if (on_pan_start != null) {
      on_pan_start(this._pan_event("pan_start", ev, dx, dy));
    }
  }
  on_pan(ev, dx, dy) {
    const { on_pan } = this.handlers;
    if (on_pan != null) {
      on_pan(this._pan_event("pan", ev, dx, dy));
    }
  }
  on_pan_end(ev, dx, dy) {
    const { on_pan_end } = this.handlers;
    if (on_pan_end != null) {
      on_pan_end(this._pan_event("pan_end", ev, dx, dy));
    }
  }
  on_pinch_start(ev0, ev1, scale) {
    const { on_pinch_start } = this.handlers;
    if (on_pinch_start != null) {
      on_pinch_start(this._pinch_event("pinch_start", ev0, ev1, scale));
    }
  }
  on_pinch(ev0, ev1, scale) {
    const { on_pinch } = this.handlers;
    if (on_pinch != null) {
      on_pinch(this._pinch_event("pinch", ev0, ev1, scale));
    }
  }
  on_pinch_end(ev0, ev1, scale) {
    const { on_pinch_end } = this.handlers;
    if (on_pinch_end != null) {
      on_pinch_end(this._pinch_event("pinch_end", ev0, ev1, scale));
    }
  }
  on_rotate_start(ev0, ev1, rotation) {
    const { on_rotate_start } = this.handlers;
    if (on_rotate_start != null) {
      on_rotate_start(this._rotate_event("rotate_start", ev0, ev1, rotation));
    }
  }
  on_rotate(ev0, ev1, rotation) {
    const { on_rotate } = this.handlers;
    if (on_rotate != null) {
      on_rotate(this._rotate_event("rotate", ev0, ev1, rotation));
    }
  }
  on_rotate_end(ev0, ev1, rotation) {
    const { on_rotate_end } = this.handlers;
    if (on_rotate_end != null) {
      on_rotate_end(this._rotate_event("rotate_end", ev0, ev1, rotation));
    }
  }
  _get_sxy(event2) {
    const { pageX, pageY } = event2;
    const { left: left2, top } = offset_bbox(this.hit_area);
    return {
      sx: pageX - left2,
      sy: pageY - top
    };
  }
  _get_modifiers(event2) {
    return {
      shift: event2.shiftKey,
      ctrl: event2.ctrlKey,
      alt: event2.altKey
    };
  }
  _tap_event(type, event2) {
    return {
      type,
      ...this._get_sxy(event2),
      modifiers: this._get_modifiers(event2),
      native: event2
    };
  }
  _move_event(type, event2) {
    return {
      type,
      ...this._get_sxy(event2),
      modifiers: this._get_modifiers(event2),
      native: event2
    };
  }
  _pan_event(type, event2, dx, dy) {
    return {
      type,
      ...this._get_sxy(event2),
      dx,
      dy,
      modifiers: this._get_modifiers(event2),
      native: event2
    };
  }
  _pinch_event(type, event0, event1, scale) {
    const { sx: sx0, sy: sy0 } = this._get_sxy(event0);
    const { sx: sx1, sy: sy1 } = this._get_sxy(event1);
    return {
      type,
      sx: (sx0 + sx1) / 2,
      sy: (sy0 + sy1) / 2,
      scale,
      modifiers: this._get_modifiers(event0),
      native: event0
    };
  }
  _rotate_event(type, event0, event1, rotation) {
    const { sx: sx0, sy: sy0 } = this._get_sxy(event0);
    const { sx: sx1, sy: sy1 } = this._get_sxy(event1);
    return {
      type,
      sx: (sx0 + sx1) / 2,
      sy: (sy0 + sy1) / 2,
      rotation,
      modifiers: this._get_modifiers(event0),
      native: event0
    };
  }
  _movement(ptr) {
    return {
      dx: ptr.last.x - ptr.init.x,
      dy: ptr.last.y - ptr.init.y
    };
  }
  _distance(ev0, ev1) {
    const x2 = ev1.x - ev0.x;
    const y2 = ev1.y - ev0.y;
    return Math.sqrt(x2 ** 2 + y2 ** 2);
  }
  _angle(ev0, ev1) {
    const x2 = ev1.x - ev0.x;
    const y2 = ev1.y - ev0.y;
    return Math.atan2(y2, x2) * 180 / Math.PI;
  }
  _scale(ptr0, ptr1) {
    return this._distance(ptr0.last, ptr1.last) / this._distance(ptr0.init, ptr1.init);
  }
  _rotation(ptr0, ptr1) {
    return this._angle(ptr1.last, ptr0.last) + this._angle(ptr1.init, ptr0.init);
  }
};
__publicField(_UIGestures, "__name__", "UIGestures");
__publicField(_UIGestures, "move_threshold", 5);
/*px*/
__publicField(_UIGestures, "press_threshold", 300);
/*ms*/
__publicField(_UIGestures, "doubletap_threshold", 300);
/*ms*/
__publicField(_UIGestures, "pinch_threshold", 0);
/*unit less*/
__publicField(_UIGestures, "rotate_threshold", 0);
var UIGestures = _UIGestures;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/menus.js
import menus_css2, * as menus2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/menus.css.js";
import icons_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
import base_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/base.css.js";
var ContextMenu = class {
  constructor(items, options2) {
    __publicField(this, "items");
    __publicField(this, "el", div());
    __publicField(this, "shadow_el");
    __publicField(this, "_open", false);
    __publicField(this, "target");
    __publicField(this, "orientation");
    __publicField(this, "reversed");
    __publicField(this, "prevent_hide");
    __publicField(this, "extra_styles");
    __publicField(this, "entry_handler");
    __publicField(this, "class_list");
    __publicField(this, "_item_click", (entry2, i2) => {
      var _a34, _b4;
      (_a34 = this.entry_handler) == null ? void 0 : _a34.call(this, entry2, i2);
      (_b4 = entry2.handler) == null ? void 0 : _b4.call(entry2);
      this.hide();
    });
    __publicField(this, "_on_mousedown", (event2) => {
      var _a34;
      if (event2.composedPath().includes(this.el)) {
        return;
      }
      if (((_a34 = this.prevent_hide) == null ? void 0 : _a34.call(this, event2)) ?? false) {
        return;
      }
      this.hide();
    });
    __publicField(this, "_on_keydown", (event2) => {
      if (event2.key == "Escape") {
        this.hide();
      }
    });
    __publicField(this, "_on_blur", () => {
      this.hide();
    });
    this.items = items;
    this.target = options2.target;
    this.orientation = options2.orientation ?? "vertical";
    this.reversed = options2.reversed ?? false;
    this.prevent_hide = options2.prevent_hide;
    this.extra_styles = options2.extra_styles ?? [];
    this.entry_handler = options2.entry_handler;
    this.shadow_el = this.el.attachShadow({ mode: "open" });
    this.class_list = new ClassList(this.el.classList);
  }
  get is_open() {
    return this._open;
  }
  get can_open() {
    return this.items.length != 0;
  }
  remove() {
    this._unlisten();
    this.el.remove();
  }
  _listen() {
    document.addEventListener("mousedown", this._on_mousedown);
    document.addEventListener("keydown", this._on_keydown);
    window.addEventListener("blur", this._on_blur);
  }
  _unlisten() {
    document.removeEventListener("mousedown", this._on_mousedown);
    document.removeEventListener("keydown", this._on_keydown);
    window.removeEventListener("blur", this._on_blur);
  }
  _position(at) {
    const pos = (() => {
      if ("left_of" in at) {
        const { left: left2, top } = at.left_of.getBoundingClientRect();
        return { right: left2, top };
      }
      if ("right_of" in at) {
        const { top, right: right3 } = at.right_of.getBoundingClientRect();
        return { left: right3, top };
      }
      if ("below" in at) {
        const { left: left2, bottom } = at.below.getBoundingClientRect();
        return { left: left2, top: bottom };
      }
      if ("above" in at) {
        const { left: left2, top } = at.above.getBoundingClientRect();
        return { left: left2, bottom: top };
      }
      return at;
    })();
    const parent_el = this.el.offsetParent ?? document.body;
    const origin = (() => {
      const rect = parent_el.getBoundingClientRect();
      const style3 = getComputedStyle(parent_el);
      return {
        left: rect.left - parseFloat(style3.marginLeft),
        right: rect.right + parseFloat(style3.marginRight),
        top: rect.top - parseFloat(style3.marginTop),
        bottom: rect.bottom + parseFloat(style3.marginBottom)
      };
    })();
    const { style: style2 } = this.el;
    style2.left = pos.left != null ? `${pos.left - origin.left}px` : "auto";
    style2.top = pos.top != null ? `${pos.top - origin.top}px` : "auto";
    style2.right = pos.right != null ? `${origin.right - pos.right}px` : "auto";
    style2.bottom = pos.bottom != null ? `${origin.bottom - pos.bottom}px` : "auto";
  }
  stylesheets() {
    return [
      base_css2,
      /*...super.stylesheets(), */
      menus_css2,
      icons_css2,
      ...this.extra_styles
    ];
  }
  empty() {
    empty2(this.shadow_el);
    this.class_list.clear();
  }
  render() {
    var _a34;
    this.empty();
    for (const style2 of this.stylesheets()) {
      const stylesheet2 = isString(style2) ? new InlineStyleSheet(style2) : style2;
      stylesheet2.install(this.shadow_el);
    }
    this.class_list.add(menus2[this.orientation]);
    const items = this.reversed ? reversed(this.items) : this.items;
    for (const [item3, i2] of enumerate(items)) {
      let el;
      if (item3 == null) {
        el = div({ class: menus2.divider });
      } else if (item3.if != null && !item3.if()) {
        continue;
      } else if (item3.custom != null) {
        el = item3.custom;
      } else {
        const icon3 = item3.icon != null ? div({ class: [menus2.menu_icon, item3.icon] }) : null;
        const classes = [((_a34 = item3.active) == null ? void 0 : _a34.call(item3)) ?? false ? menus2.active : null, item3.class];
        el = div({ class: classes, title: item3.tooltip, tabIndex: 0 }, icon3, item3.label, item3.content);
        el.addEventListener("click", () => {
          this._item_click(item3, i2);
        });
        el.addEventListener("keydown", (event2) => {
          if (event2.key == "Enter") {
            this._item_click(item3, i2);
          }
        });
      }
      this.shadow_el.appendChild(el);
    }
  }
  show(at) {
    if (this.items.length == 0) {
      return;
    }
    this.render();
    if (this.shadow_el.children.length == 0) {
      return;
    }
    (this.target.shadowRoot ?? this.target).appendChild(this.el);
    this._position(at ?? { left: 0, top: 0 });
    this._listen();
    this._open = true;
  }
  hide() {
    if (this._open) {
      this._open = false;
      this._unlisten();
      this.el.remove();
    }
  }
  toggle(at) {
    this._open ? this.hide() : this.show(at);
  }
};
__publicField(ContextMenu, "__name__", "ContextMenu");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/tool_button.js
import tool_button_css, * as tool_button from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tool_button.css.js";
import icons_css3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ToolButtonView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_menu");
    __publicField(this, "_ui_gestures");
  }
  initialize() {
    super.initialize();
    const { location } = this.parent.model;
    const reverse = location == "left" || location == "above";
    const orientation = this.parent.model.horizontal ? "vertical" : "horizontal";
    const items = this.model.tool.menu ?? [];
    this._menu = new ContextMenu(!reverse ? items : reversed(items), {
      target: this.parent.el,
      orientation,
      prevent_hide: (event2) => {
        return event2.composedPath().includes(this.el);
      }
    });
    this._ui_gestures = new UIGestures(this.el, {
      on_tap: (event2) => {
        if (this._menu.is_open) {
          this._menu.hide();
          return;
        }
        if (event2.native.composedPath().includes(this.el)) {
          this._clicked();
        }
      },
      on_press: () => {
        this._pressed();
      }
    });
    this.el.addEventListener("keydown", (event2) => {
      switch (event2.key) {
        case "Enter": {
          this._clicked();
          break;
        }
        case " ": {
          this._pressed();
          break;
        }
        default:
      }
    });
  }
  connect_signals() {
    super.connect_signals();
    this._ui_gestures.connect_signals();
    this.connect(this.model.change, () => this.render());
    this.connect(this.model.tool.change, () => this.render());
  }
  remove() {
    this._ui_gestures.remove();
    this._menu.remove();
    super.remove();
  }
  stylesheets() {
    return [...super.stylesheets(), tool_button_css, icons_css3];
  }
  render() {
    super.render();
    this.class_list.add(tool_button[this.parent.model.location]);
    if (this.model.tool.disabled) {
      this.class_list.add(tool_button.disabled);
    }
    const icon_el = div({ class: tool_button.tool_icon });
    this.shadow_el.appendChild(icon_el);
    const icon3 = this.model.icon ?? this.model.tool.computed_icon;
    if (icon3 != null) {
      if (icon3.startsWith("data:image")) {
        const url2 = `url("${encodeURI(icon3)}")`;
        icon_el.style.backgroundImage = url2;
      } else if (icon3.startsWith("--")) {
        icon_el.style.backgroundImage = `var(${icon3})`;
      } else if (icon3.startsWith(".")) {
        const cls = icon3.substring(1);
        icon_el.classList.add(cls);
      } else if (ToolIcon.valid(icon3)) {
        const cls = `bk-tool-icon-${icon3.replace(/_/g, "-")}`;
        icon_el.classList.add(cls);
      }
    }
    if (this.model.tool.menu != null) {
      const chevron_el = div({ class: tool_button.tool_chevron });
      this.shadow_el.appendChild(chevron_el);
    }
    const tooltip = this.model.tooltip ?? this.model.tool.tooltip;
    this.el.title = tooltip;
    this.el.tabIndex = 0;
  }
  _pressed() {
    const at = (() => {
      switch (this.parent.model.location) {
        case "right":
          return { left_of: this.el };
        case "left":
          return { right_of: this.el };
        case "above":
          return { below: this.el };
        case "below":
          return { above: this.el };
      }
    })();
    this._menu.toggle(at);
  }
};
__publicField(ToolButtonView, "__name__", "ToolButtonView");
var _ToolButton = class _ToolButton extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToolButton, "__name__", "ToolButton");
_ToolButton.define(({ Str: Str2, Regex: Regex2, Ref: Ref2, Nullable: Nullable2, Or: Or2 }) => ({
  tool: [Or2(Ref2(Tool), Ref2(ToolProxy))],
  icon: [Nullable2(Or2(ToolIcon, Regex2(/^--/), Regex2(/^\./), Regex2(/^data:image/))), null],
  tooltip: [Nullable2(Str2), null]
}));
var ToolButton = _ToolButton;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/on_off_button.js
import * as tools from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tool_button.css.js";
var OnOffButtonView = class extends ToolButtonView {
  _toggle_active() {
    this.class_list.toggle(tools.active, this.model.tool.active);
  }
  connect_signals() {
    super.connect_signals();
    const { active: active8 } = this.model.tool.properties;
    this.on_change(active8, () => {
      this._toggle_active();
    });
  }
  render() {
    super.render();
    this._toggle_active();
  }
  _clicked() {
    const { active: active8 } = this.model.tool;
    this.model.tool.active = !active8;
  }
};
__publicField(OnOffButtonView, "__name__", "OnOffButtonView");
var _OnOffButton = class _OnOffButton extends ToolButton {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_OnOffButton, "__name__", "OnOffButton");
_OnOffButton.prototype.default_view = OnOffButtonView;
var OnOffButton = _OnOffButton;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/gesture_tool.js
var GestureToolView = class extends ToolView {
  get plot_view() {
    return this.parent;
  }
};
__publicField(GestureToolView, "__name__", "GestureToolView");
var GestureTool = class extends Tool {
  constructor(attrs) {
    super(attrs);
  }
  tool_button() {
    return new OnOffButton({ tool: this });
  }
};
__publicField(GestureTool, "__name__", "GestureTool");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/inspect_tool.js
var InspectToolView = class extends ToolView {
  get plot_view() {
    return this.parent;
  }
};
__publicField(InspectToolView, "__name__", "InspectToolView");
var _InspectTool = class _InspectTool extends Tool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "event_type", "move");
  }
  tool_button() {
    return new OnOffButton({ tool: this });
  }
};
__publicField(_InspectTool, "__name__", "InspectTool");
_InspectTool.define(() => ({
  toggleable: [new PropertyAlias("visible")]
}));
_InspectTool.override({
  active: true
});
var InspectTool = _InspectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/click_button.js
var ClickButtonView = class extends ToolButtonView {
  _clicked() {
    this.model.tool.do.emit(void 0);
  }
};
__publicField(ClickButtonView, "__name__", "ClickButtonView");
var _ClickButton = class _ClickButton extends ToolButton {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ClickButton, "__name__", "ClickButton");
_ClickButton.prototype.default_view = ClickButtonView;
var ClickButton = _ClickButton;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/action_tool.js
var ActionToolView = class extends ToolView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.do, (arg) => this.doit(arg));
  }
};
__publicField(ActionToolView, "__name__", "ActionToolView");
var ActionTool = class extends Tool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "do", new Signal(this, "do"));
  }
  tool_button() {
    return new ClickButton({ tool: this });
  }
};
__publicField(ActionTool, "__name__", "ActionTool");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/help_tool.js
import { tool_icon_help } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var HelpToolView = class extends ActionToolView {
  doit() {
    window.open(this.model.redirect);
  }
};
__publicField(HelpToolView, "__name__", "HelpToolView");
var _HelpTool = class _HelpTool extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Help");
    __publicField(this, "tool_icon", tool_icon_help);
  }
};
__publicField(_HelpTool, "__name__", "HelpTool");
_HelpTool.prototype.default_view = HelpToolView;
_HelpTool.define(({ Str: Str2 }) => ({
  redirect: [Str2, "https://docs.bokeh.org/en/latest/docs/user_guide/interaction/tools.html"]
}));
_HelpTool.override({
  description: "Click the question mark to learn more about Bokeh plot tools."
});
_HelpTool.register_alias("help", () => new _HelpTool());
var HelpTool = _HelpTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/toolbar.js
import toolbars_css, * as toolbars from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/toolbar.css.js";
import logos_css, * as logos from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/logo.css.js";
import icons_css4 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ToolbarView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_tool_button_views", /* @__PURE__ */ new Map());
    __publicField(this, "_tool_buttons");
    __publicField(this, "_items", []);
    __publicField(this, "_overflow_menu");
    __publicField(this, "_overflow_el");
    __publicField(this, "_visible", null);
  }
  get tool_buttons() {
    return this._tool_buttons.flat();
  }
  get overflow_el() {
    return this._overflow_el;
  }
  get visible() {
    return !this.model.visible ? false : !this.model.autohide || (this._visible ?? false);
  }
  *children() {
    yield* super.children();
    yield* this._tool_button_views.values();
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    for (const child_view of this._tool_button_views.values()) {
      if (!child_view.has_finished()) {
        return false;
      }
    }
    return true;
  }
  initialize() {
    super.initialize();
    const { location } = this.model;
    const reversed2 = location == "left" || location == "above";
    const orientation = this.model.horizontal ? "vertical" : "horizontal";
    this._overflow_menu = new ContextMenu([], {
      target: this.el,
      orientation,
      reversed: reversed2,
      prevent_hide: (event2) => {
        return event2.composedPath().includes(this._overflow_el);
      }
    });
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._build_tool_button_views();
  }
  connect_signals() {
    super.connect_signals();
    const { buttons: buttons7, tools: tools2, location, autohide } = this.model.properties;
    this.on_change([buttons7, tools2], async () => {
      await this._build_tool_button_views();
      this.render();
    });
    this.on_change(location, () => {
      this.render();
    });
    this.on_change(autohide, () => {
      this._on_visible_change();
    });
  }
  stylesheets() {
    return [...super.stylesheets(), toolbars_css, logos_css, icons_css4];
  }
  remove() {
    remove_views(this._tool_button_views);
    super.remove();
  }
  async _build_tool_button_views() {
    this._tool_buttons = (() => {
      const { buttons: buttons7 } = this.model;
      if (buttons7 == "auto") {
        const groups = [
          ...values(this.model.gestures).map((gesture) => gesture.tools),
          this.model.actions,
          this.model.inspectors,
          this.model.auxiliaries
        ];
        const buttons8 = groups.map((group) => {
          return group.filter((tool) => tool.visible).map((tool) => tool.tool_button());
        });
        return buttons8;
      } else {
        return split(buttons7, null);
      }
    })();
    await build_views(this._tool_button_views, this._tool_buttons.flat(), { parent: this });
  }
  set_visibility(visible) {
    if (visible != this._visible) {
      this._visible = visible;
      this._on_visible_change();
    }
  }
  _on_visible_change() {
    this.el.classList.toggle(toolbars.hidden, !this.visible);
  }
  _after_resize() {
    super._after_resize();
    this._after_render();
  }
  _menu_at() {
    switch (this.model.location) {
      case "right":
        return { left_of: this._overflow_el };
      case "left":
        return { right_of: this._overflow_el };
      case "above":
        return { below: this._overflow_el };
      case "below":
        return { above: this._overflow_el };
    }
  }
  toggle_menu() {
    this._overflow_menu.toggle(this._menu_at());
  }
  render() {
    super.render();
    this.el.classList.add(toolbars[this.model.location]);
    this.el.classList.toggle(toolbars.inner, this.model.inner);
    this._on_visible_change();
    const { horizontal: horizontal2 } = this.model;
    this._overflow_el = div({ class: toolbars.tool_overflow, tabIndex: 0 }, horizontal2 ? "⋮" : "⋯");
    this._overflow_el.addEventListener("click", (_event) => {
      this.toggle_menu();
    });
    this._overflow_el.addEventListener("keydown", (event2) => {
      if (event2.key == "Enter") {
        this.toggle_menu();
      }
    });
    this._items = [];
    if (this.model.logo != null) {
      const gray = this.model.logo === "grey" ? logos.grey : null;
      const logo_el = a({ href: "https://bokeh.org/", target: "_blank", class: [logos.logo, logos.logo_small, gray] });
      this._items.push(logo_el);
      this.shadow_el.appendChild(logo_el);
    }
    for (const [, button_view] of this._tool_button_views) {
      button_view.render_to(this.shadow_el);
    }
    const bars = this._tool_buttons.map((group) => group.map((button2) => this._tool_button_views.get(button2).el));
    const non_empty = bars.filter((bar2) => bar2.length != 0);
    const divider5 = () => div({ class: toolbars.divider });
    for (const el of join(non_empty, divider5)) {
      this._items.push(el);
      this.shadow_el.append(el);
    }
  }
  _after_render() {
    super._after_render();
    clear(this._overflow_menu.items);
    if (this.shadow_el.contains(this._overflow_el)) {
      this.shadow_el.removeChild(this._overflow_el);
    }
    for (const el of this._items) {
      if (!this.shadow_el.contains(el)) {
        this.shadow_el.append(el);
      }
    }
    const { horizontal: horizontal2 } = this.model;
    const overflow_size = 15;
    const { bbox } = this;
    const overflow_cls = horizontal2 ? toolbars.right : toolbars.above;
    let size2 = 0;
    let overflowed = false;
    for (const el of this._items) {
      if (overflowed) {
        this.shadow_el.removeChild(el);
        this._overflow_menu.items.push({ custom: el, class: overflow_cls });
      } else {
        const { width, height } = el.getBoundingClientRect();
        size2 += horizontal2 ? width : height;
        overflowed = horizontal2 ? size2 > bbox.width - overflow_size : size2 > bbox.height - overflow_size;
        if (overflowed) {
          this.shadow_el.removeChild(el);
          this.shadow_el.appendChild(this._overflow_el);
          this._overflow_menu.items.push({ custom: el, class: overflow_cls });
        }
      }
    }
    if (this._overflow_menu.is_open) {
      this._overflow_menu.show(this._menu_at());
    }
  }
};
__publicField(ToolbarView, "__name__", "ToolbarView");
var GestureToolLike = Or(Ref(GestureTool), Ref(ToolProxy));
var GestureEntry = Struct({
  tools: List(GestureToolLike),
  active: Nullable(GestureToolLike)
});
var GesturesMap = Struct({
  pan: GestureEntry,
  scroll: GestureEntry,
  pinch: GestureEntry,
  rotate: GestureEntry,
  move: GestureEntry,
  tap: GestureEntry,
  doubletap: GestureEntry,
  press: GestureEntry,
  pressup: GestureEntry,
  multi: GestureEntry
});
var Inspection = Tool;
function create_gesture_map() {
  return {
    pan: { tools: [], active: null },
    scroll: { tools: [], active: null },
    pinch: { tools: [], active: null },
    rotate: { tools: [], active: null },
    move: { tools: [], active: null },
    tap: { tools: [], active: null },
    doubletap: { tools: [], active: null },
    press: { tools: [], active: null },
    pressup: { tools: [], active: null },
    multi: { tools: [], active: null }
  };
}
var _Toolbar = class _Toolbar extends UIElement {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "active_changed");
  }
  get horizontal() {
    return this.location == "above" || this.location == "below";
  }
  get vertical() {
    return this.location == "left" || this.location == "right";
  }
  connect_signals() {
    super.connect_signals();
    const { tools: tools2, active_drag, active_inspect, active_scroll, active_tap, active_multi } = this.properties;
    this.on_change([tools2, active_drag, active_inspect, active_scroll, active_tap, active_multi], () => {
      this._init_tools();
      this._activate_tools();
    });
  }
  initialize() {
    super.initialize();
    this.active_changed = new Signal0(this, "active_changed");
    this._init_tools();
    this._activate_tools();
  }
  _init_tools() {
    const visited = /* @__PURE__ */ new Set();
    function isa(tool, type) {
      const is = (tool instanceof ToolProxy ? tool.underlying : tool) instanceof type;
      if (is) {
        visited.add(tool);
      }
      return is;
    }
    const new_inspectors = this.tools.filter((t) => isa(t, InspectTool));
    this.inspectors = new_inspectors;
    const new_help = this.tools.filter((t) => isa(t, HelpTool));
    this.help = new_help;
    const new_actions = this.tools.filter((t) => isa(t, ActionTool));
    this.actions = new_actions;
    const new_gestures = create_gesture_map();
    for (const tool of this.tools) {
      if (isa(tool, GestureTool)) {
        new_gestures[tool.event_role].tools.push(tool);
      }
    }
    for (const et of typed_keys(new_gestures)) {
      const gesture = this.gestures[et];
      gesture.tools = sort_by(new_gestures[et].tools, (tool) => tool.default_order);
      if (gesture.active != null && every(gesture.tools, (tool) => {
        var _a34;
        return tool.id != ((_a34 = gesture.active) == null ? void 0 : _a34.id);
      })) {
        gesture.active = null;
      }
    }
    const new_auxiliaries = this.tools.filter((tool) => !visited.has(tool));
    this.auxiliaries = new_auxiliaries;
  }
  _activate_tools() {
    if (this.active_inspect == "auto") {
    } else if (this.active_inspect == null) {
      for (const inspector of this.inspectors) {
        inspector.active = false;
      }
    } else if (isArray(this.active_inspect)) {
      const active_inspect = intersection(this.active_inspect, this.inspectors);
      if (active_inspect.length != this.active_inspect.length) {
        this.active_inspect = active_inspect;
      }
      for (const inspector of this.inspectors) {
        if (!includes(this.active_inspect, inspector)) {
          inspector.active = false;
        }
      }
    } else {
      let found = false;
      for (const inspector of this.inspectors) {
        if (inspector != this.active_inspect) {
          inspector.active = false;
        } else {
          found = true;
        }
      }
      if (!found) {
        this.active_inspect = null;
      }
    }
    const _activate_gesture = (tool) => {
      if (tool.active) {
        this._active_change(tool);
      } else {
        tool.active = true;
      }
    };
    for (const gesture of values(this.gestures)) {
      for (const tool of gesture.tools) {
        this.connect(tool.properties.active.change, () => {
          this._active_change(tool);
          this.active_changed.emit();
        });
      }
    }
    function _get_active_attr(et) {
      switch (et) {
        case "tap":
          return "active_tap";
        case "pan":
          return "active_drag";
        case "pinch":
        case "scroll":
          return "active_scroll";
        case "multi":
          return "active_multi";
        default:
          return null;
      }
    }
    function _supports_auto(et, tool) {
      return et == "tap" || et == "pan" || tool.supports_auto();
    }
    const is_active_gesture = (active_tool) => {
      return this.tools.includes(active_tool) || active_tool instanceof Tool && this.tools.some((tool) => tool instanceof ToolProxy && tool.tools.includes(active_tool));
    };
    for (const [event_role, gesture] of entries(this.gestures)) {
      const et = event_role;
      const active_attr = _get_active_attr(et);
      if (active_attr != null) {
        const active_tool = this[active_attr];
        if (active_tool == "auto") {
          if (gesture.tools.length != 0) {
            const [tool] = gesture.tools;
            if (_supports_auto(et, tool)) {
              _activate_gesture(tool);
            }
          }
        } else if (active_tool != null) {
          if (is_active_gesture(active_tool)) {
            _activate_gesture(active_tool);
          } else {
            this[active_attr] = null;
          }
        } else {
          this.gestures[et].active = null;
          for (const tool of this.gestures[et].tools) {
            tool.active = false;
          }
        }
      }
    }
    this.active_changed.emit();
  }
  _active_change(tool) {
    const { event_types } = tool;
    for (const et of event_types) {
      if (tool.active) {
        const currently_active_tool = this.gestures[et].active;
        if (currently_active_tool != null && tool != currently_active_tool) {
          logger.debug(`Toolbar: deactivating tool: ${currently_active_tool} for event type '${et}'`);
          currently_active_tool.active = false;
        }
        this.gestures[et].active = tool;
        logger.debug(`Toolbar: activating tool: ${tool} for event type '${et}'`);
      } else {
        this.gestures[et].active = null;
      }
    }
  }
};
__publicField(_Toolbar, "__name__", "Toolbar");
_Toolbar.prototype.default_view = ToolbarView;
_Toolbar.define(({ Bool: Bool2, List: List2, Or: Or2, Ref: Ref2, Nullable: Nullable2, Auto: Auto2 }) => ({
  tools: [List2(Or2(Ref2(Tool), Ref2(ToolProxy))), []],
  logo: [Nullable2(Logo), "normal"],
  autohide: [Bool2, false],
  active_drag: [Nullable2(Or2(GestureToolLike, Auto2)), "auto"],
  active_inspect: [Nullable2(Or2(Ref2(Inspection), List2(Ref2(Inspection)), Ref2(ToolProxy), Auto2)), "auto"],
  active_scroll: [Nullable2(Or2(GestureToolLike, Auto2)), "auto"],
  active_tap: [Nullable2(Or2(GestureToolLike, Auto2)), "auto"],
  active_multi: [Nullable2(Or2(GestureToolLike, Auto2)), "auto"]
}));
_Toolbar.internal(({ List: List2, Bool: Bool2, Ref: Ref2, Or: Or2, Null: Null2, Auto: Auto2 }) => {
  return {
    buttons: [Or2(List2(Or2(Ref2(ToolButton), Null2)), Auto2), "auto"],
    location: [Location, "right"],
    inner: [Bool2, false],
    gestures: [GesturesMap, create_gesture_map],
    actions: [List2(Or2(Ref2(ActionTool), Ref2(ToolProxy))), []],
    inspectors: [List2(Or2(Ref2(InspectTool), Ref2(ToolProxy))), []],
    auxiliaries: [List2(Or2(Ref2(Tool), Ref2(ToolProxy))), []],
    help: [List2(Or2(Ref2(HelpTool), Ref2(ToolProxy))), []]
  };
});
var Toolbar = _Toolbar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/toolbar_panel.js
var ToolbarPanelView = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "toolbar_view");
    __publicField(this, "_previous_bbox", new BBox());
  }
  rendering_target() {
    return this.plot_view.canvas_view.events_el;
  }
  update_layout() {
    this.layout = new SideLayout(this.panel, () => this.get_size(), true);
  }
  after_layout() {
    this.toolbar_view.after_render();
  }
  has_finished() {
    return super.has_finished() && this.toolbar_view.has_finished();
  }
  *children() {
    yield* super.children();
    yield this.toolbar_view;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.toolbar_view = await build_view(this.model.toolbar, { parent: this.canvas });
  }
  connect_signals() {
    super.connect_signals();
    this.plot_view.mouseenter.connect(() => {
      this.toolbar_view.set_visibility(true);
    });
    this.plot_view.mouseleave.connect(() => {
      this.toolbar_view.set_visibility(false);
    });
  }
  remove() {
    this.toolbar_view.remove();
    super.remove();
  }
  render() {
    super.render();
    this.toolbar_view.render_to(this.shadow_el);
  }
  _paint() {
    display(this.el);
    const { bbox } = this.layout;
    if (!this._previous_bbox.equals(bbox)) {
      position(this.el, bbox);
      this._previous_bbox = bbox;
      empty2(this.el);
      this.el.style.position = "absolute";
      const { style: style2 } = this.toolbar_view.el;
      if (this.toolbar_view.model.horizontal) {
        style2.width = "100%";
        style2.height = "unset";
      } else {
        style2.width = "unset";
        style2.height = "100%";
      }
    }
    if (!this.model.visible) {
      undisplay(this.el);
    }
  }
  _get_size() {
    const { tools: tools2, logo: logo2 } = this.model.toolbar;
    return {
      width: tools2.length * 30 + (logo2 != null ? 25 : 0) + 15,
      // TODO: approximate, use a proper layout instead.
      height: 30
    };
  }
};
__publicField(ToolbarPanelView, "__name__", "ToolbarPanelView");
var _ToolbarPanel = class _ToolbarPanel extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToolbarPanel, "__name__", "ToolbarPanel");
_ToolbarPanel.prototype.default_view = ToolbarPanelView;
_ToolbarPanel.define(({ Ref: Ref2 }) => ({
  toolbar: [Ref2(Toolbar)]
}));
var ToolbarPanel = _ToolbarPanel;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/whisker.js
var WhiskerView = class extends UpperLowerView {
  constructor() {
    super(...arguments);
    __publicField(this, "lower_head");
    __publicField(this, "upper_head");
  }
  *children() {
    yield* super.children();
    const { lower_head, upper_head } = this;
    if (lower_head != null) {
      yield lower_head;
    }
    if (upper_head != null) {
      yield upper_head;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { lower_head, upper_head } = this.model;
    if (lower_head != null) {
      this.lower_head = await build_view(lower_head, { parent: this });
    }
    if (upper_head != null) {
      this.upper_head = await build_view(upper_head, { parent: this });
    }
  }
  set_data(source2) {
    var _a34, _b4;
    super.set_data(source2);
    const indices = BitSet.all_set(this._lower.length);
    (_a34 = this.lower_head) == null ? void 0 : _a34.set_data(source2, indices);
    (_b4 = this.upper_head) == null ? void 0 : _b4.set_data(source2, indices);
  }
  _paint_data(ctx) {
    if (this.visuals.line.doit) {
      for (let i2 = 0, end = this._lower_sx.length; i2 < end; i2++) {
        ctx.beginPath();
        ctx.moveTo(this._lower_sx[i2], this._lower_sy[i2]);
        ctx.lineTo(this._upper_sx[i2], this._upper_sy[i2]);
        this.visuals.line.apply(ctx, i2);
      }
    }
    const angle = this.model.dimension == "height" ? 0 : Math.PI / 2;
    if (this.lower_head != null) {
      for (let i2 = 0, end = this._lower_sx.length; i2 < end; i2++) {
        ctx.save();
        ctx.translate(this._lower_sx[i2], this._lower_sy[i2]);
        ctx.rotate(angle + Math.PI);
        this.lower_head.paint(ctx, i2);
        ctx.restore();
      }
    }
    if (this.upper_head != null) {
      for (let i2 = 0, end = this._upper_sx.length; i2 < end; i2++) {
        ctx.save();
        ctx.translate(this._upper_sx[i2], this._upper_sy[i2]);
        ctx.rotate(angle);
        this.upper_head.paint(ctx, i2);
        ctx.restore();
      }
    }
  }
};
__publicField(WhiskerView, "__name__", "WhiskerView");
var _Whisker = class _Whisker extends UpperLower {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Whisker, "__name__", "Whisker");
_Whisker.prototype.default_view = WhiskerView;
_Whisker.mixins(LineVector);
_Whisker.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  lower_head: [Nullable2(Ref2(ArrowHead)), () => new TeeHead({ size: 10 })],
  upper_head: [Nullable2(Ref2(ArrowHead)), () => new TeeHead({ size: 10 })]
}));
_Whisker.override({
  level: "underlay"
});
var Whisker = _Whisker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/html/text_annotation.js
var TextAnnotationView2 = class extends AnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "text_el");
  }
  rendering_target() {
    return this.plot_view.canvas_view.overlays_el;
  }
  update_layout() {
    const { panel } = this;
    if (panel != null) {
      this.layout = new SideLayout(panel, () => this.get_size(), true);
    } else {
      this.layout = void 0;
    }
  }
  initialize() {
    super.initialize();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.paint());
  }
  paint() {
    if (!this.model.visible) {
      undisplay(this.el);
      return;
    }
    super.paint();
  }
  get padding() {
    return padding(this.model.padding);
  }
  get border_radius() {
    return border_radius(this.model.border_radius);
  }
  render() {
    super.render();
    this.text_el = document.createTextNode("");
    this.shadow_el.append(this.text_el);
  }
  _paint_text(ctx, text2, sx, sy, angle) {
    const { el } = this;
    undisplay(el);
    this.text_el.textContent = text2;
    this.visuals.text.set_value(ctx);
    const { padding: padding2, border_radius: border_radius2 } = this;
    this.position.replace(`
    :host {
      position: absolute;
      left: ${sx}px;
      top: ${sy}px;
    }
    `);
    this.style.replace(`
    :host {
      color: ${ctx.fillStyle};
      -webkit-text-stroke: 1px ${ctx.strokeStyle};
      font: ${ctx.font};
      white-space: pre;

      padding-left: ${padding2.left}px;
      padding-right: ${padding2.right}px;
      padding-top: ${padding2.top}px;
      padding-bottom: ${padding2.bottom}px;

      border-top-left-radius: ${border_radius2.top_left}px;
      border-top-right-radius: ${border_radius2.top_right}px;
      border-bottom-right-radius: ${border_radius2.bottom_right}px;
      border-bottom-left-radius: ${border_radius2.bottom_left}px;
    }
    `);
    const [x_anchor, x_t] = (() => {
      switch (this.visuals.text.text_align.get_value()) {
        case "left":
          return ["left", "0%"];
        case "center":
          return ["center", "-50%"];
        case "right":
          return ["right", "-100%"];
      }
    })();
    const [y_anchor, y_t] = (() => {
      switch (this.visuals.text.text_baseline.get_value()) {
        case "top":
          return ["top", "0%"];
        case "middle":
          return ["center", "-50%"];
        case "bottom":
          return ["bottom", "-100%"];
        default:
          return ["center", "-50%"];
      }
    })();
    let transform2 = `translate(${x_t}, ${y_t})`;
    if (angle != 0) {
      transform2 += ` rotate(${angle}rad)`;
    }
    this.style.append(`
    :host {
      transform-origin: ${x_anchor} ${y_anchor};
      transform: ${transform2};
    }
    `);
    if (this.layout == null) {
    }
    if (this.visuals.background_fill.doit) {
      this.visuals.background_fill.set_value(ctx);
      this.style.append(`
      :host {
        background-color: ${ctx.fillStyle};
      }
      `);
    }
    if (this.visuals.border_line.doit) {
      this.visuals.border_line.set_value(ctx);
      this.style.append(`
      :host {
        border-style: ${ctx.getLineDash().length < 2 ? "solid" : "dashed"};
        border-width: ${ctx.lineWidth}px;
        border-color: ${ctx.strokeStyle};
      }
      `);
    }
    display(el);
  }
};
__publicField(TextAnnotationView2, "__name__", "TextAnnotationView");
var _TextAnnotation2 = class _TextAnnotation2 extends Annotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TextAnnotation2, "__name__", "TextAnnotation");
_TextAnnotation2.define(() => ({
  padding: [Padding, 0],
  border_radius: [BorderRadius, 0]
}));
var TextAnnotation2 = _TextAnnotation2;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/html/label.js
var HTMLLabelView = class extends TextAnnotationView2 {
  update_layout() {
    const { panel } = this;
    if (panel != null) {
      this.layout = new SideLayout(panel, () => this.get_size(), false);
    } else {
      this.layout = void 0;
    }
  }
  // XXX: this needs to use CSS computed styles
  _get_size() {
    const { text: text2 } = this.model;
    const graphics = new TextBox({ text: text2 });
    const { angle, angle_units } = this.model;
    graphics.angle = compute_angle(angle, angle_units);
    graphics.visuals = this.visuals.text.values();
    const size2 = graphics.size();
    const { padding: padding2 } = this;
    const width = size2.width + padding2.left + padding2.right;
    const height = size2.height + padding2.top + padding2.bottom;
    return { width, height };
  }
  _paint() {
    const { angle, angle_units } = this.model;
    const rotation = compute_angle(angle, angle_units);
    const panel = this.layout != null ? this.layout : this.plot_view.frame;
    const xscale = this.coordinates.x_scale;
    const yscale = this.coordinates.y_scale;
    let sx = (() => {
      switch (this.model.x_units) {
        case "canvas":
          return this.model.x;
        case "screen":
          return panel.bbox.xview.compute(this.model.x);
        case "data":
          return xscale.compute(this.model.x);
      }
    })();
    let sy = (() => {
      switch (this.model.y_units) {
        case "canvas":
          return this.model.y;
        case "screen":
          return panel.bbox.yview.compute(this.model.y);
        case "data":
          return yscale.compute(this.model.y);
      }
    })();
    sx += this.model.x_offset;
    sy -= this.model.y_offset;
    this._paint_text(this.layer.ctx, this.model.text, sx, sy, rotation);
  }
};
__publicField(HTMLLabelView, "__name__", "HTMLLabelView");
var _HTMLLabel = class _HTMLLabel extends TextAnnotation2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HTMLLabel, "__name__", "HTMLLabel");
_HTMLLabel.prototype.default_view = HTMLLabelView;
_HTMLLabel.mixins([
  Text,
  ["border_", Line],
  ["background_", Fill],
  ["background_", Hatch]
]);
_HTMLLabel.define(({ Float: Float2, Str: Str2, Angle }) => ({
  x: [Float2],
  x_units: [CoordinateUnits, "data"],
  y: [Float2],
  y_units: [CoordinateUnits, "data"],
  text: [Str2, ""],
  angle: [Angle, 0],
  angle_units: [AngleUnits, "rad"],
  x_offset: [Float2, 0],
  y_offset: [Float2, 0]
}));
_HTMLLabel.override({
  background_fill_color: null,
  background_hatch_color: null,
  border_line_color: null
});
var HTMLLabel = _HTMLLabel;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/html/label_set.js
var HTMLLabelSetView = class extends DataAnnotationView {
  constructor() {
    super(...arguments);
    __publicField(this, "_x");
    __publicField(this, "_y");
    __publicField(this, "sx");
    __publicField(this, "sy");
    __publicField(this, "text");
    __publicField(this, "angle");
    __publicField(this, "x_offset");
    __publicField(this, "y_offset");
    __publicField(this, "els", []);
  }
  set_data(source2) {
    super.set_data(source2);
    this.els.forEach((el) => el.remove());
    this.els = [...this.text.map(() => div({ style: { display: "none" } }))];
    this.plot_view.canvas_view.overlays_el.append(...this.els);
  }
  remove() {
    this.els.forEach((el) => el.remove());
    this.els = [];
    super.remove();
  }
  _rerender() {
    this.paint();
  }
  map_data() {
    const { x_scale, y_scale } = this.coordinates;
    const panel = this.layout != null ? this.layout : this.plot_view.frame;
    this.sx = (() => {
      switch (this.model.x_units) {
        case "canvas":
          return new ScreenArray(this._x);
        case "screen":
          return panel.bbox.xview.v_compute(this._x);
        case "data":
          return x_scale.v_compute(this._x);
      }
    })();
    this.sy = (() => {
      switch (this.model.y_units) {
        case "canvas":
          return new ScreenArray(this._y);
        case "screen":
          return panel.bbox.yview.v_compute(this._y);
        case "data":
          return y_scale.v_compute(this._y);
      }
    })();
  }
  _paint_data() {
    const { ctx } = this.layer;
    for (let i2 = 0, end = this.text.length; i2 < end; i2++) {
      const x_offset_i = this.x_offset.get(i2);
      const y_offset_i = this.y_offset.get(i2);
      const sx_i = this.sx[i2] + x_offset_i;
      const sy_i = this.sy[i2] - y_offset_i;
      const angle_i = this.angle.get(i2);
      const text_i = this.text.get(i2);
      if (!isFinite(sx_i + sy_i + angle_i) || text_i == null) {
        continue;
      }
      this._paint_text(ctx, i2, text_i, sx_i, sy_i, angle_i);
    }
  }
  _paint_text(ctx, i2, text2, sx, sy, angle) {
    assert(i2 in this.els);
    const el = this.els[i2];
    el.textContent = text2;
    this.visuals.text.set_vectorize(ctx, i2);
    el.style.position = "absolute";
    el.style.left = `${sx}px`;
    el.style.top = `${sy}px`;
    el.style.color = ctx.fillStyle;
    el.style.webkitTextStroke = `1px ${ctx.strokeStyle}`;
    el.style.font = ctx.font;
    el.style.lineHeight = "normal";
    el.style.whiteSpace = "pre";
    const [x_anchor, x_t] = (() => {
      switch (this.visuals.text.text_align.get(i2)) {
        case "left":
          return ["left", "0%"];
        case "center":
          return ["center", "-50%"];
        case "right":
          return ["right", "-100%"];
      }
    })();
    const [y_anchor, y_t] = (() => {
      switch (this.visuals.text.text_baseline.get(i2)) {
        case "top":
          return ["top", "0%"];
        case "middle":
          return ["center", "-50%"];
        case "bottom":
          return ["bottom", "-100%"];
        default:
          return ["center", "-50%"];
      }
    })();
    let transform2 = `translate(${x_t}, ${y_t})`;
    if (angle != 0) {
      transform2 += `rotate(${angle}rad)`;
    }
    el.style.transformOrigin = `${x_anchor} ${y_anchor}`;
    el.style.transform = transform2;
    if (this.layout == null) {
    }
    if (this.visuals.background_fill.doit) {
      this.visuals.background_fill.set_vectorize(ctx, i2);
      el.style.backgroundColor = ctx.fillStyle;
    }
    if (this.visuals.border_line.doit) {
      this.visuals.border_line.set_vectorize(ctx, i2);
      el.style.borderStyle = ctx.getLineDash().length < 2 ? "solid" : "dashed";
      el.style.borderWidth = `${ctx.lineWidth}px`;
      el.style.borderColor = ctx.strokeStyle;
    }
    display(el);
  }
};
__publicField(HTMLLabelSetView, "__name__", "HTMLLabelSetView");
var _HTMLLabelSet = class _HTMLLabelSet extends DataAnnotation {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HTMLLabelSet, "__name__", "HTMLLabelSet");
_HTMLLabelSet.prototype.default_view = HTMLLabelSetView;
_HTMLLabelSet.mixins([
  TextVector,
  ["border_", LineVector],
  ["background_", FillVector]
]);
_HTMLLabelSet.define(() => ({
  x: [XCoordinateSpec, { field: "x" }],
  y: [YCoordinateSpec, { field: "y" }],
  x_units: [CoordinateUnits, "data"],
  y_units: [CoordinateUnits, "data"],
  text: [NullStringSpec, { field: "text" }],
  angle: [AngleSpec, 0],
  x_offset: [NumberSpec, { value: 0 }],
  y_offset: [NumberSpec, { value: 0 }]
}));
_HTMLLabelSet.override({
  background_fill_color: null,
  border_line_color: null
});
var HTMLLabelSet = _HTMLLabelSet;

// node_modules/@bokeh/bokehjs/build/js/lib/models/annotations/html/title.js
var HTMLTitleView = class extends TextAnnotationView2 {
  _get_location() {
    const hmargin = this.model.offset;
    const vmargin = this.model.standoff / 2;
    let sx, sy;
    const { bbox } = this.layout;
    switch (this.panel.side) {
      case "above":
      case "below": {
        switch (this.model.vertical_align) {
          case "top":
            sy = bbox.top + vmargin;
            break;
          case "middle":
            sy = bbox.vcenter;
            break;
          case "bottom":
            sy = bbox.bottom - vmargin;
            break;
        }
        switch (this.model.align) {
          case "left":
            sx = bbox.left + hmargin;
            break;
          case "center":
            sx = bbox.hcenter;
            break;
          case "right":
            sx = bbox.right - hmargin;
            break;
        }
        break;
      }
      case "left": {
        switch (this.model.vertical_align) {
          case "top":
            sx = bbox.left + vmargin;
            break;
          case "middle":
            sx = bbox.hcenter;
            break;
          case "bottom":
            sx = bbox.right - vmargin;
            break;
        }
        switch (this.model.align) {
          case "left":
            sy = bbox.bottom - hmargin;
            break;
          case "center":
            sy = bbox.vcenter;
            break;
          case "right":
            sy = bbox.top + hmargin;
            break;
        }
        break;
      }
      case "right": {
        switch (this.model.vertical_align) {
          case "top":
            sx = bbox.right - vmargin;
            break;
          case "middle":
            sx = bbox.hcenter;
            break;
          case "bottom":
            sx = bbox.left + vmargin;
            break;
        }
        switch (this.model.align) {
          case "left":
            sy = bbox.top + hmargin;
            break;
          case "center":
            sy = bbox.vcenter;
            break;
          case "right":
            sy = bbox.bottom - hmargin;
            break;
        }
        break;
      }
    }
    return [sx, sy];
  }
  _paint() {
    const { text: text2 } = this.model;
    if (text2.length == 0) {
      return;
    }
    this.model.text_baseline = this.model.vertical_align;
    this.model.text_align = this.model.align;
    const [sx, sy] = this._get_location();
    const angle = this.panel.get_label_angle_heuristic("parallel");
    this._paint_text(this.layer.ctx, text2, sx, sy, angle);
  }
  // XXX: this needs to use CSS computed styles
  _get_size() {
    const { text: text2 } = this.model;
    const graphics = new TextBox({ text: text2 });
    graphics.visuals = this.visuals.text.values();
    const size2 = graphics.size();
    const { padding: padding2 } = this;
    const width = size2.width + padding2.left + padding2.right;
    const height = size2.height + padding2.top + padding2.bottom;
    return { width, height: height == 0 ? 0 : 2 + height + this.model.standoff };
  }
};
__publicField(HTMLTitleView, "__name__", "HTMLTitleView");
var _HTMLTitle = class _HTMLTitle extends TextAnnotation2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HTMLTitle, "__name__", "HTMLTitle");
_HTMLTitle.prototype.default_view = HTMLTitleView;
_HTMLTitle.mixins([
  Text,
  ["border_", Line],
  ["background_", Fill],
  ["background_", Hatch]
]);
_HTMLTitle.define(({ Float: Float2, Str: Str2 }) => ({
  text: [Str2, ""],
  vertical_align: [VerticalAlign, "bottom"],
  align: [TextAlign, "left"],
  offset: [Float2, 0],
  standoff: [Float2, 10]
}));
_HTMLTitle.prototype._props.text_align.options.internal = true;
_HTMLTitle.prototype._props.text_baseline.options.internal = true;
_HTMLTitle.override({
  text_font_size: "13px",
  text_font_style: "bold",
  text_line_height: 1,
  background_fill_color: null,
  background_hatch_color: null,
  border_line_color: null
});
var HTMLTitle = _HTMLTitle;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/customjs.js
var _CustomJS = class _CustomJS extends Callback {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_state", null);
  }
  connect_signals() {
    super.connect_signals();
    const { args, code: code2, module: module2 } = this.properties;
    this.on_change([args, code2, module2], () => this._state = null);
  }
  async _compile_module() {
    const url = URL.createObjectURL(new Blob([this.code], { type: "text/javascript" }));
    try {
      const module = await eval(`import("${url}")`);
      if (isFunction(module.default)) {
        return module.default;
      } else {
        logger.warn("custom ES module didn't export a default function");
        return () => void 0;
      }
    } finally {
      URL.revokeObjectURL(url);
    }
  }
  async _compile_function() {
    const [names4 = [], values2 = []] = unzip(entries(this.args));
    const code2 = use_strict(this.code);
    const func = new Function(...names4, "cb_obj", "cb_data", "cb_context", code2);
    return function(...args) {
      return func.call(this, ...values2, ...args);
    };
  }
  _is_es_module(code2) {
    return code2.split("\n").some((line) => line.trimStart().startsWith("export default"));
  }
  async _compile() {
    const module2 = (() => {
      if (this.module == "auto") {
        return this._is_es_module(this.code);
      } else {
        return this.module;
      }
    })();
    if (module2) {
      return { func: await this._compile_module(), module: module2 };
    } else {
      return { func: await this._compile_function(), module: module2 };
    }
  }
  async state() {
    if (this._state == null) {
      this._state = await this._compile();
    }
    return this._state;
  }
  async execute(obj, data3 = {}) {
    const { func, module: module2 } = await this.state();
    const context = { index };
    if (module2) {
      return func(to_object(this.args), obj, data3, context);
    } else {
      return func.call(obj, obj, data3, context);
    }
  }
};
__publicField(_CustomJS, "__name__", "CustomJS");
_CustomJS.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2, Auto: Auto2, Or: Or2, Bool: Bool2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2],
  module: [Or2(Auto2, Bool2), "auto"]
}));
var CustomJS = _CustomJS;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/open_url.js
var _OpenURL = class _OpenURL extends Callback {
  constructor(attrs) {
    super(attrs);
  }
  navigate(url2) {
    if (this.same_tab) {
      window.location.href = url2;
    } else {
      window.open(url2);
    }
  }
  execute(_cb_obj, { source: source2 }) {
    const open_url = (i2) => {
      const url2 = replace_placeholders(this.url, source2, i2, void 0, void 0, encodeURI);
      if (!isString(url2)) {
        throw new Error("HTML output is not supported in this context");
      }
      this.navigate(url2);
    };
    const { selected } = source2;
    for (const i2 of selected.indices) {
      open_url(i2);
    }
    for (const i2 of selected.line_indices) {
      open_url(i2);
    }
  }
};
__publicField(_OpenURL, "__name__", "OpenURL");
_OpenURL.define(({ Bool: Bool2, Str: Str2 }) => ({
  url: [Str2, "http://"],
  same_tab: [Bool2, false]
}));
var OpenURL = _OpenURL;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/set_value.js
var _SetValue = class _SetValue extends Callback {
  constructor(attrs) {
    super(attrs);
  }
  execute() {
    const { obj, attr: attr2, value: value2 } = this;
    if (attr2 in obj.properties) {
      obj.setv({ [attr2]: value2 });
    } else {
      logger.error(`${obj.type}.${attr2} is not a property`);
    }
  }
};
__publicField(_SetValue, "__name__", "SetValue");
_SetValue.define(({ Str: Str2, Unknown: Unknown2, Ref: Ref2 }) => ({
  obj: [Ref2(HasProps)],
  attr: [Str2],
  value: [Unknown2]
}));
var SetValue = _SetValue;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/toggle_visibility.js
var _ToggleVisibility = class _ToggleVisibility extends Callback {
  constructor(attrs) {
    super(attrs);
  }
  execute() {
    const { target } = this;
    target.visible = !target.visible;
  }
};
__publicField(_ToggleVisibility, "__name__", "ToggleVisibility");
_ToggleVisibility.define(({ Ref: Ref2 }) => ({
  target: [Ref2(UIElement)]
}));
var ToggleVisibility = _ToggleVisibility;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/text.js
var TextView = class extends DOMNodeView {
  render() {
    this.el.textContent = this.model.content;
  }
  // TODO This shouldn't be here.
  after_render() {
    this.finish();
  }
  _create_element() {
    return document.createTextNode("");
  }
};
__publicField(TextView, "__name__", "TextView");
var _Text = class _Text extends DOMNode {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Text, "__name__", "Text");
_Text.prototype.default_view = TextView;
_Text.define(({ Str: Str2 }) => ({
  content: [Str2, ""]
}));
var Text3 = _Text;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/dialog.js
import dialogs_css, * as dialogs from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/dialogs.css.js";
import icons_css5 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var base_z_index = 1e3;
var UIElementLike = Or(Ref(UIElement), Ref(DOMNode));
var _stacking_order = [];
var _minimization_area = (() => {
  const el = div();
  const shadow_el = el.attachShadow({ mode: "open" });
  const stylesheet2 = new InlineStyleSheet(`
:host {
  display: flex;
  flex-direction: column;
  flex-wrap: nowrap;
  position: fixed;
  left: 0;
  bottom: 0;
  width: max-content;
  height: max-content;
}
:host:empty {
  display: none;
}
`);
  stylesheet2.install(shadow_el);
  void dom_ready().then(() => document.body.append(el));
  return el;
})();
var DialogView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_title");
    __publicField(this, "_content");
    __publicField(this, "_position", new InlineStyleSheet());
    __publicField(this, "_stacking", new InlineStyleSheet());
    __publicField(this, "_has_rendered", false);
    __publicField(this, "_handles");
    __publicField(this, "_pin_el");
    __publicField(this, "_collapse_el");
    __publicField(this, "_minimize_el");
    __publicField(this, "_maximize_el");
    __publicField(this, "_close_el");
    __publicField(this, "_pinned", false);
    __publicField(this, "_normal_bbox", null);
    __publicField(this, "_collapsed", false);
    __publicField(this, "_minimized", false);
    __publicField(this, "_maximized", false);
  }
  *children() {
    yield* super.children();
    yield this._title;
    yield this._content;
  }
  stylesheets() {
    return [...super.stylesheets(), dialogs_css, icons_css5, this._position, this._stacking];
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const title3 = (() => {
      const { title: title4 } = this.model;
      return isString(title4) || title4 == null ? new Text3({ content: title4 ?? "" }) : title4;
    })();
    const content2 = (() => {
      const { content: content3 } = this.model;
      return isString(content3) ? new Text3({ content: content3 }) : content3;
    })();
    this._title = await build_view(title3, { parent: this });
    this._content = await build_view(content2, { parent: this });
  }
  connect_signals() {
    super.connect_signals();
    const { visible } = this.model.properties;
    this.connect(visible.change, () => this._toggle(this.model.visible));
  }
  remove() {
    remove2(_stacking_order, this);
    this._content.remove();
    this._title.remove();
    super.remove();
  }
  _reposition(position2) {
    this._position.replace(":host", {
      left: "left" in position2 ? px(position2.left) : "unset",
      right: "right" in position2 ? px(position2.right) : "unset",
      top: "top" in position2 ? px(position2.top) : "unset",
      bottom: "bottom" in position2 ? px(position2.bottom) : "unset",
      width: "width" in position2 ? px(position2.width) : "unset",
      height: "height" in position2 ? px(position2.height) : "unset"
    });
    this.update_bbox();
  }
  render() {
    super.render();
    this._title.render();
    this._content.render();
    const inner_el = div({ class: dialogs.inner });
    this.shadow_el.append(inner_el);
    const header_el = div({ class: dialogs.header });
    const content_el = div({ class: dialogs.content }, this._content.el);
    const footer_el = div({ class: dialogs.footer });
    inner_el.append(header_el);
    inner_el.append(content_el);
    inner_el.append(footer_el);
    const grip_el = div({ class: dialogs.grip });
    const title_el = div({ class: dialogs.title }, grip_el, this._title.el);
    const controls_el = div({ class: dialogs.controls });
    header_el.append(title_el, controls_el);
    const pin_el = div({ class: [dialogs.ctrl, dialogs.pin], title: "Pin" });
    pin_el.addEventListener("click", () => this.pin());
    this._pin_el = pin_el;
    const collapse_el = div({ class: [dialogs.ctrl, dialogs.collapse], title: "Collapse" });
    collapse_el.addEventListener("click", () => this.collapse());
    this._collapse_el = collapse_el;
    const minimize_el = div({ class: [dialogs.ctrl, dialogs.minimize], title: "Minimize" });
    minimize_el.addEventListener("click", () => this.minimize());
    this._minimize_el = minimize_el;
    const maximize_el = div({ class: [dialogs.ctrl, dialogs.maximize], title: "Maximize" });
    maximize_el.addEventListener("click", () => this.maximize());
    this._maximize_el = maximize_el;
    const close_el = div({ class: [dialogs.ctrl, dialogs.close], title: "Close" });
    close_el.addEventListener("click", () => this.close());
    this._close_el = close_el;
    if (this.model.pinnable) {
      controls_el.append(pin_el);
    }
    if (this.model.collapsible) {
      controls_el.append(collapse_el);
    }
    if (this.model.minimizable) {
      controls_el.append(minimize_el);
    }
    if (this.model.maximizable) {
      controls_el.append(maximize_el);
    }
    if (this.model.closable) {
      controls_el.append(close_el);
    }
    const handles = this._handles = {
      // area
      area: title_el,
      // edges
      top: div({ class: [dialogs.handle, dialogs.resize_top] }),
      bottom: div({ class: [dialogs.handle, dialogs.resize_bottom] }),
      left: div({ class: [dialogs.handle, dialogs.resize_left] }),
      right: div({ class: [dialogs.handle, dialogs.resize_right] }),
      // corners
      top_left: div({ class: [dialogs.handle, dialogs.resize_top_left] }),
      top_right: div({ class: [dialogs.handle, dialogs.resize_top_right] }),
      bottom_left: div({ class: [dialogs.handle, dialogs.resize_bottom_left] }),
      bottom_right: div({ class: [dialogs.handle, dialogs.resize_bottom_right] })
    };
    this.shadow_el.append(handles.top, handles.bottom, handles.left, handles.right, handles.top_left, handles.top_right, handles.bottom_left, handles.bottom_right);
    let state = null;
    const cancel = () => {
      state = null;
      document.removeEventListener("pointermove", pointer_move);
      document.removeEventListener("pointerup", pointer_up);
      document.removeEventListener("keydown", key_press);
      this.el.classList.remove(dialogs.interacting);
    };
    const pointer_move = (event2) => {
      assert(state != null);
      event2.preventDefault();
      this.el.classList.add(dialogs.interacting);
      const dx = event2.x - state.xy.x;
      const dy = event2.y - state.xy.y;
      const { target, bbox } = state;
      const delta_bbox = this._move_bbox(target, bbox, dx, dy);
      this._reposition(delta_bbox);
    };
    const pointer_up = (event2) => {
      assert(state != null);
      event2.preventDefault();
      cancel();
    };
    const key_press = (event2) => {
      if (event2.key == "Escape") {
        assert(state != null);
        event2.preventDefault();
        const { left: left2, top, width, height } = state.bbox;
        this._reposition({ left: left2, top, width, height });
        cancel();
      }
    };
    this.el.addEventListener("pointerdown", (event2) => {
      assert(state == null);
      this.bring_to_front();
      const target = this._hit_target(event2.composedPath());
      if (target == null || !this._can_hit(target)) {
        return;
      }
      event2.preventDefault();
      const { x: x2, y: y2 } = event2;
      state = {
        bbox: bounding_box(this.el),
        xy: { x: x2, y: y2 },
        target
      };
      document.addEventListener("pointermove", pointer_move);
      document.addEventListener("pointerup", pointer_up);
      document.addEventListener("keydown", key_press);
      const target_el = this._handles[target];
      target_el.setPointerCapture(event2.pointerId);
    });
    title_el.addEventListener("wheel", (event2) => {
      const dy = event2.deltaY;
      if (dy < 0 && !this._collapsed || dy > 0 && this._collapsed) {
        event2.preventDefault();
        event2.stopPropagation();
        this.collapse();
      }
    });
    this._has_rendered = true;
    if (this.model.visible) {
      this.bring_to_front();
    }
  }
  get resizable() {
    const { resizable } = this.model;
    return {
      left: resizable == "left" || resizable == "x" || resizable == "all",
      right: resizable == "right" || resizable == "x" || resizable == "all",
      top: resizable == "top" || resizable == "y" || resizable == "all",
      bottom: resizable == "bottom" || resizable == "y" || resizable == "all"
    };
  }
  _hit_target(path) {
    const { _handles } = this;
    for (const el of path) {
      switch (el) {
        case _handles.area:
          return "area";
        case _handles.top:
          return "top";
        case _handles.bottom:
          return "bottom";
        case _handles.left:
          return "left";
        case _handles.right:
          return "right";
        case _handles.top_left:
          return "top_left";
        case _handles.top_right:
          return "top_right";
        case _handles.bottom_left:
          return "bottom_left";
        case _handles.bottom_right:
          return "bottom_right";
      }
    }
    return null;
  }
  _can_hit(target) {
    if (this._minimized || this._maximized) {
      return false;
    }
    const { left: left2, right: right3, top, bottom } = this.resizable;
    switch (target) {
      case "top_left":
        return top && left2;
      case "top_right":
        return top && right3;
      case "bottom_left":
        return bottom && left2;
      case "bottom_right":
        return bottom && right3;
      case "left":
        return left2;
      case "right":
        return right3;
      case "top":
        return top;
      case "bottom":
        return bottom;
      case "area":
        return this.model.movable != "none";
    }
  }
  _move_bbox(target, bbox, dx, dy) {
    const resolve = (dim, limit2) => {
      if (limit2 instanceof Coordinate) {
        return this.resolve_as_scalar(limit2, dim);
      } else {
        return NaN;
      }
    };
    const slimits = BBox.from_lrtb({
      left: resolve("x", this.model.left_limit),
      right: resolve("x", this.model.right_limit),
      top: resolve("y", this.model.top_limit),
      bottom: resolve("y", this.model.bottom_limit)
    });
    const [dl2, dr, dt2, db] = (() => {
      const { symmetric } = this.model;
      const [Dx, Dy] = symmetric ? [-dx, -dy] : [0, 0];
      switch (target) {
        case "top_left":
          return [dx, Dx, dy, Dy];
        case "top_right":
          return [Dx, dx, dy, Dy];
        case "bottom_left":
          return [dx, Dx, Dy, dy];
        case "bottom_right":
          return [Dx, dx, Dy, dy];
        case "left":
          return [dx, Dx, 0, 0];
        case "right":
          return [Dx, dx, 0, 0];
        case "top":
          return [0, 0, dy, Dy];
        case "bottom":
          return [0, 0, Dy, dy];
        case "area": {
          switch (this.model.movable) {
            case "both":
              return [dx, dx, dy, dy];
            case "x":
              return [dx, dx, 0, 0];
            case "y":
              return [0, 0, dy, dy];
            case "none":
              return [0, 0, 0, 0];
          }
        }
      }
    })();
    const min10 = (a2, b2) => min([a2, b2]);
    const sgn = (v) => v < 0 ? -1 : v > 0 ? 1 : 0;
    let { left: left2, right: right3, left_sign, right_sign } = (() => {
      const left3 = bbox.left + dl2;
      const right4 = bbox.right + dr;
      const left_sign2 = sgn(dl2);
      const right_sign2 = sgn(dr);
      if (left3 <= right4) {
        return { left: left3, right: right4, left_sign: left_sign2, right_sign: right_sign2 };
      } else {
        return { left: right4, right: left3, left_sign: right_sign2, right_sign: left_sign2 };
      }
    })();
    let { top, bottom, top_sign, bottom_sign } = (() => {
      const top2 = bbox.top + dt2;
      const bottom2 = bbox.bottom + db;
      const top_sign2 = sgn(dt2);
      const bottom_sign2 = sgn(db);
      if (top2 <= bottom2) {
        return { top: top2, bottom: bottom2, top_sign: top_sign2, bottom_sign: bottom_sign2 };
      } else {
        return { top: bottom2, bottom: top2, top_sign: bottom_sign2, bottom_sign: top_sign2 };
      }
    })();
    const Dl = left2 - slimits.left;
    const Dr = slimits.right - right3;
    const Dh = min10(Dl < 0 ? Dl : NaN, Dr < 0 ? Dr : NaN);
    if (isFinite(Dh) && Dh < 0) {
      left2 += -left_sign * -Dh;
      right3 += -right_sign * -Dh;
    }
    const Dt = top - slimits.top;
    const Db = slimits.bottom - bottom;
    const Dv = min10(Dt < 0 ? Dt : NaN, Db < 0 ? Db : NaN);
    if (isFinite(Dv) && Dv < 0) {
      top += -top_sign * -Dv;
      bottom += -bottom_sign * -Dv;
    }
    return BBox.from_lrtb({ left: left2, right: right3, top, bottom });
  }
  pin() {
    const { _pinned } = this;
    for (const dialog_view of _stacking_order) {
      if (dialog_view == this) {
        this._pin(!_pinned);
      } else {
        dialog_view._pin(false);
      }
    }
    if (!_pinned) {
      this.bring_to_front();
    }
  }
  _pin(value2) {
    if (this._pinned != value2) {
      this._pinned = value2;
      this.el.classList.toggle(dialogs.pinned, this._pinned);
      this._pin_el.title = this._pinned ? "Unpin" : "Pin";
    }
  }
  collapse() {
    const position2 = (() => {
      if (!this._collapsed) {
        this._minimize(false);
        this._maximize(false);
        if (this._normal_bbox == null) {
          this._normal_bbox = bounding_box(this.el);
        }
        const { left: left2, top, width } = this._normal_bbox;
        return { left: left2, top, width, height: "max-content" };
      } else {
        const { _normal_bbox } = this;
        assert(_normal_bbox != null);
        this._normal_bbox = null;
        return _normal_bbox;
      }
    })();
    this._reposition(position2);
    this._collapse(!this._collapsed);
  }
  _collapse(value2) {
    if (this._collapsed != value2) {
      this._collapsed = value2;
      this.el.classList.toggle(dialogs.collapsed, this._collapsed);
      this._collapse_el.title = this._collapsed ? "Restore" : "Collapse";
    }
  }
  minimize() {
    const position2 = (() => {
      if (!this._minimized) {
        this._pin(false);
        this._collapse(false);
        this._maximize(false);
        if (this._normal_bbox == null) {
          this._normal_bbox = bounding_box(this.el);
        }
        return { width: "auto", height: "max-content" };
      } else {
        const { _normal_bbox } = this;
        assert(_normal_bbox != null);
        this._normal_bbox = null;
        return _normal_bbox;
      }
    })();
    this._reposition(position2);
    this._minimize(!this._minimized);
  }
  _minimize(value2) {
    if (this._minimized != value2) {
      this._minimized = value2;
      const target = value2 ? _minimization_area.shadowRoot ?? _minimization_area : document.body;
      target.append(this.el);
      this.el.classList.toggle(dialogs.minimized, this._minimized);
      this._minimize_el.title = this._minimized ? "Restore" : "Minimize";
    }
  }
  maximize() {
    const position2 = (() => {
      if (!this._maximized) {
        this._collapse(false);
        this._minimize(false);
        if (this._normal_bbox == null) {
          this._normal_bbox = bounding_box(this.el);
        }
        return { left: 0, top: 0, width: "100%", height: "100%" };
      } else {
        const { _normal_bbox } = this;
        assert(_normal_bbox != null);
        this._normal_bbox = null;
        return _normal_bbox;
      }
    })();
    this._reposition(position2);
    this._maximize(!this._maximized);
  }
  _maximize(value2) {
    if (this._maximized != value2) {
      this._maximized = value2;
      this.el.classList.toggle(dialogs.maximized, this._maximized);
      this._maximize_el.title = this._maximized ? "Restore" : "Maximize";
    }
  }
  restore() {
    this._collapse(false);
    this._minimize(false);
    this._maximize(false);
    const { _normal_bbox } = this;
    if (_normal_bbox != null) {
      this._reposition(_normal_bbox);
      this._normal_bbox = null;
    }
  }
  _toggle(show3) {
    if (show3) {
      if (!this._has_rendered) {
        this.render_to(document.body);
        this.r_after_render();
      }
      this.bring_to_front();
    } else {
      remove2(_stacking_order, this);
      this.el.remove();
    }
  }
  open() {
    this.model.setv({ visible: true }, { check_eq: false });
  }
  close() {
    switch (this.model.close_action) {
      case "hide": {
        this.model.visible = false;
        break;
      }
      case "destroy": {
        this.remove();
        break;
      }
    }
  }
  bring_to_front() {
    if (!_stacking_order.includes(this)) {
      _stacking_order.push(this);
    }
    const pinned2 = find(_stacking_order, (view) => view._pinned);
    if (pinned2 != null) {
      remove2(_stacking_order, pinned2);
    }
    remove2(_stacking_order, this);
    _stacking_order.push(this);
    if (pinned2 != null) {
      _stacking_order.push(pinned2);
    }
    for (const [dialog_view, i2] of enumerate(_stacking_order)) {
      dialog_view._stacking.replace(":host", {
        "z-index": `${base_z_index + i2}`
      });
    }
  }
};
__publicField(DialogView, "__name__", "DialogView");
var _Dialog = class _Dialog extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Dialog, "__name__", "Dialog");
_Dialog.prototype.default_view = DialogView;
_Dialog.define(({ Bool: Bool2, Str: Str2, Ref: Ref2, Or: Or2, Nullable: Nullable2, Enum: Enum2 }) => ({
  title: [Nullable2(Or2(Str2, Ref2(DOMNode), Ref2(UIElement))), null],
  content: [Or2(Str2, Ref2(DOMNode), Ref2(UIElement))],
  pinnable: [Bool2, true],
  collapsible: [Bool2, true],
  minimizable: [Bool2, true],
  maximizable: [Bool2, true],
  closable: [Bool2, true],
  close_action: [Enum2("hide", "destroy"), "destroy"],
  resizable: [Resizable, "all"],
  movable: [Movable, "both"],
  symmetric: [Bool2, false],
  top_limit: [Limit, null],
  bottom_limit: [Limit, null],
  left_limit: [Limit, null],
  right_limit: [Limit, null]
}));
var Dialog = _Dialog;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/open_dialog.js
var _OpenDialog = class _OpenDialog extends Callback {
  constructor(attrs) {
    super(attrs);
  }
  async execute() {
    var _a34;
    const { dialog: dialog2 } = this;
    const views = (_a34 = dialog2.document) == null ? void 0 : _a34.views_manager;
    if (views != null) {
      let dialog_view = views.find_one(dialog2);
      if (dialog_view == null) {
        dialog_view = await views.build_view(dialog2);
      }
      dialog_view.open();
    }
  }
};
__publicField(_OpenDialog, "__name__", "OpenDialog");
_OpenDialog.define(({ Ref: Ref2 }) => ({
  dialog: [Ref2(Dialog)]
}));
var OpenDialog = _OpenDialog;

// node_modules/@bokeh/bokehjs/build/js/lib/models/callbacks/close_dialog.js
var _CloseDialog = class _CloseDialog extends Callback {
  constructor(attrs) {
    super(attrs);
  }
  async execute() {
    var _a34, _b4, _c;
    const { dialog: dialog2 } = this;
    (_c = (_b4 = (_a34 = dialog2.document) == null ? void 0 : _a34.views_manager) == null ? void 0 : _b4.find_one(dialog2)) == null ? void 0 : _c.close();
  }
};
__publicField(_CloseDialog, "__name__", "CloseDialog");
_CloseDialog.define(({ Ref: Ref2 }) => ({
  dialog: [Ref2(Dialog)]
}));
var CloseDialog = _CloseDialog;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/wheel.js
function fontSize(element) {
  const value2 = getComputedStyle(element).fontSize;
  const size2 = parseInt(value2, 10);
  return isNaN(size2) ? null : size2;
}
function lineHeight(element) {
  const parent = element.offsetParent ?? document.body;
  return fontSize(parent) ?? fontSize(element) ?? 16;
}
function pageHeight(element) {
  return element.clientHeight;
}
function getDeltaY(event2) {
  let deltaY = -event2.deltaY;
  if (event2.target instanceof HTMLElement) {
    switch (event2.deltaMode) {
      case event2.DOM_DELTA_LINE:
        deltaY *= lineHeight(event2.target);
        break;
      case event2.DOM_DELTA_PAGE:
        deltaY *= pageHeight(event2.target);
        break;
    }
  }
  return deltaY;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/ui_events.js
function is_Moveable(obj) {
  return isObject(obj) && "on_enter" in obj && "on_move" in obj && "on_leave" in obj;
}
function is_Pannable(obj) {
  return isObject(obj) && "on_pan_start" in obj && "on_pan" in obj && "on_pan_end" in obj;
}
function is_Pinchable(obj) {
  return isObject(obj) && "on_pinch_start" in obj && "on_pinch" in obj && "on_pinch_end" in obj;
}
function is_Rotatable(obj) {
  return isObject(obj) && "on_rotate_start" in obj && "on_rotate" in obj && "on_rotate_end" in obj;
}
var UIEventBus = class {
  constructor(canvas_view) {
    __publicField(this, "canvas_view");
    __publicField(this, "pan_start", new Signal(this, "pan:start"));
    __publicField(this, "pan", new Signal(this, "pan"));
    __publicField(this, "pan_end", new Signal(this, "pan:end"));
    __publicField(this, "pinch_start", new Signal(this, "pinch:start"));
    __publicField(this, "pinch", new Signal(this, "pinch"));
    __publicField(this, "pinch_end", new Signal(this, "pinch:end"));
    __publicField(this, "rotate_start", new Signal(this, "rotate:start"));
    __publicField(this, "rotate", new Signal(this, "rotate"));
    __publicField(this, "rotate_end", new Signal(this, "rotate:end"));
    __publicField(this, "tap", new Signal(this, "tap"));
    __publicField(this, "doubletap", new Signal(this, "doubletap"));
    __publicField(this, "press", new Signal(this, "press"));
    __publicField(this, "pressup", new Signal(this, "pressup"));
    __publicField(this, "move_enter", new Signal(this, "move:enter"));
    __publicField(this, "move", new Signal(this, "move"));
    __publicField(this, "move_exit", new Signal(this, "move:exit"));
    __publicField(this, "scroll", new Signal(this, "scroll"));
    __publicField(this, "keydown", new Signal(this, "keydown"));
    __publicField(this, "keyup", new Signal(this, "keyup"));
    __publicField(this, "hit_area");
    __publicField(this, "ui_gestures");
    __publicField(this, "_tools", /* @__PURE__ */ new Map());
    __publicField(this, "_prev_move", null);
    __publicField(this, "_curr_pan", null);
    __publicField(this, "_curr_pinch", null);
    __publicField(this, "_curr_rotate", null);
    __publicField(this, "_current_pan_view", null);
    __publicField(this, "_current_pinch_view", null);
    __publicField(this, "_current_rotate_view", null);
    __publicField(this, "_current_move_views", []);
    this.canvas_view = canvas_view;
    this.hit_area = canvas_view.events_el;
    this.on_tap = this.on_tap.bind(this);
    this.on_doubletap = this.on_doubletap.bind(this);
    this.on_press = this.on_press.bind(this);
    this.on_pressup = this.on_pressup.bind(this);
    this.on_enter = this.on_enter.bind(this);
    this.on_move = this.on_move.bind(this);
    this.on_leave = this.on_leave.bind(this);
    this.on_pan_start = this.on_pan_start.bind(this);
    this.on_pan = this.on_pan.bind(this);
    this.on_pan_end = this.on_pan_end.bind(this);
    this.on_pinch_start = this.on_pinch_start.bind(this);
    this.on_pinch = this.on_pinch.bind(this);
    this.on_pinch_end = this.on_pinch_end.bind(this);
    this.on_rotate_start = this.on_rotate_start.bind(this);
    this.on_rotate = this.on_rotate.bind(this);
    this.on_rotate_end = this.on_rotate_end.bind(this);
    this.ui_gestures = new UIGestures(this.hit_area, this, { must_be_target: true });
    this.ui_gestures.connect_signals();
    this.on_context_menu = this.on_context_menu.bind(this);
    this.on_mouse_wheel = this.on_mouse_wheel.bind(this);
    this.on_key_down = this.on_key_down.bind(this);
    this.on_key_up = this.on_key_up.bind(this);
    this.hit_area.addEventListener("contextmenu", this.on_context_menu);
    this.hit_area.addEventListener("wheel", this.on_mouse_wheel);
    document.addEventListener("keydown", this.on_key_down);
    document.addEventListener("keyup", this.on_key_up);
  }
  remove() {
    this.ui_gestures.remove();
    this.hit_area.removeEventListener("contextmenu", this.on_context_menu);
    this.hit_area.removeEventListener("wheel", this.on_mouse_wheel);
    document.removeEventListener("keydown", this.on_key_down);
    document.removeEventListener("keyup", this.on_key_up);
  }
  register_tool(tool_view) {
    const { model: tool } = tool_view;
    if (this._tools.has(tool)) {
      throw new Error(`${tool} already registered`);
    } else {
      this._tools.set(tool, tool_view);
    }
  }
  hit_test_renderers(plot_view, sx, sy) {
    var _a34;
    const collected = [];
    for (const view of reversed(plot_view.all_renderer_views)) {
      if (((_a34 = view.interactive_hit) == null ? void 0 : _a34.call(view, sx, sy)) ?? false) {
        collected.push(view);
      }
    }
    return collected;
  }
  set_cursor(cursor) {
    this.hit_area.style.cursor = cursor ?? "default";
  }
  hit_test_frame(plot_view, sx, sy) {
    return plot_view.frame.bbox.contains(sx, sy);
  }
  hit_test_plot(sx, sy) {
    for (const plot_view of this.canvas_view.plot_views) {
      if (plot_view.bbox.relative().contains(sx, sy)) {
        return plot_view;
      }
    }
    return null;
  }
  _trigger(signal, e) {
    var _a34;
    if (!this.hit_area.isConnected) {
      return;
    }
    const { sx, sy, native: srcEvent } = e;
    const plot_view = this.hit_test_plot(sx, sy);
    const curr_view = plot_view;
    const relativize_event = (_plot_view) => {
      const [rel_sx, rel_sy] = [sx, sy];
      return { ...e, sx: rel_sx, sy: rel_sy };
    };
    if (e.type == "pan_start" || e.type == "pan" || e.type == "pan_end") {
      let pan_view;
      if (e.type == "pan_start" && curr_view != null) {
        this._curr_pan = { plot_view: curr_view };
        pan_view = curr_view;
      } else if (e.type == "pan" && this._curr_pan != null) {
        pan_view = this._curr_pan.plot_view;
      } else if (e.type == "pan_end" && this._curr_pan != null) {
        pan_view = this._curr_pan.plot_view;
        this._curr_pan = null;
      } else {
        pan_view = null;
      }
      if (pan_view != null) {
        const event2 = relativize_event(pan_view);
        this.__trigger(pan_view, signal, event2, srcEvent);
      }
    } else if (e.type == "pinch_start" || e.type == "pinch" || e.type == "pinch_end") {
      let pinch_view;
      if (e.type == "pinch_start" && curr_view != null) {
        this._curr_pinch = { plot_view: curr_view };
        pinch_view = curr_view;
      } else if (e.type == "pinch" && this._curr_pinch != null) {
        pinch_view = this._curr_pinch.plot_view;
      } else if (e.type == "pinch_end" && this._curr_pinch != null) {
        pinch_view = this._curr_pinch.plot_view;
        this._curr_pinch = null;
      } else {
        pinch_view = null;
      }
      if (pinch_view != null) {
        const event2 = relativize_event(pinch_view);
        this.__trigger(pinch_view, signal, event2, srcEvent);
      }
    } else if (e.type == "rotate_start" || e.type == "rotate" || e.type == "rotate_end") {
      let rotate_view;
      if (e.type == "rotate_start" && curr_view != null) {
        this._curr_rotate = { plot_view: curr_view };
        rotate_view = curr_view;
      } else if (e.type == "rotate" && this._curr_rotate != null) {
        rotate_view = this._curr_rotate.plot_view;
      } else if (e.type == "rotate_end" && this._curr_rotate != null) {
        rotate_view = this._curr_rotate.plot_view;
        this._curr_rotate = null;
      } else {
        rotate_view = null;
      }
      if (rotate_view != null) {
        const event2 = relativize_event(rotate_view);
        this.__trigger(rotate_view, signal, event2, srcEvent);
      }
    } else if (e.type == "enter" || e.type == "move" || e.type == "leave") {
      const prev_view = (_a34 = this._prev_move) == null ? void 0 : _a34.plot_view;
      if (prev_view != null && (e.type == "leave" || prev_view != curr_view)) {
        const { sx: sx2, sy: sy2 } = relativize_event(prev_view);
        this.__trigger(prev_view, this.move_exit, { type: "leave", sx: sx2, sy: sy2, modifiers: { shift: false, ctrl: false, alt: false }, native: srcEvent }, srcEvent);
      }
      if (curr_view != null && (e.type == "enter" || prev_view != curr_view)) {
        const { sx: sx2, sy: sy2 } = relativize_event(curr_view);
        this.__trigger(curr_view, this.move_enter, { type: "enter", sx: sx2, sy: sy2, modifiers: { shift: false, ctrl: false, alt: false }, native: srcEvent }, srcEvent);
      }
      if (curr_view != null && e.type == "move") {
        const event2 = relativize_event(curr_view);
        this.__trigger(curr_view, signal, event2, srcEvent);
      }
      this._prev_move = { sx, sy, plot_view: curr_view };
    } else {
      if (curr_view != null) {
        const event2 = relativize_event(curr_view);
        this.__trigger(curr_view, signal, event2, srcEvent);
      }
    }
  }
  __trigger(plot_view, signal, e, srcEvent) {
    var _a34;
    const gestures = plot_view.model.toolbar.gestures;
    const event_type = signal.name;
    const base_type = event_type.split(":")[0];
    const views = this.hit_test_renderers(plot_view, e.sx, e.sy);
    if (base_type == "pan") {
      const event2 = e;
      if (this._current_pan_view == null) {
        if (event_type == "pan:start") {
          for (const view of views) {
            if (!is_Pannable(view)) {
              continue;
            }
            if (view.on_pan_start(event2)) {
              this._current_pan_view = view;
              srcEvent.preventDefault();
              return;
            }
          }
        }
      } else {
        if (event_type == "pan") {
          this._current_pan_view.on_pan(event2);
        } else if (event_type == "pan:end") {
          this._current_pan_view.on_pan_end(event2);
          this._current_pan_view = null;
        }
        srcEvent.preventDefault();
        return;
      }
    } else if (base_type == "pinch") {
      const event2 = e;
      if (this._current_pinch_view == null) {
        if (event_type == "pinch:start") {
          for (const view of views) {
            if (!is_Pinchable(view)) {
              continue;
            }
            if (view.on_pinch_start(event2)) {
              this._current_pinch_view = view;
              srcEvent.preventDefault();
              return;
            }
          }
        }
      } else {
        if (event_type == "pinch") {
          this._current_pinch_view.on_pinch(event2);
        } else if (event_type == "pinch:end") {
          this._current_pinch_view.on_pinch_end(event2);
          this._current_pinch_view = null;
        }
        srcEvent.preventDefault();
        return;
      }
    } else if (base_type == "rotate") {
      const event2 = e;
      if (this._current_rotate_view == null) {
        if (event_type == "rotate:start") {
          for (const view of views) {
            if (!is_Rotatable(view)) {
              continue;
            }
            if (view.on_rotate_start(event2)) {
              this._current_rotate_view = view;
              srcEvent.preventDefault();
              return;
            }
          }
        }
      } else {
        if (event_type == "rotate") {
          this._current_rotate_view.on_rotate(event2);
        } else if (event_type == "rotate:end") {
          this._current_rotate_view.on_rotate_end(event2);
          this._current_rotate_view = null;
        }
        srcEvent.preventDefault();
        return;
      }
    } else if (base_type == "move") {
      const event2 = e;
      const new_views = new Set(views);
      const current_views = new Set(this._current_move_views);
      this._current_move_views = [];
      for (const view of current_views) {
        if (!new_views.has(view)) {
          current_views.delete(view);
          view.on_leave(event2);
        }
      }
      for (const view of views) {
        if (!is_Moveable(view)) {
          continue;
        }
        if (!current_views.has(view)) {
          if (view.on_enter(e)) {
            this._current_move_views.push(view);
          }
        } else {
          this._current_move_views.push(view);
          view.on_move(event2);
        }
      }
    }
    function get_tool_view(tool_like) {
      if (tool_like != null) {
        const tool = tool_like instanceof ToolProxy ? tool_like.tools[0] : tool_like;
        return plot_view.tool_views.get(tool) ?? null;
      } else {
        return null;
      }
    }
    const top_view = views.at(0);
    switch (base_type) {
      case "move": {
        const active_gesture = gestures.move.active;
        if (active_gesture != null) {
          this.trigger(signal, e, active_gesture);
        }
        const active_inspectors = plot_view.model.toolbar.inspectors.filter((t) => t.active);
        const cursor = (() => {
          const current_view = this._current_pan_view ?? this._current_pinch_view ?? this._current_rotate_view ?? this._current_move_views.at(0) ?? top_view ?? get_tool_view(active_gesture);
          if (current_view != null) {
            const cursor2 = current_view.cursor(e.sx, e.sy);
            if (cursor2 != null) {
              return cursor2;
            }
          }
          if (this.hit_test_frame(plot_view, e.sx, e.sy) && !is_empty(active_inspectors)) {
            return "crosshair";
          }
          return null;
        })();
        this.set_cursor(cursor);
        if (top_view != null && !top_view.model.propagate_hover && !is_empty(active_inspectors)) {
          signal = this.move_exit;
        }
        active_inspectors.map((inspector) => this.trigger(signal, e, inspector));
        break;
      }
      case "tap": {
        const path = srcEvent.composedPath();
        if (path.length != 0 && path[0] != this.hit_area) {
          return;
        }
        (_a34 = top_view == null ? void 0 : top_view.on_hit) == null ? void 0 : _a34.call(top_view, e.sx, e.sy);
        if (this.hit_test_frame(plot_view, e.sx, e.sy)) {
          const active_gesture = gestures.tap.active;
          if (active_gesture != null) {
            this.trigger(signal, e, active_gesture);
          }
        }
        break;
      }
      case "doubletap": {
        if (this.hit_test_frame(plot_view, e.sx, e.sy)) {
          const active_gesture = gestures.doubletap.active ?? gestures.tap.active;
          if (active_gesture != null) {
            this.trigger(signal, e, active_gesture);
          }
        }
        break;
      }
      case "press": {
        if (this.hit_test_frame(plot_view, e.sx, e.sy)) {
          const active_gesture = gestures.press.active ?? gestures.tap.active;
          if (active_gesture != null) {
            this.trigger(signal, e, active_gesture);
          }
        }
        break;
      }
      case "pinch": {
        const active_gesture = gestures.pinch.active ?? gestures.scroll.active;
        if (active_gesture != null) {
          if (this.trigger(signal, e, active_gesture)) {
            srcEvent.preventDefault();
            srcEvent.stopPropagation();
          }
        }
        break;
      }
      case "scroll": {
        const active_gesture = gestures.scroll.active;
        if (active_gesture != null) {
          if (this.trigger(signal, e, active_gesture)) {
            srcEvent.preventDefault();
            srcEvent.stopPropagation();
          }
        }
        break;
      }
      case "pan": {
        const active_gesture = gestures.pan.active;
        if (active_gesture != null) {
          if (this.trigger(signal, e, active_gesture)) {
            srcEvent.preventDefault();
            srcEvent.stopPropagation();
          }
        }
        break;
      }
      default: {
        const active_gesture = gestures[base_type].active;
        if (active_gesture != null) {
          this.trigger(signal, e, active_gesture);
        }
      }
    }
    this._trigger_bokeh_event(plot_view, e);
  }
  trigger(signal, e, tool = null) {
    const emit = (tool2) => {
      const tool_view = this._tools.get(tool2);
      if (tool_view == null) {
        return false;
      }
      const fn = (() => {
        switch (signal) {
          case this.pan_start:
            return tool_view._pan_start;
          case this.pan:
            return tool_view._pan;
          case this.pan_end:
            return tool_view._pan_end;
          case this.pinch_start:
            return tool_view._pinch_start;
          case this.pinch:
            return tool_view._pinch;
          case this.pinch_end:
            return tool_view._pinch_end;
          case this.rotate_start:
            return tool_view._rotate_start;
          case this.rotate:
            return tool_view._rotate;
          case this.rotate_end:
            return tool_view._rotate_end;
          case this.move_enter:
            return tool_view._move_enter;
          case this.move:
            return tool_view._move;
          case this.move_exit:
            return tool_view._move_exit;
          case this.tap:
            return tool_view._tap;
          case this.doubletap:
            return tool_view._doubletap;
          case this.press:
            return tool_view._press;
          case this.pressup:
            return tool_view._pressup;
          case this.scroll:
            return tool_view._scroll;
          case this.keydown:
            return tool_view._keydown;
          case this.keyup:
            return tool_view._keyup;
          default:
            return null;
        }
      })();
      if (fn == null) {
        return false;
      }
      const val = fn.bind(tool_view)(e);
      if (isBoolean(val)) {
        return val;
      } else {
        return true;
      }
    };
    if (tool != null) {
      return emit(tool);
    } else {
      let result = false;
      for (const tool2 of this._tools.keys()) {
        const emitted = emit(tool2);
        result || (result = emitted);
      }
      return result;
    }
  }
  /*protected*/
  _trigger_bokeh_event(plot_view, ev) {
    const bokeh_event = (() => {
      const { sx, sy, modifiers } = ev;
      const x2 = plot_view.frame.x_scale.invert(sx);
      const y2 = plot_view.frame.y_scale.invert(sy);
      switch (ev.type) {
        case "wheel":
          return new MouseWheel(sx, sy, x2, y2, ev.delta, modifiers);
        case "enter":
          return new MouseEnter(sx, sy, x2, y2, modifiers);
        case "move":
          return new MouseMove(sx, sy, x2, y2, modifiers);
        case "leave":
          return new MouseLeave(sx, sy, x2, y2, modifiers);
        case "tap":
          return new Tap(sx, sy, x2, y2, modifiers);
        case "double_tap":
          return new DoubleTap(sx, sy, x2, y2, modifiers);
        case "press":
          return new Press(sx, sy, x2, y2, modifiers);
        case "press_up":
          return new PressUp(sx, sy, x2, y2, modifiers);
        case "pan_start":
          return new PanStart(sx, sy, x2, y2, modifiers);
        case "pan":
          return new Pan(sx, sy, x2, y2, ev.dx, ev.dy, modifiers);
        case "pan_end":
          return new PanEnd(sx, sy, x2, y2, modifiers);
        case "pinch_start":
          return new PinchStart(sx, sy, x2, y2, modifiers);
        case "pinch":
          return new Pinch(sx, sy, x2, y2, ev.scale, modifiers);
        case "pinch_end":
          return new PinchEnd(sx, sy, x2, y2, modifiers);
        case "rotate_start":
          return new RotateStart(sx, sy, x2, y2, modifiers);
        case "rotate":
          return new Rotate(sx, sy, x2, y2, ev.rotation, modifiers);
        case "rotate_end":
          return new RotateEnd(sx, sy, x2, y2, modifiers);
        default:
          return null;
      }
    })();
    if (bokeh_event != null) {
      plot_view.model.trigger_event(bokeh_event);
    }
  }
  _get_sxy(event2) {
    const { pageX, pageY } = event2;
    const { left: left2, top } = offset_bbox(this.hit_area);
    return {
      sx: pageX - left2,
      sy: pageY - top
    };
  }
  _get_modifiers(event2) {
    return {
      shift: event2.shiftKey,
      ctrl: event2.ctrlKey,
      alt: event2.altKey
    };
  }
  _scroll_event(event2) {
    return {
      type: event2.type,
      ...this._get_sxy(event2),
      delta: getDeltaY(event2),
      modifiers: this._get_modifiers(event2),
      native: event2
    };
  }
  _key_event(event2) {
    return {
      type: event2.type,
      key: event2.key,
      modifiers: this._get_modifiers(event2),
      native: event2
    };
  }
  on_tap(event2) {
    this._trigger(this.tap, event2);
  }
  on_doubletap(event2) {
    this._trigger(this.doubletap, event2);
  }
  on_press(event2) {
    this._trigger(this.press, event2);
  }
  on_pressup(event2) {
    this._trigger(this.pressup, event2);
  }
  on_enter(event2) {
    this._trigger(this.move_enter, event2);
  }
  on_move(event2) {
    this._trigger(this.move, event2);
  }
  on_leave(event2) {
    this._trigger(this.move_exit, event2);
  }
  on_pan_start(event2) {
    this._trigger(this.pan_start, event2);
  }
  on_pan(event2) {
    this._trigger(this.pan, event2);
  }
  on_pan_end(event2) {
    this._trigger(this.pan_end, event2);
  }
  on_pinch_start(event2) {
    this._trigger(this.pinch_start, event2);
  }
  on_pinch(event2) {
    this._trigger(this.pinch, event2);
  }
  on_pinch_end(event2) {
    this._trigger(this.pinch_end, event2);
  }
  on_rotate_start(event2) {
    this._trigger(this.rotate_start, event2);
  }
  on_rotate(event2) {
    this._trigger(this.rotate, event2);
  }
  on_rotate_end(event2) {
    this._trigger(this.rotate_end, event2);
  }
  on_mouse_wheel(event2) {
    this._trigger(this.scroll, this._scroll_event(event2));
  }
  on_context_menu(_event) {
  }
  on_key_down(event2) {
    this.trigger(this.keydown, this._key_event(event2));
  }
  on_key_up(event2) {
    this.trigger(this.keyup, this._key_event(event2));
  }
};
__publicField(UIEventBus, "__name__", "UIEventBus");

// node_modules/@bokeh/bokehjs/build/js/lib/models/canvas/canvas.js
import * as canvas_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/canvas.css.js";
import icons_css6 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
async function init_webgl() {
  const canvas3 = document.createElement("canvas");
  const gl = canvas3.getContext("webgl", { alpha: true, antialias: false, depth: false, premultipliedAlpha: true });
  if (gl != null) {
    const webgl = await load_module(import("./webgl-6COEMJP4.js"));
    if (webgl != null) {
      const regl_wrapper = webgl.get_regl(gl);
      if (regl_wrapper.has_webgl) {
        return { canvas: canvas3, regl_wrapper };
      } else {
        logger.trace("WebGL is supported, but not the required extensions");
      }
    } else {
      logger.trace("WebGL is supported, but bokehjs(.min).js bundle is not available");
    }
  } else {
    logger.trace("WebGL is not supported");
  }
  return null;
}
var global_webgl = /* @__PURE__ */ (() => {
  let _global_webgl;
  return async () => {
    if (_global_webgl !== void 0) {
      return _global_webgl;
    } else {
      return _global_webgl = await init_webgl();
    }
  };
})();
var CanvasView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "webgl", null);
    __publicField(this, "underlays_el");
    __publicField(this, "primary");
    __publicField(this, "overlays");
    __publicField(this, "overlays_el");
    __publicField(this, "events_el");
    __publicField(this, "ui_event_bus");
    __publicField(this, "_size", new InlineStyleSheet());
    __publicField(this, "touch_action", new InlineStyleSheet());
    __publicField(this, "plot_views", []);
  }
  initialize() {
    super.initialize();
    this.underlays_el = div({ class: canvas_css.layer });
    this.primary = this.create_layer();
    this.overlays = this.create_layer();
    this.overlays_el = div({ class: canvas_css.layer });
    this.events_el = div({ class: [canvas_css.layer, canvas_css.events] });
    this.ui_event_bus = new UIEventBus(this);
  }
  get layers() {
    return [
      this.underlays_el,
      this.primary,
      this.overlays,
      this.overlays_el,
      this.events_el
    ];
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    if (this.model.output_backend == "webgl") {
      this.webgl = await global_webgl();
      if (settings.force_webgl && this.webgl == null) {
        throw new Error("webgl is not available");
      }
    }
  }
  remove() {
    this.ui_event_bus.remove();
    super.remove();
  }
  stylesheets() {
    return [...super.stylesheets(), canvas_css.default, icons_css6, this._size, this.touch_action];
  }
  render() {
    super.render();
    const elements = [
      this.underlays_el,
      this.primary.el,
      this.overlays.el,
      this.overlays_el,
      this.events_el
    ];
    this.shadow_el.append(...elements);
  }
  get pixel_ratio() {
    return this.primary.pixel_ratio;
  }
  _update_bbox() {
    const changed = super._update_bbox();
    if (changed) {
      const { width, height } = this.bbox;
      this._size.replace(`.${canvas_css.layer}`, {
        width: px(width),
        height: px(height)
      });
      this.primary.resize(width, height);
      this.overlays.resize(width, height);
    }
    return changed;
  }
  after_resize() {
    if (this.plot_views.length != 0) {
      this.finish();
    } else {
      super.after_resize();
    }
  }
  _after_resize() {
    super._after_resize();
    const { width, height } = this.bbox;
    this.primary.resize(width, height);
    this.overlays.resize(width, height);
  }
  resize() {
    this._update_bbox();
    this._after_resize();
  }
  prepare_webgl(frame_box) {
    const { webgl } = this;
    if (webgl != null) {
      const { width, height } = this.bbox;
      webgl.canvas.width = this.pixel_ratio * width;
      webgl.canvas.height = this.pixel_ratio * height;
      const [sx, sy, w, h7] = frame_box;
      const { xview, yview } = this.bbox;
      const vx = xview.compute(sx);
      const vy = yview.compute(sy + h7);
      const ratio = this.pixel_ratio;
      webgl.regl_wrapper.set_scissor(ratio * vx, ratio * vy, ratio * w, ratio * h7);
      this._clear_webgl();
    }
  }
  blit_webgl(ctx) {
    const { webgl } = this;
    if (webgl != null && webgl.canvas.width * webgl.canvas.height > 0) {
      logger.debug("Blitting WebGL canvas");
      ctx.restore();
      ctx.drawImage(webgl.canvas, 0, 0);
      ctx.save();
      if (this.model.hidpi) {
        const ratio = this.pixel_ratio;
        ctx.scale(ratio, ratio);
        ctx.translate(0.5, 0.5);
      }
      this._clear_webgl();
    }
  }
  _clear_webgl() {
    const { webgl } = this;
    if (webgl != null) {
      const { regl_wrapper, canvas: canvas3 } = webgl;
      regl_wrapper.clear(canvas3.width, canvas3.height);
    }
  }
  compose() {
    const composite = this.create_layer();
    const { width, height } = this.bbox;
    composite.resize(width, height);
    composite.ctx.drawImage(this.primary.canvas, 0, 0);
    composite.ctx.drawImage(this.overlays.canvas, 0, 0);
    return composite;
  }
  create_layer() {
    const { output_backend, hidpi } = this.model;
    return new CanvasLayer(output_backend, hidpi);
  }
  to_blob() {
    return this.compose().to_blob();
  }
};
__publicField(CanvasView, "__name__", "CanvasView");
var _Canvas = class _Canvas extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Canvas, "__name__", "Canvas");
_Canvas.prototype.default_view = CanvasView;
_Canvas.define(({ Bool: Bool2 }) => ({
  hidpi: [Bool2, true],
  output_backend: [OutputBackend, "canvas"]
}));
var Canvas = _Canvas;

// node_modules/@bokeh/bokehjs/build/js/lib/models/comparisons/comparison.js
var Comparison = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Comparison, "__name__", "Comparison");

// node_modules/@bokeh/bokehjs/build/js/lib/models/comparisons/customjs_compare.js
var _CustomJSCompare = class _CustomJSCompare extends Comparison {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  _make_func() {
    const code2 = use_strict(this.code);
    return new Function("x", "y", ...this.names, code2);
  }
  compute(x2, y2) {
    const func = this._make_func();
    return func(x2, y2, this.values);
  }
};
__publicField(_CustomJSCompare, "__name__", "CustomJSCompare");
_CustomJSCompare.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomJSCompare = _CustomJSCompare;

// node_modules/@bokeh/bokehjs/build/js/lib/models/comparisons/nan_compare.js
var _NanCompare = class _NanCompare extends Comparison {
  constructor(attrs) {
    super(attrs);
  }
  compute(x2, y2) {
    if (isNumber(x2) && isNaN(x2)) {
      return this.ascending_first ? -1 : 1;
    }
    if (isNumber(y2) && isNaN(y2)) {
      return this.ascending_first ? 1 : -1;
    }
    if (isNumber(x2) && isNumber(y2)) {
      return x2 == y2 ? 0 : x2 < y2 ? -1 : 1;
    }
    return 0;
  }
};
__publicField(_NanCompare, "__name__", "NanCompare");
_NanCompare.define(({ Bool: Bool2 }) => ({
  ascending_first: [Bool2, false]
}));
var NanCompare = _NanCompare;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/expression.js
var Expression = class extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_result");
  }
  initialize() {
    super.initialize();
    this._result = /* @__PURE__ */ new Map();
  }
  v_compute(source2) {
    let result = this._result.get(source2);
    if (result === void 0 || source2.changed_for(this)) {
      result = this._v_compute(source2);
      this._result.set(source2, result);
    }
    return result;
  }
};
__publicField(Expression, "__name__", "Expression");
var ScalarExpression = class extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_result");
  }
  initialize() {
    super.initialize();
    this._result = /* @__PURE__ */ new Map();
  }
  compute(source2) {
    let result = this._result.get(source2);
    if (result === void 0 || source2.changed_for(this)) {
      result = this._compute(source2);
      this._result.set(source2, result);
    }
    return result;
  }
};
__publicField(ScalarExpression, "__name__", "ScalarExpression");

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/customjs_expr.js
var _CustomJSExpr = class _CustomJSExpr extends Expression {
  constructor(attrs) {
    super(attrs);
  }
  connect_signals() {
    super.connect_signals();
    for (const value2 of values(this.args)) {
      if (value2 instanceof HasProps) {
        value2.change.connect(() => {
          this._result.clear();
          this.change.emit();
        });
      }
    }
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  get func() {
    const code2 = use_strict(this.code);
    return new GeneratorFunction(...this.names, code2);
  }
  _v_compute(source2) {
    const generator = this.func.apply(source2, this.values);
    let result = generator.next();
    if ((result.done ?? false) && result.value !== void 0) {
      const { value: value2 } = result;
      if (isArray(value2) || isTypedArray(value2)) {
        return value2;
      } else if (isIterable(value2)) {
        return [...value2];
      } else {
        return repeat(value2, source2.length);
      }
    } else {
      const array2 = [];
      do {
        array2.push(result.value);
        result = generator.next();
      } while (!(result.done ?? false));
      return array2;
    }
  }
};
__publicField(_CustomJSExpr, "__name__", "CustomJSExpr");
_CustomJSExpr.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomJSExpr = _CustomJSExpr;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/stack.js
var _Stack = class _Stack extends Expression {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    const n2 = source2.get_length() ?? 0;
    const result = new Float64Array(n2);
    for (const f2 of this.fields) {
      const column = dict(source2.data).get(f2);
      if (column != null) {
        const k = Math.min(n2, column.length);
        for (let i2 = 0; i2 < k; i2++) {
          result[i2] += column[i2];
        }
      }
    }
    return result;
  }
};
__publicField(_Stack, "__name__", "Stack");
_Stack.define(({ Str: Str2, List: List2 }) => ({
  fields: [List2(Str2), []]
}));
var Stack2 = _Stack;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/cumsum.js
var _CumSum = class _CumSum extends Expression {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    const result = new Float64Array(source2.get_length() ?? 0);
    const column = dict(source2.data).get(this.field) ?? [];
    const offset3 = this.include_zero ? 1 : 0;
    result[0] = this.include_zero ? 0 : column[0];
    for (let i2 = 1; i2 < result.length; i2++) {
      result[i2] = result[i2 - 1] + column[i2 - offset3];
    }
    return result;
  }
};
__publicField(_CumSum, "__name__", "CumSum");
_CumSum.define(({ Bool: Bool2, Str: Str2 }) => ({
  field: [Str2],
  include_zero: [Bool2, false]
}));
var CumSum = _CumSum;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/minimum.js
var _Minimum = class _Minimum extends ScalarExpression {
  constructor(attrs) {
    super(attrs);
  }
  _compute(source2) {
    const column = dict(source2.data).get(this.field) ?? [];
    return Math.min(this.initial, min(column));
  }
};
__publicField(_Minimum, "__name__", "Minimum");
_Minimum.define(({ Float: Float2, Str: Str2 }) => ({
  field: [Str2],
  initial: [Float2, Infinity]
}));
var Minimum = _Minimum;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/maximum.js
var _Maximum = class _Maximum extends ScalarExpression {
  constructor(attrs) {
    super(attrs);
  }
  _compute(source2) {
    const column = dict(source2.data).get(this.field) ?? [];
    return Math.max(this.initial, max(column));
  }
};
__publicField(_Maximum, "__name__", "Maximum");
_Maximum.define(({ Float: Float2, Str: Str2 }) => ({
  field: [Str2],
  initial: [Float2, -Infinity]
}));
var Maximum = _Maximum;

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/coordinate_transform.js
var CoordinateTransform2 = class extends Expression {
  constructor(attrs) {
    super(attrs);
  }
  get x() {
    return new XComponent({ transform: this });
  }
  get y() {
    return new YComponent({ transform: this });
  }
};
__publicField(CoordinateTransform2, "__name__", "CoordinateTransform");
var _XYComponent = class _XYComponent extends Expression {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_XYComponent, "__name__", "XYComponent");
_XYComponent.define(({ Ref: Ref2 }) => ({
  transform: [Ref2(CoordinateTransform2)]
}));
var XYComponent = _XYComponent;
var XComponent = class extends XYComponent {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    return this.transform.v_compute(source2).x;
  }
};
__publicField(XComponent, "__name__", "XComponent");
var YComponent = class extends XYComponent {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    return this.transform.v_compute(source2).y;
  }
};
__publicField(YComponent, "__name__", "YComponent");

// node_modules/@bokeh/bokehjs/build/js/lib/models/expressions/polar.js
var _PolarTransform = class _PolarTransform extends CoordinateTransform2 {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    const radius = this.properties.radius.uniform(source2);
    const angle = this.properties.angle.uniform(source2);
    const coeff = this.direction == "anticlock" ? -1 : 1;
    const n2 = Math.min(radius.length, angle.length);
    const x2 = new Float64Array(n2);
    const y2 = new Float64Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      const radius_i = radius.get(i2);
      const angle_i = angle.get(i2) * coeff;
      x2[i2] = radius_i * Math.cos(angle_i);
      y2[i2] = radius_i * Math.sin(angle_i);
    }
    return { x: x2, y: y2 };
  }
};
__publicField(_PolarTransform, "__name__", "PolarTransform");
_PolarTransform.define(({}) => ({
  radius: [DistanceSpec, { field: "radius" }],
  angle: [AngleSpec, { field: "angle" }],
  direction: [Direction, "anticlock"]
}));
var PolarTransform = _PolarTransform;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/boolean_filter.js
var _BooleanFilter = class _BooleanFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  compute_indices(source2) {
    const size2 = source2.get_length() ?? 1;
    const { booleans } = this;
    if (booleans == null) {
      return BitSet.all_set(size2);
    } else {
      return BitSet.from_booleans(size2, booleans);
    }
  }
};
__publicField(_BooleanFilter, "__name__", "BooleanFilter");
_BooleanFilter.define(({ Bool: Bool2, Iterable, Nullable: Nullable2 }) => ({
  booleans: [Nullable2(Iterable(Bool2)), null]
}));
var BooleanFilter = _BooleanFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/customjs_filter.js
var _CustomJSFilter = class _CustomJSFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  get func() {
    const code2 = use_strict(this.code);
    return new Function(...this.names, "source", code2);
  }
  compute_indices(source2) {
    const size2 = source2.get_length() ?? 1;
    const filter2 = this.func(...this.values, source2);
    if (filter2 == null) {
      return BitSet.all_set(size2);
    } else if (isArrayOf(filter2, isInteger)) {
      return BitSet.from_indices(size2, filter2);
    } else if (isArrayOf(filter2, isBoolean)) {
      return BitSet.from_booleans(size2, filter2);
    } else {
      throw new Error(`expect an array of integers or booleans, or null, got ${filter2}`);
    }
  }
};
__publicField(_CustomJSFilter, "__name__", "CustomJSFilter");
_CustomJSFilter.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomJSFilter = _CustomJSFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/group_filter.js
var _GroupFilter = class _GroupFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  compute_indices(source2) {
    const column = source2.get_column(this.column_name);
    const size2 = source2.get_length() ?? 1;
    if (column == null) {
      logger.warn(`${this}: groupby column '${this.column_name}' not found in the data source`);
      return BitSet.all_set(size2);
    } else {
      const indices = new BitSet(size2, 0);
      const cmp = new Comparator();
      for (let i2 = 0; i2 < indices.size; i2++) {
        if (cmp.eq(column[i2], this.group)) {
          indices.set(i2);
        }
      }
      return indices;
    }
  }
};
__publicField(_GroupFilter, "__name__", "GroupFilter");
_GroupFilter.define(({ Str: Str2, Unknown: Unknown2 }) => ({
  column_name: [Str2],
  group: [Unknown2]
}));
var GroupFilter = _GroupFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/index_filter.js
var _IndexFilter = class _IndexFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  compute_indices(source2) {
    const size2 = source2.get_length() ?? 1;
    const { indices } = this;
    if (indices == null) {
      return BitSet.all_set(size2);
    } else {
      return BitSet.from_indices(size2, indices);
    }
  }
};
__publicField(_IndexFilter, "__name__", "IndexFilter");
_IndexFilter.define(({ Int: Int2, Iterable, Nullable: Nullable2 }) => ({
  indices: [Nullable2(Iterable(Int2)), null]
}));
var IndexFilter = _IndexFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/inversion_filter.js
var _InversionFilter = class _InversionFilter extends Filter {
  constructor(attrs) {
    super(attrs);
  }
  connect_signals() {
    super.connect_signals();
    const emit_changed = () => {
      this.change.emit();
    };
    const connect_operands = (operands2) => {
      for (const operand of operands2) {
        this.connect(operand.change, emit_changed);
      }
    };
    const disconnect_operands = (operands2) => {
      for (const operand of operands2) {
        this.disconnect(operand.change, emit_changed);
      }
    };
    let operands = (() => {
      const { operand } = this.properties;
      return operand.is_unset ? [] : [operand.get_value()];
    })();
    connect_operands(operands);
    this.on_change(this.properties.operand, () => {
      disconnect_operands(operands);
      operands = [this.operand];
      connect_operands(operands);
    });
  }
  compute_indices(source2) {
    const index2 = this.operand.compute_indices(source2);
    index2.invert();
    return index2;
  }
};
__publicField(_InversionFilter, "__name__", "InversionFilter");
_InversionFilter.define(({ Ref: Ref2 }) => ({
  operand: [Ref2(Filter)]
}));
var InversionFilter = _InversionFilter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/union_filter.js
var UnionFilter = class extends CompositeFilter {
  constructor(attrs) {
    super(attrs);
  }
  _inplace_op(index2, op) {
    index2.add(op);
  }
};
__publicField(UnionFilter, "__name__", "UnionFilter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/difference_filter.js
var DifferenceFilter = class extends CompositeFilter {
  constructor(attrs) {
    super(attrs);
  }
  _inplace_op(index2, op) {
    index2.subtract(op);
  }
};
__publicField(DifferenceFilter, "__name__", "DifferenceFilter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/filters/symmetric_difference_filter.js
var SymmetricDifferenceFilter = class extends CompositeFilter {
  constructor(attrs) {
    super(attrs);
  }
  _inplace_op(index2, op) {
    index2.symmetric_subtract(op);
  }
};
__publicField(SymmetricDifferenceFilter, "__name__", "SymmetricDifferenceFilter");

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/annular_wedge.js
var AnnularWedgeView = class extends XYGlyphView {
  async load_glglyph() {
    const { AnnularWedgeGL } = await import("./annular_wedge-UW67NSMG.js");
    return AnnularWedgeGL;
  }
  _map_data() {
    this._define_or_inherit_attr("sinner_radius", () => {
      if (this.model.properties.inner_radius.units == "data") {
        if (this.inherited_x && this.inherited_inner_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.inner_radius);
        }
      } else {
        return this.inherited_inner_radius ? inherit : to_screen(this.inner_radius);
      }
    });
    this._define_or_inherit_attr("souter_radius", () => {
      if (this.model.properties.outer_radius.units == "data") {
        if (this.inherited_x && this.inherited_outer_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.outer_radius);
        }
      } else {
        return this.inherited_outer_radius ? inherit : to_screen(this.outer_radius);
      }
    });
    this._define_or_inherit_attr("max_souter_radius", () => max(this.souter_radius));
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, start_angle, end_angle, sinner_radius, souter_radius } = { ...this, ...data3 };
    const anticlock = this.model.direction == "anticlock";
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sinner_radius_i = sinner_radius[i2];
      const souter_radius_i = souter_radius[i2];
      const start_angle_i = start_angle.get(i2);
      const end_angle_i = end_angle.get(i2);
      if (!isFinite(sx_i + sy_i + sinner_radius_i + souter_radius_i + start_angle_i + end_angle_i)) {
        continue;
      }
      const angle_i = end_angle_i - start_angle_i;
      ctx.translate(sx_i, sy_i);
      ctx.rotate(start_angle_i);
      ctx.beginPath();
      ctx.moveTo(souter_radius_i, 0);
      ctx.arc(0, 0, souter_radius_i, 0, angle_i, anticlock);
      ctx.rotate(angle_i);
      ctx.lineTo(sinner_radius_i, 0);
      ctx.arc(0, 0, sinner_radius_i, 0, -angle_i, !anticlock);
      ctx.closePath();
      ctx.rotate(-angle_i - start_angle_i);
      ctx.translate(-sx_i, -sy_i);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const sx0 = sx - this.max_souter_radius;
    const sx1 = sx + this.max_souter_radius;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    const sy0 = sy - this.max_souter_radius;
    const sy1 = sy + this.max_souter_radius;
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const candidates = [];
    for (const i2 of this.index.indices({ x0, x1, y0, y1 })) {
      const or2 = this.souter_radius[i2] ** 2;
      const ir2 = this.sinner_radius[i2] ** 2;
      const [sx02, sx12] = this.renderer.xscale.r_compute(x2, this.x[i2]);
      const [sy02, sy12] = this.renderer.yscale.r_compute(y2, this.y[i2]);
      const dist = (sx02 - sx12) ** 2 + (sy02 - sy12) ** 2;
      if (dist <= or2 && dist >= ir2) {
        candidates.push(i2);
      }
    }
    const anticlock = this.model.direction == "anticlock";
    const indices = [];
    for (const i2 of candidates) {
      const angle = Math.atan2(sy - this.sy[i2], sx - this.sx[i2]);
      const is_full_circle = Math.abs(this.start_angle.get(i2) - this.end_angle.get(i2)) >= 2 * Math.PI;
      if (is_full_circle || angle_between(-angle, -this.start_angle.get(i2), -this.end_angle.get(i2), anticlock)) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
  scenterxy(i2) {
    const r = (this.sinner_radius[i2] + this.souter_radius[i2]) / 2;
    const a2 = (this.start_angle.get(i2) + this.end_angle.get(i2)) / 2;
    const scx = this.sx[i2] + r * Math.cos(a2);
    const scy = this.sy[i2] + r * Math.sin(a2);
    return [scx, scy];
  }
};
__publicField(AnnularWedgeView, "__name__", "AnnularWedgeView");
var _AnnularWedge = class _AnnularWedge extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_AnnularWedge, "__name__", "AnnularWedge");
_AnnularWedge.prototype.default_view = AnnularWedgeView;
_AnnularWedge.mixins([LineVector, FillVector, HatchVector]);
_AnnularWedge.define(({}) => ({
  direction: [Direction, "anticlock"],
  inner_radius: [DistanceSpec, { field: "inner_radius" }],
  outer_radius: [DistanceSpec, { field: "outer_radius" }],
  start_angle: [AngleSpec, { field: "start_angle" }],
  end_angle: [AngleSpec, { field: "end_angle" }]
}));
var AnnularWedge = _AnnularWedge;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/annulus.js
var AnnulusView = class extends XYGlyphView {
  async load_glglyph() {
    const { AnnulusGL } = await import("./annulus-KSDY43VF.js");
    return AnnulusGL;
  }
  _map_data() {
    this._define_or_inherit_attr("sinner_radius", () => {
      if (this.model.properties.inner_radius.units == "data") {
        if (this.inherited_x && this.inherited_inner_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.inner_radius);
        }
      } else {
        return this.inherited_inner_radius ? inherit : to_screen(this.inner_radius);
      }
    });
    this._define_or_inherit_attr("souter_radius", () => {
      if (this.model.properties.outer_radius.units == "data") {
        if (this.inherited_x && this.inherited_outer_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.outer_radius);
        }
      } else {
        return this.inherited_outer_radius ? inherit : to_screen(this.outer_radius);
      }
    });
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sinner_radius, souter_radius } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sinner_radius_i = sinner_radius[i2];
      const souter_radius_i = souter_radius[i2];
      if (!isFinite(sx_i + sy_i + sinner_radius_i + souter_radius_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.arc(sx_i, sy_i, sinner_radius_i, 0, 2 * Math.PI, true);
      ctx.moveTo(sx_i + souter_radius_i, sy_i);
      ctx.arc(sx_i, sy_i, souter_radius_i, 2 * Math.PI, 0, false);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    let x0, y0;
    let x1, y1;
    if (this.model.properties.outer_radius.units == "data") {
      x0 = x2 - this.max_outer_radius;
      x1 = x2 + this.max_outer_radius;
      y0 = y2 - this.max_outer_radius;
      y1 = y2 + this.max_outer_radius;
    } else {
      const sx0 = sx - this.max_outer_radius;
      const sx1 = sx + this.max_outer_radius;
      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
      const sy0 = sy - this.max_outer_radius;
      const sy1 = sy + this.max_outer_radius;
      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    }
    const indices = [];
    for (const i2 of this.index.indices({ x0, x1, y0, y1 })) {
      const or2 = this.souter_radius[i2] ** 2;
      const ir2 = this.sinner_radius[i2] ** 2;
      const [sx0, sx1] = this.renderer.xscale.r_compute(x2, this.x[i2]);
      const [sy0, sy1] = this.renderer.yscale.r_compute(y2, this.y[i2]);
      const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;
      if (dist <= or2 && dist >= ir2) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index2) {
    const len = index2 + 1;
    const sx = new Array(len);
    sx[index2] = (x0 + x1) / 2;
    const sy = new Array(len);
    sy[index2] = (y0 + y1) / 2;
    const r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;
    const sinner_radius = new Array(len);
    sinner_radius[index2] = r * 0.4;
    const souter_radius = new Array(len);
    souter_radius[index2] = r * 0.8;
    this._paint(ctx, [index2], { sx, sy, sinner_radius, souter_radius });
  }
};
__publicField(AnnulusView, "__name__", "AnnulusView");
var _Annulus = class _Annulus extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Annulus, "__name__", "Annulus");
_Annulus.prototype.default_view = AnnulusView;
_Annulus.mixins([LineVector, FillVector, HatchVector]);
_Annulus.define(({}) => ({
  inner_radius: [DistanceSpec, { field: "inner_radius" }],
  outer_radius: [DistanceSpec, { field: "outer_radius" }]
}));
var Annulus = _Annulus;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/arc.js
var ArcView = class extends XYGlyphView {
  _map_data() {
    this._define_or_inherit_attr("sradius", () => {
      if (this.model.properties.radius.units == "data") {
        if (this.inherited_x && this.inherited_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.radius);
        }
      } else {
        return this.inherited_radius ? inherit : to_screen(this.radius);
      }
    });
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.line.doit) {
      return;
    }
    const { sx, sy, sradius, start_angle, end_angle } = { ...this, ...data3 };
    const anticlock = this.model.direction == "anticlock";
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sradius_i = sradius[i2];
      const start_angle_i = start_angle.get(i2);
      const end_angle_i = end_angle.get(i2);
      if (!isFinite(sx_i + sy_i + sradius_i + start_angle_i + end_angle_i)) {
        continue;
      }
      this._render_decorations(ctx, i2, sx_i, sy_i, sradius_i, start_angle_i, end_angle_i, anticlock);
      ctx.beginPath();
      ctx.arc(sx_i, sy_i, sradius_i, start_angle_i, end_angle_i, anticlock);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _render_decorations(ctx, i2, sx, sy, sradius, start_angle, end_angle, _anticlock) {
    const { sin: sin3, cos: cos3, PI: PI3 } = Math;
    for (const decoration of this.decorations.values()) {
      ctx.save();
      if (decoration.model.node == "start") {
        const x2 = sradius * cos3(start_angle) + sx;
        const y2 = sradius * sin3(start_angle) + sy;
        ctx.translate(x2, y2);
        ctx.rotate(start_angle + PI3);
      } else if (decoration.model.node == "end") {
        const x2 = sradius * Math.cos(end_angle) + sx;
        const y2 = sradius * Math.sin(end_angle) + sy;
        ctx.translate(x2, y2);
        ctx.rotate(end_angle);
      }
      decoration.marking.paint(ctx, i2);
      ctx.restore();
    }
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(ArcView, "__name__", "ArcView");
var _Arc = class _Arc extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Arc, "__name__", "Arc");
_Arc.prototype.default_view = ArcView;
_Arc.mixins(LineVector);
_Arc.define(({}) => ({
  direction: [Direction, "anticlock"],
  radius: [DistanceSpec, { field: "radius" }],
  start_angle: [AngleSpec, { field: "start_angle" }],
  end_angle: [AngleSpec, { field: "end_angle" }]
}));
var Arc = _Arc;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/algorithms.js
var { abs: abs7, sqrt: sqrt3, min: min7, max: max10 } = Math;
function qbb(x0, y0, cx, cy, x1, y1) {
  function _qbb(u2, v, w) {
    if (v == (u2 + w) / 2) {
      return [u2, w];
    } else {
      const t = (u2 - v) / (u2 - 2 * v + w);
      const bd = u2 * (1 - t) ** 2 + 2 * v * (1 - t) * t + w * t ** 2;
      return [min7(u2, w, bd), max10(u2, w, bd)];
    }
  }
  const [x_min, x_max] = _qbb(x0, cx, x1);
  const [y_min, y_max] = _qbb(y0, cy, y1);
  return {
    x0: x_min,
    x1: x_max,
    y0: y_min,
    y1: y_max
  };
}
function cbb(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {
  const x3 = x1;
  const y3 = y1;
  x1 = cx0;
  y1 = cy0;
  const x2 = cx1;
  const y2 = cy1;
  const tvalues = [];
  for (let i2 = 0; i2 <= 2; i2++) {
    let a2, b2, c;
    if (i2 == 0) {
      b2 = 6 * x0 - 12 * x1 + 6 * x2;
      a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b2 = 6 * y0 - 12 * y1 + 6 * y2;
      a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (abs7(a2) < 1e-12) {
      if (abs7(b2) < 1e-12) {
        continue;
      }
      const t = -c / b2;
      if (0 < t && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    const b2ac = b2 ** 2 - 4 * c * a2;
    const sqrtb2ac = sqrt3(b2ac);
    if (b2ac < 0) {
      continue;
    }
    const t1 = (-b2 + sqrtb2ac) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    const t2 = (-b2 - sqrtb2ac) / (2 * a2);
    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }
  const n2 = tvalues.length;
  let j = n2;
  const x_bounds = Array(n2 + 2);
  const y_bounds = Array(n2 + 2);
  while (j-- > 0) {
    const t = tvalues[j];
    const mt = 1 - t;
    const x4 = mt ** 3 * x0 + 3 * mt ** 2 * t * x1 + 3 * mt * t ** 2 * x2 + t ** 3 * x3;
    const y4 = mt ** 3 * y0 + 3 * mt ** 2 * t * y1 + 3 * mt * t ** 2 * y2 + t ** 3 * y3;
    x_bounds[j] = x4;
    y_bounds[j] = y4;
  }
  x_bounds[n2] = x0;
  y_bounds[n2] = y0;
  x_bounds[n2 + 1] = x3;
  y_bounds[n2 + 1] = y3;
  const [x_min, x_max, y_min, y_max] = minmax2(x_bounds, y_bounds);
  return { x0: x_min, x1: x_max, y0: y_min, y1: y_max };
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/bezier.js
var BezierView = class extends GlyphView {
  _project_data() {
    this._project_xy("x0", this.x0, "y0", this.y0);
    this._project_xy("x1", this.x1, "y1", this.y1);
  }
  _index_data(index2) {
    const { data_size, x0, y0, x1, y1, cx0, cy0, cx1, cy1 } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x0_i = x0[i2];
      const y0_i = y0[i2];
      const x1_i = x1[i2];
      const y1_i = y1[i2];
      const cx0_i = cx0[i2];
      const cy0_i = cy0[i2];
      const cx1_i = cx1[i2];
      const cy1_i = cy1[i2];
      if (!isFinite(x0_i + x1_i + y0_i + y1_i + cx0_i + cy0_i + cx1_i + cy1_i)) {
        index2.add_empty();
      } else {
        const { x0: x02, y0: y02, x1: x12, y1: y12 } = cbb(x0_i, y0_i, cx0_i, cy0_i, cx1_i, cy1_i, x1_i, y1_i);
        index2.add_rect(x02, y02, x12, y12);
      }
    }
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.line.doit) {
      return;
    }
    const { sx0, sy0, sx1, sy1, scx0, scy0, scx1, scy1 } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx0_i = sx0[i2];
      const sy0_i = sy0[i2];
      const sx1_i = sx1[i2];
      const sy1_i = sy1[i2];
      const scx0_i = scx0[i2];
      const scy0_i = scy0[i2];
      const scx1_i = scx1[i2];
      const scy1_i = scy1[i2];
      if (!isFinite(sx0_i + sy0_i + sx1_i + sy1_i + scx0_i + scy0_i + scx1_i + scy1_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.moveTo(sx0_i, sy0_i);
      ctx.bezierCurveTo(scx0_i, scy0_i, scx1_i, scy1_i, sx1_i, sy1_i);
      this.visuals.line.apply(ctx, i2);
    }
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
  scenterxy() {
    throw new Error(`${this}.scenterxy() is not implemented`);
  }
};
__publicField(BezierView, "__name__", "BezierView");
var _Bezier = class _Bezier extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Bezier, "__name__", "Bezier");
_Bezier.prototype.default_view = BezierView;
_Bezier.define(({}) => ({
  x0: [XCoordinateSpec, { field: "x0" }],
  y0: [YCoordinateSpec, { field: "y0" }],
  x1: [XCoordinateSpec, { field: "x1" }],
  y1: [YCoordinateSpec, { field: "y1" }],
  cx0: [XCoordinateSpec, { field: "cx0" }],
  cy0: [YCoordinateSpec, { field: "cy0" }],
  cx1: [XCoordinateSpec, { field: "cx1" }],
  cy1: [YCoordinateSpec, { field: "cy1" }]
}));
_Bezier.mixins(LineVector);
var Bezier = _Bezier;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/lrtb.js
var LRTBView = class extends GlyphView {
  async load_glglyph() {
    const { LRTBGL } = await import("./lrtb-GHRUHO7Z.js");
    return LRTBGL;
  }
  get_anchor_point(anchor2, i2, _spt) {
    const left2 = Math.min(this.sleft[i2], this.sright[i2]);
    const right3 = Math.max(this.sright[i2], this.sleft[i2]);
    const top = Math.min(this.stop[i2], this.sbottom[i2]);
    const bottom = Math.max(this.sbottom[i2], this.stop[i2]);
    switch (anchor2) {
      case "top_left":
        return { x: left2, y: top };
      case "top":
      case "top_center":
        return { x: (left2 + right3) / 2, y: top };
      case "top_right":
        return { x: right3, y: top };
      case "bottom_left":
        return { x: left2, y: bottom };
      case "bottom":
      case "bottom_center":
        return { x: (left2 + right3) / 2, y: bottom };
      case "bottom_right":
        return { x: right3, y: bottom };
      case "left":
      case "center_left":
        return { x: left2, y: (top + bottom) / 2 };
      case "center":
      case "center_center":
        return { x: (left2 + right3) / 2, y: (top + bottom) / 2 };
      case "right":
      case "center_right":
        return { x: right3, y: (top + bottom) / 2 };
    }
  }
  _set_data(indices) {
    super._set_data(indices);
    this.border_radius = border_radius(this.model.border_radius);
  }
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const { l, r, t, b: b2 } = this._lrtb(i2);
      index2.add_rect(min10(l, r), min10(t, b2), max18(r, l), max18(t, b2));
    }
  }
  _paint(ctx, indices, data3) {
    const { sleft, sright, stop, sbottom, border_radius: border_radius2 } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sleft_i = sleft[i2];
      const stop_i = stop[i2];
      const sright_i = sright[i2];
      const sbottom_i = sbottom[i2];
      if (!isFinite(sleft_i + stop_i + sright_i + sbottom_i)) {
        continue;
      }
      ctx.beginPath();
      const box = BBox.from_lrtb({ left: sleft_i, right: sright_i, top: stop_i, bottom: sbottom_i });
      round_rect(ctx, box, border_radius2);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  // We need to clamp the endpoints inside the viewport, because various browser canvas
  // implementations have issues drawing rects with enpoints far outside the viewport
  _clamp_to_viewport() {
    const { min: min10, max: max18 } = Math;
    const { h_range, v_range } = this.renderer.plot_view.frame.bbox;
    if (!this.inherited_sleft) {
      inplace_map(this.sleft, (left2) => max18(left2, h_range.start));
    }
    if (!this.inherited_sright) {
      inplace_map(this.sright, (right3) => min10(right3, h_range.end));
    }
    if (!this.inherited_stop) {
      inplace_map(this.stop, (top) => max18(top, v_range.start));
    }
    if (!this.inherited_sbottom) {
      inplace_map(this.sbottom, (bottom) => min10(bottom, v_range.end));
    }
  }
  _hit_rect(geometry) {
    return this._hit_rect_against_index(geometry);
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const indices = [...this.index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 })];
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    let indices;
    if (geometry.direction == "v") {
      const y2 = this.renderer.yscale.invert(sy);
      const hr2 = this.renderer.plot_view.frame.bbox.h_range;
      const [x0, x1] = this.renderer.xscale.r_invert(hr2.start, hr2.end);
      indices = [...this.index.indices({ x0, y0: y2, x1, y1: y2 })];
    } else {
      const x2 = this.renderer.xscale.invert(sx);
      const vr = this.renderer.plot_view.frame.bbox.v_range;
      const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);
      indices = [...this.index.indices({ x0: x2, y0, x1: x2, y1 })];
    }
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(LRTBView, "__name__", "LRTBView");
var _LRTB = class _LRTB extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LRTB, "__name__", "LRTB");
_LRTB.mixins([LineVector, FillVector, HatchVector]);
_LRTB.define(() => ({
  border_radius: [BorderRadius, 0]
}));
var LRTB2 = _LRTB;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/block.js
var BlockView = class extends LRTBView {
  scenterxy(i2) {
    const scx = this.sleft[i2] / 2 + this.sright[i2] / 2;
    const scy = this.stop[i2] / 2 + this.sbottom[i2] / 2;
    return [scx, scy];
  }
  _lrtb(i2) {
    const x_i = this.x[i2];
    const y_i = this.y[i2];
    const width_i = this.width.get(i2);
    const height_i = this.height.get(i2);
    const [l, r] = minmax(x_i, x_i + width_i);
    const [b2, t] = minmax(y_i, y_i + height_i);
    return { l, r, t, b: b2 };
  }
  _map_data() {
    const { sx, sy } = this;
    const n2 = sx.length;
    if (this.inherited_x && this.inherited_width) {
      this._inherit_attr("sleft");
      this._inherit_attr("sright");
    } else {
      const sw = this.sdist(this.renderer.xscale, this.x, this.width, "edge");
      const sleft = new ScreenArray(n2);
      const sright = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        sleft[i2] = sx[i2];
        sright[i2] = sx[i2] + sw[i2];
      }
      this._define_attr("sleft", sleft);
      this._define_attr("sright", sright);
    }
    if (this.inherited_y && this.inherited_height) {
      this._inherit_attr("stop");
      this._inherit_attr("sbottom");
    } else {
      const sh = this.sdist(this.renderer.yscale, this.y, this.height, "edge");
      const stop = new ScreenArray(n2);
      const sbottom = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        stop[i2] = sy[i2] - sh[i2];
        sbottom[i2] = sy[i2];
      }
      this._define_attr("stop", stop);
      this._define_attr("sbottom", sbottom);
    }
    this._clamp_to_viewport();
  }
};
__publicField(BlockView, "__name__", "BlockView");
var _Block = class _Block extends LRTB2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Block, "__name__", "Block");
_Block.prototype.default_view = BlockView;
_Block.define(({}) => ({
  x: [XCoordinateSpec, { field: "x" }],
  y: [YCoordinateSpec, { field: "y" }],
  width: [DistanceSpec, { value: 1 }],
  height: [DistanceSpec, { value: 1 }]
}));
var Block = _Block;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/radial_glyph.js
var RadialGlyphView = class extends XYGlyphView {
  _index_data(index2) {
    const { x: x2, y: y2, radius, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x_i = x2[i2];
      const y_i = y2[i2];
      const r_i = radius.get(i2);
      index2.add_rect(x_i - r_i, y_i - r_i, x_i + r_i, y_i + r_i);
    }
  }
  _map_data() {
    this._define_or_inherit_attr("sradius", () => {
      if (this.model.properties.radius.units == "data") {
        const sradius_x = () => this.sdist(this.renderer.xscale, this.x, this.radius);
        const sradius_y = () => this.sdist(this.renderer.yscale, this.y, this.radius);
        const { radius_dimension } = this.model;
        switch (radius_dimension) {
          case "x": {
            return this.inherited_x && this.inherited_radius ? inherit : sradius_x();
          }
          case "y": {
            return this.inherited_y && this.inherited_radius ? inherit : sradius_y();
          }
          case "min":
          case "max": {
            if (this.inherited_x && this.inherited_y && this.inherited_radius) {
              return inherit;
            } else {
              return elementwise(sradius_x(), sradius_y(), Math[radius_dimension]);
            }
          }
        }
      } else {
        return this.inherited_sradius ? inherit : to_screen(this.radius);
      }
    });
  }
  _mask_data() {
    const { frame } = this.renderer.plot_view;
    const shr = frame.x_target;
    const svr = frame.y_target;
    let hr2;
    let vr;
    if (this.model.properties.radius.units == "data") {
      hr2 = shr.map((x2) => this.renderer.xscale.invert(x2)).widen(this.max_radius);
      vr = svr.map((y2) => this.renderer.yscale.invert(y2)).widen(this.max_radius);
    } else {
      hr2 = shr.widen(this.max_radius).map((x2) => this.renderer.xscale.invert(x2));
      vr = svr.widen(this.max_radius).map((y2) => this.renderer.yscale.invert(y2));
    }
    return this.index.indices({
      x0: hr2.start,
      x1: hr2.end,
      y0: vr.start,
      y1: vr.end
    });
  }
  draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index2) {
    const len = index2 + 1;
    const sx = new Array(len);
    sx[index2] = (x0 + x1) / 2;
    const sy = new Array(len);
    sy[index2] = (y0 + y1) / 2;
    const sradius = new Array(len);
    sradius[index2] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;
    this._paint(ctx, [index2], { sx, sy, sradius });
  }
};
__publicField(RadialGlyphView, "__name__", "RadialGlyphView");
var _RadialGlyph = class _RadialGlyph extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RadialGlyph, "__name__", "RadialGlyph");
_RadialGlyph.mixins([LineVector, FillVector, HatchVector]);
_RadialGlyph.define(() => ({
  radius: [DistanceSpec, { field: "radius" }],
  radius_dimension: [RadiusDimension, "x"]
}));
var RadialGlyph = _RadialGlyph;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/circle.js
var CircleView = class extends RadialGlyphView {
  async load_glglyph() {
    const { CircleGL } = await import("./circle-6IEGJPOQ.js");
    return CircleGL;
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sradius } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sradius_i = sradius[i2];
      if (!isFinite(sx_i + sy_i + sradius_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.arc(sx_i, sy_i, sradius_i, 0, 2 * Math.PI, false);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const { hit_dilation } = this.model;
    const [x0, x1, y0, y1] = (() => {
      if (this.model.properties.radius.units == "data") {
        const dr = this.max_radius * hit_dilation;
        const x02 = x2 - dr;
        const x12 = x2 + dr;
        const y02 = y2 - dr;
        const y12 = y2 + dr;
        return [x02, x12, y02, y12];
      } else {
        const ds = this.max_radius * hit_dilation;
        const sx0 = sx - ds;
        const sx1 = sx + ds;
        const sy0 = sy - ds;
        const sy1 = sy + ds;
        const [x02, x12] = this.renderer.xscale.r_invert(sx0, sx1);
        const [y02, y12] = this.renderer.yscale.r_invert(sy0, sy1);
        return [x02, x12, y02, y12];
      }
    })();
    const candidates = this.index.indices({ x0, x1, y0, y1 });
    const indices = [];
    if (this.model.properties.radius.units == "data") {
      for (const i2 of candidates) {
        const r2 = (this.sradius[i2] * hit_dilation) ** 2;
        const [sx0, sx1] = this.renderer.xscale.r_compute(x2, this.x[i2]);
        const [sy0, sy1] = this.renderer.yscale.r_compute(y2, this.y[i2]);
        const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;
        if (dist <= r2) {
          indices.push(i2);
        }
      }
    } else {
      for (const i2 of candidates) {
        const r2 = (this.sradius[i2] * hit_dilation) ** 2;
        const dist = (this.sx[i2] - sx) ** 2 + (this.sy[i2] - sy) ** 2;
        if (dist <= r2) {
          indices.push(i2);
        }
      }
    }
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    const bounds = this.bounds();
    const [x0, x1, y0, y1] = (() => {
      const dr = this.max_radius;
      if (geometry.direction == "h") {
        const sx0 = sx - dr;
        const sx1 = sx + dr;
        const [x02, x12] = this.renderer.xscale.r_invert(sx0, sx1);
        const { y0: y02, y1: y12 } = bounds;
        return [x02, x12, y02, y12];
      } else {
        const sy0 = sy - dr;
        const sy1 = sy + dr;
        const { x0: x02, x1: x12 } = bounds;
        const [y02, y12] = this.renderer.yscale.r_invert(sy0, sy1);
        return [x02, x12, y02, y12];
      }
    })();
    const indices = [...this.index.indices({ x0, x1, y0, y1 })];
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1 } = geometry;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const candidates = this.index.indices({ x0, x1, y0, y1 });
    const indices = [];
    for (const i2 of candidates) {
      const sx_i = this.sx[i2];
      const sy_i = this.sy[i2];
      if (sx0 <= sx_i && sx_i <= sx1 && sy0 <= sy_i && sy_i <= sy1) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_poly(geometry) {
    const { sx: sxs, sy: sys } = geometry;
    const candidates = (() => {
      const [sx0, sx1, sy0, sy1] = minmax2(sxs, sys);
      const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
      const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
      return this.index.indices({ x0, x1, y0, y1 });
    })();
    const indices = [];
    for (const i2 of candidates) {
      if (point_in_poly(this.sx[i2], this.sy[i2], sxs, sys)) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
};
__publicField(CircleView, "__name__", "CircleView");
var _Circle = class _Circle extends RadialGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Circle, "__name__", "Circle");
_Circle.prototype.default_view = CircleView;
_Circle.define(({ Float: Float2 }) => ({
  hit_dilation: [Float2, 1]
}));
var Circle = _Circle;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/center_rotatable.js
var CenterRotatableView = class extends XYGlyphView {
  get max_w2() {
    return this.model.properties.width.units == "data" ? this.max_width / 2 : 0;
  }
  get max_h2() {
    return this.model.properties.height.units == "data" ? this.max_height / 2 : 0;
  }
  _bounds({ x0, x1, y0, y1 }) {
    const { max_w2, max_h2 } = this;
    return {
      x0: x0 - max_w2,
      x1: x1 + max_w2,
      y0: y0 - max_h2,
      y1: y1 + max_h2
    };
  }
};
__publicField(CenterRotatableView, "__name__", "CenterRotatableView");
var _CenterRotatable = class _CenterRotatable extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CenterRotatable, "__name__", "CenterRotatable");
_CenterRotatable.mixins([LineVector, FillVector, HatchVector]);
_CenterRotatable.define(({}) => ({
  angle: [AngleSpec, 0],
  width: [DistanceSpec, { field: "width" }],
  height: [DistanceSpec, { field: "height" }]
}));
var CenterRotatable = _CenterRotatable;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/ellipse.js
var EllipseView = class extends CenterRotatableView {
  _map_data() {
    this._define_or_inherit_attr("swidth", () => {
      if (this.model.properties.width.units == "data") {
        if (this.inherited_x && this.inherited_width) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.width, "center");
        }
      } else {
        return this.inherited_width ? inherit : to_screen(this.width);
      }
    });
    this._define_or_inherit_attr("sheight", () => {
      if (this.model.properties.height.units == "data") {
        if (this.inherited_y && this.inherited_height) {
          return inherit;
        } else {
          return this.sdist(this.renderer.yscale, this.y, this.height, "center");
        }
      } else {
        return this.inherited_height ? inherit : to_screen(this.height);
      }
    });
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, swidth, sheight, angle } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const swidth_i = swidth[i2];
      const sheight_i = sheight[i2];
      const angle_i = angle.get(i2);
      if (!isFinite(sx_i + sy_i + swidth_i + sheight_i + angle_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.ellipse(sx_i, sy_i, swidth_i / 2, sheight_i / 2, angle_i, 0, 2 * Math.PI);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    let x0, x1, y0, y1, cond, sx0, sx1, sy0, sy1;
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    if (this.model.properties.width.units == "data") {
      x0 = x2 - this.max_width;
      x1 = x2 + this.max_width;
    } else {
      sx0 = sx - this.max_width;
      sx1 = sx + this.max_width;
      [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    }
    if (this.model.properties.height.units == "data") {
      y0 = y2 - this.max_height;
      y1 = y2 + this.max_height;
    } else {
      sy0 = sy - this.max_height;
      sy1 = sy + this.max_height;
      [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    }
    const candidates = this.index.indices({ x0, x1, y0, y1 });
    const indices = [];
    for (const i2 of candidates) {
      cond = point_in_ellipse(sx, sy, this.angle.get(i2), this.sheight[i2] / 2, this.swidth[i2] / 2, this.sx[i2], this.sy[i2]);
      if (cond) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index2) {
    const n2 = index2 + 1;
    const sx = new Array(n2);
    sx[index2] = (x0 + x1) / 2;
    const sy = new Array(n2);
    sy[index2] = (y0 + y1) / 2;
    const scale = this.swidth[index2] / this.sheight[index2];
    const d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
    const swidth = new Array(n2);
    const sheight = new Array(n2);
    if (scale > 1) {
      swidth[index2] = d;
      sheight[index2] = d / scale;
    } else {
      swidth[index2] = d * scale;
      sheight[index2] = d;
    }
    const angle = new UniformScalar(0, n2);
    this._paint(ctx, [index2], { sx, sy, swidth, sheight, angle });
  }
};
__publicField(EllipseView, "__name__", "EllipseView");
var _Ellipse = class _Ellipse extends CenterRotatable {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Ellipse, "__name__", "Ellipse");
_Ellipse.prototype.default_view = EllipseView;
var Ellipse = _Ellipse;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/hbar.js
var HBarView = class extends LRTBView {
  scenterxy(i2) {
    const scx = (this.sleft[i2] + this.sright[i2]) / 2;
    const scy = this.sy[i2];
    return [scx, scy];
  }
  _lrtb(i2) {
    const left_i = this.left[i2];
    const right_i = this.right[i2];
    const y_i = this.y[i2];
    const half_height_i = this.height.get(i2) / 2;
    const l = Math.min(left_i, right_i);
    const r = Math.max(left_i, right_i);
    const t = y_i + half_height_i;
    const b2 = y_i - half_height_i;
    return { l, r, t, b: b2 };
  }
  _map_data() {
    if (this.inherited_y && this.inherited_height) {
      this._inherit_attr("sheight");
      this._inherit_attr("stop");
      this._inherit_attr("sbottom");
    } else {
      const sheight = this.sdist(this.renderer.yscale, this.y, this.height, "center");
      const { sy } = this;
      const n2 = this.sy.length;
      const stop = new ScreenArray(n2);
      const sbottom = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        const sy_i = sy[i2];
        const sheight_i = sheight[i2];
        stop[i2] = sy_i - sheight_i / 2;
        sbottom[i2] = sy_i + sheight_i / 2;
      }
      this._define_attr("sheight", sheight);
      this._define_attr("stop", stop);
      this._define_attr("sbottom", sbottom);
    }
    this._clamp_to_viewport();
  }
};
__publicField(HBarView, "__name__", "HBarView");
var _HBar = class _HBar extends LRTB2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HBar, "__name__", "HBar");
_HBar.prototype.default_view = HBarView;
_HBar.define(({}) => ({
  left: [XCoordinateSpec, { value: 0 }],
  y: [YCoordinateSpec, { field: "y" }],
  height: [DistanceSpec, { value: 1 }],
  right: [XCoordinateSpec, { field: "right" }]
}));
var HBar = _HBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/hex_tile.js
var HexTileView = class extends GlyphView {
  async load_glglyph() {
    const { HexTileGL } = await import("./hex_tile-CBIGNGRC.js");
    return HexTileGL;
  }
  scenterxy(i2) {
    const scx = this.sx[i2];
    const scy = this.sy[i2];
    return [scx, scy];
  }
  _set_data() {
    const { orientation, size: size2, aspect_scale } = this.model;
    const { q: q2, r } = this;
    const n2 = this.q.length;
    const x2 = new Float64Array(n2);
    const y2 = new Float64Array(n2);
    const sqrt32 = Math.sqrt(3);
    if (orientation == "pointytop") {
      for (let i2 = 0; i2 < n2; i2++) {
        const q_i = q2.get(i2);
        const r2_i = r.get(i2) / 2;
        x2[i2] = size2 * sqrt32 * (q_i + r2_i) / aspect_scale;
        y2[i2] = -3 * size2 * r2_i;
      }
    } else {
      for (let i2 = 0; i2 < n2; i2++) {
        const q2_i = q2.get(i2) / 2;
        const r_i = r.get(i2);
        x2[i2] = 3 * size2 * q2_i;
        y2[i2] = -size2 * sqrt32 * (r_i + q2_i) * aspect_scale;
      }
    }
    this._define_attr("x", x2);
    this._define_attr("y", y2);
  }
  _project_data() {
    this._project_xy("x", this.x, "y", this.y);
  }
  _index_data(index2) {
    let ysize = this.model.size;
    let xsize = Math.sqrt(3) * ysize / 2;
    if (this.model.orientation == "flattop") {
      [xsize, ysize] = [ysize, xsize];
      ysize *= this.model.aspect_scale;
    } else {
      xsize /= this.model.aspect_scale;
    }
    const { x: x2, y: y2, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x_i = x2[i2];
      const y_i = y2[i2];
      index2.add_rect(x_i - xsize, y_i - ysize, x_i + xsize, y_i + ysize);
    }
  }
  // overriding map_data instead of _map_data because the default automatic mappings
  // for other glyphs (with cartesian coordinates) is not useful
  map_data() {
    var _a34;
    const [sx, sy] = this.renderer.coordinates.map_to_screen(this.x, this.y);
    const [svx, svy] = this._get_unscaled_vertices();
    this._define_attr("sx", sx);
    this._define_attr("sy", sy);
    this._define_attr("svx", svx);
    this._define_attr("svy", svy);
    (_a34 = this.glglyph) == null ? void 0 : _a34.set_data_mapped();
  }
  _get_unscaled_vertices() {
    const size2 = this.model.size;
    const aspect_scale = this.model.aspect_scale;
    if (this.model.orientation == "pointytop") {
      const rscale = this.renderer.yscale;
      const hscale = this.renderer.xscale;
      const r = Math.abs(rscale.compute(0) - rscale.compute(size2));
      const h7 = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size2)) / aspect_scale;
      const r2 = r / 2;
      const svx = [0, -h7, -h7, 0, h7, h7];
      const svy = [r, r2, -r2, -r, -r2, r2];
      return [svx, svy];
    } else {
      const rscale = this.renderer.xscale;
      const hscale = this.renderer.yscale;
      const r = Math.abs(rscale.compute(0) - rscale.compute(size2));
      const h7 = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size2)) * aspect_scale;
      const r2 = r / 2;
      const svx = [r, r2, -r2, -r, -r2, r2];
      const svy = [0, -h7, -h7, 0, h7, h7];
      return [svx, svy];
    }
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, svx, svy, scale } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const scale_i = scale.get(i2);
      if (!isFinite(sx_i + sy_i + scale_i)) {
        continue;
      }
      ctx.translate(sx_i, sy_i);
      ctx.beginPath();
      for (let j = 0; j < 6; j++) {
        ctx.lineTo(svx[j] * scale_i, svy[j] * scale_i);
      }
      ctx.closePath();
      ctx.translate(-sx_i, -sy_i);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const candidates = this.index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 });
    const indices = [];
    for (const i2 of candidates) {
      if (point_in_poly(sx - this.sx[i2], sy - this.sy[i2], this.svx, this.svy)) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const rect = (() => {
      if (geometry.direction == "v") {
        const { sy } = geometry;
        const y2 = this.renderer.yscale.invert(sy);
        const hr2 = this.renderer.plot_view.frame.bbox.h_range;
        const [x0, x1] = this.renderer.xscale.r_invert(hr2.start, hr2.end);
        return { x0, y0: y2, x1, y1: y2 };
      } else {
        const { sx } = geometry;
        const x2 = this.renderer.xscale.invert(sx);
        const vr = this.renderer.plot_view.frame.bbox.v_range;
        const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);
        return { x0: x2, y0, x1: x2, y1 };
      }
    })();
    const indices = [...this.index.indices(rect)];
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1 } = geometry;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const indices = [...this.index.indices({ x0, x1, y0, y1 })];
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(HexTileView, "__name__", "HexTileView");
var _HexTile = class _HexTile extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HexTile, "__name__", "HexTile");
_HexTile.prototype.default_view = HexTileView;
_HexTile.mixins([LineVector, FillVector, HatchVector]);
_HexTile.define(({ Float: Float2 }) => ({
  r: [NumberSpec, { field: "r" }],
  q: [NumberSpec, { field: "q" }],
  scale: [NumberSpec, 1],
  size: [Float2, 1],
  aspect_scale: [Float2, 1],
  orientation: [HexTileOrientation, "pointytop"]
}));
_HexTile.override({ line_color: null });
var HexTile = _HexTile;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/hspan.js
var { abs: abs8, max: max11 } = Math;
var UNUSED = 0;
var HSpanView = class extends GlyphView {
  after_visuals() {
    super.after_visuals();
    this.max_line_width = max2(this.line_width);
  }
  _index_data(index2) {
    for (const y_i of this.y) {
      index2.add_point(UNUSED, y_i);
    }
  }
  _bounds(bounds) {
    const { y0, y1 } = bounds;
    return { x0: NaN, x1: NaN, y0, y1 };
  }
  _map_data() {
    super._map_data();
    const { round: round8 } = Math;
    if (!this.inherited_sy) {
      const sy = map(this.sy, (yi) => round8(yi));
      this._define_attr("sy", sy);
    }
  }
  scenterxy(i2) {
    const { hcenter } = this.renderer.plot_view.frame.bbox;
    return [hcenter, this.sy[i2]];
  }
  _paint(ctx, indices, data3) {
    const { sy } = { ...this, ...data3 };
    const { left: left2, right: right3 } = this.renderer.plot_view.frame.bbox;
    for (const i2 of indices) {
      const sy_i = sy[i2];
      if (!isFinite(sy_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.moveTo(left2, sy_i);
      ctx.lineTo(right3, sy_i);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _get_candidates(sy0, sy1) {
    const { max_line_width } = this;
    const [y0, y1] = this.renderer.yscale.r_invert(sy0 - max_line_width, (sy1 ?? sy0) + max_line_width);
    return this.index.indices({ x0: 0, x1: 0, y0, y1 });
  }
  _find_spans(candidates, fn) {
    const { sy, line_width } = this;
    const indices = [];
    for (const i2 of candidates) {
      const sy_i = sy[i2];
      const line_width_i = line_width.get(i2);
      if (fn(sy_i, line_width_i)) {
        indices.push(i2);
      }
    }
    return indices;
  }
  _hit_point(geometry) {
    const { sy: gsy } = geometry;
    const candidates = this._get_candidates(gsy);
    const indices = this._find_spans(candidates, (sy, line_width) => {
      return abs8(sy - gsy) <= max11(
        line_width / 2,
        2
        /*px*/
      );
    });
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const indices = (() => {
      if (geometry.direction == "v") {
        return range(0, this.data_size);
      } else {
        const { sy: gsy } = geometry;
        const candidates = this._get_candidates(gsy);
        return this._find_spans(candidates, (sy, line_width) => {
          return abs8(sy - gsy) <= max11(
            line_width / 2,
            2
            /*px*/
          );
        });
      }
    })();
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const indices = (() => {
      const { sy0: gsy0, sy1: gsy1 } = geometry;
      const candidates = this._get_candidates(gsy0, gsy1);
      return this._find_spans(candidates, (sy, line_width) => {
        return gsy0 - line_width / 2 <= sy && sy <= gsy1 + line_width / 2;
      });
    })();
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(HSpanView, "__name__", "HSpanView");
var _HSpan = class _HSpan extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HSpan, "__name__", "HSpan");
_HSpan.prototype.default_view = HSpanView;
_HSpan.mixins([LineVector]);
_HSpan.define(() => ({
  y: [YCoordinateSpec, { field: "y" }]
}));
var HSpan = _HSpan;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/hstrip.js
var UNUSED2 = 0;
var HStripView = class extends GlyphView {
  async lazy_initialize() {
    await super.lazy_initialize();
    const { webgl } = this.renderer.plot_view.canvas_view;
    if (webgl != null && webgl.regl_wrapper.has_webgl) {
      const { LRTBGL } = await import("./lrtb-GHRUHO7Z.js");
      this.glglyph = new LRTBGL(webgl.regl_wrapper, this);
    }
  }
  get sleft() {
    const { left: left2 } = this.renderer.plot_view.frame.bbox;
    const n2 = this.data_size;
    const sleft = new ScreenArray(n2);
    sleft.fill(left2);
    return sleft;
  }
  get sright() {
    const { right: right3 } = this.renderer.plot_view.frame.bbox;
    const n2 = this.data_size;
    const sright = new ScreenArray(n2);
    sright.fill(right3);
    return sright;
  }
  get stop() {
    return this.sy0;
  }
  get sbottom() {
    return this.sy1;
  }
  _set_data(indices) {
    super._set_data(indices);
    const { abs: abs11 } = Math;
    const { max: max18, map: map4, zip: zip2 } = iterator_exports;
    const { y0, y1 } = this;
    if (this.inherited_y0 && this.inherited_y1) {
      this._inherit_attr("max_height");
    } else {
      const max_height = max18(map4(zip2(y0, y1), ([y0_i, y1_i]) => abs11(y0_i - y1_i)));
      this._define_attr("max_height", max_height);
    }
  }
  _index_data(index2) {
    const { y0, y1, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const y0_i = y0[i2];
      const y1_i = y1[i2];
      index2.add_rect(UNUSED2, y0_i, UNUSED2, y1_i);
    }
  }
  _bounds(bounds) {
    const { y0, y1 } = bounds;
    return { x0: NaN, x1: NaN, y0, y1 };
  }
  _map_data() {
    super._map_data();
    const { round: round8 } = Math;
    if (!this.inherited_sy0) {
      const sy0 = map(this.sy0, (yi) => round8(yi));
      this._define_attr("sy0", sy0);
    }
    if (!this.inherited_sy1) {
      const sy1 = map(this.sy1, (yi) => round8(yi));
      this._define_attr("sy1", sy1);
    }
  }
  scenterxy(i2) {
    const { hcenter } = this.renderer.plot_view.frame.bbox;
    return [hcenter, (this.sy0[i2] + this.sy1[i2]) / 2];
  }
  _paint(ctx, indices, data3) {
    const { sy0, sy1 } = { ...this, ...data3 };
    const { left: left2, right: right3, width } = this.renderer.plot_view.frame.bbox;
    for (const i2 of indices) {
      const sy0_i = sy0[i2];
      const sy1_i = sy1[i2];
      if (!isFinite(sy0_i + sy1_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.rect(left2, sy0_i, width, sy1_i - sy0_i);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      ctx.beginPath();
      ctx.moveTo(left2, sy0_i);
      ctx.lineTo(right3, sy0_i);
      ctx.moveTo(left2, sy1_i);
      ctx.lineTo(right3, sy1_i);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _get_candidates(sy0, sy1) {
    const { max_height } = this;
    const [dy0, dy1] = this.renderer.yscale.r_invert(sy0, sy1 ?? sy0);
    const y0 = dy0 - max_height;
    const y1 = dy1 + max_height;
    return this.index.indices({ x0: 0, x1: 0, y0, y1 });
  }
  _find_strips(candidates, fn) {
    function contains3(sy02, sy12) {
      return sy02 <= sy12 ? fn(sy02, sy12) : fn(sy12, sy02);
    }
    const { sy0, sy1 } = this;
    const indices = [];
    for (const i2 of candidates) {
      const sy0_i = sy0[i2];
      const sy1_i = sy1[i2];
      if (contains3(sy0_i, sy1_i)) {
        indices.push(i2);
      }
    }
    return indices;
  }
  _hit_point(geometry) {
    const { sy } = geometry;
    const candidates = this._get_candidates(sy);
    const indices = this._find_strips(candidates, (sy0, sy1) => sy0 <= sy && sy <= sy1);
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const indices = (() => {
      if (geometry.direction == "v") {
        return range(0, this.data_size);
      } else {
        const { sy } = geometry;
        const candidates = this._get_candidates(sy);
        return this._find_strips(candidates, (sy0, sy1) => sy0 <= sy && sy <= sy1);
      }
    })();
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const indices = (() => {
      const { sy0: gsy0, sy1: gsy1 } = geometry;
      const candidates = this._get_candidates(gsy0, gsy1);
      return this._find_strips(candidates, (sy0, sy1) => {
        return gsy0 <= sy0 && sy0 <= gsy1 && gsy0 <= sy1 && sy1 <= gsy1;
      });
    })();
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(HStripView, "__name__", "HStripView");
var _HStrip = class _HStrip extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HStrip, "__name__", "HStrip");
_HStrip.prototype.default_view = HStripView;
_HStrip.mixins([LineVector, FillVector, HatchVector]);
_HStrip.define(() => ({
  y0: [YCoordinateSpec, { field: "y0" }],
  y1: [YCoordinateSpec, { field: "y1" }]
}));
var HStrip = _HStrip;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image_base.js
var ImageBaseView = class extends XYGlyphView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_paint());
  }
  get image_dimension() {
    return 2;
  }
  get xy_scale() {
    switch (this.model.origin) {
      case "bottom_left":
        return { x: 1, y: -1 };
      case "top_left":
        return { x: 1, y: 1 };
      case "bottom_right":
        return { x: -1, y: -1 };
      case "top_right":
        return { x: -1, y: 1 };
    }
  }
  get xy_offset() {
    switch (this.model.origin) {
      case "bottom_left":
        return { x: 0, y: 1 };
      case "top_left":
        return { x: 0, y: 0 };
      case "bottom_right":
        return { x: 1, y: 1 };
      case "top_right":
        return { x: 1, y: 0 };
    }
  }
  get xy_anchor() {
    return anchor(this.model.anchor);
  }
  get xy_sign() {
    const xr = this.renderer.xscale.source_range;
    const yr = this.renderer.yscale.source_range;
    return {
      x: xr.is_reversed ? -1 : 1,
      y: yr.is_reversed ? -1 : 1
    };
  }
  _paint(ctx, indices, data3) {
    const { image_data, sx, sy, sdw, sdh } = { ...this, ...data3 };
    const { xy_sign, xy_scale, xy_offset, xy_anchor } = this;
    assert(image_data != null);
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    if (this.visuals.image.doit) {
      for (const i2 of indices) {
        const image_data_i = image_data[i2];
        const sx_i = sx[i2];
        const sy_i = sy[i2];
        const sdw_i = sdw[i2];
        const sdh_i = sdh[i2];
        if (image_data_i == null || !isFinite(sx_i + sy_i + sdw_i + sdh_i)) {
          continue;
        }
        const tx_i = xy_sign.x * xy_anchor.x * sdw_i;
        const ty_i = xy_sign.y * xy_anchor.y * sdh_i;
        ctx.save();
        ctx.translate(sx_i - tx_i, sy_i - ty_i);
        ctx.scale(xy_sign.x * xy_scale.x, xy_sign.y * xy_scale.y);
        this.visuals.image.set_vectorize(ctx, i2);
        ctx.drawImage(image_data_i, -xy_offset.x * sdw_i, -xy_offset.y * sdh_i, sdw_i, sdh_i);
        ctx.restore();
      }
    }
    ctx.restore();
  }
  get _can_inherit_image_data() {
    return this.inherited_image;
  }
  _set_data(indices) {
    const n2 = this.data_size;
    if (!this._can_inherit_image_data) {
      if (typeof this.image_data === "undefined" || this.image_data.length != n2) {
        this._define_attr("image_data", new Array(n2).fill(null));
        this._define_attr("image_width", new Uint32Array(n2));
        this._define_attr("image_height", new Uint32Array(n2));
      }
      const { image_dimension } = this;
      for (let i2 = 0; i2 < n2; i2++) {
        if (indices != null && !indices.includes(i2)) {
          continue;
        }
        const img2 = this.image.get(i2);
        assert(img2.dimension == image_dimension, `expected a ${image_dimension}D array, not ${img2.dimension}D`);
        const [height, width] = img2.shape;
        this.image_width[i2] = width;
        this.image_height[i2] = height;
        const buf8 = this._flat_img_to_buf8(img2);
        this._set_image_data_from_buffer(i2, buf8);
      }
    } else {
      this._inherit_attr("image_data");
      this._inherit_attr("image_width");
      this._inherit_attr("image_height");
    }
  }
  _index_data(index2) {
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const [l, r, t, b2] = this._lrtb(i2);
      index2.add_rect(l, b2, r, t);
    }
  }
  _lrtb(i2) {
    const dw_i = this.dw.get(i2);
    const dh_i = this.dh.get(i2);
    const x_i = this.x[i2];
    const y_i = this.y[i2];
    const { xy_anchor } = this;
    const [x0, x1] = [x_i - xy_anchor.x * dw_i, x_i + (1 - xy_anchor.x) * dw_i];
    const [y0, y1] = [y_i + xy_anchor.y * dh_i, y_i - (1 - xy_anchor.y) * dh_i];
    const [l, r] = x0 <= x1 ? [x0, x1] : [x1, x0];
    const [b2, t] = y0 <= y1 ? [y0, y1] : [y1, y0];
    return [l, r, t, b2];
  }
  _get_or_create_canvas(i2) {
    assert(this.image_data != null);
    const image_data_i = this.image_data[i2];
    if (image_data_i != null && image_data_i.width == this.image_width[i2] && image_data_i.height == this.image_height[i2]) {
      return image_data_i;
    } else {
      const canvas3 = document.createElement("canvas");
      canvas3.width = this.image_width[i2];
      canvas3.height = this.image_height[i2];
      return canvas3;
    }
  }
  _set_image_data_from_buffer(i2, buf8) {
    assert(this.image_data != null);
    const canvas3 = this._get_or_create_canvas(i2);
    const ctx = canvas3.getContext("2d");
    const image_data = ctx.getImageData(0, 0, this.image_width[i2], this.image_height[i2]);
    image_data.data.set(buf8);
    ctx.putImageData(image_data, 0, 0);
    this.image_data[i2] = canvas3;
  }
  _map_data() {
    this._define_or_inherit_attr("sdw", () => {
      if (this.model.properties.dw.units == "data") {
        if (this.inherited_x && this.inherited_dw) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.dw, "edge", this.model.dilate);
        }
      } else {
        return this.inherited_dw ? inherit : to_screen(this.dw);
      }
    });
    this._define_or_inherit_attr("sdh", () => {
      if (this.model.properties.dh.units == "data") {
        if (this.inherited_y && this.inherited_dh) {
          return inherit;
        } else {
          return this.sdist(this.renderer.yscale, this.y, this.dh, "edge", this.model.dilate);
        }
      } else {
        return this.inherited_dh ? inherit : to_screen(this.dh);
      }
    });
  }
  _image_index(index2, x2, y2) {
    const [l, r, t, b2] = this._lrtb(index2);
    const width = this.image_width[index2];
    const height = this.image_height[index2];
    const dx = (r - l) / width;
    const dy = (t - b2) / height;
    const i2 = Math.floor((x2 - l) / dx);
    const j = Math.floor((y2 - b2) / dy);
    return { index: index2, i: i2, j, flat_index: j * width + i2 };
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const candidates = this.index.indices({ x0: x2, x1: x2, y0: y2, y1: y2 });
    const result = new Selection();
    const indices = [];
    for (const index2 of candidates) {
      if (isFinite(sx) && isFinite(sy)) {
        indices.push(index2);
        result.image_indices.push(this._image_index(index2, x2, y2));
      }
    }
    result.indices = indices;
    return result;
  }
};
__publicField(ImageBaseView, "__name__", "ImageBaseView");
var _ImageBase = class _ImageBase extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ImageBase, "__name__", "ImageBase");
_ImageBase.mixins(ImageVector);
_ImageBase.define(({ Bool: Bool2 }) => ({
  image: [NDArraySpec, { field: "image" }],
  dw: [DistanceSpec, { field: "dw" }],
  dh: [DistanceSpec, { field: "dh" }],
  dilate: [Bool2, false],
  origin: [ImageOrigin, "bottom_left"],
  anchor: [Anchor2, "bottom_left"]
}));
var ImageBase = _ImageBase;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image.js
var ImageView = class extends ImageBaseView {
  async load_glglyph() {
    const { ImageGL } = await import("./image-PBZNMSYB.js");
    return ImageGL;
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.color_mapper.change, () => this._update_image());
  }
  _update_image() {
    if (this.glglyph != null) {
      this.glglyph.set_image_changed();
    }
    if (this.image_data != null) {
      this._set_data(null);
      this.renderer.request_paint();
    }
  }
  get _can_inherit_image_data() {
    return super._can_inherit_image_data && this._can_inherit_from(this.model.properties.color_mapper, this.base);
  }
  _flat_img_to_buf8(img2) {
    const cmap = this.model.color_mapper.rgba_mapper;
    return cmap.v_compute(img2);
  }
};
__publicField(ImageView, "__name__", "ImageView");
var Greys9 = () => ["#000000", "#252525", "#525252", "#737373", "#969696", "#bdbdbd", "#d9d9d9", "#f0f0f0", "#ffffff"];
var _Image = class _Image extends ImageBase {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Image, "__name__", "Image");
_Image.prototype.default_view = ImageView;
_Image.define(({ Ref: Ref2 }) => ({
  color_mapper: [Ref2(ColorMapper), () => new LinearColorMapper({ palette: Greys9() })]
}));
var Image4 = _Image;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image_rgba.js
var ImageRGBAView = class extends ImageBaseView {
  async load_glglyph() {
    const { ImageGL } = await import("./image-PBZNMSYB.js");
    return ImageGL;
  }
  _flat_img_to_buf8(img2) {
    const array2 = isTypedArray(img2) ? img2 : new Uint32Array(img2);
    return new Uint8ClampedArray(array2.buffer);
  }
};
__publicField(ImageRGBAView, "__name__", "ImageRGBAView");
var _ImageRGBA = class _ImageRGBA extends ImageBase {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ImageRGBA, "__name__", "ImageRGBA");
_ImageRGBA.prototype.default_view = ImageRGBAView;
var ImageRGBA = _ImageRGBA;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image_stack.js
var ImageStackView = class extends ImageBaseView {
  async load_glglyph() {
    const { ImageGL } = await import("./image-PBZNMSYB.js");
    return ImageGL;
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.color_mapper.change, () => this._update_image());
  }
  get image_dimension() {
    return 3;
  }
  _update_image() {
    if (this.glglyph != null) {
      this.glglyph.set_image_changed();
    }
    if (this.image_data != null) {
      this._set_data(null);
      this.renderer.request_paint();
    }
  }
  get _can_inherit_image_data() {
    return super._can_inherit_image_data && this._can_inherit_from(this.model.properties.color_mapper, this.base);
  }
  _flat_img_to_buf8(img2) {
    const cmap = this.model.color_mapper.rgba_mapper;
    return cmap.v_compute(img2);
  }
};
__publicField(ImageStackView, "__name__", "ImageStackView");
var _ImageStack = class _ImageStack extends ImageBase {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ImageStack, "__name__", "ImageStack");
_ImageStack.prototype.default_view = ImageStackView;
_ImageStack.define(({ Ref: Ref2 }) => ({
  color_mapper: [Ref2(StackColorMapper)]
}));
var ImageStack = _ImageStack;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/image_url.js
var ImageURLView = class extends XYGlyphView {
  constructor() {
    super(...arguments);
    __publicField(this, "_images_rendered", false);
    __publicField(this, "_bounds_rect");
    __publicField(this, "anchor");
    /*protected*/
    __publicField(this, "image", new Array(0));
    __publicField(this, "loaders");
    __publicField(this, "resolved");
    __publicField(this, "_set_data_iteration", 0);
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_paint());
  }
  _index_data(index2) {
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      index2.add_empty();
    }
  }
  _set_data() {
    if (this.inherited_url) {
      return;
    }
    this._set_data_iteration++;
    const { url: url2 } = this;
    const n_url = url2.length;
    this.image = resize(this.image, n_url, null);
    this.loaders = new Array(n_url).fill(null);
    this.resolved = new BitSet(n_url);
    const { retry_attempts, retry_timeout } = this.model;
    const { _set_data_iteration } = this;
    for (let i2 = 0; i2 < n_url; i2++) {
      const url_i = url2.get(i2);
      if (url_i == "") {
        continue;
      }
      const loader = new ImageLoader(url_i, {
        loaded: (image_i) => {
          if (this._set_data_iteration == _set_data_iteration && !this.resolved.get(i2)) {
            this.resolved.set(i2);
            this.image[i2] = image_i;
            this.loaders[i2] = null;
            this.renderer.request_paint();
          }
        },
        failed: () => {
          if (this._set_data_iteration == _set_data_iteration) {
            this.resolved.set(i2);
            this.loaders[i2] = null;
            const image_i = this.image[i2];
            if (image_i != null) {
              this.image[i2] = null;
              this.renderer.request_paint();
            }
          }
        },
        attempts: retry_attempts + 1,
        timeout: retry_timeout
      });
      this.loaders[i2] = loader;
    }
    const w_data = this.model.properties.w.units == "data";
    const h_data = this.model.properties.h.units == "data";
    const n2 = this.data_size;
    const xs = new ScreenArray(w_data ? 2 * n2 : n2);
    const ys = new ScreenArray(h_data ? 2 * n2 : n2);
    this.anchor = anchor(this.model.anchor);
    const { x: x_anchor, y: y_anchor } = this.anchor;
    function x0x1(x2, w) {
      const x02 = x2 - x_anchor * w;
      return [x02, x02 + w];
    }
    function y0y1(y2, h7) {
      const y02 = y2 + y_anchor * h7;
      return [y02, y02 - h7];
    }
    if (w_data) {
      for (let i2 = 0; i2 < n2; i2++) {
        [xs[i2], xs[n2 + i2]] = x0x1(this.x[i2], this.w.get(i2) ?? 0);
      }
    } else {
      xs.set(this.x, 0);
    }
    if (h_data) {
      for (let i2 = 0; i2 < n2; i2++) {
        [ys[i2], ys[n2 + i2]] = y0y1(this.y[i2], this.h.get(i2) ?? 0);
      }
    } else {
      ys.set(this.y, 0);
    }
    const [x0, x1, y0, y1] = minmax2(xs, ys);
    this._bounds_rect = { x0, x1, y0, y1 };
  }
  has_finished() {
    return super.has_finished() && this._images_rendered;
  }
  _map_data() {
    const w = () => this.w.map((w_i) => w_i ?? NaN);
    const h7 = () => this.h.map((h_i) => h_i ?? NaN);
    this._define_or_inherit_attr("sw", () => {
      if (this.model.properties.w.units == "data") {
        if (this.inherited_x && this.inherited_w) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, w(), "edge", this.model.dilate);
        }
      } else {
        return this.inherited_w ? inherit : to_screen(w());
      }
    });
    this._define_or_inherit_attr("sh", () => {
      if (this.model.properties.h.units == "data") {
        if (this.inherited_y && this.inherited_h) {
          return inherit;
        } else {
          return this.sdist(this.renderer.yscale, this.y, h7(), "edge", this.model.dilate);
        }
      } else {
        return this.inherited_h ? inherit : to_screen(h7());
      }
    });
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sw, sh, angle, global_alpha } = { ...this, ...data3 };
    const { image, loaders, resolved } = this;
    const { frame } = this.renderer.plot_view;
    const { left: left2, top, width, height } = frame.bbox;
    ctx.beginPath();
    ctx.rect(left2 + 1, top + 1, width - 2, height - 2);
    ctx.clip();
    let finished = true;
    for (const i2 of indices) {
      const loader_i = loaders[i2];
      if (!isFinite(sx[i2] + sy[i2] + angle.get(i2) + global_alpha.get(i2))) {
        continue;
      }
      if (!resolved.get(i2)) {
        if (loader_i != null && loader_i.image.complete) {
          image[i2] = loader_i.image;
          loaders[i2] = null;
          resolved.set(i2);
        } else {
          finished = false;
        }
      }
      const image_i = image[i2];
      if (image_i == null) {
        continue;
      }
      if (image_i.naturalWidth == 0 && image_i.naturalHeight == 0) {
        continue;
      }
      this._render_image(ctx, i2, image_i, sx, sy, sw, sh, angle, global_alpha);
    }
    if (finished && !this._images_rendered) {
      this._images_rendered = true;
      this.notify_finished();
    }
  }
  _render_image(ctx, i2, image, sx, sy, sw, sh, angle, alpha) {
    if (!isFinite(sw[i2])) {
      sw[i2] = image.width;
    }
    if (!isFinite(sh[i2])) {
      sh[i2] = image.height;
    }
    const sw_i = sw[i2];
    const sh_i = sh[i2];
    const { anchor: anchor2 } = this;
    const dx_i = anchor2.x * sw_i;
    const dy_i = anchor2.y * sh_i;
    const sx_i = sx[i2] - dx_i;
    const sy_i = sy[i2] - dy_i;
    const angle_i = angle.get(i2);
    const alpha_i = alpha.get(i2);
    ctx.save();
    ctx.globalAlpha = alpha_i;
    const sw2 = sw_i / 2;
    const sh2 = sh_i / 2;
    if (angle_i != 0) {
      ctx.translate(sx_i, sy_i);
      ctx.translate(sw2, sh2);
      ctx.rotate(angle_i);
      ctx.translate(-sw2, -sh2);
      ctx.drawImage(image, 0, 0, sw_i, sh_i);
      ctx.translate(sw2, sh2);
      ctx.rotate(-angle_i);
      ctx.translate(-sw2, -sh2);
      ctx.translate(-sx_i, -sy_i);
    } else {
      ctx.drawImage(image, sx_i, sy_i, sw_i, sh_i);
    }
    ctx.restore();
  }
  bounds() {
    return this._bounds_rect;
  }
};
__publicField(ImageURLView, "__name__", "ImageURLView");
var _ImageURL = class _ImageURL extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ImageURL, "__name__", "ImageURL");
_ImageURL.prototype.default_view = ImageURLView;
_ImageURL.define(({ Bool: Bool2, Int: Int2 }) => ({
  url: [StringSpec, { field: "url" }],
  anchor: [Anchor, "top_left"],
  global_alpha: [NumberSpec, { value: 1 }],
  angle: [AngleSpec, 0],
  w: [NullDistanceSpec, null],
  h: [NullDistanceSpec, null],
  dilate: [Bool2, false],
  retry_attempts: [Int2, 0],
  retry_timeout: [Int2, 0]
}));
var ImageURL = _ImageURL;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/text.js
var TextAnchorSpec = class extends DataSpec {
};
__publicField(TextAnchorSpec, "__name__", "TextAnchorSpec");
var OutlineShapeSpec = class extends DataSpec {
};
__publicField(OutlineShapeSpec, "__name__", "OutlineShapeSpec");
var TextView2 = class extends XYGlyphView {
  async _build_labels(text2) {
    return Array.from(text2, (value2) => {
      if (value2 == null) {
        return null;
      } else {
        const text3 = `${value2}`;
        return new TextBox({ text: text3 });
      }
    });
  }
  async _set_lazy_data() {
    if (this.inherited_text) {
      this._inherit_attr("labels");
    } else {
      this._define_attr("labels", await this._build_labels(this.text));
    }
  }
  after_visuals() {
    super.after_visuals();
    const n2 = this.data_size;
    const { anchor: anchor2 } = this.base ?? this;
    const { padding: padding2, border_radius: border_radius2 } = this.model;
    const { text_align, text_baseline } = this.visuals.text;
    if (anchor2.is_Scalar() && anchor2.value != "auto") {
      this.anchor_ = new UniformScalar(anchor(anchor2.value), n2);
    } else if (anchor2.is_Scalar() && text_align.is_Scalar() && text_baseline.is_Scalar()) {
      this.anchor_ = new UniformScalar(text_anchor(anchor2.value, text_align.value, text_baseline.value), n2);
    } else {
      const anchors = new Array(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        const anchor_i = anchor2.get(i2);
        const align_i = text_align.get(i2);
        const baseline_i = text_baseline.get(i2);
        anchors[i2] = text_anchor(anchor_i, align_i, baseline_i);
      }
      this.anchor_ = new UniformVector(anchors);
    }
    this.padding = padding(padding2);
    this.border_radius = border_radius(border_radius2);
    this.swidth = new Float32Array(n2);
    this.sheight = new Float32Array(n2);
    const { left: left2, right: right3, top, bottom } = this.padding;
    for (const [label3, i2] of enumerate(this.labels)) {
      if (label3 == null) {
        continue;
      }
      label3.visuals = this.visuals.text.values(i2);
      label3.position = { sx: 0, sy: 0, x_anchor: "left", y_anchor: "top" };
      label3.align = "auto";
      const size2 = label3.size();
      const width = left2 + size2.width + right3;
      const height = top + size2.height + bottom;
      this.swidth[i2] = width;
      this.sheight[i2] = height;
    }
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, x_offset, y_offset, angle, outline_shape } = { ...this, ...data3 };
    const { text: text2, background_fill, background_hatch, border_line } = this.visuals;
    const { anchor_: anchor2, border_radius: border_radius2, padding: padding2 } = this;
    const { labels, swidth, sheight } = this;
    for (const i2 of indices) {
      const sx_i = sx[i2] + x_offset.get(i2);
      const sy_i = sy[i2] + y_offset.get(i2);
      const angle_i = angle.get(i2);
      const label_i = labels[i2];
      const shape_i = outline_shape.get(i2);
      if (!isFinite(sx_i + sy_i + angle_i) || label_i == null) {
        continue;
      }
      const swidth_i = swidth[i2];
      const sheight_i = sheight[i2];
      const anchor_i = anchor2.get(i2);
      const dx_i = anchor_i.x * swidth_i;
      const dy_i = anchor_i.y * sheight_i;
      ctx.translate(sx_i, sy_i);
      ctx.rotate(angle_i);
      ctx.translate(-dx_i, -dy_i);
      if (shape_i != "none" && (background_fill.v_doit(i2) || background_hatch.v_doit(i2) || border_line.v_doit(i2))) {
        const bbox = new BBox({ x: 0, y: 0, width: swidth_i, height: sheight_i });
        const visuals = {
          fill: background_fill,
          hatch: background_hatch,
          line: border_line
        };
        this._paint_shape(ctx, i2, shape_i, bbox, visuals, border_radius2);
      }
      if (text2.v_doit(i2)) {
        const { left: left2, top } = padding2;
        ctx.translate(left2, top);
        label_i.visuals = text2.values(i2);
        label_i.paint(ctx);
        ctx.translate(-left2, -top);
      }
      ctx.translate(dx_i, dy_i);
      ctx.rotate(-angle_i);
      ctx.translate(-sx_i, -sy_i);
    }
  }
  _paint_shape(ctx, i2, shape, bbox, visuals, border_radius2) {
    ctx.beginPath();
    switch (shape) {
      case "none": {
        break;
      }
      case "box":
      case "rectangle": {
        round_rect(ctx, bbox, border_radius2);
        break;
      }
      case "square": {
        const square2 = (() => {
          const { x: x2, y: y2, width, height } = bbox;
          if (width > height) {
            const dy = (width - height) / 2;
            return new BBox({ x: x2, y: y2 - dy, width, height: width });
          } else {
            const dx = (height - width) / 2;
            return new BBox({ x: x2 - dx, y: y2, width: height, height });
          }
        })();
        round_rect(ctx, square2, border_radius2);
        break;
      }
      case "circle": {
        const cx = bbox.x_center;
        const cy = bbox.y_center;
        const radius = sqrt(bbox.width ** 2 + bbox.height ** 2) / 2;
        ctx.arc(cx, cy, radius, 0, 2 * PI, false);
        break;
      }
      case "ellipse": {
        const cx = bbox.x_center;
        const cy = bbox.y_center;
        const rx = bbox.width / 2;
        const ry = bbox.height / 2;
        const n2 = 1.5;
        const x_0 = rx;
        const y_0 = ry;
        const a2 = sqrt(x_0 ** 2 + x_0 ** (2 / n2) * y_0 ** (2 - 2 / n2));
        const b2 = sqrt(y_0 ** 2 + y_0 ** (2 / n2) * x_0 ** (2 - 2 / n2));
        ctx.ellipse(cx, cy, a2, b2, 0, 0, 2 * PI);
        break;
      }
      case "trapezoid": {
        const { left: left2, right: right3, top, bottom, width } = bbox;
        const ext = 0.2 * width;
        ctx.moveTo(left2, top);
        ctx.lineTo(right3, top);
        ctx.lineTo(right3 + ext, bottom);
        ctx.lineTo(left2 - ext, bottom);
        ctx.closePath();
        break;
      }
      case "parallelogram": {
        const { left: left2, right: right3, top, bottom, width } = bbox;
        const ext = 0.2 * width;
        ctx.moveTo(left2, top);
        ctx.lineTo(right3 + ext, top);
        ctx.lineTo(right3, bottom);
        ctx.lineTo(left2 - ext, bottom);
        ctx.closePath();
        break;
      }
      case "diamond": {
        const { x_center, y_center, width, height } = bbox;
        ctx.moveTo(x_center, y_center - height);
        ctx.lineTo(width + width / 2, y_center);
        ctx.lineTo(x_center, y_center + height);
        ctx.lineTo(-width / 2, y_center);
        ctx.closePath();
        break;
      }
      case "triangle": {
        const w = bbox.width;
        const h7 = bbox.height;
        const l = sqrt(3) / 2 * w;
        const H = h7 + l;
        ctx.translate(w / 2, -l);
        ctx.moveTo(0, 0);
        ctx.lineTo(H / 2, H);
        ctx.lineTo(-H / 2, H);
        ctx.closePath();
        ctx.translate(-w / 2, l);
        break;
      }
    }
    visuals.fill.apply(ctx, i2);
    visuals.hatch.apply(ctx, i2);
    visuals.line.apply(ctx, i2);
  }
  _hit_point(geometry) {
    const hit_xy = { x: geometry.sx, y: geometry.sy };
    const { sx, sy, x_offset, y_offset, angle, labels } = this;
    const { anchor_: anchor2 } = this;
    const { swidth, sheight } = this;
    const n2 = this.data_size;
    const indices = [];
    for (let i2 = 0; i2 < n2; i2++) {
      const sx_i = sx[i2] + x_offset.get(i2);
      const sy_i = sy[i2] + y_offset.get(i2);
      const angle_i = angle.get(i2);
      const label_i = labels[i2];
      if (!isFinite(sx_i + sy_i + angle_i) || label_i == null) {
        continue;
      }
      const swidth_i = swidth[i2];
      const sheight_i = sheight[i2];
      const anchor_i = anchor2.get(i2);
      const dx_i = anchor_i.x * swidth_i;
      const dy_i = anchor_i.y * sheight_i;
      const { x: x2, y: y2 } = rotate_around(hit_xy, { x: sx_i, y: sy_i }, -angle_i);
      const left2 = sx_i - dx_i;
      const top = sy_i - dy_i;
      const right3 = left2 + swidth_i;
      const bottom = top + sheight_i;
      if (left2 <= x2 && x2 <= right3 && top <= y2 && y2 <= bottom) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  rect_i(i2) {
    const { sx, sy, x_offset, y_offset, angle, labels } = this;
    const { anchor_: anchor2 } = this;
    const { swidth, sheight } = this;
    const sx_i = sx[i2] + x_offset.get(i2);
    const sy_i = sy[i2] + y_offset.get(i2);
    const angle_i = angle.get(i2);
    const label_i = labels[i2];
    if (!isFinite(sx_i + sy_i + angle_i) || label_i == null) {
      return {
        p0: { x: NaN, y: NaN },
        p1: { x: NaN, y: NaN },
        p2: { x: NaN, y: NaN },
        p3: { x: NaN, y: NaN }
      };
    }
    const swidth_i = swidth[i2];
    const sheight_i = sheight[i2];
    const anchor_i = anchor2.get(i2);
    const dx_i = anchor_i.x * swidth_i;
    const dy_i = anchor_i.y * sheight_i;
    const bbox = new BBox({
      x: sx_i - dx_i,
      y: sy_i - dy_i,
      width: swidth_i,
      height: sheight_i
    });
    const { rect } = bbox;
    if (angle_i == 0) {
      return rect;
    } else {
      const tr2 = new AffineTransform();
      tr2.rotate_around(sx_i, sy_i, angle_i);
      return tr2.apply_rect(rect);
    }
  }
  scenterxy(i2) {
    const { p0, p1, p2, p3 } = this.rect_i(i2);
    const sx = (p0.x + p1.x + p2.x + p3.x) / 4;
    const sy = (p0.y + p1.y + p2.y + p3.y) / 4;
    return [sx, sy];
  }
};
__publicField(TextView2, "__name__", "TextView");
var _Text2 = class _Text2 extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Text2, "__name__", "Text");
_Text2.prototype.default_view = TextView2;
_Text2.mixins([
  TextVector,
  ["border_", LineVector],
  ["background_", FillVector],
  ["background_", HatchVector]
]);
_Text2.define(() => ({
  text: [NullStringSpec, { field: "text" }],
  angle: [AngleSpec, 0],
  x_offset: [NumberSpec, 0],
  y_offset: [NumberSpec, 0],
  anchor: [TextAnchorSpec, { value: "auto" }],
  padding: [Padding, 0],
  border_radius: [BorderRadius, 0],
  outline_shape: [OutlineShapeSpec, "box"]
}));
_Text2.override({
  border_line_color: null,
  background_fill_color: null,
  background_hatch_color: null
});
var Text4 = _Text2;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/math_text_glyph.js
var MathTextGlyphView = class extends TextView2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_label_views", /* @__PURE__ */ new Map());
  }
  remove() {
    remove_views(this._label_views);
    super.remove();
  }
  *children() {
    yield* super.children();
    yield* this._label_views.values();
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    for (const view of this._label_views.values()) {
      if (!view.has_finished()) {
        return false;
      }
    }
    return true;
  }
  async _build_labels(text2) {
    const labels = Array.from(text2, (text_i) => {
      return text_i == null ? null : this._build_label(text_i);
    });
    await build_views(this._label_views, labels.filter((v) => v != null), { parent: this.renderer });
    return labels.map((label_i) => {
      return label_i == null ? null : this._label_views.get(label_i).graphics();
    });
  }
  async after_lazy_visuals() {
    await super.after_lazy_visuals();
    const promises = [...this._label_views.values()].map((label_view) => {
      if (label_view instanceof MathTextView) {
        return label_view.request_image();
      } else {
        return null;
      }
    });
    await Promise.allSettled(promises);
    const { left: left2, right: right3, top, bottom } = this.padding;
    for (const [label3, i2] of enumerate(this.labels)) {
      if (label3 == null) {
        continue;
      }
      if (!(label3 instanceof MathTextView)) {
        continue;
      }
      const size2 = label3.size();
      const width = left2 + size2.width + right3;
      const height = top + size2.height + bottom;
      this.swidth[i2] = width;
      this.sheight[i2] = height;
    }
  }
};
__publicField(MathTextGlyphView, "__name__", "MathTextGlyphView");
var MathTextGlyph = class extends Text4 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(MathTextGlyph, "__name__", "MathTextGlyph");

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/mathml_glyph.js
var MathMLGlyphView = class extends MathTextGlyphView {
  _build_label(text2) {
    return new MathML({ text: text2 });
  }
};
__publicField(MathMLGlyphView, "__name__", "MathMLGlyphView");
var _MathMLGlyph = class _MathMLGlyph extends MathTextGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MathMLGlyph, "__name__", "MathMLGlyph");
_MathMLGlyph.prototype.default_view = MathMLGlyphView;
var MathMLGlyph = _MathMLGlyph;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/multi_line.js
var MultiLineView = class extends GlyphView {
  async load_glglyph() {
    const { MultiLineGL } = await import("./multi_line-2OSLDI4L.js");
    return MultiLineGL;
  }
  _project_data() {
    this._project_xy("xs", this.xs.data, "ys", this.ys.data);
  }
  _index_data(index2) {
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const xsi = this.xs.get(i2);
      const ysi = this.ys.get(i2);
      const [x0, x1, y0, y1] = minmax2(xsi, ysi);
      index2.add_rect(x0, y0, x1, y1);
    }
  }
  _paint(ctx, indices, data3) {
    const { sxs, sys } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx = sxs.get(i2);
      const sy = sys.get(i2);
      const n2 = Math.min(sx.length, sy.length);
      let move = true;
      ctx.beginPath();
      for (let j = 0; j < n2; j++) {
        const sx_j = sx[j];
        const sy_j = sy[j];
        if (!isFinite(sx_j + sy_j)) {
          move = true;
        } else {
          if (move) {
            ctx.moveTo(sx_j, sy_j);
            move = false;
          } else {
            ctx.lineTo(sx_j, sy_j);
          }
        }
      }
      this.visuals.line.set_vectorize(ctx, i2);
      ctx.stroke();
    }
  }
  _hit_point(geometry) {
    const point = { x: geometry.sx, y: geometry.sy };
    let shortest = 9999;
    const hits = /* @__PURE__ */ new Map();
    for (let i2 = 0, end = this.sxs.length; i2 < end; i2++) {
      const threshold = Math.max(2, this.line_width.get(i2) / 2);
      const sxsi = this.sxs.get(i2);
      const sysi = this.sys.get(i2);
      let points = null;
      for (let j = 0, endj = sxsi.length - 1; j < endj; j++) {
        const p0 = { x: sxsi[j], y: sysi[j] };
        const p1 = { x: sxsi[j + 1], y: sysi[j + 1] };
        const dist = dist_to_segment(point, p0, p1);
        if (dist < threshold && dist < shortest) {
          shortest = dist;
          points = [j];
        }
      }
      if (points != null) {
        hits.set(i2, points);
      }
    }
    return new Selection({
      indices: [...hits.keys()],
      multiline_indices: hits
    });
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    let val;
    let vs;
    if (geometry.direction == "v") {
      val = this.renderer.yscale.invert(sy);
      vs = this.ys;
    } else {
      val = this.renderer.xscale.invert(sx);
      vs = this.xs;
    }
    const hits = /* @__PURE__ */ new Map();
    for (let i2 = 0, end = vs.length; i2 < end; i2++) {
      const vsi = vs.get(i2);
      const points = [];
      for (let j = 0, endj = vsi.length - 1; j < endj; j++) {
        if (vsi[j] <= val && val <= vsi[j + 1]) {
          points.push(j);
        }
      }
      if (points.length > 0) {
        hits.set(i2, points);
      }
    }
    return new Selection({
      indices: [...hits.keys()],
      multiline_indices: hits
    });
  }
  get_interpolation_hit(i2, point_i, geometry) {
    const xsi = this.xs.get(i2);
    const ysi = this.ys.get(i2);
    const x2 = xsi[point_i];
    const y2 = ysi[point_i];
    const x3 = xsi[point_i + 1];
    const y3 = ysi[point_i + 1];
    return line_interpolation(this.renderer, geometry, x2, y2, x3, y3);
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
  scenterxy() {
    throw new Error(`${this}.scenterxy() is not implemented`);
  }
};
__publicField(MultiLineView, "__name__", "MultiLineView");
var _MultiLine = class _MultiLine extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultiLine, "__name__", "MultiLine");
_MultiLine.prototype.default_view = MultiLineView;
_MultiLine.define(({}) => ({
  xs: [XCoordinateSeqSpec, { field: "xs" }],
  ys: [YCoordinateSeqSpec, { field: "ys" }]
}));
_MultiLine.mixins(LineVector);
var MultiLine = _MultiLine;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/multi_polygons.js
var MultiPolygonsView = class extends GlyphView {
  constructor() {
    super(...arguments);
    __publicField(this, "_hole_index");
  }
  _project_data() {
  }
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const xsi = this.xs[i2];
      const ysi = this.ys[i2];
      if (xsi.length == 0 || ysi.length == 0) {
        index2.add_empty();
        continue;
      }
      let xi0 = Infinity;
      let xi1 = -Infinity;
      let yi0 = Infinity;
      let yi1 = -Infinity;
      for (let j = 0, endj = xsi.length; j < endj; j++) {
        const xsij = xsi[j][0];
        const ysij = ysi[j][0];
        if (xsij.length != 0 && ysij.length != 0) {
          const [xij0, xij1, yij0, yij1] = minmax2(xsij, ysij);
          xi0 = min10(xi0, xij0);
          xi1 = max18(xi1, xij1);
          yi0 = min10(yi0, yij0);
          yi1 = max18(yi1, yij1);
        }
      }
      index2.add_rect(xi0, yi0, xi1, yi1);
    }
    this._hole_index = this._index_hole_data();
  }
  _index_hole_data() {
    const { min: min10, max: max18 } = Math;
    const { data_size } = this;
    const index2 = new SpatialIndex(data_size);
    for (let i2 = 0; i2 < data_size; i2++) {
      const xsi = this.xs[i2];
      const ysi = this.ys[i2];
      if (xsi.length == 0 || ysi.length == 0) {
        index2.add_empty();
        continue;
      }
      let xi0 = Infinity;
      let xi1 = -Infinity;
      let yi0 = Infinity;
      let yi1 = -Infinity;
      for (let j = 0, endj = xsi.length; j < endj; j++) {
        const xsij = xsi[j];
        const ysij = ysi[j];
        if (xsij.length > 1 && ysij.length > 1) {
          for (let k = 1, endk = xsij.length; k < endk; k++) {
            const [xij0, xij1, yij0, yij1] = minmax2(xsij[k], ysij[k]);
            xi0 = min10(xi0, xij0);
            xi1 = max18(xi1, xij1);
            yi0 = min10(yi0, yij0);
            yi1 = max18(yi1, yij1);
          }
        }
      }
      index2.add_rect(xi0, yi0, xi1, yi1);
    }
    index2.finish();
    return index2;
  }
  _mask_data() {
    const { x_source, y_source } = this.renderer.coordinates;
    return this.index.indices({
      x0: x_source.min,
      x1: x_source.max,
      y0: y_source.min,
      y1: y_source.max
    });
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.fill.doit && !this.visuals.line.doit) {
      return;
    }
    const { sxs, sys } = { ...this, ...data3 };
    for (const i2 of indices) {
      ctx.beginPath();
      const sx_i = sxs[i2];
      const sy_i = sys[i2];
      const nj = Math.min(sx_i.length, sy_i.length);
      for (let j = 0; j < nj; j++) {
        const sx_ij = sx_i[j];
        const sy_ij = sy_i[j];
        const nk = Math.min(sx_ij.length, sy_ij.length);
        for (let k = 0; k < nk; k++) {
          const sx_ijk = sx_ij[k];
          const sy_ijk = sy_ij[k];
          const nl = Math.min(sx_ijk.length, sy_ijk.length);
          for (let l = 0; l < nl; l++) {
            const sx_ijkl = sx_ijk[l];
            const sy_ijkl = sy_ijk[l];
            if (l == 0) {
              ctx.moveTo(sx_ijkl, sy_ijkl);
            } else {
              ctx.lineTo(sx_ijkl, sy_ijkl);
            }
          }
          ctx.closePath();
        }
      }
      this.visuals.fill.apply(ctx, i2, "evenodd");
      this.visuals.hatch.apply(ctx, i2, "evenodd");
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_poly(geometry) {
    const { sx: sxs, sy: sys, greedy = false } = geometry;
    const candidates = (() => {
      const xs = this.renderer.xscale.v_invert(sxs);
      const ys = this.renderer.yscale.v_invert(sys);
      const [x0, x1, y0, y1] = minmax2(xs, ys);
      return this.index.indices({ x0, x1, y0, y1 });
    })();
    const indices = [];
    for (const i2 of candidates) {
      const sxs_i = this.sxs[i2];
      const sys_i = this.sys[i2];
      let hit = !greedy;
      const nj = sxs_i.length;
      for (let j = 0; j < nj; j++) {
        const sxs_ij0 = sxs_i[j][0];
        const sys_ij0 = sys_i[j][0];
        const nk = sxs_ij0.length;
        for (let k = 0; k < nk; k++) {
          const sxs_ij0k = sxs_ij0[k];
          const sys_ij0k = sys_ij0[k];
          if (!point_in_poly(sxs_ij0k, sys_ij0k, sxs, sys)) {
            if (!greedy) {
              hit = false;
              break;
            }
          } else {
            if (greedy) {
              hit = true;
              break;
            }
          }
        }
        if (!greedy) {
          if (!hit) {
            break;
          }
        } else {
          if (hit) {
            break;
          }
        }
      }
      if (hit) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1, greedy } = geometry;
    const sxs = [sx0, sx1, sx1, sx0];
    const sys = [sy0, sy0, sy1, sy1];
    return this._hit_poly({ type: "poly", sx: sxs, sy: sys, greedy });
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const candidates = this.index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 });
    const hole_candidates = this._hole_index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 });
    const indices = [];
    for (const index2 of candidates) {
      const sxs = this.sxs[index2];
      const sys = this.sys[index2];
      for (let j = 0, endj = sxs.length; j < endj; j++) {
        const nk = sxs[j].length;
        if (point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {
          if (nk == 1) {
            indices.push(index2);
          } else if (!hole_candidates.get(index2)) {
            indices.push(index2);
          } else if (nk > 1) {
            let in_a_hole = false;
            for (let k = 1; k < nk; k++) {
              const sxs_k = sxs[j][k];
              const sys_k = sys[j][k];
              if (point_in_poly(sx, sy, sxs_k, sys_k)) {
                in_a_hole = true;
                break;
              } else {
                continue;
              }
            }
            if (!in_a_hole) {
              indices.push(index2);
            }
          }
        }
      }
    }
    return new Selection({ indices });
  }
  _get_snap_coord(array2) {
    return sum(array2) / array2.length;
  }
  scenterxy(i2, sx, sy) {
    if (this.sxs[i2].length == 1) {
      const scx = this._get_snap_coord(this.sxs[i2][0][0]);
      const scy = this._get_snap_coord(this.sys[i2][0][0]);
      return [scx, scy];
    } else {
      const sxs = this.sxs[i2];
      const sys = this.sys[i2];
      for (let j = 0, end = sxs.length; j < end; j++) {
        if (point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {
          const scx = this._get_snap_coord(sxs[j][0]);
          const scy = this._get_snap_coord(sys[j][0]);
          return [scx, scy];
        }
      }
    }
    unreachable();
  }
  map_data() {
    if (this.inherited_xs && this.inherited_ys) {
      this._inherit_attr("sxs");
      this._inherit_attr("sys");
    } else {
      const { xs, ys } = this;
      const n_i = xs.length;
      const sxs = new Array(n_i);
      const sys = new Array(n_i);
      for (let i2 = 0; i2 < n_i; i2++) {
        const n_j = xs[i2].length;
        sxs[i2] = new Array(n_j);
        sys[i2] = new Array(n_j);
        for (let j = 0; j < n_j; j++) {
          const n_k = xs[i2][j].length;
          sxs[i2][j] = new Array(n_k);
          sys[i2][j] = new Array(n_k);
          for (let k = 0; k < n_k; k++) {
            const [sx, sy] = this.renderer.coordinates.map_to_screen(xs[i2][j][k], ys[i2][j][k]);
            sxs[i2][j][k] = sx;
            sys[i2][j][k] = sy;
          }
        }
      }
      this._define_attr("sxs", sxs);
      this._define_attr("sys", sys);
    }
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(MultiPolygonsView, "__name__", "MultiPolygonsView");
var _MultiPolygons = class _MultiPolygons extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultiPolygons, "__name__", "MultiPolygons");
_MultiPolygons.prototype.default_view = MultiPolygonsView;
_MultiPolygons.define(({}) => ({
  xs: [XCoordinateSeqSeqSeqSpec, { field: "xs" }],
  ys: [YCoordinateSeqSeqSeqSpec, { field: "ys" }]
}));
_MultiPolygons.mixins([LineVector, FillVector, HatchVector]);
var MultiPolygons = _MultiPolygons;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/ngon.js
function ngon(x2, y2, r, n2, angle) {
  const xs = new Float32Array(n2);
  const ys = new Float32Array(n2);
  const alpha_i = 2 * Math.PI / n2;
  for (let i2 = 0; i2 < n2; i2++) {
    const alpha = i2 * alpha_i + angle;
    xs[i2] = x2 + r * Math.sin(alpha);
    ys[i2] = y2 + r * -Math.cos(alpha);
  }
  return [xs, ys];
}
var NgonView = class extends RadialGlyphView {
  async load_glglyph() {
    const { NgonGL } = await import("./ngon-S4ZEX55C.js");
    return NgonGL;
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sradius, angle, n: n2 } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sradius_i = sradius[i2];
      const angle_i = angle.get(i2);
      const n_i = n2.get(i2);
      if (n_i < 3 || !isFinite(sx_i + sy_i + sradius_i + angle_i + n_i)) {
        continue;
      }
      const [sxs, sys] = ngon(sx_i, sy_i, sradius_i, n_i, angle_i);
      ctx.beginPath();
      ctx.moveTo(sxs[0], sys[0]);
      for (let i3 = 1; i3 <= n_i; i3++) {
        ctx.lineTo(sxs[i3], sys[i3]);
      }
      ctx.closePath();
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _ngon(index2) {
    const { sx, sy, sradius, angle, n: n2 } = { ...this };
    const sx_i = sx[index2];
    const sy_i = sy[index2];
    const sradius_i = sradius[index2];
    const angle_i = angle.get(index2);
    const n_i = n2.get(index2);
    return ngon(sx_i, sy_i, sradius_i, n_i, angle_i);
  }
  _hit_point(geometry) {
    const x2 = this.renderer.xscale.invert(geometry.sx);
    const y2 = this.renderer.yscale.invert(geometry.sy);
    const candidates = this.index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 });
    const indices = [];
    for (const index2 of candidates) {
      const [sxs, sys] = this._ngon(index2);
      if (point_in_poly(geometry.sx, geometry.sy, sxs, sys)) {
        indices.push(index2);
      }
    }
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    const { x0, x1, y0, y1 } = this.bounds();
    const [val, dim, candidates] = (() => {
      switch (geometry.direction) {
        case "v": {
          const y2 = this.renderer.yscale.invert(sy);
          const candidates2 = this.index.indices({ x0, y0: y2, x1, y1: y2 });
          return [sy, 1, candidates2];
        }
        case "h": {
          const x2 = this.renderer.xscale.invert(sx);
          const candidates2 = this.index.indices({ x0: x2, y0, x1: x2, y1 });
          return [sx, 0, candidates2];
        }
      }
    })();
    const indices = [];
    for (const index2 of candidates) {
      const coords = this._ngon(index2)[dim];
      for (let i2 = 0; i2 < coords.length - 1; i2++) {
        if (coords[i2] <= val && val <= coords[i2 + 1] || coords[i2 + 1] <= val && val <= coords[i2]) {
          indices.push(index2);
          break;
        }
      }
    }
    return new Selection({ indices });
  }
  _hit_poly(geometry) {
    const { sx: gsx, sy: gsy } = geometry;
    const candidates = (() => {
      const xs = this.renderer.xscale.v_invert(gsx);
      const ys = this.renderer.yscale.v_invert(gsy);
      const [x0, x1, y0, y1] = minmax2(xs, ys);
      return this.index.indices({ x0, x1, y0, y1 });
    })();
    const indices = [];
    for (const index2 of candidates) {
      const [sxs, sys] = this._ngon(index2);
      if (vertex_overlap(sxs, sys, gsx, gsy)) {
        indices.push(index2);
        continue;
      }
      if (edge_intersection(sxs, sys, gsx, gsy)) {
        indices.push(index2);
        continue;
      }
    }
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1 } = geometry;
    const sxs = [sx0, sx1, sx1, sx0];
    const sys = [sy0, sy0, sy1, sy1];
    return this._hit_poly({ type: "poly", sx: sxs, sy: sys });
  }
};
__publicField(NgonView, "__name__", "NgonView");
var _Ngon = class _Ngon extends RadialGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Ngon, "__name__", "Ngon");
_Ngon.prototype.default_view = NgonView;
_Ngon.define(() => ({
  angle: [AngleSpec, 0],
  n: [NumberSpec, { field: "n" }]
}));
var Ngon = _Ngon;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/patches.js
var PatchesView = class extends GlyphView {
  _project_data() {
    this._project_xy("xs", this.xs.data, "ys", this.ys.data);
  }
  _index_data(index2) {
    const { data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const xsi = this.xs.get(i2);
      const ysi = this.ys.get(i2);
      const [x0, x1, y0, y1] = minmax2(xsi, ysi);
      index2.add_rect(x0, y0, x1, y1);
    }
  }
  _mask_data() {
    const { x_source, y_source } = this.renderer.coordinates;
    return this.index.indices({
      x0: x_source.min,
      x1: x_source.max,
      y0: y_source.min,
      y1: y_source.max
    });
  }
  _paint(ctx, indices, data3) {
    const { sxs, sys } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sxs.get(i2);
      const sy_i = sys.get(i2);
      let move = true;
      ctx.beginPath();
      const n2 = Math.min(sx_i.length, sy_i.length);
      for (let j = 0; j < n2; j++) {
        const sx_j = sx_i[j];
        const sy_j = sy_i[j];
        if (!isFinite(sx_j + sy_j)) {
          ctx.closePath();
          move = true;
        } else {
          if (move) {
            ctx.moveTo(sx_j, sy_j);
            move = false;
          } else {
            ctx.lineTo(sx_j, sy_j);
          }
        }
      }
      ctx.closePath();
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_poly(geometry) {
    const { sx: sxs, sy: sys, greedy = false } = geometry;
    const candidates = (() => {
      const xs = this.renderer.xscale.v_invert(sxs);
      const ys = this.renderer.yscale.v_invert(sys);
      const [x0, x1, y0, y1] = minmax2(xs, ys);
      return this.index.indices({ x0, x1, y0, y1 });
    })();
    const indices = [];
    for (const i2 of candidates) {
      const sxs_i = this.sxs.get(i2);
      const sys_i = this.sys.get(i2);
      const n2 = sxs_i.length;
      if (n2 == 0) {
        continue;
      }
      let hit = !greedy;
      for (let j = 0; j < n2; j++) {
        const sx = sxs_i[j];
        const sy = sys_i[j];
        if (!point_in_poly(sx, sy, sxs, sys)) {
          if (!greedy) {
            hit = false;
            break;
          }
        } else {
          if (greedy) {
            hit = true;
            break;
          }
        }
      }
      if (hit) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1, greedy } = geometry;
    const sxs = [sx0, sx1, sx1, sx0];
    const sys = [sy0, sy0, sy1, sy1];
    return this._hit_poly({ type: "poly", sx: sxs, sy: sys, greedy });
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    const candidates = this.index.indices({ x0: x2, y0: y2, x1: x2, y1: y2 });
    const indices = [];
    for (const index2 of candidates) {
      const sxsi = this.sxs.get(index2);
      const sysi = this.sys.get(index2);
      const n2 = sxsi.length;
      for (let k = 0, j = 0; ; j++) {
        if (isNaN(sxsi[j]) || j == n2) {
          const sxsi_kj = sxsi.subarray(k, j);
          const sysi_kj = sysi.subarray(k, j);
          if (point_in_poly(sx, sy, sxsi_kj, sysi_kj)) {
            indices.push(index2);
            break;
          }
          k = j + 1;
        }
        if (j == n2) {
          break;
        }
      }
    }
    return new Selection({ indices });
  }
  _get_snap_coord(array2) {
    return sum(array2) / array2.length;
  }
  scenterxy(i2, sx, sy) {
    const sxsi = this.sxs.get(i2);
    const sysi = this.sys.get(i2);
    const n2 = sxsi.length;
    let has_nan = false;
    for (let k = 0, j = 0; ; j++) {
      const this_nan = isNaN(sxsi[j]);
      has_nan = has_nan || this_nan;
      if (j == n2 && !has_nan) {
        const scx = this._get_snap_coord(sxsi);
        const scy = this._get_snap_coord(sysi);
        return [scx, scy];
      }
      if (this_nan || j == n2) {
        const sxsi_kj = sxsi.subarray(k, j);
        const sysi_kj = sysi.subarray(k, j);
        if (point_in_poly(sx, sy, sxsi_kj, sysi_kj)) {
          const scx = this._get_snap_coord(sxsi_kj);
          const scy = this._get_snap_coord(sysi_kj);
          return [scx, scy];
        }
        k = j + 1;
      }
      if (j == n2) {
        break;
      }
    }
    unreachable();
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(PatchesView, "__name__", "PatchesView");
var _Patches = class _Patches extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Patches, "__name__", "Patches");
_Patches.prototype.default_view = PatchesView;
_Patches.define(({}) => ({
  xs: [XCoordinateSeqSpec, { field: "xs" }],
  ys: [YCoordinateSeqSpec, { field: "ys" }]
}));
_Patches.mixins([LineVector, FillVector, HatchVector]);
var Patches = _Patches;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/quad.js
var QuadView = class extends LRTBView {
  scenterxy(i2) {
    const scx = this.sleft[i2] / 2 + this.sright[i2] / 2;
    const scy = this.stop[i2] / 2 + this.sbottom[i2] / 2;
    return [scx, scy];
  }
  _lrtb(i2) {
    const l = this.left[i2];
    const r = this.right[i2];
    const t = this.top[i2];
    const b2 = this.bottom[i2];
    return { l, r, t, b: b2 };
  }
};
__publicField(QuadView, "__name__", "QuadView");
var _Quad = class _Quad extends LRTB2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Quad, "__name__", "Quad");
_Quad.prototype.default_view = QuadView;
_Quad.define(({}) => ({
  right: [XCoordinateSpec, { field: "right" }],
  bottom: [YCoordinateSpec, { field: "bottom" }],
  left: [XCoordinateSpec, { field: "left" }],
  top: [YCoordinateSpec, { field: "top" }]
}));
var Quad = _Quad;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/quadratic.js
var QuadraticView = class extends GlyphView {
  _project_data() {
    this._project_xy("x0", this.x0, "y0", this.y0);
    this._project_xy("x1", this.x1, "y1", this.y1);
  }
  _index_data(index2) {
    const { x0, x1, y0, y1, cx, cy, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x0_i = x0[i2];
      const x1_i = x1[i2];
      const y0_i = y0[i2];
      const y1_i = y1[i2];
      const cx_i = cx[i2];
      const cy_i = cy[i2];
      if (!isFinite(x0_i + x1_i + y0_i + y1_i + cx_i + cy_i)) {
        index2.add_empty();
      } else {
        const { x0: x02, y0: y02, x1: x12, y1: y12 } = qbb(x0_i, y0_i, cx_i, cy_i, x1_i, y1_i);
        index2.add_rect(x02, y02, x12, y12);
      }
    }
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.line.doit) {
      return;
    }
    const { sx0, sy0, sx1, sy1, scx, scy } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx0_i = sx0[i2];
      const sy0_i = sy0[i2];
      const sx1_i = sx1[i2];
      const sy1_i = sy1[i2];
      const scx_i = scx[i2];
      const scy_i = scy[i2];
      if (!isFinite(sx0_i + sy0_i + sx1_i + sy1_i + scx_i + scy_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.moveTo(sx0_i, sy0_i);
      ctx.quadraticCurveTo(scx_i, scy_i, sx1_i, sy1_i);
      this.visuals.line.apply(ctx, i2);
    }
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
  scenterxy() {
    throw new Error(`${this}.scenterxy() is not implemented`);
  }
};
__publicField(QuadraticView, "__name__", "QuadraticView");
var _Quadratic = class _Quadratic extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Quadratic, "__name__", "Quadratic");
_Quadratic.prototype.default_view = QuadraticView;
_Quadratic.define(({}) => ({
  x0: [XCoordinateSpec, { field: "x0" }],
  y0: [YCoordinateSpec, { field: "y0" }],
  x1: [XCoordinateSpec, { field: "x1" }],
  y1: [YCoordinateSpec, { field: "y1" }],
  cx: [XCoordinateSpec, { field: "cx" }],
  cy: [YCoordinateSpec, { field: "cy" }]
}));
_Quadratic.mixins(LineVector);
var Quadratic = _Quadratic;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/ray.js
var RayView = class extends XYGlyphView {
  _map_data() {
    this._define_or_inherit_attr("slength", () => {
      if (this.model.properties.length.units == "data") {
        if (this.inherited_x && this.inherited_length) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.length);
        }
      } else {
        return this.inherited_length ? inherit : to_screen(this.length);
      }
    });
    if (!this.inherited_slength) {
      const { width, height } = this.renderer.plot_view.frame.bbox;
      const inf_len = 2 * (width + height);
      const { slength } = this;
      const n2 = slength.length;
      for (let i2 = 0; i2 < n2; i2++) {
        if (slength[i2] == 0) {
          slength[i2] = inf_len;
        }
      }
    }
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.line.doit) {
      return;
    }
    const { sx, sy, slength, angle } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const angle_i = angle.get(i2);
      const slength_i = slength[i2];
      if (!isFinite(sx_i + sy_i + angle_i + slength_i)) {
        continue;
      }
      ctx.translate(sx_i, sy_i);
      ctx.rotate(angle_i);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(slength_i, 0);
      this.visuals.line.apply(ctx, i2);
      ctx.rotate(-angle_i);
      ctx.translate(-sx_i, -sy_i);
    }
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(RayView, "__name__", "RayView");
var _Ray = class _Ray extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Ray, "__name__", "Ray");
_Ray.prototype.default_view = RayView;
_Ray.mixins(LineVector);
_Ray.define(({}) => ({
  length: [DistanceSpec, 0],
  angle: [AngleSpec, 0]
}));
var Ray = _Ray;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/rect.js
var { abs: abs9, sqrt: sqrt4 } = Math;
var RectView = class extends CenterRotatableView {
  async load_glglyph() {
    const { RectGL } = await import("./rect-QDKXOJRW.js");
    return RectGL;
  }
  _set_data(indices) {
    super._set_data(indices);
    this.border_radius = border_radius(this.model.border_radius);
  }
  _map_data() {
    const n2 = this.data_size;
    if (this.inherited_x && this.inherited_width) {
      this._inherit_attr("swidth");
      this._inherit_attr("sx0");
    } else {
      let swidth;
      let sx0;
      if (this.model.properties.width.units == "data") {
        [swidth, sx0] = this._map_dist_corner_for_data_side_length(this.x, this.width, this.renderer.xscale);
      } else {
        swidth = to_screen(this.width);
        sx0 = new ScreenArray(n2);
        const { sx } = this;
        for (let i2 = 0; i2 < n2; i2++) {
          sx0[i2] = sx[i2] - swidth[i2] / 2;
        }
      }
      this._define_attr("swidth", swidth);
      this._define_attr("sx0", sx0);
    }
    if (this.inherited_y && this.inherited_height) {
      this._inherit_attr("sheight");
      this._inherit_attr("sy1");
    } else {
      let sheight;
      let sy1;
      if (this.model.properties.height.units == "data") {
        [sheight, sy1] = this._map_dist_corner_for_data_side_length(this.y, this.height, this.renderer.yscale);
      } else {
        sheight = to_screen(this.height);
        sy1 = new ScreenArray(n2);
        const { sy } = this;
        for (let i2 = 0; i2 < n2; i2++) {
          sy1[i2] = sy[i2] - sheight[i2] / 2;
        }
      }
      this._define_attr("sheight", sheight);
      this._define_attr("sy1", sy1);
    }
    if (this.inherited_swidth && this.inherited_sheight) {
      this._inherit_attr("max_x2_ddist");
      this._inherit_attr("max_y2_ddist");
    } else {
      const { sx0, sy1, swidth, sheight } = this;
      const ssemi_diag = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        const swidth_i = swidth[i2];
        const sheight_i = sheight[i2];
        ssemi_diag[i2] = sqrt4(swidth_i ** 2 + sheight_i ** 2) / 2;
      }
      const scenter_x = new ScreenArray(n2);
      const scenter_y = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        scenter_x[i2] = sx0[i2] + swidth[i2] / 2;
        scenter_y[i2] = sy1[i2] + sheight[i2] / 2;
      }
      const max_x2_ddist = max(this._ddist(0, scenter_x, ssemi_diag));
      const max_y2_ddist = max(this._ddist(1, scenter_y, ssemi_diag));
      this._define_attr("max_x2_ddist", max_x2_ddist);
      this._define_attr("max_y2_ddist", max_y2_ddist);
    }
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sx0, sy1, swidth, sheight, angle, border_radius: border_radius2 } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sx0_i = sx0[i2];
      const sy1_i = sy1[i2];
      const swidth_i = swidth[i2];
      const sheight_i = sheight[i2];
      const angle_i = angle.get(i2);
      if (!isFinite(sx_i + sy_i + sx0_i + sy1_i + swidth_i + sheight_i + angle_i)) {
        continue;
      }
      if (swidth_i == 0 || sheight_i == 0) {
        continue;
      }
      ctx.beginPath();
      if (angle_i != 0) {
        ctx.translate(sx_i, sy_i);
        ctx.rotate(angle_i);
        const box = new BBox({ x: -swidth_i / 2, y: -sheight_i / 2, width: swidth_i, height: sheight_i });
        round_rect(ctx, box, border_radius2);
        ctx.rotate(-angle_i);
        ctx.translate(-sx_i, -sy_i);
      } else {
        const box = new BBox({ x: sx0_i, y: sy1_i, width: swidth_i, height: sheight_i });
        round_rect(ctx, box, border_radius2);
      }
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_rect(geometry) {
    return this._hit_rect_against_index(geometry);
  }
  _hit_point(geometry) {
    const hit_xy = { x: geometry.sx, y: geometry.sy };
    const x2 = this.renderer.xscale.invert(hit_xy.x);
    const y2 = this.renderer.yscale.invert(hit_xy.y);
    const candidates = this.index.indices({
      x0: x2 - this.max_x2_ddist,
      x1: x2 + this.max_x2_ddist,
      y0: y2 - this.max_y2_ddist,
      y1: y2 + this.max_y2_ddist
    });
    const { sx, sy, sx0, sy1, swidth: sw, sheight: sh, angle } = this;
    const indices = [];
    for (const i2 of candidates) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sx0_i = sx0[i2];
      const sy1_i = sy1[i2];
      const sw_i = sw[i2];
      const sh_i = sh[i2];
      const angle_i = angle.get(i2);
      const hit_rxy = rotate_around(hit_xy, { x: sx_i, y: sy_i }, -angle_i);
      const x3 = hit_rxy.x - sx0_i;
      const y3 = hit_rxy.y - sy1_i;
      if (0 <= x3 && x3 <= sw_i && 0 <= y3 && y3 <= sh_i) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _map_dist_corner_for_data_side_length(coord, side_length, scale) {
    const n2 = coord.length;
    const pt0 = new Float64Array(n2);
    const pt1 = new Float64Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      const coord_i = coord[i2];
      const half_side_length_i = side_length.get(i2) / 2;
      pt0[i2] = coord_i - half_side_length_i;
      pt1[i2] = coord_i + half_side_length_i;
    }
    const spt0 = scale.v_compute(pt0);
    const spt1 = scale.v_compute(pt1);
    const sside_length = this.sdist(scale, pt0, side_length, "edge", this.model.dilate);
    let spt_corner = spt0;
    for (let i2 = 0; i2 < n2; i2++) {
      const spt0i = spt0[i2];
      const spt1i = spt1[i2];
      if (!isNaN(spt0i + spt1i) && spt0i != spt1i) {
        spt_corner = spt0i < spt1i ? spt0 : spt1;
        break;
      }
    }
    return [sside_length, spt_corner];
  }
  _ddist(dim, spts, spans) {
    const ArrayType = infer_type(spts, spans);
    const scale = dim == 0 ? this.renderer.xscale : this.renderer.yscale;
    const spt0 = spts;
    const m = spt0.length;
    const spt1 = new ArrayType(m);
    for (let i2 = 0; i2 < m; i2++) {
      spt1[i2] = spt0[i2] + spans[i2];
    }
    const pt0 = scale.v_invert(spt0);
    const pt1 = scale.v_invert(spt1);
    const n2 = pt0.length;
    const ddist = new ArrayType(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      ddist[i2] = abs9(pt1[i2] - pt0[i2]);
    }
    return ddist;
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(RectView, "__name__", "RectView");
var _Rect = class _Rect extends CenterRotatable {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Rect, "__name__", "Rect");
_Rect.prototype.default_view = RectView;
_Rect.define(({ Bool: Bool2 }) => ({
  border_radius: [BorderRadius, 0],
  dilate: [Bool2, false]
}));
var Rect = _Rect;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/marker.js
var MarkerView = class extends XYGlyphView {
  constructor() {
    super(...arguments);
    __publicField(this, "_render_one");
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, size: size2, angle } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const size_i = size2.get(i2);
      const angle_i = angle.get(i2);
      if (!isFinite(sx_i + sy_i + size_i + angle_i)) {
        continue;
      }
      const r = size_i / 2;
      ctx.beginPath();
      ctx.translate(sx_i, sy_i);
      if (angle_i != 0) {
        ctx.rotate(angle_i);
      }
      this._render_one(ctx, i2, r, this.visuals);
      if (angle_i != 0) {
        ctx.rotate(-angle_i);
      }
      ctx.translate(-sx_i, -sy_i);
    }
  }
  _mask_data() {
    const { x_target, y_target } = this.renderer.plot_view.frame;
    const hr2 = x_target.widen(this.max_size).map((x2) => this.renderer.xscale.invert(x2));
    const vr = y_target.widen(this.max_size).map((y2) => this.renderer.yscale.invert(y2));
    return this.index.indices({
      x0: hr2.start,
      x1: hr2.end,
      y0: vr.start,
      y1: vr.end
    });
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const { max_size } = this;
    const { hit_dilation } = this.model;
    const sx0 = sx - max_size * hit_dilation;
    const sx1 = sx + max_size * hit_dilation;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    const sy0 = sy - max_size * hit_dilation;
    const sy1 = sy + max_size * hit_dilation;
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const candidates = this.index.indices({ x0, x1, y0, y1 });
    const indices = [];
    for (const i2 of candidates) {
      const s2 = this.size.get(i2) / 2 * hit_dilation;
      if (Math.abs(this.sx[i2] - sx) <= s2 && Math.abs(this.sy[i2] - sy) <= s2) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const { sx, sy } = geometry;
    const bounds = this.bounds();
    const half_size = this.max_size / 2;
    const [x0, x1, y0, y1] = (() => {
      if (geometry.direction == "h") {
        const { y0: y02, y1: y12 } = bounds;
        const sx0 = sx - half_size;
        const sx1 = sx + half_size;
        const [x02, x12] = this.renderer.xscale.r_invert(sx0, sx1);
        return [x02, x12, y02, y12];
      } else {
        const { x0: x02, x1: x12 } = bounds;
        const sy0 = sy - half_size;
        const sy1 = sy + half_size;
        const [y02, y12] = this.renderer.yscale.r_invert(sy0, sy1);
        return [x02, x12, y02, y12];
      }
    })();
    const indices = [...this.index.indices({ x0, x1, y0, y1 })];
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const { sx0, sx1, sy0, sy1 } = geometry;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const indices = [...this.index.indices({ x0, x1, y0, y1 })];
    return new Selection({ indices });
  }
  _hit_poly(geometry) {
    const { sx: sxs, sy: sys } = geometry;
    const candidates = (() => {
      const xs = this.renderer.xscale.v_invert(sxs);
      const ys = this.renderer.yscale.v_invert(sys);
      const [x0, x1, y0, y1] = minmax2(xs, ys);
      return this.index.indices({ x0, x1, y0, y1 });
    })();
    const indices = [];
    for (const i2 of candidates) {
      if (point_in_poly(this.sx[i2], this.sy[i2], sxs, sys)) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _get_legend_args({ x0, x1, y0, y1 }, index2) {
    const n2 = index2 + 1;
    const sx = new Array(n2);
    const sy = new Array(n2);
    sx[index2] = (x0 + x1) / 2;
    sy[index2] = (y0 + y1) / 2;
    const vsize = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
    const size2 = new UniformScalar(vsize, n2);
    const angle = new UniformScalar(0, n2);
    return { sx, sy, size: size2, angle };
  }
  draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index2) {
    const args = this._get_legend_args({ x0, x1, y0, y1 }, index2);
    this._paint(ctx, [index2], args);
  }
};
__publicField(MarkerView, "__name__", "MarkerView");
var _Marker = class _Marker extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Marker, "__name__", "Marker");
_Marker.mixins([LineVector, FillVector, HatchVector]);
_Marker.define(({ Float: Float2 }) => ({
  size: [ScreenSizeSpec, { value: 4 }],
  angle: [AngleSpec, 0],
  hit_dilation: [Float2, 1]
}));
var Marker = _Marker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/defs.js
var SQ3 = Math.sqrt(3);
var SQ5 = Math.sqrt(5);
var c36 = (SQ5 + 1) / 4;
var s36 = Math.sqrt((5 - SQ5) / 8);
var c72 = (SQ5 - 1) / 4;
var s72 = Math.sqrt((5 + SQ5) / 8);
function _one_line(ctx, r) {
  ctx.moveTo(-r, 0);
  ctx.lineTo(r, 0);
}
function _one_x(ctx, r) {
  ctx.rotate(Math.PI / 4);
  _one_cross(ctx, r);
  ctx.rotate(-Math.PI / 4);
}
function _one_y(ctx, r) {
  const h7 = r * SQ3;
  const a2 = h7 / 3;
  ctx.moveTo(-h7 / 2, -a2);
  ctx.lineTo(0, 0);
  ctx.lineTo(h7 / 2, -a2);
  ctx.lineTo(0, 0);
  ctx.lineTo(0, r);
}
function _one_cross(ctx, r) {
  ctx.moveTo(0, r);
  ctx.lineTo(0, -r);
  ctx.moveTo(-r, 0);
  ctx.lineTo(r, 0);
}
function _one_dot(ctx, r) {
  ctx.beginPath();
  ctx.arc(0, 0, r / 4, 0, 2 * Math.PI, false);
  ctx.closePath();
}
function _one_diamond(ctx, r) {
  ctx.moveTo(0, r);
  ctx.lineTo(r / 1.5, 0);
  ctx.lineTo(0, -r);
  ctx.lineTo(-r / 1.5, 0);
  ctx.closePath();
}
function _one_hex(ctx, r) {
  const r2 = r / 2;
  const h7 = SQ3 * r2;
  ctx.moveTo(r, 0);
  ctx.lineTo(r2, -h7);
  ctx.lineTo(-r2, -h7);
  ctx.lineTo(-r, 0);
  ctx.lineTo(-r2, h7);
  ctx.lineTo(r2, h7);
  ctx.closePath();
}
function _one_star(ctx, r) {
  const a2 = Math.sqrt(5 - 2 * SQ5) * r;
  ctx.moveTo(0, -r);
  ctx.lineTo(a2 * c72, -r + a2 * s72);
  ctx.lineTo(a2 * (1 + c72), -r + a2 * s72);
  ctx.lineTo(a2 * (1 + c72 - c36), -r + a2 * (s72 + s36));
  ctx.lineTo(a2 * (1 + 2 * c72 - c36), -r + a2 * (2 * s72 + s36));
  ctx.lineTo(0, -r + a2 * 2 * s72);
  ctx.lineTo(-a2 * (1 + 2 * c72 - c36), -r + a2 * (2 * s72 + s36));
  ctx.lineTo(-a2 * (1 + c72 - c36), -r + a2 * (s72 + s36));
  ctx.lineTo(-a2 * (1 + c72), -r + a2 * s72);
  ctx.lineTo(-a2 * c72, -r + a2 * s72);
  ctx.closePath();
}
function _one_tri(ctx, r) {
  const h7 = r * SQ3;
  const a2 = h7 / 3;
  ctx.moveTo(-r, a2);
  ctx.lineTo(r, a2);
  ctx.lineTo(0, a2 - h7);
  ctx.closePath();
}
function asterisk(ctx, i2, r, visuals) {
  _one_cross(ctx, r);
  _one_x(ctx, r);
  visuals.line.apply(ctx, i2);
}
function circle(ctx, i2, r, visuals) {
  ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function circle_cross(ctx, i2, r, visuals) {
  ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  _one_cross(ctx, r);
  visuals.line.apply(ctx, i2);
}
function circle_dot(ctx, i2, r, visuals) {
  circle(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function circle_y(ctx, i2, r, visuals) {
  ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  _one_y(ctx, r);
  visuals.line.apply(ctx, i2);
}
function circle_x(ctx, i2, r, visuals) {
  ctx.arc(0, 0, r, 0, 2 * Math.PI, false);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  _one_x(ctx, r);
  visuals.line.apply(ctx, i2);
}
function cross(ctx, i2, r, visuals) {
  _one_cross(ctx, r);
  visuals.line.apply(ctx, i2);
}
function diamond(ctx, i2, r, visuals) {
  _one_diamond(ctx, r);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function diamond_cross(ctx, i2, r, visuals) {
  _one_diamond(ctx, r);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  ctx.moveTo(0, r);
  ctx.lineTo(0, -r);
  ctx.moveTo(-r / 1.5, 0);
  ctx.lineTo(r / 1.5, 0);
  visuals.line.apply(ctx, i2);
}
function diamond_dot(ctx, i2, r, visuals) {
  diamond(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function dot(ctx, i2, r, visuals) {
  _one_dot(ctx, r);
  visuals.line.set_vectorize(ctx, i2);
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
}
function hex(ctx, i2, r, visuals) {
  _one_hex(ctx, r);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function hex_dot(ctx, i2, r, visuals) {
  hex(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function inverted_triangle(ctx, i2, r, visuals) {
  ctx.rotate(Math.PI);
  _one_tri(ctx, r);
  ctx.rotate(-Math.PI);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function plus(ctx, i2, r, visuals) {
  const a2 = 3 * r / 8;
  const b2 = r;
  const xs = [a2, a2, b2, b2, a2, a2, -a2, -a2, -b2, -b2, -a2, -a2];
  const ys = [b2, a2, a2, -a2, -a2, -b2, -b2, -a2, -a2, a2, a2, b2];
  ctx.beginPath();
  for (let j = 0; j < 12; j++) {
    ctx.lineTo(xs[j], ys[j]);
  }
  ctx.closePath();
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function square(ctx, i2, r, visuals) {
  const size2 = 2 * r;
  ctx.rect(-r, -r, size2, size2);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function square_pin(ctx, i2, r, visuals) {
  const a2 = 3 * r / 8;
  ctx.moveTo(-r, -r);
  ctx.quadraticCurveTo(0, -a2, r, -r);
  ctx.quadraticCurveTo(a2, 0, r, r);
  ctx.quadraticCurveTo(0, a2, -r, r);
  ctx.quadraticCurveTo(-a2, 0, -r, -r);
  ctx.closePath();
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function square_cross(ctx, i2, r, visuals) {
  const size2 = 2 * r;
  ctx.rect(-r, -r, size2, size2);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  _one_cross(ctx, r);
  visuals.line.apply(ctx, i2);
}
function square_dot(ctx, i2, r, visuals) {
  square(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function square_x(ctx, i2, r, visuals) {
  const size2 = 2 * r;
  ctx.rect(-r, -r, size2, size2);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  ctx.moveTo(-r, r);
  ctx.lineTo(r, -r);
  ctx.moveTo(-r, -r);
  ctx.lineTo(r, r);
  visuals.line.apply(ctx, i2);
}
function star(ctx, i2, r, visuals) {
  _one_star(ctx, r);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function star_dot(ctx, i2, r, visuals) {
  star(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function triangle(ctx, i2, r, visuals) {
  _one_tri(ctx, r);
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function triangle_dot(ctx, i2, r, visuals) {
  triangle(ctx, i2, r, visuals);
  dot(ctx, i2, r, visuals);
}
function triangle_pin(ctx, i2, r, visuals) {
  const h7 = r * SQ3;
  const a2 = h7 / 3;
  const b2 = 3 * a2 / 8;
  ctx.moveTo(-r, a2);
  ctx.quadraticCurveTo(0, b2, r, a2);
  ctx.quadraticCurveTo(SQ3 * b2 / 2, b2 / 2, 0, a2 - h7);
  ctx.quadraticCurveTo(-SQ3 * b2 / 2, b2 / 2, -r, a2);
  ctx.closePath();
  visuals.fill.apply(ctx, i2);
  visuals.hatch.apply(ctx, i2);
  visuals.line.apply(ctx, i2);
}
function dash(ctx, i2, r, visuals) {
  _one_line(ctx, r);
  visuals.line.apply(ctx, i2);
}
function x(ctx, i2, r, visuals) {
  _one_x(ctx, r);
  visuals.line.apply(ctx, i2);
}
function y(ctx, i2, r, visuals) {
  _one_y(ctx, r);
  visuals.line.apply(ctx, i2);
}
var marker_funcs = {
  asterisk,
  circle,
  circle_cross,
  circle_dot,
  circle_y,
  circle_x,
  cross,
  diamond,
  diamond_dot,
  diamond_cross,
  dot,
  hex,
  hex_dot,
  inverted_triangle,
  plus,
  square,
  square_cross,
  square_dot,
  square_pin,
  square_x,
  star,
  star_dot,
  triangle,
  triangle_dot,
  triangle_pin,
  dash,
  x,
  y
};

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/scatter.js
var ScatterView = class extends MarkerView {
  async load_glglyph() {
    const { MultiMarkerGL } = await import("./multi_marker-EONVUHSZ.js");
    return MultiMarkerGL;
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, size: size2, angle, marker } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const size_i = size2.get(i2);
      const angle_i = angle.get(i2);
      const marker_i = marker.get(i2);
      if (!isFinite(sx_i + sy_i + size_i + angle_i) || marker_i == null) {
        continue;
      }
      const r = size_i / 2;
      ctx.beginPath();
      ctx.translate(sx_i, sy_i);
      if (angle_i != 0) {
        ctx.rotate(angle_i);
      }
      marker_funcs[marker_i](ctx, i2, r, this.visuals);
      if (angle_i != 0) {
        ctx.rotate(-angle_i);
      }
      ctx.translate(-sx_i, -sy_i);
    }
  }
  draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index2) {
    const n2 = index2 + 1;
    const marker = this.marker.get(index2);
    const args = {
      ...this._get_legend_args({ x0, x1, y0, y1 }, index2),
      marker: new UniformScalar(marker, n2)
    };
    this._paint(ctx, [index2], args);
  }
};
__publicField(ScatterView, "__name__", "ScatterView");
var _Scatter = class _Scatter extends Marker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Scatter, "__name__", "Scatter");
_Scatter.prototype.default_view = ScatterView;
_Scatter.define(() => ({
  marker: [MarkerSpec, { value: "circle" }]
}));
var Scatter = _Scatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/segment.js
var SegmentView = class extends GlyphView {
  _project_data() {
    this._project_xy("x0", this.x0, "y0", this.y0);
    this._project_xy("x1", this.x1, "y1", this.y1);
  }
  _index_data(index2) {
    const { min: min10, max: max18 } = Math;
    const { x0, x1, y0, y1, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x0_i = x0[i2];
      const x1_i = x1[i2];
      const y0_i = y0[i2];
      const y1_i = y1[i2];
      index2.add_rect(min10(x0_i, x1_i), min10(y0_i, y1_i), max18(x0_i, x1_i), max18(y0_i, y1_i));
    }
  }
  _paint(ctx, indices, data3) {
    if (!this.visuals.line.doit) {
      return;
    }
    const { sx0, sy0, sx1, sy1 } = { ...this, ...data3 };
    for (const i2 of indices) {
      const sx0_i = sx0[i2];
      const sy0_i = sy0[i2];
      const sx1_i = sx1[i2];
      const sy1_i = sy1[i2];
      if (!isFinite(sx0_i + sy0_i + sx1_i + sy1_i)) {
        continue;
      }
      this._render_decorations(ctx, i2, sx0_i, sy0_i, sx1_i, sy1_i);
      ctx.beginPath();
      ctx.moveTo(sx0_i, sy0_i);
      ctx.lineTo(sx1_i, sy1_i);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _render_decorations(ctx, i2, sx0, sy0, sx1, sy1) {
    const { PI: PI3 } = Math;
    const angle = atan2([sx0, sy0], [sx1, sy1]) + PI3 / 2;
    for (const decoration of this.decorations.values()) {
      ctx.save();
      if (decoration.model.node == "start") {
        ctx.translate(sx0, sy0);
        ctx.rotate(angle + PI3);
      } else if (decoration.model.node == "end") {
        ctx.translate(sx1, sy1);
        ctx.rotate(angle);
      }
      decoration.marking.paint(ctx, i2);
      ctx.restore();
    }
  }
  _hit_point(geometry) {
    const { sx, sy } = geometry;
    const point = { x: sx, y: sy };
    const lw_voffset = 2;
    const [x0, x1] = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset);
    const [y0, y1] = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset);
    const candidates = this.index.indices({ x0, y0, x1, y1 });
    const indices = [];
    for (const i2 of candidates) {
      const threshold2 = Math.max(2, this.line_width.get(i2) / 2) ** 2;
      const p0 = { x: this.sx0[i2], y: this.sy0[i2] };
      const p1 = { x: this.sx1[i2], y: this.sy1[i2] };
      const dist2 = dist_to_segment_squared(point, p0, p1);
      if (dist2 < threshold2) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const [hr2, vr] = this.renderer.plot_view.frame.bbox.ranges;
    const { sx, sy } = geometry;
    let v0;
    let v1;
    let val;
    if (geometry.direction == "v") {
      val = this.renderer.yscale.invert(sy);
      [v0, v1] = [this.y0, this.y1];
    } else {
      val = this.renderer.xscale.invert(sx);
      [v0, v1] = [this.x0, this.x1];
    }
    const indices = [];
    const [x0, x1] = this.renderer.xscale.r_invert(hr2.start, hr2.end);
    const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);
    const candidates = this.index.indices({ x0, y0, x1, y1 });
    for (const i2 of candidates) {
      if (v0[i2] <= val && val <= v1[i2] || v1[i2] <= val && val <= v0[i2]) {
        indices.push(i2);
      }
      const threshold = 1.5 + this.line_width.get(i2) / 2;
      if (v0[i2] == v1[i2]) {
        if (geometry.direction == "h") {
          if (Math.abs(this.sx0[i2] - sx) <= threshold) {
            indices.push(i2);
          }
        } else {
          if (Math.abs(this.sy0[i2] - sy) <= threshold) {
            indices.push(i2);
          }
        }
      }
    }
    return new Selection({ indices });
  }
  scenterxy(i2) {
    const scx = this.sx0[i2] / 2 + this.sx1[i2] / 2;
    const scy = this.sy0[i2] / 2 + this.sy1[i2] / 2;
    return [scx, scy];
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(SegmentView, "__name__", "SegmentView");
var _Segment = class _Segment extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Segment, "__name__", "Segment");
_Segment.prototype.default_view = SegmentView;
_Segment.define(({}) => ({
  x0: [XCoordinateSpec, { field: "x0" }],
  y0: [YCoordinateSpec, { field: "y0" }],
  x1: [XCoordinateSpec, { field: "x1" }],
  y1: [YCoordinateSpec, { field: "y1" }]
}));
_Segment.mixins(LineVector);
var Segment = _Segment;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/interpolation.js
function catmullrom_spline(x2, y2, T = 10, tension = 0.5, closed = false) {
  assert(x2.length == y2.length);
  const n2 = x2.length;
  const N = closed ? n2 + 1 : n2;
  const ArrayType = infer_type(x2, y2);
  const xx = new ArrayType(N + 2);
  const yy = new ArrayType(N + 2);
  xx.set(x2, 1);
  yy.set(y2, 1);
  if (closed) {
    xx[0] = x2[n2 - 1];
    yy[0] = y2[n2 - 1];
    xx[N] = x2[0];
    yy[N] = y2[0];
    xx[N + 1] = x2[1];
    yy[N + 1] = y2[1];
  } else {
    xx[0] = x2[0];
    yy[0] = y2[0];
    xx[N + 1] = x2[n2 - 1];
    yy[N + 1] = y2[n2 - 1];
  }
  const basis = new ArrayType(4 * (T + 1));
  for (let j = 0, k = 0; j <= T; j++) {
    const t = j / T;
    const t_2 = t ** 2;
    const t_3 = t * t_2;
    basis[k++] = 2 * t_3 - 3 * t_2 + 1;
    basis[k++] = -2 * t_3 + 3 * t_2;
    basis[k++] = t_3 - 2 * t_2 + t;
    basis[k++] = t_3 - t_2;
  }
  const xt = new ArrayType((N - 1) * (T + 1));
  const yt = new ArrayType((N - 1) * (T + 1));
  for (let i2 = 1, k = 0; i2 < N; i2++) {
    const t0x = (xx[i2 + 1] - xx[i2 - 1]) * tension;
    const t0y = (yy[i2 + 1] - yy[i2 - 1]) * tension;
    const t1x = (xx[i2 + 2] - xx[i2]) * tension;
    const t1y = (yy[i2 + 2] - yy[i2]) * tension;
    for (let j = 0; j <= 4 * T; k++) {
      const h00 = basis[j++];
      const h01 = basis[j++];
      const h10 = basis[j++];
      const h11 = basis[j++];
      xt[k] = h00 * xx[i2] + h01 * xx[i2 + 1] + h10 * t0x + h11 * t1x;
      yt[k] = h00 * yy[i2] + h01 * yy[i2 + 1] + h10 * t0y + h11 * t1y;
    }
  }
  return [xt, yt];
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/spline.js
var SplineView = class extends XYGlyphView {
  _set_data() {
    const { tension, closed } = this.model;
    const [xt, yt] = catmullrom_spline(this.x, this.y, 20, tension, closed);
    this._define_attr("xt", xt);
    this._define_attr("yt", yt);
  }
  _map_data() {
    const { x_scale, y_scale } = this.renderer.coordinates;
    const sxt = x_scale.v_compute(this.xt);
    const syt = y_scale.v_compute(this.yt);
    this._define_attr("sxt", sxt);
    this._define_attr("syt", syt);
  }
  _paint(ctx, _indices, data3) {
    const { sxt, syt } = { ...this, ...data3 };
    let move = true;
    ctx.beginPath();
    const n2 = sxt.length;
    for (let j = 0; j < n2; j++) {
      const sx_i = sxt[j];
      const sy_i = syt[j];
      if (!isFinite(sx_i + sy_i)) {
        move = true;
      } else {
        if (move) {
          ctx.moveTo(sx_i, sy_i);
          move = false;
        } else {
          ctx.lineTo(sx_i, sy_i);
        }
      }
    }
    this.visuals.line.set_value(ctx);
    ctx.stroke();
  }
};
__publicField(SplineView, "__name__", "SplineView");
var _Spline = class _Spline extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Spline, "__name__", "Spline");
_Spline.prototype.default_view = SplineView;
_Spline.mixins(LineScalar);
_Spline.define(({ Bool: Bool2, Float: Float2 }) => ({
  tension: [Float2, 0.5],
  closed: [Bool2, false]
}));
var Spline = _Spline;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/step.js
var StepView = class extends XYGlyphView {
  async load_glglyph() {
    const { StepGL } = await import("./step-F3YCQ4JC.js");
    return StepGL;
  }
  _paint(ctx, indices, data3) {
    const npoints = indices.length;
    if (npoints < 2) {
      return;
    }
    const { sx, sy } = { ...this, ...data3 };
    const mode = this.model.mode;
    this.visuals.line.set_value(ctx);
    let drawing = false;
    let prev_finite = false;
    const i2 = indices[0];
    let is_finite = isFinite(sx[i2] + sy[i2]);
    if (mode == "center") {
      drawing = this._render_xy(ctx, drawing, is_finite ? sx[i2] : NaN, sy[i2]);
    }
    for (const i3 of indices) {
      const next_finite = isFinite(sx[i3 + 1] + sy[i3 + 1]);
      switch (mode) {
        case "before":
          drawing = this._render_xy(ctx, drawing, is_finite ? sx[i3] : NaN, sy[i3]);
          if (i3 < sx.length - 1) {
            drawing = this._render_xy(ctx, drawing, is_finite && next_finite ? sx[i3] : NaN, sy[i3 + 1]);
          }
          break;
        case "after":
          drawing = this._render_xy(ctx, drawing, is_finite ? sx[i3] : NaN, sy[i3]);
          if (i3 < sx.length - 1) {
            drawing = this._render_xy(ctx, drawing, is_finite && next_finite ? sx[i3 + 1] : NaN, sy[i3]);
          }
          break;
        case "center":
          if (is_finite && next_finite) {
            const midx = (sx[i3] + sx[i3 + 1]) / 2;
            drawing = this._render_xy(ctx, drawing, midx, sy[i3]);
            drawing = this._render_xy(ctx, drawing, midx, sy[i3 + 1]);
          } else {
            if (prev_finite) {
              drawing = this._render_xy(ctx, drawing, is_finite ? sx[i3] : NaN, sy[i3]);
            }
            drawing = this._render_xy(ctx, drawing, next_finite ? sx[i3 + 1] : NaN, sy[i3 + 1]);
          }
          break;
        default:
          unreachable();
      }
      prev_finite = is_finite;
      is_finite = next_finite;
    }
    if (drawing) {
      const i3 = indices[npoints - 1];
      if (this._render_xy(ctx, drawing, is_finite ? sx[i3] : NaN, sy[i3])) {
        ctx.stroke();
      }
    }
  }
  _render_xy(ctx, drawing, x2, y2) {
    if (isFinite(x2 + y2)) {
      if (drawing) {
        ctx.lineTo(x2, y2);
      } else {
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        drawing = true;
      }
    } else if (drawing) {
      ctx.stroke();
      drawing = false;
    }
    return drawing;
  }
  draw_legend_for_index(ctx, bbox, _index) {
    generic_line_scalar_legend(this.visuals, ctx, bbox);
  }
};
__publicField(StepView, "__name__", "StepView");
var _Step = class _Step extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Step, "__name__", "Step");
_Step.prototype.default_view = StepView;
_Step.mixins(LineScalar);
_Step.define(() => ({
  mode: [StepMode, "before"]
}));
var Step = _Step;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/tex_glyph.js
var DisplayMode = Or(Enum("inline", "block"), Auto);
var TeXGlyphView = class extends MathTextGlyphView {
  _build_label(text2) {
    const { macros, display: display2 } = this.model;
    if (display2 == "auto") {
      const obj = parse_delimited_string(text2);
      if (obj instanceof TeX) {
        obj.macros = macros;
      }
      return obj;
    } else {
      return new TeX({ text: text2, macros, inline: display2 == "inline" });
    }
  }
};
__publicField(TeXGlyphView, "__name__", "TeXGlyphView");
var _TeXGlyph = class _TeXGlyph extends MathTextGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TeXGlyph, "__name__", "TeXGlyph");
_TeXGlyph.prototype.default_view = TeXGlyphView;
_TeXGlyph.define(({ Float: Float2, Str: Str2, Dict: Dict2, Tuple: Tuple2, Or: Or2 }) => ({
  macros: [Dict2(Or2(Str2, Tuple2(Str2, Float2))), {}],
  display: [DisplayMode, "auto"]
}));
var TeXGlyph = _TeXGlyph;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/vbar.js
var VBarView = class extends LRTBView {
  scenterxy(i2) {
    const scx = this.sx[i2];
    const scy = (this.stop[i2] + this.sbottom[i2]) / 2;
    return [scx, scy];
  }
  _lrtb(i2) {
    const half_width_i = this.width.get(i2) / 2;
    const x_i = this.x[i2];
    const top_i = this.top[i2];
    const bottom_i = this.bottom[i2];
    const l = x_i - half_width_i;
    const r = x_i + half_width_i;
    const t = Math.max(top_i, bottom_i);
    const b2 = Math.min(top_i, bottom_i);
    return { l, r, t, b: b2 };
  }
  _map_data() {
    if (this.inherited_x && this.inherited_width) {
      this._inherit_attr("swidth");
      this._inherit_attr("sleft");
      this._inherit_attr("sright");
    } else {
      const swidth = this.sdist(this.renderer.xscale, this.x, this.width, "center");
      const { sx } = this;
      const n2 = sx.length;
      const sleft = new ScreenArray(n2);
      const sright = new ScreenArray(n2);
      for (let i2 = 0; i2 < n2; i2++) {
        const sx_i = sx[i2];
        const swidth_i = swidth[i2];
        sleft[i2] = sx_i - swidth_i / 2;
        sright[i2] = sx_i + swidth_i / 2;
      }
      this._define_attr("swidth", swidth);
      this._define_attr("sleft", sleft);
      this._define_attr("sright", sright);
    }
    this._clamp_to_viewport();
  }
};
__publicField(VBarView, "__name__", "VBarView");
var _VBar = class _VBar extends LRTB2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VBar, "__name__", "VBar");
_VBar.prototype.default_view = VBarView;
_VBar.define(({}) => ({
  x: [XCoordinateSpec, { field: "x" }],
  bottom: [YCoordinateSpec, { value: 0 }],
  width: [DistanceSpec, { value: 1 }],
  top: [YCoordinateSpec, { field: "top" }]
}));
var VBar = _VBar;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/vspan.js
var { abs: abs10, max: max12 } = Math;
var UNUSED3 = 0;
var VSpanView = class extends GlyphView {
  after_visuals() {
    super.after_visuals();
    this.max_line_width = max2(this.line_width);
  }
  _index_data(index2) {
    for (const x_i of this.x) {
      index2.add_point(x_i, UNUSED3);
    }
  }
  _bounds(bounds) {
    const { x0, x1 } = bounds;
    return { x0, x1, y0: NaN, y1: NaN };
  }
  _map_data() {
    super._map_data();
    const { round: round8 } = Math;
    if (!this.inherited_sx) {
      const sx = map(this.sx, (xi) => round8(xi));
      this._define_attr("sx", sx);
    }
  }
  scenterxy(i2) {
    const { vcenter } = this.renderer.plot_view.frame.bbox;
    return [this.sx[i2], vcenter];
  }
  _paint(ctx, indices, data3) {
    const { sx } = { ...this, ...data3 };
    const { top, bottom } = this.renderer.plot_view.frame.bbox;
    for (const i2 of indices) {
      const sx_i = sx[i2];
      if (!isFinite(sx_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.moveTo(sx_i, top);
      ctx.lineTo(sx_i, bottom);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _get_candidates(sx0, sx1) {
    const { max_line_width } = this;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0 - max_line_width, (sx1 ?? sx0) + max_line_width);
    return this.index.indices({ x0, x1, y0: 0, y1: 0 });
  }
  _find_spans(candidates, fn) {
    const { sx, line_width } = this;
    const indices = [];
    for (const i2 of candidates) {
      const sx_i = sx[i2];
      const line_width_i = line_width.get(i2);
      if (fn(sx_i, line_width_i)) {
        indices.push(i2);
      }
    }
    return indices;
  }
  _hit_point(geometry) {
    const { sx: gsx } = geometry;
    const candidates = this._get_candidates(gsx);
    const indices = this._find_spans(candidates, (sx, line_width) => {
      return abs10(sx - gsx) <= max12(
        line_width,
        2
        /*px*/
      );
    });
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const indices = (() => {
      if (geometry.direction == "h") {
        return range(0, this.data_size);
      } else {
        const { sx: gsx } = geometry;
        const candidates = this._get_candidates(gsx);
        return this._find_spans(candidates, (sx, line_width) => {
          return abs10(sx - gsx) <= max12(
            line_width / 2,
            2
            /*px*/
          );
        });
      }
    })();
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const indices = (() => {
      const { sx0: gsx0, sx1: gsx1 } = geometry;
      const candidates = this._get_candidates(gsx0, gsx1);
      return this._find_spans(candidates, (sx, line_width) => {
        return gsx0 - line_width / 2 <= sx && sx <= gsx1 + line_width / 2;
      });
    })();
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_line_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(VSpanView, "__name__", "VSpanView");
var _VSpan = class _VSpan extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VSpan, "__name__", "VSpan");
_VSpan.prototype.default_view = VSpanView;
_VSpan.mixins([LineVector]);
_VSpan.define(() => ({
  x: [XCoordinateSpec, { field: "x" }]
}));
var VSpan = _VSpan;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/vstrip.js
var UNUSED4 = 0;
var VStripView = class extends GlyphView {
  async lazy_initialize() {
    await super.lazy_initialize();
    const { webgl } = this.renderer.plot_view.canvas_view;
    if (webgl != null && webgl.regl_wrapper.has_webgl) {
      const { LRTBGL } = await import("./lrtb-GHRUHO7Z.js");
      this.glglyph = new LRTBGL(webgl.regl_wrapper, this);
    }
  }
  get sleft() {
    return this.sx0;
  }
  get sright() {
    return this.sx1;
  }
  get stop() {
    const { top } = this.renderer.plot_view.frame.bbox;
    const n2 = this.data_size;
    const stop = new ScreenArray(n2);
    stop.fill(top);
    return stop;
  }
  get sbottom() {
    const { bottom } = this.renderer.plot_view.frame.bbox;
    const n2 = this.data_size;
    const sbottom = new ScreenArray(n2);
    sbottom.fill(bottom);
    return sbottom;
  }
  _set_data(indices) {
    super._set_data(indices);
    const { abs: abs11 } = Math;
    const { max: max18, map: map4, zip: zip2 } = iterator_exports;
    const { x0, x1 } = this;
    if (this.inherited_x0 && this.inherited_x1) {
      this._inherit_attr("max_width");
    } else {
      const max_width = max18(map4(zip2(x0, x1), ([x0_i, x1_i]) => abs11(x0_i - x1_i)));
      this._define_attr("max_width", max_width);
    }
  }
  _index_data(index2) {
    const { x0, x1, data_size } = this;
    for (let i2 = 0; i2 < data_size; i2++) {
      const x0_i = x0[i2];
      const x1_i = x1[i2];
      index2.add_rect(x0_i, UNUSED4, x1_i, UNUSED4);
    }
  }
  _bounds(bounds) {
    const { x0, x1 } = bounds;
    return { x0, x1, y0: NaN, y1: NaN };
  }
  _map_data() {
    super._map_data();
    const { round: round8 } = Math;
    if (!this.inherited_sx0) {
      const sx0 = map(this.sx0, (xi) => round8(xi));
      this._define_attr("sx0", sx0);
    }
    if (!this.inherited_sx1) {
      const sx1 = map(this.sx1, (xi) => round8(xi));
      this._define_attr("sx1", sx1);
    }
  }
  scenterxy(i2) {
    const { vcenter } = this.renderer.plot_view.frame.bbox;
    return [(this.sx0[i2] + this.sx1[i2]) / 2, vcenter];
  }
  _paint(ctx, indices, data3) {
    const { sx0, sx1 } = { ...this, ...data3 };
    const { top, bottom, height } = this.renderer.plot_view.frame.bbox;
    for (const i2 of indices) {
      const sx0_i = sx0[i2];
      const sx1_i = sx1[i2];
      if (!isFinite(sx0_i + sx1_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.rect(sx0_i, top, sx1_i - sx0_i, height);
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      ctx.beginPath();
      ctx.moveTo(sx0_i, top);
      ctx.lineTo(sx0_i, bottom);
      ctx.moveTo(sx1_i, top);
      ctx.lineTo(sx1_i, bottom);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _get_candidates(sx0, sx1) {
    const { max_width } = this;
    const [dx0, dx1] = this.renderer.xscale.r_invert(sx0, sx1 ?? sx0);
    const x0 = dx0 - max_width;
    const x1 = dx1 + max_width;
    return this.index.indices({ x0, x1, y0: 0, y1: 0 });
  }
  _find_strips(candidates, fn) {
    function contains3(sx02, sx12) {
      return sx02 <= sx12 ? fn(sx02, sx12) : fn(sx12, sx02);
    }
    const { sx0, sx1 } = this;
    const indices = [];
    for (const i2 of candidates) {
      const sx0_i = sx0[i2];
      const sx1_i = sx1[i2];
      if (contains3(sx0_i, sx1_i)) {
        indices.push(i2);
      }
    }
    return indices;
  }
  _hit_point(geometry) {
    const { sx } = geometry;
    const candidates = this._get_candidates(sx);
    const indices = this._find_strips(candidates, (sx0, sx1) => sx0 <= sx && sx <= sx1);
    return new Selection({ indices });
  }
  _hit_span(geometry) {
    const indices = (() => {
      if (geometry.direction == "h") {
        return range(0, this.data_size);
      } else {
        const { sx } = geometry;
        const candidates = this._get_candidates(sx);
        return this._find_strips(candidates, (sx0, sx1) => sx0 <= sx && sx <= sx1);
      }
    })();
    return new Selection({ indices });
  }
  _hit_rect(geometry) {
    const indices = (() => {
      const { sx0: gsx0, sx1: gsx1 } = geometry;
      const candidates = this._get_candidates(gsx0, gsx1);
      return this._find_strips(candidates, (sx0, sx1) => {
        return gsx0 <= sx0 && sx0 <= gsx1 && gsx0 <= sx1 && sx1 <= gsx1;
      });
    })();
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
};
__publicField(VStripView, "__name__", "VStripView");
var _VStrip = class _VStrip extends Glyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VStrip, "__name__", "VStrip");
_VStrip.prototype.default_view = VStripView;
_VStrip.mixins([LineVector, FillVector, HatchVector]);
_VStrip.define(() => ({
  x0: [XCoordinateSpec, { field: "x0" }],
  x1: [XCoordinateSpec, { field: "x1" }]
}));
var VStrip = _VStrip;

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/wedge.js
var WedgeView = class extends XYGlyphView {
  async load_glglyph() {
    const { WedgeGL } = await import("./wedge-MNKLPWXA.js");
    return WedgeGL;
  }
  _map_data() {
    this._define_or_inherit_attr("sradius", () => {
      if (this.model.properties.radius.units == "data") {
        if (this.inherited_x && this.inherited_radius) {
          return inherit;
        } else {
          return this.sdist(this.renderer.xscale, this.x, this.radius);
        }
      } else {
        return this.inherited_radius ? inherit : to_screen(this.radius);
      }
    });
    this._define_or_inherit_attr("max_sradius", () => max(this.sradius));
  }
  _paint(ctx, indices, data3) {
    const { sx, sy, sradius, start_angle, end_angle } = { ...this, ...data3 };
    const anticlock = this.model.direction == "anticlock";
    for (const i2 of indices) {
      const sx_i = sx[i2];
      const sy_i = sy[i2];
      const sradius_i = sradius[i2];
      const start_angle_i = start_angle.get(i2);
      const end_angle_i = end_angle.get(i2);
      if (!isFinite(sx_i + sy_i + sradius_i + start_angle_i + end_angle_i)) {
        continue;
      }
      ctx.beginPath();
      ctx.arc(sx_i, sy_i, sradius_i, start_angle_i, end_angle_i, anticlock);
      ctx.lineTo(sx_i, sy_i);
      ctx.closePath();
      this.visuals.fill.apply(ctx, i2);
      this.visuals.hatch.apply(ctx, i2);
      this.visuals.line.apply(ctx, i2);
    }
  }
  _hit_point(geometry) {
    let dist, sx0, sx1, sy0, sy1;
    const { sx, sy } = geometry;
    const x2 = this.renderer.xscale.invert(sx);
    const y2 = this.renderer.yscale.invert(sy);
    sx0 = sx - this.max_sradius;
    sx1 = sx + this.max_sradius;
    const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);
    sy0 = sy - this.max_sradius;
    sy1 = sy + this.max_sradius;
    const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);
    const candidates = [];
    for (const i2 of this.index.indices({ x0, x1, y0, y1 })) {
      const r2 = this.sradius[i2] ** 2;
      [sx0, sx1] = this.renderer.xscale.r_compute(x2, this.x[i2]);
      [sy0, sy1] = this.renderer.yscale.r_compute(y2, this.y[i2]);
      dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;
      if (dist <= r2) {
        candidates.push(i2);
      }
    }
    const anticlock = this.model.direction == "anticlock";
    const indices = [];
    for (const i2 of candidates) {
      const angle = Math.atan2(sy - this.sy[i2], sx - this.sx[i2]);
      const is_full_circle = Math.abs(this.start_angle.get(i2) - this.end_angle.get(i2)) >= 2 * Math.PI;
      if (is_full_circle || angle_between(-angle, -this.start_angle.get(i2), -this.end_angle.get(i2), anticlock)) {
        indices.push(i2);
      }
    }
    return new Selection({ indices });
  }
  draw_legend_for_index(ctx, bbox, index2) {
    generic_area_vector_legend(this.visuals, ctx, bbox, index2);
  }
  scenterxy(i2) {
    const r = this.sradius[i2] / 2;
    const a2 = (this.start_angle.get(i2) + this.end_angle.get(i2)) / 2;
    const scx = this.sx[i2] + r * Math.cos(a2);
    const scy = this.sy[i2] + r * Math.sin(a2);
    return [scx, scy];
  }
};
__publicField(WedgeView, "__name__", "WedgeView");
var _Wedge = class _Wedge extends XYGlyph {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Wedge, "__name__", "Wedge");
_Wedge.prototype.default_view = WedgeView;
_Wedge.mixins([LineVector, FillVector, HatchVector]);
_Wedge.define(({}) => ({
  direction: [Direction, "anticlock"],
  radius: [DistanceSpec, { field: "radius" }],
  start_angle: [AngleSpec, { field: "start_angle" }],
  end_angle: [AngleSpec, { field: "end_angle" }]
}));
var Wedge = _Wedge;

// node_modules/@bokeh/bokehjs/build/js/lib/models/graphs/graph_hit_test_policy.js
var GraphHitTestPolicy = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
  _hit_test(geometry, graph_view, renderer_view) {
    if (!graph_view.model.visible) {
      return null;
    }
    const hit_test_result = renderer_view.glyph.hit_test(geometry);
    if (hit_test_result == null) {
      return null;
    } else {
      return renderer_view.model.view.convert_selection_from_subset(hit_test_result);
    }
  }
};
__publicField(GraphHitTestPolicy, "__name__", "GraphHitTestPolicy");
var EdgesOnly = class extends GraphHitTestPolicy {
  constructor(attrs) {
    super(attrs);
  }
  hit_test(geometry, graph_view) {
    return this._hit_test(geometry, graph_view, graph_view.edge_view);
  }
  do_selection(hit_test_result, graph, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const edge_selection = graph.edge_renderer.data_source.selected;
    edge_selection.update(hit_test_result, final, mode);
    graph.edge_renderer.data_source._select.emit();
    return !edge_selection.is_empty();
  }
  do_inspection(hit_test_result, geometry, graph_view, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const { edge_renderer } = graph_view.model;
    const edge_inspection = edge_renderer.get_selection_manager().get_or_create_inspector(graph_view.edge_view.model);
    edge_inspection.update(hit_test_result, final, mode);
    graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });
    graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view.model, { geometry }]);
    return !edge_inspection.is_empty();
  }
};
__publicField(EdgesOnly, "__name__", "EdgesOnly");
var NodesOnly = class extends GraphHitTestPolicy {
  constructor(attrs) {
    super(attrs);
  }
  hit_test(geometry, graph_view) {
    return this._hit_test(geometry, graph_view, graph_view.node_view);
  }
  do_selection(hit_test_result, graph, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const node_selection = graph.node_renderer.data_source.selected;
    node_selection.update(hit_test_result, final, mode);
    graph.node_renderer.data_source._select.emit();
    return !node_selection.is_empty();
  }
  do_inspection(hit_test_result, geometry, graph_view, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const { node_renderer } = graph_view.model;
    const node_inspection = node_renderer.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);
    node_inspection.update(hit_test_result, final, mode);
    graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });
    graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view.model, { geometry }]);
    return !node_inspection.is_empty();
  }
};
__publicField(NodesOnly, "__name__", "NodesOnly");
var NodesAndLinkedEdges = class extends GraphHitTestPolicy {
  constructor(attrs) {
    super(attrs);
  }
  hit_test(geometry, graph_view) {
    return this._hit_test(geometry, graph_view, graph_view.node_view);
  }
  get_linked_edges(node_source, edge_source, mode) {
    const node_data = dict(node_source.data);
    const index2 = node_data.get("index") ?? [];
    const node_indices = (() => {
      switch (mode) {
        case "selection":
          return map(node_source.selected.indices, (i2) => index2[i2]);
        case "inspection":
          return map(node_source.inspected.indices, (i2) => index2[i2]);
      }
    })();
    const edge_data = dict(edge_source.data);
    const start2 = edge_data.get("start") ?? [];
    const end = edge_data.get("end") ?? [];
    const edge_indices = [];
    const n2 = start2.length;
    for (let i2 = 0; i2 < n2; i2++) {
      if (contains(node_indices, start2[i2]) || contains(node_indices, end[i2])) {
        edge_indices.push(i2);
      }
    }
    const linked_edges = new Selection();
    for (const i2 of edge_indices) {
      linked_edges.multiline_indices.set(i2, [0]);
    }
    linked_edges.indices = edge_indices;
    return linked_edges;
  }
  do_selection(hit_test_result, graph, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const node_selection = graph.node_renderer.data_source.selected;
    node_selection.update(hit_test_result, final, mode);
    const edge_selection = graph.edge_renderer.data_source.selected;
    const linked_edges_selection = this.get_linked_edges(graph.node_renderer.data_source, graph.edge_renderer.data_source, "selection");
    edge_selection.update(linked_edges_selection, final, mode);
    graph.node_renderer.data_source._select.emit();
    return !node_selection.is_empty();
  }
  do_inspection(hit_test_result, geometry, graph_view, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
    node_inspection.update(hit_test_result, final, mode);
    graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });
    const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
    const linked_edges = this.get_linked_edges(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, "inspection");
    edge_inspection.update(linked_edges, final, mode);
    graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });
    graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view.model, { geometry }]);
    return !node_inspection.is_empty();
  }
};
__publicField(NodesAndLinkedEdges, "__name__", "NodesAndLinkedEdges");
var EdgesAndLinkedNodes = class extends GraphHitTestPolicy {
  constructor(attrs) {
    super(attrs);
  }
  hit_test(geometry, graph_view) {
    return this._hit_test(geometry, graph_view, graph_view.edge_view);
  }
  get_linked_nodes(node_source, edge_source, mode) {
    const edge_indices = (() => {
      switch (mode) {
        case "selection":
          return edge_source.selected.indices;
        case "inspection":
          return edge_source.inspected.indices;
      }
    })();
    const edge_data = dict(edge_source.data);
    const start2 = edge_data.get("start") ?? [];
    const end = edge_data.get("end") ?? [];
    const nodes = [];
    for (const i2 of edge_indices) {
      nodes.push(start2[i2], end[i2]);
    }
    const node_data = dict(node_source.data);
    const index2 = node_data.get("index") ?? [];
    const node_indices = uniq(nodes).map((i2) => index_of(index2, i2));
    return new Selection({ indices: node_indices });
  }
  do_selection(hit_test_result, graph, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const edge_selection = graph.edge_renderer.data_source.selected;
    edge_selection.update(hit_test_result, final, mode);
    const node_selection = graph.node_renderer.data_source.selected;
    const linked_nodes = this.get_linked_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, "selection");
    node_selection.update(linked_nodes, final, mode);
    graph.edge_renderer.data_source._select.emit();
    return !edge_selection.is_empty();
  }
  do_inspection(hit_test_result, geometry, graph_view, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);
    edge_inspection.update(hit_test_result, final, mode);
    graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });
    const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
    const linked_nodes = this.get_linked_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, "inspection");
    node_inspection.update(linked_nodes, final, mode);
    graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });
    graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view.model, { geometry }]);
    return !edge_inspection.is_empty();
  }
};
__publicField(EdgesAndLinkedNodes, "__name__", "EdgesAndLinkedNodes");
var NodesAndAdjacentNodes = class extends GraphHitTestPolicy {
  constructor(attrs) {
    super(attrs);
  }
  hit_test(geometry, graph_view) {
    return this._hit_test(geometry, graph_view, graph_view.node_view);
  }
  get_adjacent_nodes(node_source, edge_source, mode) {
    const node_data = dict(node_source.data);
    const index2 = node_data.get("index") ?? [];
    const selected_node_indices = (() => {
      switch (mode) {
        case "selection":
          return map(node_source.selected.indices, (i2) => index2[i2]);
        case "inspection":
          return map(node_source.inspected.indices, (i2) => index2[i2]);
      }
    })();
    const edge_data = dict(edge_source.data);
    const start2 = edge_data.get("start") ?? [];
    const end = edge_data.get("end") ?? [];
    const adjacent_nodes = [];
    const selected_nodes = [];
    for (let i2 = 0; i2 < start2.length; i2++) {
      if (contains(selected_node_indices, start2[i2])) {
        adjacent_nodes.push(end[i2]);
        selected_nodes.push(start2[i2]);
      }
      if (contains(selected_node_indices, end[i2])) {
        adjacent_nodes.push(start2[i2]);
        selected_nodes.push(end[i2]);
      }
    }
    for (let i2 = 0; i2 < selected_nodes.length; i2++) {
      adjacent_nodes.push(selected_nodes[i2]);
    }
    const adjacent_node_indices = uniq(adjacent_nodes).map((i2) => index_of(index2, i2));
    return new Selection({ indices: adjacent_node_indices });
  }
  do_selection(hit_test_result, graph, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const node_selection = graph.node_renderer.data_source.selected;
    node_selection.update(hit_test_result, final, mode);
    const adjacent_nodes_selection = this.get_adjacent_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, "selection");
    if (!adjacent_nodes_selection.is_empty()) {
      node_selection.update(adjacent_nodes_selection, final, mode);
    }
    graph.node_renderer.data_source._select.emit();
    return !node_selection.is_empty();
  }
  do_inspection(hit_test_result, geometry, graph_view, final, mode) {
    if (hit_test_result == null) {
      return false;
    }
    const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);
    node_inspection.update(hit_test_result, final, mode);
    graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });
    const adjacent_nodes_inspection = this.get_adjacent_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, "inspection");
    if (!adjacent_nodes_inspection.is_empty()) {
      node_inspection.update(adjacent_nodes_inspection, final, mode);
      graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });
    }
    graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view.model, { geometry }]);
    return !node_inspection.is_empty();
  }
};
__publicField(NodesAndAdjacentNodes, "__name__", "NodesAndAdjacentNodes");

// node_modules/@bokeh/bokehjs/build/js/lib/models/graphs/layout_provider.js
var LayoutProvider = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
  get node_coordinates() {
    return new NodeCoordinates({ layout: this });
  }
  get edge_coordinates() {
    return new EdgeCoordinates({ layout: this });
  }
};
__publicField(LayoutProvider, "__name__", "LayoutProvider");
var _GraphCoordinates = class _GraphCoordinates extends CoordinateTransform2 {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GraphCoordinates, "__name__", "GraphCoordinates");
_GraphCoordinates.define(({ Ref: Ref2 }) => ({
  layout: [Ref2(LayoutProvider)]
}));
var GraphCoordinates = _GraphCoordinates;
var NodeCoordinates = class extends GraphCoordinates {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    const [x2, y2] = this.layout.get_node_coordinates(source2);
    return { x: x2, y: y2 };
  }
};
__publicField(NodeCoordinates, "__name__", "NodeCoordinates");
var EdgeCoordinates = class extends GraphCoordinates {
  constructor(attrs) {
    super(attrs);
  }
  _v_compute(source2) {
    const [x2, y2] = this.layout.get_edge_coordinates(source2);
    return { x: x2, y: y2 };
  }
};
__publicField(EdgeCoordinates, "__name__", "EdgeCoordinates");

// node_modules/@bokeh/bokehjs/build/js/lib/models/graphs/static_layout_provider.js
var GraphLayout = Or(Dict(Arrayable(Float)), Mapping(Or(Int, Str), Arrayable(Float)));
var _StaticLayoutProvider = class _StaticLayoutProvider extends LayoutProvider {
  constructor(attrs) {
    super(attrs);
  }
  get_node_coordinates(node_source) {
    const data3 = dict(node_source.data);
    const index2 = data3.get("index") ?? [];
    const n2 = index2.length;
    const xs = new Float64Array(n2);
    const ys = new Float64Array(n2);
    const graph_layout = dict(this.graph_layout);
    for (let i2 = 0; i2 < n2; i2++) {
      const j = index2[i2];
      const [x2, y2] = graph_layout.get(j) ?? [NaN, NaN];
      xs[i2] = x2;
      ys[i2] = y2;
    }
    return [xs, ys];
  }
  get_edge_coordinates(edge_source) {
    const data3 = dict(edge_source.data);
    const starts = data3.get("start") ?? [];
    const ends = data3.get("end") ?? [];
    const n2 = Math.min(starts.length, ends.length);
    const xs = [];
    const ys = [];
    const edge_xs = data3.get("xs");
    const edge_ys = data3.get("ys");
    const has_paths = edge_xs != null && edge_ys != null;
    const graph_layout = dict(this.graph_layout);
    for (let i2 = 0; i2 < n2; i2++) {
      const in_layout = graph_layout.has(starts[i2]) && graph_layout.has(ends[i2]);
      if (has_paths && in_layout) {
        xs.push(edge_xs[i2]);
        ys.push(edge_ys[i2]);
      } else {
        const start2 = graph_layout.get(starts[i2]) ?? [NaN, NaN];
        const end = graph_layout.get(ends[i2]) ?? [NaN, NaN];
        xs.push([start2[0], end[0]]);
        ys.push([start2[1], end[1]]);
      }
    }
    return [xs, ys];
  }
};
__publicField(_StaticLayoutProvider, "__name__", "StaticLayoutProvider");
_StaticLayoutProvider.define(() => ({
  graph_layout: [GraphLayout, /* @__PURE__ */ new Map()]
  // TODO: length == 2
}));
var StaticLayoutProvider = _StaticLayoutProvider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/grids/grid.js
var GridView = class extends GuideRendererView {
  _paint() {
    const ctx = this.layer.ctx;
    ctx.save();
    this._draw_regions(ctx);
    this._draw_minor_grids(ctx);
    this._draw_grids(ctx);
    ctx.restore();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.request_paint());
  }
  _draw_regions(ctx) {
    if (!this.visuals.band_fill.doit && !this.visuals.band_hatch.doit) {
      return;
    }
    const [xs, ys] = this.grid_coords("major", false);
    for (let i2 = 0; i2 < xs.length - 1; i2++) {
      if (i2 % 2 != 1) {
        continue;
      }
      const [sx0, sy0] = this.coordinates.map_to_screen(xs[i2], ys[i2]);
      const [sx1, sy1] = this.coordinates.map_to_screen(xs[i2 + 1], ys[i2 + 1]);
      ctx.beginPath();
      ctx.rect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);
      this.visuals.band_fill.apply(ctx);
      this.visuals.band_hatch.apply(ctx);
    }
  }
  _draw_grids(ctx) {
    if (!this.visuals.grid_line.doit) {
      return;
    }
    const [xs, ys] = this.grid_coords("major");
    this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);
  }
  _draw_minor_grids(ctx) {
    if (!this.visuals.minor_grid_line.doit) {
      return;
    }
    const [xs, ys] = this.grid_coords("minor");
    this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);
  }
  _draw_grid_helper(ctx, visuals, xs, ys) {
    visuals.set_value(ctx);
    ctx.beginPath();
    for (let i2 = 0; i2 < xs.length; i2++) {
      const [sx, sy] = this.coordinates.map_to_screen(xs[i2], ys[i2]);
      ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));
      for (let i3 = 1; i3 < sx.length; i3++) {
        ctx.lineTo(Math.round(sx[i3]), Math.round(sy[i3]));
      }
    }
    ctx.stroke();
  }
  // {{{ TODO: state
  ranges() {
    const i2 = this.model.dimension;
    const j = 1 - i2;
    const { ranges } = this.coordinates;
    return [ranges[i2], ranges[j]];
  }
  computed_bounds() {
    const [range2] = this.ranges();
    const user_bounds = this.model.bounds;
    const range_bounds = [range2.min, range2.max];
    let start2;
    let end;
    if (isArray(user_bounds)) {
      start2 = Math.min(user_bounds[0], user_bounds[1]);
      end = Math.max(user_bounds[0], user_bounds[1]);
      if (start2 < range_bounds[0]) {
        start2 = range_bounds[0];
      }
      if (end > range_bounds[1]) {
        end = range_bounds[1];
      }
    } else {
      [start2, end] = range_bounds;
      for (const axis_view of this.plot_view.axis_views) {
        if (axis_view.dimension == this.model.dimension && axis_view.model.x_range_name == this.model.x_range_name && axis_view.model.y_range_name == this.model.y_range_name) {
          [start2, end] = axis_view.computed_bounds;
        }
      }
    }
    return [start2, end];
  }
  grid_coords(location, exclude_ends = true) {
    const i2 = this.model.dimension;
    const j = 1 - i2;
    const [range2, cross_range] = this.ranges();
    const [start2, end] = (() => {
      const [start3, end2] = this.computed_bounds();
      return [Math.min(start3, end2), Math.max(start3, end2)];
    })();
    const coords = [[], []];
    const ticker = this.model.get_ticker();
    if (ticker == null) {
      return coords;
    }
    const ticks = ticker.get_ticks(start2, end, range2, cross_range.min)[location];
    const min10 = range2.min;
    const max18 = range2.max;
    const [cmin, cmax] = (() => {
      const { cross_bounds } = this.model;
      if (cross_bounds == "auto") {
        return [cross_range.min, cross_range.max];
      } else {
        return cross_bounds;
      }
    })();
    if (!exclude_ends) {
      if (ticks[0] != min10) {
        ticks.splice(0, 0, min10);
      }
      if (ticks[ticks.length - 1] != max18) {
        ticks.push(max18);
      }
    }
    for (let ii = 0; ii < ticks.length; ii++) {
      if ((ticks[ii] == min10 || ticks[ii] == max18) && exclude_ends) {
        continue;
      }
      const dim_i = [];
      const dim_j = [];
      const N = 2;
      for (let n2 = 0; n2 < N; n2++) {
        const loc = cmin + (cmax - cmin) / (N - 1) * n2;
        dim_i.push(ticks[ii]);
        dim_j.push(loc);
      }
      coords[i2].push(dim_i);
      coords[j].push(dim_j);
    }
    return coords;
  }
};
__publicField(GridView, "__name__", "GridView");
var _Grid = class _Grid extends GuideRenderer {
  constructor(attrs) {
    super(attrs);
  }
  get_ticker() {
    if (this.ticker != null) {
      return this.ticker;
    }
    if (this.axis != null) {
      return this.axis.ticker;
    }
    return null;
  }
};
__publicField(_Grid, "__name__", "Grid");
_Grid.prototype.default_view = GridView;
_Grid.mixins([
  ["grid_", Line],
  ["minor_grid_", Line],
  ["band_", Fill],
  ["band_", Hatch]
]);
_Grid.define(({ Float: Float2, Auto: Auto2, Enum: Enum2, Ref: Ref2, Tuple: Tuple2, Or: Or2, Nullable: Nullable2 }) => ({
  bounds: [Or2(Tuple2(Float2, Float2), Auto2), "auto"],
  cross_bounds: [Or2(Tuple2(Float2, Float2), Auto2), "auto"],
  dimension: [Enum2(0, 1), 0],
  axis: [Nullable2(Ref2(Axis)), null],
  ticker: [Nullable2(Ref2(Ticker)), null]
}));
_Grid.override({
  level: "underlay",
  band_fill_color: null,
  band_fill_alpha: 0,
  grid_line_color: "#e5e5e5",
  minor_grid_line_color: null
});
var Grid2 = _Grid;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/dom_element.js
var DOMElementView2 = class extends DOMNodeView {
  constructor() {
    super(...arguments);
    __publicField(this, "child_views", /* @__PURE__ */ new Map());
  }
  *children() {
    yield* super.children();
    yield* this.child_views.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const children = this.model.children.filter((obj) => !isString(obj));
    await build_views(this.child_views, children, { parent: this });
  }
  remove() {
    remove_views(this.child_views);
    super.remove();
  }
  render() {
    empty2(this.el);
    apply_styles(this.el.style, this.model.style);
    for (const child of this.model.children) {
      if (isString(child)) {
        const node = document.createTextNode(child);
        this.el.appendChild(node);
      } else {
        const child_view = this.child_views.get(child);
        child_view.render_to(this.el);
      }
    }
    this.finish();
  }
};
__publicField(DOMElementView2, "__name__", "DOMElementView");
var _DOMElement = class _DOMElement extends DOMNode {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DOMElement, "__name__", "DOMElement");
_DOMElement.define(({ Str: Str2, List: List2, Or: Or2, Ref: Ref2 }) => {
  return {
    style: [StylesLike, {}],
    children: [List2(Or2(Str2, Ref2(DOMNode), Ref2(UIElement))), []]
  };
});
var DOMElement = _DOMElement;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/html.js
var HTMLRef = Or(Ref(DOMElement), Ref(UIElement));
var HTMLMarkup = Str;
var HTMLView = class extends DOMElementView2 {
  constructor() {
    super(...arguments);
    __publicField(this, "_refs", /* @__PURE__ */ new Map());
  }
  get refs() {
    const { html: html2, refs } = this.model;
    return [
      ...isArray(html2) ? html2.filter((item3) => !isString(item3)) : [],
      ...refs
    ];
  }
  *children() {
    yield* super.children();
    yield* this._refs.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await build_views(this._refs, this.refs);
  }
  remove() {
    remove_views(this._refs);
    super.remove();
  }
  render() {
    super.render();
    const html2 = (() => {
      const { html: html3 } = this.model;
      if (isArray(html3)) {
        return html3.map((item3) => isString(item3) ? item3 : `<ref id="${item3.id}"></ref>`).join("");
      } else {
        return html3;
      }
    })();
    const nodes = (() => {
      if (isString(html2)) {
        return this.parse_html(html2);
      } else {
        return [html2];
      }
    })();
    this.el.append(...nodes);
    this.finish();
  }
  parse_html(html2) {
    const parser = new DOMParser();
    const document2 = parser.parseFromString(html2, "text/html");
    const iter = document2.createNodeIterator(document2, NodeFilter.SHOW_ELEMENT, (node2) => {
      return node2.nodeName.toLowerCase() == "ref" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    });
    let node;
    next_node: while ((node = iter.nextNode()) != null) {
      assert(node instanceof Element);
      const id = node.getAttribute("id");
      if (id != null) {
        for (const [model2, view] of this._refs) {
          if (model2.id == id) {
            view.render();
            node.replaceWith(view.el);
            continue next_node;
          }
        }
        node.replaceWith(span(`<not found: id=${id}>`));
        continue;
      }
      const name = node.getAttribute("name");
      if (name != null) {
        for (const [model2, view] of this._refs) {
          if (model2.name == name) {
            view.render();
            node.replaceWith(view.el);
            continue next_node;
          }
        }
        node.replaceWith(span(`<not found: name=${name}>`));
        continue;
      }
    }
    return [...document2.body.childNodes];
  }
};
__publicField(HTMLView, "__name__", "HTMLView");
var _HTML = class _HTML extends DOMElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HTML, "__name__", "HTML");
_HTML.prototype.default_view = HTMLView;
_HTML.define(({ Node: Node3, List: List2, Or: Or2 }) => ({
  html: [Or2(Node3, HTMLMarkup, List2(Or2(HTMLMarkup, HTMLRef)))],
  refs: [List2(HTMLRef), []]
}));
var HTML = _HTML;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/pane.js
var ElementLike2 = Or(Ref(UIElement), Ref(DOMNode), Ref(HTML));
var PaneView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "_element_views", /* @__PURE__ */ new Map());
  }
  get elements() {
    return this.model.elements;
  }
  get element_views() {
    return this.elements.map((element) => this._element_views.get(element)).filter((view) => view != null);
  }
  *children() {
    yield* super.children();
    yield* this.element_views;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._build_elements();
  }
  async _build_elements() {
    return await build_views(this._element_views, this.elements, { parent: this });
  }
  async _update_elements() {
    const { created } = await this._build_elements();
    const created_elements = new Set(created);
    for (const element_view of this.element_views) {
      element_view.el.remove();
    }
    for (const element_view of this.element_views) {
      const is_new = created_elements.has(element_view);
      const target = element_view.rendering_target() ?? this.shadow_el;
      if (is_new) {
        element_view.render_to(target);
      } else {
        target.append(element_view.el);
      }
    }
    this.r_after_render();
  }
  remove() {
    remove_views(this._element_views);
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const { elements } = this.model.properties;
    this.on_change(elements, async () => {
      await this._update_elements();
    });
  }
  render() {
    super.render();
    for (const element_view of this.element_views) {
      const target = element_view.rendering_target() ?? this.shadow_el;
      element_view.render_to(target);
    }
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    for (const element_view of this.element_views) {
      if (!element_view.has_finished()) {
        return false;
      }
    }
    return true;
  }
};
__publicField(PaneView, "__name__", "PaneView");
var _Pane = class _Pane extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Pane, "__name__", "Pane");
_Pane.prototype.default_view = PaneView;
_Pane.define(({ List: List2 }) => ({
  elements: [List2(ElementLike2), []]
}));
var Pane = _Pane;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/layout_dom.js
var _LayoutDOMView = class _LayoutDOMView extends PaneView {
  constructor() {
    super(...arguments);
    __publicField(this, "_child_views", /* @__PURE__ */ new Map());
    __publicField(this, "layout");
    __publicField(this, "mouseenter", new Signal(this, "mouseenter"));
    __publicField(this, "mouseleave", new Signal(this, "mouseleave"));
    __publicField(this, "disabled", new Signal(this, "disabled"));
    __publicField(this, "_auto_width", "fit-content");
    __publicField(this, "_auto_height", "fit-content");
    __publicField(this, "_layout_computed", false);
  }
  get is_layout_root() {
    return this.is_root || !(this.parent instanceof _LayoutDOMView);
  }
  _after_resize() {
    super._after_resize();
    if (this.is_layout_root && !this._was_built) {
      logger.warn(`${this} wasn't built properly`);
      this.render();
      this.r_after_render();
    } else {
      this.compute_layout();
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this.build_child_views();
  }
  remove() {
    for (const child_view of this.child_views) {
      child_view.remove();
    }
    this._child_views.clear();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    this.el.addEventListener("mouseenter", (event2) => {
      this.mouseenter.emit(event2);
    });
    this.el.addEventListener("mouseleave", (event2) => {
      this.mouseleave.emit(event2);
    });
    if (this.parent instanceof _LayoutDOMView) {
      this.connect(this.parent.disabled, (disabled5) => {
        this.disabled.emit(disabled5 || this.model.disabled);
      });
    }
    const p2 = this.model.properties;
    this.on_change(p2.disabled, () => {
      this.disabled.emit(this.model.disabled);
    });
    this.on_change([
      p2.css_classes,
      p2.stylesheets,
      p2.width,
      p2.height,
      p2.min_width,
      p2.min_height,
      p2.max_width,
      p2.max_height,
      p2.margin,
      p2.width_policy,
      p2.height_policy,
      p2.flow_mode,
      p2.sizing_mode,
      p2.aspect_ratio,
      p2.visible
    ], () => this.invalidate_layout());
  }
  *children() {
    yield* super.children();
    yield* this.child_views;
  }
  get child_views() {
    return this.child_models.map((child) => this._child_views.get(child)).filter((view) => view != null);
  }
  get layoutable_views() {
    return this.child_views.filter((c) => c instanceof _LayoutDOMView);
  }
  async build_child_views() {
    const { created, removed } = await build_views(this._child_views, this.child_models, { parent: this });
    for (const view of removed) {
      this._resize_observer.unobserve(view.el);
    }
    for (const view of created) {
      this._resize_observer.observe(view.el, { box: "border-box" });
    }
    return created;
  }
  render() {
    super.render();
    for (const child_view of this.child_views) {
      const target = child_view.rendering_target() ?? this.shadow_el;
      child_view.render_to(target);
    }
  }
  _update_children() {
  }
  async update_children() {
    const created = await this.build_child_views();
    const created_children = new Set(created);
    for (const child_view of this.child_views) {
      child_view.el.remove();
    }
    for (const child_view of this.child_views) {
      const is_new = created_children.has(child_view);
      const target = child_view.rendering_target() ?? this.shadow_el;
      if (is_new) {
        child_view.render_to(target);
      } else {
        target.append(child_view.el);
      }
    }
    this.r_after_render();
    this._update_children();
    this.invalidate_layout();
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "flow" };
  }
  _update_layout() {
    function css_sizing(policy, size2, auto_size, margin2) {
      switch (policy) {
        case "auto":
          return size2 != null ? px(size2) : auto_size;
        case "fixed":
          return size2 != null ? px(size2) : "fit-content";
        case "fit":
          return "fit-content";
        case "min":
          return "min-content";
        case "max":
          return margin2 == null ? "100%" : `calc(100% - ${margin2})`;
      }
    }
    function css_display(display3) {
      const { inner: inner3, outer } = display3;
      switch (`${inner3} ${outer}`) {
        case "block flow":
          return "block";
        case "inline flow":
          return "inline";
        case "block flow-root":
          return "flow-root";
        case "inline flow-root":
          return "inline-block";
        case "block flex":
          return "flex";
        case "inline flex":
          return "inline-flex";
        case "block grid":
          return "grid";
        case "inline grid":
          return "inline-grid";
        case "block table":
          return "table";
        case "inline table":
          return "inline-table";
        default:
          unreachable();
      }
    }
    function to_css(value2) {
      return isNumber(value2) ? px(value2) : `${value2.percent}%`;
    }
    const styles3 = {};
    const display2 = this._intrinsic_display();
    styles3.display = css_display(display2);
    const sizing = this.box_sizing();
    const { width_policy, height_policy, width, height, aspect_ratio } = sizing;
    const computed_aspect = (() => {
      if (aspect_ratio == "auto") {
        if (width != null && height != null) {
          return width / height;
        }
      } else if (isNumber(aspect_ratio)) {
        return aspect_ratio;
      }
      return null;
    })();
    if (aspect_ratio == "auto") {
      if (width != null && height != null) {
        styles3.aspect_ratio = `${width} / ${height}`;
      } else {
        styles3.aspect_ratio = "auto";
      }
    } else if (isNumber(aspect_ratio)) {
      styles3.aspect_ratio = `${aspect_ratio}`;
    }
    const { margin } = this.model;
    const margins = (() => {
      if (margin != null) {
        if (isNumber(margin)) {
          styles3.margin = px(margin);
          return { width: px(2 * margin), height: px(2 * margin) };
        } else if (margin.length == 2) {
          const [vertical2, horizontal2] = margin;
          styles3.margin = `${px(vertical2)} ${px(horizontal2)}`;
          return { width: px(2 * horizontal2), height: px(2 * vertical2) };
        } else {
          const [top, right3, bottom, left2] = margin;
          styles3.margin = `${px(top)} ${px(right3)} ${px(bottom)} ${px(left2)}`;
          return { width: px(left2 + right3), height: px(top + bottom) };
        }
      } else {
        return { width: null, height: null };
      }
    })();
    const [css_width, css_height] = (() => {
      const css_width2 = css_sizing(width_policy, width, this._auto_width, margins.width);
      const css_height2 = css_sizing(height_policy, height, this._auto_height, margins.height);
      if (aspect_ratio != null) {
        if (width_policy != height_policy) {
          if (width_policy == "fixed") {
            return [css_width2, "auto"];
          }
          if (height_policy == "fixed") {
            return ["auto", css_height2];
          }
          if (width_policy == "max") {
            return [css_width2, "auto"];
          }
          if (height_policy == "max") {
            return ["auto", css_height2];
          }
          return ["auto", "auto"];
        } else {
          if (width_policy != "fixed" && height_policy != "fixed") {
            if (computed_aspect != null) {
              if (computed_aspect >= 1) {
                return [css_width2, "auto"];
              } else {
                return ["auto", css_height2];
              }
            }
          }
        }
      }
      return [css_width2, css_height2];
    })();
    styles3.width = css_width;
    styles3.height = css_height;
    const { min_width, max_width } = this.model;
    const { min_height, max_height } = this.model;
    styles3.min_width = min_width == null ? "0px" : to_css(min_width);
    styles3.min_height = min_height == null ? "0px" : to_css(min_height);
    if (this.is_layout_root) {
      if (max_width != null) {
        styles3.max_width = to_css(max_width);
      }
      if (max_height != null) {
        styles3.max_height = to_css(max_height);
      }
    } else {
      if (max_width != null) {
        styles3.max_width = `min(${to_css(max_width)}, 100%)`;
      } else if (width_policy != "fixed") {
        styles3.max_width = "100%";
      }
      if (max_height != null) {
        styles3.max_height = `min(${to_css(max_height)}, 100%)`;
      } else if (height_policy != "fixed") {
        styles3.max_height = "100%";
      }
    }
    const { resizable } = this.model;
    if (resizable !== false) {
      const resize2 = (() => {
        switch (resizable) {
          case "width":
            return "horizontal";
          case "height":
            return "vertical";
          case true:
          case "both":
            return "both";
        }
      })();
      styles3.resize = resize2;
      styles3.overflow = "auto";
    }
    this.style.append(":host", styles3);
  }
  update_layout() {
    this.update_style();
    for (const child_view of this.layoutable_views) {
      child_view.update_layout();
    }
    this._update_layout();
  }
  get is_managed() {
    return this.parent instanceof _LayoutDOMView;
  }
  /**
   * Update CSS layout with computed values from canvas layout.
   * This can be done more frequently than `_update_layout()`.
   */
  _measure_layout() {
  }
  measure_layout() {
    for (const child_view of this.layoutable_views) {
      child_view.measure_layout();
    }
    this._measure_layout();
  }
  compute_layout() {
    if (this.parent instanceof _LayoutDOMView) {
      this.parent.compute_layout();
    } else {
      this.measure_layout();
      this.update_bbox();
      this._compute_layout();
      this.after_layout();
    }
    this._layout_computed = true;
  }
  _compute_layout() {
    if (this.layout != null) {
      this.layout.compute(this.bbox.size);
      for (const child_view of this.layoutable_views) {
        if (child_view.layout == null) {
          child_view._compute_layout();
        } else {
          child_view._propagate_layout();
        }
      }
    } else {
      for (const child_view of this.layoutable_views) {
        child_view._compute_layout();
      }
    }
  }
  _propagate_layout() {
    for (const child_view of this.layoutable_views) {
      if (child_view.layout == null) {
        child_view._compute_layout();
      }
    }
  }
  update_bbox() {
    for (const child_view of this.layoutable_views) {
      child_view.update_bbox();
    }
    const changed = super.update_bbox();
    if (this.layout != null) {
      this.layout.visible = this.is_displayed;
    }
    return changed;
  }
  _after_layout() {
  }
  after_layout() {
    for (const child_view of this.layoutable_views) {
      child_view.after_layout();
    }
    this._after_layout();
  }
  _after_render() {
    if (!this.is_managed) {
      this.invalidate_layout();
    }
  }
  invalidate_layout() {
    if (this.parent instanceof _LayoutDOMView) {
      this.parent.invalidate_layout();
    } else {
      this.update_layout();
      this.compute_layout();
    }
  }
  invalidate_render() {
    this.render();
    this.invalidate_layout();
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    if (this.is_layout_root && !this._layout_computed) {
      return false;
    }
    for (const child_view of this.child_views) {
      if (!child_view.has_finished()) {
        return false;
      }
    }
    return true;
  }
  box_sizing() {
    let { width_policy, height_policy, aspect_ratio } = this.model;
    const { sizing_mode } = this.model;
    if (sizing_mode != null) {
      if (sizing_mode == "inherit") {
        if (this.parent instanceof _LayoutDOMView) {
          const sizing = this.parent.box_sizing();
          width_policy = sizing.width_policy;
          height_policy = sizing.height_policy;
          if (aspect_ratio == null) {
            aspect_ratio = sizing.aspect_ratio;
          }
        }
      } else if (sizing_mode == "fixed") {
        width_policy = height_policy = "fixed";
      } else if (sizing_mode == "stretch_both") {
        width_policy = height_policy = "max";
      } else if (sizing_mode == "stretch_width") {
        width_policy = "max";
      } else if (sizing_mode == "stretch_height") {
        height_policy = "max";
      } else {
        if (aspect_ratio == null) {
          aspect_ratio = "auto";
        }
        switch (sizing_mode) {
          case "scale_width":
            width_policy = "max";
            height_policy = "min";
            break;
          case "scale_height":
            width_policy = "min";
            height_policy = "max";
            break;
          case "scale_both":
            width_policy = "max";
            height_policy = "max";
            break;
        }
      }
    }
    const [halign, valign] = (() => {
      const { align } = this.model;
      if (align == "auto") {
        return [void 0, void 0];
      } else if (isArray(align)) {
        return align;
      } else {
        return [align, align];
      }
    })();
    const { width, height } = this.model;
    return {
      width_policy,
      height_policy,
      width,
      height,
      aspect_ratio,
      halign,
      valign
    };
  }
  export(type = "auto", hidpi = true) {
    const output_backend = (() => {
      switch (type) {
        case "auto":
        case "png":
          return "canvas";
        case "svg":
          return "svg";
      }
    })();
    const composite = new CanvasLayer(output_backend, hidpi);
    const { x: x2, y: y2, width, height } = this.bbox;
    composite.resize(width, height);
    const bg_color = getComputedStyle(this.el).backgroundColor;
    composite.ctx.fillStyle = bg_color;
    composite.ctx.fillRect(x2, y2, width, height);
    for (const view of this.child_views) {
      const region = view.export(type, hidpi);
      const { x: x3, y: y3 } = view.bbox.scale(composite.pixel_ratio);
      composite.ctx.drawImage(region.canvas, x3, y3);
    }
    return composite;
  }
};
__publicField(_LayoutDOMView, "__name__", "LayoutDOMView");
var LayoutDOMView = _LayoutDOMView;
var _LayoutDOM = class _LayoutDOM extends Pane {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LayoutDOM, "__name__", "LayoutDOM");
_LayoutDOM.define((types) => {
  const { Bool: Bool2, Float: Float2, Auto: Auto2, Tuple: Tuple2, Or: Or2, Null: Null2, Nullable: Nullable2 } = types;
  const Number2 = Tuple2(Float2, Float2);
  const Number4 = Tuple2(Float2, Float2, Float2, Float2);
  return {
    width: [Nullable2(Float2), null],
    height: [Nullable2(Float2), null],
    min_width: [Nullable2(Float2), null],
    min_height: [Nullable2(Float2), null],
    max_width: [Nullable2(Float2), null],
    max_height: [Nullable2(Float2), null],
    margin: [Nullable2(Or2(Float2, Number2, Number4)), null],
    width_policy: [Or2(SizingPolicy, Auto2), "auto"],
    height_policy: [Or2(SizingPolicy, Auto2), "auto"],
    aspect_ratio: [Or2(Float2, Auto2, Null2), null],
    flow_mode: [FlowMode, "block"],
    sizing_mode: [Nullable2(SizingMode), null],
    disabled: [Bool2, false],
    align: [Or2(Align, Tuple2(Align, Align), Auto2), "auto"],
    resizable: [Or2(Bool2, Dimensions), false]
  };
});
var LayoutDOM = _LayoutDOM;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/alignments.js
var { max: max13 } = Math;
var GridAlignmentLayout = class extends Layoutable {
  constructor(children) {
    super();
    __publicField(this, "children");
    this.children = children;
  }
  _measure(_viewport) {
    return { width: 0, height: 0 };
  }
  compute(viewport = {}) {
    const { width, height } = viewport;
    assert(width != null && height != null);
    const size_hint = { width, height };
    const outer = new BBox({ left: 0, top: 0, width, height });
    let inner3 = void 0;
    if (size_hint.inner != null) {
      const { left: left2, top, right: right3, bottom } = size_hint.inner;
      inner3 = new BBox({ left: left2, top, right: width - right3, bottom: height - bottom });
    }
    this.set_geometry(outer, inner3);
  }
  _set_geometry(outer, inner3) {
    super._set_geometry(outer, inner3);
    const items = this.children.map((_2, child) => {
      const { layout, bbox } = child;
      assert(layout != null);
      const size_hint = layout.measure(bbox);
      return { child, layout, bbox, size_hint };
    });
    const row_extents = Array(items.nrows).fill(null).map(() => ({ top: 0, bottom: 0 }));
    const col_extents = Array(items.ncols).fill(null).map(() => ({ left: 0, right: 0 }));
    items.foreach(({ r0, c0, r1, c1 }, { size_hint }) => {
      const { inner: inner4 } = size_hint;
      if (inner4 != null) {
        col_extents[c0].left = max13(col_extents[c0].left, inner4.left);
        col_extents[c1].right = max13(col_extents[c1].right, inner4.right);
        row_extents[r0].top = max13(row_extents[r0].top, inner4.top);
        row_extents[r1].bottom = max13(row_extents[r1].bottom, inner4.bottom);
      }
    });
    items.foreach(({ r0, c0, r1, c1 }, { layout, size_hint, bbox }) => {
      const outer_bbox = bbox;
      const inner_bbox = size_hint.inner == null ? void 0 : (() => {
        const { inner: inner4, align } = size_hint;
        const align_left = (align == null ? void 0 : align.left) ?? true;
        const align_right = (align == null ? void 0 : align.right) ?? true;
        const align_top = (align == null ? void 0 : align.top) ?? true;
        const align_bottom = (align == null ? void 0 : align.bottom) ?? true;
        const fixed_width = (align == null ? void 0 : align.fixed_width) ?? false;
        const fixed_height = (align == null ? void 0 : align.fixed_height) ?? false;
        const { left: left2, right: right3 } = (() => {
          if (fixed_width) {
            const inner_width = outer_bbox.width - inner4.right - inner4.left;
            if (align_left) {
              const left3 = col_extents[c0].left;
              const right4 = outer_bbox.width - (left3 + inner_width);
              return { left: left3, right: right4 };
            } else if (align_right) {
              const right4 = col_extents[c1].right;
              const left3 = outer_bbox.width - (right4 + inner_width);
              return { left: left3, right: right4 };
            } else {
              const left3 = inner4.left;
              const right4 = inner4.right;
              return { left: left3, right: right4 };
            }
          } else {
            const left3 = align_left ? col_extents[c0].left : inner4.left;
            const right4 = align_right ? col_extents[c1].right : inner4.right;
            return { left: left3, right: right4 };
          }
        })();
        const { top, bottom } = (() => {
          if (fixed_height) {
            const inner_height = outer_bbox.height - inner4.bottom - inner4.top;
            if (align_top) {
              const top2 = row_extents[r0].top;
              const bottom2 = outer_bbox.height - (top2 + inner_height);
              return { top: top2, bottom: bottom2 };
            } else if (align_bottom) {
              const bottom2 = row_extents[r1].bottom;
              const top2 = outer_bbox.height - (bottom2 + inner_height);
              return { top: top2, bottom: bottom2 };
            } else {
              const top2 = inner4.top;
              const bottom2 = inner4.bottom;
              return { top: top2, bottom: bottom2 };
            }
          } else {
            const top2 = align_top ? row_extents[r0].top : inner4.top;
            const bottom2 = align_bottom ? row_extents[r1].bottom : inner4.bottom;
            return { top: top2, bottom: bottom2 };
          }
        })();
        const { width, height } = outer_bbox;
        return BBox.from_lrtb({ left: left2, top, right: width - right3, bottom: height - bottom });
      })();
      layout.set_geometry(outer_bbox, inner_bbox);
    });
  }
};
__publicField(GridAlignmentLayout, "__name__", "GridAlignmentLayout");

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/flex_box.js
var FlexBoxView = class extends LayoutDOMView {
  connect_signals() {
    super.connect_signals();
    const { children } = this.model.properties;
    this.on_change(children, () => this.update_children());
  }
  get child_models() {
    return this.model.children;
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "flex" };
  }
  _update_layout() {
    super._update_layout();
    this.style.append(":host", {
      flex_direction: this._direction,
      gap: px(this.model.spacing)
    });
    const layoutable = new Container();
    let r0 = 0;
    let c0 = 0;
    for (const view of this.child_views) {
      if (!(view instanceof LayoutDOMView)) {
        continue;
      }
      const sizing = view.box_sizing();
      const flex = (() => {
        const policy = this._direction == "row" ? sizing.width_policy : sizing.height_policy;
        const size2 = this._direction == "row" ? sizing.width : sizing.height;
        const basis = size2 != null ? px(size2) : "auto";
        switch (policy) {
          case "auto":
          case "fixed":
            return `0 0 ${basis}`;
          case "fit":
            return "1 1 auto";
          case "min":
            return "0 1 auto";
          case "max":
            return "1 0 0px";
        }
      })();
      const align_self = (() => {
        const policy = this._direction == "row" ? sizing.height_policy : sizing.width_policy;
        switch (policy) {
          case "auto":
          case "fixed":
          case "fit":
          case "min":
            return this._direction == "row" ? sizing.valign : sizing.halign;
          case "max":
            return "stretch";
        }
      })();
      view.style.append(":host", { flex, align_self });
      if (this._direction == "row") {
        if (sizing.height_policy == "max") {
          view.style.append(":host", { height: "auto" });
        }
      } else {
        if (sizing.width_policy == "max") {
          view.style.append(":host", { width: "auto" });
        }
      }
      if (view.layout != null) {
        layoutable.add({ r0, c0, r1: r0 + 1, c1: c0 + 1 }, view);
        if (this._direction == "row") {
          c0 += 1;
        } else {
          r0 += 1;
        }
      }
    }
    if (layoutable.size != 0) {
      this.layout = new GridAlignmentLayout(layoutable);
      this.layout.set_sizing();
    } else {
      delete this.layout;
    }
  }
};
__publicField(FlexBoxView, "__name__", "FlexBoxView");
var _FlexBox = class _FlexBox extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_FlexBox, "__name__", "FlexBox");
_FlexBox.define(({ Float: Float2, List: List2, Ref: Ref2 }) => ({
  children: [List2(Ref2(UIElement)), []],
  spacing: [Float2, 0]
}));
var FlexBox = _FlexBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/column.js
var ColumnView = class extends FlexBoxView {
  constructor() {
    super(...arguments);
    __publicField(this, "_direction", "column");
  }
};
__publicField(ColumnView, "__name__", "ColumnView");
var _Column = class _Column extends FlexBox {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Column, "__name__", "Column");
_Column.prototype.default_view = ColumnView;
var Column2 = _Column;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/css_grid_box.js
var { max: max14 } = Math;
var CSSGridBoxView = class extends LayoutDOMView {
  connect_signals() {
    super.connect_signals();
    const { spacing } = this.model.properties;
    this.on_change(spacing, () => this.invalidate_layout());
  }
  get child_models() {
    return this._children.map(([child]) => child);
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "grid" };
  }
  _update_layout() {
    super._update_layout();
    const styles3 = {};
    const [row_gap, column_gap] = (() => {
      const { spacing } = this.model;
      return isNumber(spacing) ? [spacing, spacing] : spacing;
    })();
    styles3.row_gap = px(row_gap);
    styles3.column_gap = px(column_gap);
    let nrows = 0;
    let ncols = 0;
    const layoutable = new Container();
    for (const [[, row2, col2, row_span = 1, col_span = 1], i2] of enumerate(this._children)) {
      const view = this.child_views[i2];
      nrows = max14(nrows, row2 + row_span);
      ncols = max14(ncols, col2 + col_span);
      const styles4 = {};
      styles4.grid_row_start = `${row2 + 1}`;
      styles4.grid_row_end = `span ${row_span}`;
      styles4.grid_column_start = `${col2 + 1}`;
      styles4.grid_column_end = `span ${col_span}`;
      view.style.append(":host", styles4);
      if (view instanceof LayoutDOMView && view.layout != null) {
        const r0 = row2;
        const c0 = col2;
        const r1 = row2 + row_span - 1;
        const c1 = col2 + col_span - 1;
        layoutable.add({ r0, c0, r1, c1 }, view);
      }
    }
    const { _rows: rows, _cols: cols } = this;
    if (rows instanceof Map) {
      nrows = max14(nrows, ...rows.keys());
    } else if (isArray(rows)) {
      nrows = max14(nrows, rows.length);
    }
    if (cols instanceof Map) {
      ncols = max14(ncols, ...cols.keys());
    } else if (isArray(cols)) {
      ncols = max14(ncols, cols.length);
    }
    function parse_sizing(tracks, template2) {
      if (tracks instanceof Map) {
        for (const [i2, spec] of tracks.entries()) {
          if (isString(spec)) {
            template2[i2].size = spec;
          } else {
            template2[i2] = spec;
          }
        }
      } else if (isArray(tracks)) {
        for (const [spec, i2] of enumerate(tracks)) {
          if (isString(spec)) {
            template2[i2].size = spec;
          } else {
            template2[i2] = spec;
          }
        }
      } else if (tracks != null) {
        for (const row2 of template2) {
          if (isString(tracks)) {
            row2.size = tracks;
          } else {
            row2.size = tracks.size;
            row2.align = tracks.align;
          }
        }
      }
    }
    const rows_template = Array(nrows).fill(null).map(() => ({}));
    const cols_template = Array(ncols).fill(null).map(() => ({}));
    parse_sizing(rows, rows_template);
    parse_sizing(cols, cols_template);
    for (const [[, row2, col2], i2] of enumerate(this._children)) {
      const child = this.child_views[i2];
      const { halign, valign } = child.box_sizing();
      child.style.append(":host", {
        justify_self: halign ?? cols_template[col2].align,
        align_self: valign ?? rows_template[row2].align
      });
    }
    const default_size = "auto";
    styles3.grid_template_rows = rows_template.map(({ size: size2 }) => size2 ?? default_size).join(" ");
    styles3.grid_template_columns = cols_template.map(({ size: size2 }) => size2 ?? default_size).join(" ");
    this.style.append(":host", styles3);
    if (layoutable.size != 0) {
      this.layout = new GridAlignmentLayout(layoutable);
      this.layout.set_sizing();
    } else {
      delete this.layout;
    }
  }
};
__publicField(CSSGridBoxView, "__name__", "CSSGridBoxView");
var _CSSGridBox = class _CSSGridBox extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CSSGridBox, "__name__", "CSSGridBox");
_CSSGridBox.define(() => ({
  spacing: [GridSpacing, 0]
}));
var CSSGridBox = _CSSGridBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/grid_box.js
var GridBoxView = class extends CSSGridBoxView {
  connect_signals() {
    super.connect_signals();
    const { children, rows, cols } = this.model.properties;
    this.on_change(children, () => this.update_children());
    this.on_change([rows, cols], () => this.invalidate_layout());
  }
  get _children() {
    return this.model.children;
  }
  get _rows() {
    return this.model.rows;
  }
  get _cols() {
    return this.model.cols;
  }
};
__publicField(GridBoxView, "__name__", "GridBoxView");
var _GridBox = class _GridBox extends CSSGridBox {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GridBox, "__name__", "GridBox");
_GridBox.prototype.default_view = GridBoxView;
_GridBox.define(({ List: List2, Nullable: Nullable2 }) => {
  return {
    children: [List2(GridChild(UIElement)), []],
    rows: [Nullable2(TracksSizing), null],
    cols: [Nullable2(TracksSizing), null]
  };
});
var GridBox = _GridBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/group_box.js
import group_box_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/group_box.css.js";
var GroupBoxView = class extends LayoutDOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "checkbox_el");
    __publicField(this, "fieldset_el");
  }
  stylesheets() {
    return [...super.stylesheets(), group_box_css];
  }
  connect_signals() {
    super.connect_signals();
    const { child } = this.model.properties;
    this.on_change(child, () => this.update_children());
    const { checkable: checkable2, disabled: disabled5 } = this.model.properties;
    this.on_change(checkable2, () => {
      display(this.checkbox_el, this.model.checkable);
    });
    this.on_change(disabled5, () => {
      this.checkbox_el.checked = !this.model.disabled;
    });
  }
  get child_models() {
    return [this.model.child];
  }
  render() {
    super.render();
    const { checkable: checkable2, disabled: disabled5, title: title3 } = this.model;
    this.checkbox_el = input({ type: "checkbox", checked: !disabled5 });
    this.checkbox_el.addEventListener("change", () => {
      this.model.disabled = !this.checkbox_el.checked;
    });
    display(this.checkbox_el, checkable2);
    const title_el = legend({}, this.checkbox_el, title3);
    const child_els = this.child_views.map((child) => child.el);
    this.fieldset_el = fieldset({}, title_el, ...child_els);
    this.shadow_el.appendChild(this.fieldset_el);
  }
  _update_children() {
    const child_els = this.child_views.map((child) => child.el);
    this.fieldset_el.append(...child_els);
  }
};
__publicField(GroupBoxView, "__name__", "GroupBoxView");
var _GroupBox = class _GroupBox extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GroupBox, "__name__", "GroupBox");
_GroupBox.prototype.default_view = GroupBoxView;
_GroupBox.define(({ Bool: Bool2, Str: Str2, Nullable: Nullable2, Ref: Ref2 }) => ({
  title: [Nullable2(Str2), null],
  child: [Ref2(UIElement)],
  checkable: [Bool2, false]
}));
var GroupBox = _GroupBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/hbox.js
var HBoxChild = Struct({ child: Ref(UIElement), col: Opt(Index), span: Opt(Span) });
var HBoxView = class extends CSSGridBoxView {
  connect_signals() {
    super.connect_signals();
    const { children, cols } = this.model.properties;
    this.on_change(children, () => this.update_children());
    this.on_change(cols, () => this.invalidate_layout());
  }
  get _children() {
    return this.model.children.map(({ child, col: col2, span: span2 }, i2) => [child, 0, col2 ?? i2, 1, span2 ?? 1]);
  }
  get _rows() {
    return null;
  }
  get _cols() {
    return this.model.cols;
  }
};
__publicField(HBoxView, "__name__", "HBoxView");
var _HBox = class _HBox extends CSSGridBox {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HBox, "__name__", "HBox");
_HBox.prototype.default_view = HBoxView;
_HBox.define(({ List: List2, Nullable: Nullable2 }) => ({
  children: [List2(HBoxChild), []],
  cols: [Nullable2(TracksSizing), null]
}));
var HBox = _HBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/row.js
var RowView = class extends FlexBoxView {
  constructor() {
    super(...arguments);
    __publicField(this, "_direction", "row");
  }
};
__publicField(RowView, "__name__", "RowView");
var _Row = class _Row extends FlexBox {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Row, "__name__", "Row");
_Row.prototype.default_view = RowView;
var Row2 = _Row;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/scroll_box.js
var ScrollBoxView = class extends LayoutDOMView {
  stylesheets() {
    return [...super.stylesheets()];
  }
  connect_signals() {
    super.connect_signals();
    const { child, horizontal_scrollbar, vertical_scrollbar } = this.model.properties;
    this.on_change(child, () => this.update_children());
    this.on_change([horizontal_scrollbar, vertical_scrollbar], () => this.invalidate_layout());
  }
  get child_models() {
    return [this.model.child];
  }
  _update_layout() {
    super._update_layout();
    function to_overflow(policy) {
      switch (policy) {
        case "auto":
          return "auto";
        case "visible":
          return "scroll";
        case "hidden":
          return "hidden";
      }
    }
    const { horizontal_scrollbar, vertical_scrollbar } = this.model;
    this.style.append(":host", {
      overflow_x: to_overflow(horizontal_scrollbar),
      overflow_y: to_overflow(vertical_scrollbar)
    });
  }
};
__publicField(ScrollBoxView, "__name__", "ScrollBoxView");
var _ScrollBox = class _ScrollBox extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ScrollBox, "__name__", "ScrollBox");
_ScrollBox.prototype.default_view = ScrollBoxView;
_ScrollBox.define(({ Ref: Ref2 }) => ({
  child: [Ref2(UIElement)],
  horizontal_scrollbar: [ScrollbarPolicy, "auto"],
  vertical_scrollbar: [ScrollbarPolicy, "auto"]
}));
var ScrollBox = _ScrollBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/spacer.js
var SpacerView = class extends LayoutDOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "_auto_width", "auto");
    __publicField(this, "_auto_height", "auto");
  }
  get child_models() {
    return [];
  }
};
__publicField(SpacerView, "__name__", "SpacerView");
var _Spacer = class _Spacer extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Spacer, "__name__", "Spacer");
_Spacer.prototype.default_view = SpacerView;
var Spacer = _Spacer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/selectors/selector.js
var _Selector = class _Selector extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Selector, "__name__", "Selector");
_Selector.define(({ Str: Str2 }) => ({
  query: [Str2]
}));
var Selector = _Selector;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/tooltip.js
import tooltips_css, * as tooltips from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tooltips.css.js";
import icons_css7 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var NativeNode = globalThis.Node;
var TooltipView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "arrow_el");
    __publicField(this, "content_el");
    __publicField(this, "_observer");
    __publicField(this, "_target");
    __publicField(this, "_element_view", null);
    __publicField(this, "_scroll_listener");
    __publicField(this, "_has_rendered", false);
  }
  get target() {
    return this._target;
  }
  set target(el) {
    this._target = el;
  }
  _init_target() {
    const { target } = this.model;
    const el = (() => {
      var _a34;
      if (target instanceof UIElement) {
        return ((_a34 = this.owner.find_one(target)) == null ? void 0 : _a34.el) ?? null;
      } else if (target instanceof Selector) {
        return target.find_one(document);
      } else if (target instanceof NativeNode) {
        return target;
      } else {
        const { parent } = this;
        return parent instanceof DOMElementView ? parent.el : null;
      }
    })();
    if (el instanceof Element) {
      this._target = el;
    } else {
      logger.warn(`unable to resolve target '${target}' for '${this}'`);
      this._target = document.body;
    }
  }
  initialize() {
    super.initialize();
    this._init_target();
  }
  *children() {
    yield* super.children();
    if (this._element_view != null) {
      yield this._element_view;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._build_content();
  }
  async _build_content() {
    if (this._element_view != null) {
      this._element_view.remove();
      this._element_view = null;
    }
    const { content: content2 } = this.model;
    if (content2 instanceof Model) {
      this._element_view = await build_view(content2, { parent: this });
    }
  }
  connect_signals() {
    super.connect_signals();
    this._observer = new ResizeObserver(() => {
      this._reposition();
    });
    this._observer.observe(this.target);
    let throttle2 = false;
    document.addEventListener("scroll", this._scroll_listener = () => {
      if (!throttle2) {
        requestAnimationFrame(() => {
          this._reposition();
          throttle2 = false;
        });
        throttle2 = true;
      }
    }, { capture: true });
    const { target, content: content2, closable: closable2, interactive, position: position2, attachment, visible } = this.model.properties;
    this.on_change(target, () => {
      this._init_target();
      this._observer.disconnect();
      this._observer.observe(this.target);
      this.render();
      this.after_render();
    });
    this.on_change(content2, async () => {
      await this._build_content();
      this.render();
      this.after_render();
    });
    this.on_change([closable2, interactive], () => {
      this.render();
      this.after_render();
    });
    this.on_change([position2, attachment, visible], () => {
      this._reposition();
    });
  }
  disconnect_signals() {
    if (this._scroll_listener != null) {
      document.removeEventListener("scroll", this._scroll_listener, { capture: true });
      delete this._scroll_listener;
    }
    super.disconnect_signals();
  }
  remove() {
    var _a34;
    (_a34 = this._element_view) == null ? void 0 : _a34.remove();
    this._observer.disconnect();
    super.remove();
  }
  stylesheets() {
    return [...super.stylesheets(), tooltips_css, icons_css7];
  }
  get content() {
    const { content: content2 } = this.model;
    if (isString(content2)) {
      return document.createTextNode(content2);
    } else if (content2 instanceof Model) {
      assert(this._element_view != null);
      return this._element_view.el;
    } else {
      return content2;
    }
  }
  render() {
    super.render();
    const { _element_view } = this;
    if (_element_view != null) {
      _element_view.render();
      _element_view.r_after_render();
    }
    this.arrow_el = div({ class: [tooltips.arrow] });
    this.content_el = div({ class: tooltips.tooltip_content }, this.content);
    this.shadow_el.append(this.arrow_el, this.content_el);
    this.class_list.toggle(tooltips.closable, this.model.closable);
    const close_el = div({ class: tooltips.close });
    this.shadow_el.append(close_el);
    close_el.addEventListener("click", () => {
      this.model.visible = false;
    });
    this.el.classList.toggle(tooltips.show_arrow, this.model.show_arrow);
    this.el.classList.toggle(tooltips.non_interactive, !this.model.interactive);
    this._has_rendered = true;
  }
  _after_render() {
    super._after_render();
    this._reposition();
  }
  _after_resize() {
    super._after_resize();
    this._reposition();
  }
  _anchor_to_align(anchor2) {
    anchor2 = (() => {
      switch (anchor2) {
        case "top":
          return "top_center";
        case "bottom":
          return "bottom_center";
        case "left":
          return "center_left";
        case "right":
          return "center_right";
        default:
          return anchor2;
      }
    })();
    const [v, h7] = anchor2.split("_");
    return { v, h: h7 };
  }
  _reposition() {
    const target = document.body.shadowRoot ?? document.body;
    if (!this._has_rendered) {
      this.render_to(target);
      this.after_render();
      return;
    }
    const { position: position2, visible } = this.model;
    if (position2 == null || !visible) {
      this.el.remove();
      return;
    }
    target.append(this.el);
    const bbox = bounding_box(this.target);
    const [sx, sy] = (() => {
      if (isString(position2)) {
        const { v: v_align, h: h_align } = this._anchor_to_align(position2);
        const sx2 = (() => {
          switch (h_align) {
            case "left":
              return bbox.left;
            case "center":
              return bbox.hcenter;
            case "right":
              return bbox.right;
          }
        })();
        const sy2 = (() => {
          switch (v_align) {
            case "top":
              return bbox.top;
            case "center":
              return bbox.vcenter;
            case "bottom":
              return bbox.bottom;
          }
        })();
        return [sx2, sy2];
      } else if (isArray(position2)) {
        const [x2, y2] = position2;
        return [bbox.left + x2, bbox.top + y2];
      } else {
        const { x: x2, y: y2 } = this.resolve_as_xy(position2);
        return [bbox.left + x2, bbox.top + y2];
      }
    })();
    const viewport = new BBox({
      x: 0,
      y: 0,
      width: window.innerWidth,
      height: window.innerHeight
    });
    const arrow_size = box_size(this.arrow_el);
    const side = (() => {
      const attachment = (() => {
        const { attachment: attachment2 } = this.model;
        if (attachment2 == "auto") {
          if (isString(position2)) {
            const { v: v_align, h: h_align } = this._anchor_to_align(position2);
            if (h_align != "center") {
              return h_align == "left" ? "left" : "right";
            }
            if (v_align != "center") {
              return v_align == "top" ? "above" : "below";
            }
          }
          return "horizontal";
        } else {
          return attachment2;
        }
      })();
      const el_size = box_size(this.el);
      const width = el_size.width + arrow_size.width;
      const height = el_size.height + arrow_size.height;
      switch (attachment) {
        case "horizontal": {
          if (sx < bbox.hcenter) {
            return sx + width <= viewport.right ? "right" : "left";
          } else {
            return sx - width >= viewport.left ? "left" : "right";
          }
        }
        case "vertical": {
          if (sy < bbox.vcenter) {
            return sy + height <= viewport.bottom ? "below" : "above";
          } else {
            return sy - height >= viewport.top ? "above" : "below";
          }
        }
        default:
          return attachment;
      }
    })();
    this.class_list.remove(tooltips.right, tooltips.left, tooltips.above, tooltips.below);
    this.class_list.add((() => {
      switch (side) {
        case "left":
          return tooltips.right;
        case "right":
          return tooltips.left;
        case "above":
          return tooltips.below;
        case "below":
          return tooltips.above;
      }
    })());
    this.arrow_el.style.left = `${sx}px`;
    this.arrow_el.style.top = `${sy}px`;
    const { left: left2, top } = (() => {
      const { width, height } = box_size(this.el);
      function adjust_top(top2) {
        if (top2 < viewport.top) {
          return viewport.top;
        } else if (top2 + height > viewport.bottom) {
          return viewport.bottom - height;
        } else {
          return top2;
        }
      }
      function adjust_left(left3) {
        if (left3 < viewport.left) {
          return viewport.left;
        } else if (left3 + width > viewport.right) {
          return viewport.right - width;
        } else {
          return left3;
        }
      }
      switch (side) {
        case "left": {
          return {
            left: sx - width - arrow_size.width,
            top: adjust_top(sy - height / 2)
          };
        }
        case "right": {
          return {
            left: sx + arrow_size.width,
            top: adjust_top(sy - height / 2)
          };
        }
        case "above": {
          return {
            left: adjust_left(sx - width / 2),
            top: sy - height - arrow_size.height
          };
        }
        case "below": {
          return {
            left: adjust_left(sx - width / 2),
            top: sy + arrow_size.height
          };
        }
      }
    })();
    this.el.style.top = `${top}px`;
    this.el.style.left = `${left2}px`;
  }
};
__publicField(TooltipView, "__name__", "TooltipView");
var _Tooltip = class _Tooltip extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
  show({ x: x2, y: y2 }) {
    this.setv({ position: [x2, y2], visible: true }, { check_eq: false });
  }
  clear() {
    this.position = null;
  }
};
__publicField(_Tooltip, "__name__", "Tooltip");
_Tooltip.prototype.default_view = TooltipView;
_Tooltip.define(({ Bool: Bool2, Float: Float2, Str: Str2, Tuple: Tuple2, Or: Or2, Ref: Ref2, Nullable: Nullable2, Auto: Auto2 }) => ({
  target: [Or2(Ref2(UIElement), Ref2(Selector), Ref2(NativeNode), Auto2), "auto"],
  position: [Nullable2(Or2(Anchor, Tuple2(Float2, Float2), Ref2(Coordinate))), null],
  content: [Or2(Str2, Ref2(DOMNode), Ref2(UIElement), Ref2(NativeNode))],
  attachment: [Or2(TooltipAttachment, Auto2), "auto"],
  show_arrow: [Bool2, true],
  closable: [Bool2, false],
  interactive: [Bool2, true]
}));
_Tooltip.override({
  visible: false
});
var Tooltip = _Tooltip;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/tab_panel.js
var _TabPanel = class _TabPanel extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TabPanel, "__name__", "TabPanel");
_TabPanel.define(({ Bool: Bool2, Str: Str2, Ref: Ref2, Nullable: Nullable2 }) => ({
  title: [Str2, ""],
  tooltip: [Nullable2(Ref2(Tooltip)), null],
  child: [Ref2(UIElement)],
  closable: [Bool2, false],
  disabled: [Bool2, false]
}));
var TabPanel = _TabPanel;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/tabs.js
import tabs_css, * as tabs from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tabs.css.js";
import icons_css8 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var TabsView = class extends LayoutDOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "tooltip_views", /* @__PURE__ */ new Map());
    __publicField(this, "header_el");
    __publicField(this, "header_els");
  }
  connect_signals() {
    super.connect_signals();
    const { tabs: tabs2, active: active8 } = this.model.properties;
    this.on_change(tabs2, async () => {
      this._update_headers();
      await this.update_children();
    });
    this.on_change(active8, () => {
      this.update_active();
    });
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { tabs: tabs2 } = this.model;
    const tooltips2 = tabs2.map((tab2) => tab2.tooltip).filter((tt) => tt != null);
    await build_views(this.tooltip_views, tooltips2, { parent: this });
  }
  stylesheets() {
    return [...super.stylesheets(), tabs_css, icons_css8];
  }
  get child_models() {
    return this.model.tabs.map((tab2) => tab2.child);
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "grid" };
  }
  _update_layout() {
    super._update_layout();
    const loc = this.model.tabs_location;
    this.class_list.remove([...Location].map((loc2) => tabs[loc2]));
    this.class_list.add(tabs[loc]);
    const layoutable = new Container();
    for (const view of this.child_views) {
      view.style.append(":host", { grid_area: "stack" });
      if (view instanceof LayoutDOMView && view.layout != null) {
        layoutable.add({ r0: 0, c0: 0, r1: 1, c1: 1 }, view);
      }
    }
    if (layoutable.size != 0) {
      this.layout = new GridAlignmentLayout(layoutable);
      this.layout.set_sizing();
    } else {
      delete this.layout;
    }
  }
  _after_layout() {
    super._after_layout();
    const { child_views } = this;
    for (const child_view of child_views) {
      hide(child_view.el);
    }
    const { active: active8 } = this.model;
    if (active8 in child_views) {
      const tab2 = child_views[active8];
      show(tab2.el);
    }
  }
  render() {
    super.render();
    this.header_el = div({ class: tabs.header });
    this.shadow_el.append(this.header_el);
    this._update_headers();
  }
  _update_headers() {
    const { active: active8 } = this.model;
    const headers = this.model.tabs.map((tab2, i2) => {
      const tab_el = div({ class: [tabs.tab, i2 == active8 ? tabs.active : null], tabIndex: 0 }, tab2.title);
      tab_el.addEventListener("click", (event2) => {
        if (this.model.disabled) {
          return;
        }
        if (event2.target == event2.currentTarget) {
          this.change_active(i2);
        }
      });
      const tooltip_view = tab2.tooltip != null ? this.tooltip_views.get(tab2.tooltip) : null;
      if (tooltip_view != null) {
        tooltip_view.model.target = tab_el;
        const toggle_tooltip = (visible) => {
          tooltip_view.model.visible = visible;
        };
        tab_el.addEventListener("mouseenter", () => {
          toggle_tooltip(true);
        });
        tab_el.addEventListener("mouseleave", () => {
          toggle_tooltip(false);
        });
      }
      if (tab2.closable) {
        const close_el = div({ class: tabs.close });
        close_el.addEventListener("click", (event2) => {
          if (event2.target == event2.currentTarget) {
            this.model.tabs = remove_at(this.model.tabs, i2);
            const ntabs = this.model.tabs.length;
            if (this.model.active > ntabs - 1) {
              this.model.active = ntabs - 1;
            }
          }
        });
        tab_el.appendChild(close_el);
      }
      if (this.model.disabled || tab2.disabled) {
        tab_el.classList.add(tabs.disabled);
      }
      return tab_el;
    });
    this.header_els = headers;
    empty2(this.header_el);
    this.header_el.append(...headers);
  }
  change_active(i2) {
    if (i2 != this.model.active) {
      this.model.active = i2;
    }
  }
  update_active() {
    const i2 = this.model.active;
    const { header_els } = this;
    for (const el of header_els) {
      el.classList.remove(tabs.active);
    }
    if (i2 in header_els) {
      header_els[i2].classList.add(tabs.active);
    }
    const { child_views } = this;
    for (const child_view of child_views) {
      hide(child_view.el);
    }
    if (i2 in child_views) {
      show(child_views[i2].el);
    }
  }
};
__publicField(TabsView, "__name__", "TabsView");
var _Tabs = class _Tabs extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Tabs, "__name__", "Tabs");
_Tabs.prototype.default_view = TabsView;
_Tabs.define(({ Int: Int2, List: List2, Ref: Ref2 }) => ({
  tabs: [List2(Ref2(TabPanel)), []],
  tabs_location: [Location, "above"],
  active: [Int2, 0]
}));
var Tabs = _Tabs;

// node_modules/@bokeh/bokehjs/build/js/lib/models/layouts/vbox.js
var VBoxChild = Struct({ child: Ref(UIElement), row: Opt(Index), span: Opt(Span) });
var VBoxView = class extends CSSGridBoxView {
  connect_signals() {
    super.connect_signals();
    const { children, rows } = this.model.properties;
    this.on_change(children, () => this.update_children());
    this.on_change(rows, () => this.invalidate_layout());
  }
  get _children() {
    return this.model.children.map(({ child, row: row2, span: span2 }, i2) => [child, row2 ?? i2, 0, span2 ?? 1, 1]);
  }
  get _rows() {
    return this.model.rows;
  }
  get _cols() {
    return null;
  }
};
__publicField(VBoxView, "__name__", "VBoxView");
var _VBox = class _VBox extends CSSGridBox {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_VBox, "__name__", "VBox");
_VBox.prototype.default_view = VBoxView;
_VBox.define(({ List: List2, Nullable: Nullable2 }) => ({
  children: [List2(VBoxChild), []],
  rows: [Nullable2(TracksSizing), null]
}));
var VBox = _VBox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/misc/group_by.js
var GroupBy = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(GroupBy, "__name__", "GroupBy");
var _GroupByModels = class _GroupByModels extends GroupBy {
  constructor(attrs) {
    super(attrs);
  }
  *query_groups(models, _pool) {
    for (const model2 of models) {
      for (const group of this.groups) {
        if (group.includes(model2)) {
          yield group;
        }
      }
    }
  }
};
__publicField(_GroupByModels, "__name__", "GroupByModels");
_GroupByModels.define({
  groups: [List(List(Ref(Model)))]
});
var GroupByModels = _GroupByModels;
var GroupByName = class extends GroupBy {
  constructor(attrs) {
    super(attrs);
  }
  *query_groups(models, pool) {
    const groups = /* @__PURE__ */ new Map();
    for (const model2 of pool) {
      const { name } = model2;
      if (name != null) {
        let group = groups.get(name);
        if (group === void 0) {
          group = /* @__PURE__ */ new Set();
          groups.set(name, group);
        }
        group.add(model2);
      }
    }
    for (const model2 of models) {
      for (const group of groups.values()) {
        if (model2.name != null && group.has(model2)) {
          yield [...group];
        }
      }
    }
  }
};
__publicField(GroupByName, "__name__", "GroupByName");

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/customjs_transform.js
var _CustomJSTransform = class _CustomJSTransform extends Transform {
  constructor(attrs) {
    super(attrs);
  }
  get names() {
    return keys(this.args);
  }
  get values() {
    return values(this.args);
  }
  _make_transform(name, func) {
    return new Function(...this.names, name, use_strict(func));
  }
  get scalar_transform() {
    return this._make_transform("x", this.func);
  }
  get vector_transform() {
    return this._make_transform("xs", this.v_func);
  }
  compute(x2) {
    return this.scalar_transform(...this.values, x2);
  }
  v_compute(xs) {
    return this.vector_transform(...this.values, xs);
  }
};
__publicField(_CustomJSTransform, "__name__", "CustomJSTransform");
_CustomJSTransform.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  func: [Str2, ""],
  v_func: [Str2, ""]
}));
var CustomJSTransform = _CustomJSTransform;

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/range_transform.js
var _RangeTransform = class _RangeTransform extends Transform {
  constructor(attrs) {
    super(attrs);
  }
  v_compute(xs0) {
    let xs;
    if (this.range instanceof FactorRange) {
      xs = this.range.v_synthetic(xs0);
    } else if (isArrayableOf(xs0, isNumber)) {
      xs = xs0;
    } else {
      unreachable();
    }
    const result = new (infer_type(xs))(xs.length);
    for (let i2 = 0; i2 < xs.length; i2++) {
      const x2 = xs[i2];
      result[i2] = this._compute(x2);
    }
    return result;
  }
  compute(x2) {
    if (this.range instanceof FactorRange) {
      return this._compute(this.range.synthetic(x2));
    } else if (isNumber(x2)) {
      return this._compute(x2);
    } else {
      unreachable();
    }
  }
};
__publicField(_RangeTransform, "__name__", "RangeTransform");
_RangeTransform.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  range: [Nullable2(Ref2(Range)), null]
}));
var RangeTransform = _RangeTransform;

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/dodge.js
var _Dodge = class _Dodge extends RangeTransform {
  constructor(attrs) {
    super(attrs);
  }
  _compute(x2) {
    return x2 + this.value;
  }
};
__publicField(_Dodge, "__name__", "Dodge");
_Dodge.define(({ Float: Float2 }) => ({
  value: [Float2, 0]
}));
var Dodge = _Dodge;

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/interpolator.js
var _Interpolator = class _Interpolator extends Transform {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_x_sorted");
    __publicField(this, "_y_sorted");
    __publicField(this, "_sorted_dirty", true);
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.change, () => this._sorted_dirty = true);
  }
  v_compute(xs) {
    const ArrayType = infer_type(xs);
    const result = new ArrayType(xs.length);
    for (let i2 = 0; i2 < xs.length; i2++) {
      const x2 = xs[i2];
      result[i2] = this.compute(x2);
    }
    return result;
  }
  sort(descending = false) {
    if (!this._sorted_dirty) {
      return;
    }
    let tsx;
    let tsy;
    if (isString(this.x) && isString(this.y) && this.data != null) {
      const column_names = this.data.columns();
      if (!includes(column_names, this.x)) {
        throw new Error("The x parameter does not correspond to a valid column name defined in the data parameter");
      }
      if (!includes(column_names, this.y)) {
        throw new Error("The y parameter does not correspond to a valid column name defined in the data parameter");
      }
      tsx = this.data.get_column(this.x);
      tsy = this.data.get_column(this.y);
    } else if (isArray(this.x) && isArray(this.y)) {
      tsx = this.x;
      tsy = this.y;
    } else {
      throw new Error("parameters 'x' and 'y' must be both either string fields or arrays");
    }
    if (tsx.length !== tsy.length) {
      throw new Error("The length for x and y do not match");
    }
    if (tsx.length < 2) {
      throw new Error("x and y must have at least two elements to support interpolation");
    }
    const n2 = tsx.length;
    const index2 = new Uint32Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      index2[i2] = i2;
    }
    const sign = descending ? -1 : 1;
    index2.sort((i2, j) => sign * (tsx[i2] - tsx[j]));
    this._x_sorted = new (infer_type(tsx))(n2);
    this._y_sorted = new (infer_type(tsy))(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      this._x_sorted[i2] = tsx[index2[i2]];
      this._y_sorted[i2] = tsy[index2[i2]];
    }
    this._sorted_dirty = false;
  }
};
__publicField(_Interpolator, "__name__", "Interpolator");
_Interpolator.define(({ Bool: Bool2, Float: Float2, Str: Str2, Ref: Ref2, List: List2, Or: Or2, Nullable: Nullable2 }) => ({
  x: [Or2(Str2, List2(Float2))],
  y: [Or2(Str2, List2(Float2))],
  data: [Nullable2(Ref2(ColumnarDataSource)), null],
  clip: [Bool2, true]
}));
var Interpolator = _Interpolator;

// node_modules/@bokeh/bokehjs/build/js/lib/models/random/random_generator.js
var RandomGenerator = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(RandomGenerator, "__name__", "RandomGenerator");

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/jitter.js
var _Jitter = class _Jitter extends RangeTransform {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_previous_offsets", null);
    __publicField(this, "_generator");
  }
  initialize() {
    var _a34;
    super.initialize();
    this._generator = ((_a34 = this.random_generator) == null ? void 0 : _a34.generator()) ?? new SystemRandom();
  }
  v_compute(xs0) {
    const xs = (() => {
      if (this.range instanceof FactorRange) {
        return this.range.v_synthetic(xs0);
      } else {
        return xs0;
      }
    })();
    const offsets = (() => {
      var _a34;
      const xs_length = xs.length;
      if (((_a34 = this._previous_offsets) == null ? void 0 : _a34.length) != xs_length) {
        this._previous_offsets = this._v_compute(xs_length);
      }
      return this._previous_offsets;
    })();
    return map(offsets, (offset3, i2) => offset3 + xs[i2]);
  }
  _compute() {
    const { mean, width } = this;
    switch (this.distribution) {
      case "uniform":
        return this._generator.uniform(mean, width);
      case "normal":
        return this._generator.normal(mean, width);
    }
  }
  _v_compute(n2) {
    const { mean, width } = this;
    switch (this.distribution) {
      case "uniform":
        return this._generator.uniforms(mean, width, n2);
      case "normal":
        return this._generator.normals(mean, width, n2);
    }
  }
};
__publicField(_Jitter, "__name__", "Jitter");
_Jitter.define(({ Float: Float2 }) => ({
  mean: [Float2, 0],
  width: [Float2, 1],
  distribution: [Distribution, "uniform"]
}));
_Jitter.internal(({ Nullable: Nullable2, Ref: Ref2 }) => ({
  random_generator: [Nullable2(Ref2(RandomGenerator)), null]
}));
var Jitter = _Jitter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/linear_interpolator.js
var LinearInterpolator = class extends Interpolator {
  constructor(attrs) {
    super(attrs);
  }
  compute(x2) {
    this.sort(false);
    if (this.clip) {
      if (x2 < this._x_sorted[0] || x2 > this._x_sorted[this._x_sorted.length - 1]) {
        return NaN;
      }
    } else {
      if (x2 < this._x_sorted[0]) {
        return this._y_sorted[0];
      }
      if (x2 > this._x_sorted[this._x_sorted.length - 1]) {
        return this._y_sorted[this._y_sorted.length - 1];
      }
    }
    if (x2 == this._x_sorted[0]) {
      return this._y_sorted[0];
    }
    const ind = find_last_index(this._x_sorted, (num) => num < x2);
    const x1 = this._x_sorted[ind];
    const x22 = this._x_sorted[ind + 1];
    const y1 = this._y_sorted[ind];
    const y2 = this._y_sorted[ind + 1];
    return y1 + (x2 - x1) / (x22 - x1) * (y2 - y1);
  }
};
__publicField(LinearInterpolator, "__name__", "LinearInterpolator");

// node_modules/@bokeh/bokehjs/build/js/lib/models/transforms/step_interpolator.js
var _StepInterpolator = class _StepInterpolator extends Interpolator {
  constructor(attrs) {
    super(attrs);
  }
  compute(x2) {
    this.sort(false);
    if (this.clip) {
      if (x2 < this._x_sorted[0] || x2 > this._x_sorted[this._x_sorted.length - 1]) {
        return NaN;
      }
    } else {
      if (x2 < this._x_sorted[0]) {
        return this._y_sorted[0];
      }
      if (x2 > this._x_sorted[this._x_sorted.length - 1]) {
        return this._y_sorted[this._y_sorted.length - 1];
      }
    }
    let ind;
    switch (this.mode) {
      case "after": {
        ind = find_last_index(this._x_sorted, (num) => x2 >= num);
        break;
      }
      case "before": {
        ind = find_index(this._x_sorted, (num) => x2 <= num);
        break;
      }
      case "center": {
        const diffs = map(this._x_sorted, (tx) => Math.abs(tx - x2));
        const mdiff = min(diffs);
        ind = find_index(diffs, (num) => mdiff === num);
        break;
      }
      default:
        throw new Error(`unknown mode: ${this.mode}`);
    }
    return ind != -1 ? this._y_sorted[ind] : NaN;
  }
};
__publicField(_StepInterpolator, "__name__", "StepInterpolator");
_StepInterpolator.define(() => ({
  mode: [StepMode, "after"]
}));
var StepInterpolator = _StepInterpolator;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/panel.js
import panels_css, * as _panel from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/panels.css.js";
var PanelView = class extends PaneView {
  stylesheets() {
    return [...super.stylesheets(), panels_css];
  }
  connect_signals() {
    super.connect_signals();
    const { position: position2, anchor: anchor2, width, height, elements } = this.model.properties;
    this.on_change([anchor2, width, height, elements], () => this.reposition());
    this.on_transitive_change(position2, () => this.reposition());
  }
  reposition(displayed) {
    var _a34;
    super.reposition(displayed);
    const { position: position2, visible, anchor: anchor2, elements } = this.model;
    if (displayed == false || !visible || elements.length == 0) {
      this.el.remove();
      return;
    }
    const { x: left2, y: top } = this.resolve_as_xy(position2);
    if (!isFinite(left2 + top)) {
      this.el.remove();
      return;
    }
    const parent_el = ((_a34 = this.parent) == null ? void 0 : _a34.el) ?? document.body;
    const target_el = parent_el.shadowRoot ?? parent_el;
    if (!this.el.isConnected) {
      target_el.append(this.el);
    }
    this.el.style.left = px(left2);
    this.el.style.top = px(top);
    const xy2 = anchor(anchor2);
    this.el.style.transform = `translate(${-100 * xy2.x}%, ${-100 * xy2.y}%)`;
  }
};
__publicField(PanelView, "__name__", "PanelView");
var _Panel = class _Panel extends Pane {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Panel, "__name__", "Panel");
_Panel.prototype.default_view = PanelView;
_Panel.define(({ Ref: Ref2, Or: Or2, Auto: Auto2, Int: Int2 }) => ({
  position: [Ref2(Coordinate)],
  anchor: [Anchor2, "top_left"],
  width: [Or2(Auto2, Int2, Ref2(Node2)), "auto"],
  height: [Or2(Auto2, Int2, Ref2(Node2)), "auto"]
}));
var Panel = _Panel;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/elements.js
var SpanView2 = class extends DOMElementView2 {
};
__publicField(SpanView2, "__name__", "SpanView");
__publicField(SpanView2, "tag_name", "span");
var _Span2 = class _Span2 extends DOMElement {
};
__publicField(_Span2, "__name__", "Span");
_Span2.prototype.default_view = SpanView2;
var Span3 = _Span2;
var DivView = class extends DOMElementView2 {
};
__publicField(DivView, "__name__", "DivView");
__publicField(DivView, "tag_name", "div");
var _Div = class _Div extends DOMElement {
};
__publicField(_Div, "__name__", "Div");
_Div.prototype.default_view = DivView;
var Div = _Div;
var TableView = class extends DOMElementView2 {
};
__publicField(TableView, "__name__", "TableView");
__publicField(TableView, "tag_name", "table");
var _Table = class _Table extends DOMElement {
};
__publicField(_Table, "__name__", "Table");
_Table.prototype.default_view = TableView;
var Table = _Table;
var TableRowView = class extends DOMElementView2 {
};
__publicField(TableRowView, "__name__", "TableRowView");
__publicField(TableRowView, "tag_name", "tr");
var _TableRow = class _TableRow extends DOMElement {
};
__publicField(_TableRow, "__name__", "TableRow");
_TableRow.prototype.default_view = TableRowView;
var TableRow = _TableRow;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/throttle.js
function throttle(func, wait) {
  let timeout = null;
  let request = null;
  let previous = 0;
  let pending = false;
  let resolver;
  const fn = function() {
    return new Promise((resolve, reject) => {
      resolver = resolve;
      const later = function() {
        previous = Date.now();
        timeout = null;
        request = null;
        pending = false;
        try {
          func();
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      const now = Date.now();
      const remaining = wait - (now - previous);
      if (remaining <= 0 && !pending) {
        if (timeout != null) {
          clearTimeout(timeout);
        }
        pending = true;
        request = requestAnimationFrame(later);
      } else if (timeout == null && !pending) {
        timeout = setTimeout(() => request = requestAnimationFrame(later), remaining);
      } else {
        resolve();
      }
    });
  };
  fn.stop = function() {
    if (timeout != null) {
      clearTimeout(timeout);
    }
    if (request != null) {
      cancelAnimationFrame(request);
    }
    resolver();
  };
  return fn;
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/range_manager.js
var RangeManager = class {
  constructor(parent) {
    __publicField(this, "parent");
    __publicField(this, "invalidate_dataranges", true);
    this.parent = parent;
  }
  get frame() {
    return this.parent.frame;
  }
  update(range_info, options2 = {}) {
    const panning = options2.panning ?? false;
    const scrolling = options2.scrolling ?? false;
    const maintain_focus = options2.maintain_focus ?? false;
    const range_state = /* @__PURE__ */ new Map();
    for (const [range2, interval] of range_info.xrs) {
      range_state.set(range2, interval);
    }
    for (const [range2, interval] of range_info.yrs) {
      range_state.set(range2, interval);
    }
    if (scrolling && maintain_focus) {
      this._update_ranges_together(range_state);
    }
    this._update_ranges_individually(range_state, { panning, scrolling, maintain_focus });
  }
  ranges() {
    const x_ranges = /* @__PURE__ */ new Set();
    const y_ranges = /* @__PURE__ */ new Set();
    for (const range2 of this.frame.x_ranges.values()) {
      x_ranges.add(range2);
    }
    for (const range2 of this.frame.y_ranges.values()) {
      y_ranges.add(range2);
    }
    for (const renderer of this.parent.model.data_renderers) {
      const { coordinates } = renderer;
      if (coordinates != null) {
        x_ranges.add(coordinates.x_source);
        y_ranges.add(coordinates.y_source);
      }
    }
    return {
      x_ranges: [...x_ranges],
      y_ranges: [...y_ranges]
    };
  }
  reset() {
    const { x_ranges, y_ranges } = this.ranges();
    for (const range2 of x_ranges) {
      range2.reset();
    }
    for (const range2 of y_ranges) {
      range2.reset();
    }
    this.update_dataranges();
  }
  _update_dataranges(frame) {
    const bounds = /* @__PURE__ */ new Map();
    const log_bounds = /* @__PURE__ */ new Map();
    let calculate_log_bounds = false;
    for (const [, xr] of frame.x_ranges) {
      if (xr instanceof DataRange1d && xr.scale_hint == "log") {
        calculate_log_bounds = true;
      }
    }
    for (const [, yr] of frame.y_ranges) {
      if (yr instanceof DataRange1d && yr.scale_hint == "log") {
        calculate_log_bounds = true;
      }
    }
    for (const renderer of this.parent.auto_ranged_renderers) {
      const bds = renderer.bounds();
      bounds.set(renderer.model, bds);
      if (calculate_log_bounds) {
        const log_bds = renderer.log_bounds();
        log_bounds.set(renderer.model, log_bds);
      }
    }
    let follow_enabled = false;
    let has_bounds = false;
    const width = frame.x_target.span;
    const height = frame.y_target.span;
    let r;
    if (this.parent.model.match_aspect !== false && width != 0 && height != 0) {
      r = 1 / this.parent.model.aspect_scale * (width / height);
    }
    for (const [, xr] of frame.x_ranges) {
      if (xr instanceof DataRange1d) {
        const bounds_to_use = xr.scale_hint == "log" ? log_bounds : bounds;
        xr.update(bounds_to_use, 0, this.parent, r);
        if (xr.follow != null) {
          follow_enabled = true;
        }
      }
      if (xr.bounds != null) {
        has_bounds = true;
      }
    }
    for (const [, yr] of frame.y_ranges) {
      if (yr instanceof DataRange1d) {
        const bounds_to_use = yr.scale_hint == "log" ? log_bounds : bounds;
        yr.update(bounds_to_use, 1, this.parent, r);
        if (yr.follow != null) {
          follow_enabled = true;
        }
      }
      if (yr.bounds != null) {
        has_bounds = true;
      }
    }
    if (follow_enabled && has_bounds) {
      logger.warn("Follow enabled so bounds are unset.");
      for (const [, xr] of frame.x_ranges) {
        xr.bounds = null;
      }
      for (const [, yr] of frame.y_ranges) {
        yr.bounds = null;
      }
    }
  }
  update_dataranges() {
    this._update_dataranges(this.frame);
    for (const renderer of this.parent.auto_ranged_renderers) {
      const { coordinates } = renderer.model;
      if (coordinates != null) {
        this._update_dataranges(coordinates);
      }
    }
    if (this.compute_initial() != null) {
      this.invalidate_dataranges = false;
    }
  }
  compute_initial() {
    let good_vals = true;
    const { x_ranges, y_ranges } = this.frame;
    const xrs = /* @__PURE__ */ new Map();
    const yrs = /* @__PURE__ */ new Map();
    for (const [, range2] of x_ranges) {
      const { start: start2, end } = range2;
      if (isNaN(start2 + end)) {
        good_vals = false;
        break;
      }
      xrs.set(range2, { start: start2, end });
    }
    if (good_vals) {
      for (const [, range2] of y_ranges) {
        const { start: start2, end } = range2;
        if (isNaN(start2 + end)) {
          good_vals = false;
          break;
        }
        yrs.set(range2, { start: start2, end });
      }
    }
    if (good_vals) {
      return { xrs, yrs };
    } else {
      logger.warn("could not set initial ranges");
      return null;
    }
  }
  _update_ranges_together(range_state) {
    let weight = 1;
    for (const [rng, range_info] of range_state) {
      weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));
    }
    if (weight < 1) {
      for (const [rng, range_info] of range_state) {
        range_info.start = weight * range_info.start + (1 - weight) * rng.start;
        range_info.end = weight * range_info.end + (1 - weight) * rng.end;
      }
    }
  }
  _update_ranges_individually(range_state, options2) {
    const { panning, scrolling, maintain_focus } = options2;
    let hit_bound = false;
    for (const [rng, range_info] of range_state) {
      if (!scrolling || maintain_focus) {
        const weight = this._get_weight_to_constrain_interval(rng, range_info);
        if (weight < 1) {
          range_info.start = weight * range_info.start + (1 - weight) * rng.start;
          range_info.end = weight * range_info.end + (1 - weight) * rng.end;
        }
      }
      if (rng.bounds != null) {
        const [min10, max18] = rng.computed_bounds;
        const new_interval = Math.abs(range_info.end - range_info.start);
        if (rng.is_reversed) {
          if (min10 > range_info.end) {
            hit_bound = true;
            range_info.end = min10;
            if (panning || scrolling) {
              range_info.start = min10 + new_interval;
            }
          }
          if (max18 < range_info.start) {
            hit_bound = true;
            range_info.start = max18;
            if (panning || scrolling) {
              range_info.end = max18 - new_interval;
            }
          }
        } else {
          if (min10 > range_info.start) {
            hit_bound = true;
            range_info.start = min10;
            if (panning || scrolling) {
              range_info.end = min10 + new_interval;
            }
          }
          if (max18 < range_info.end) {
            hit_bound = true;
            range_info.end = max18;
            if (panning || scrolling) {
              range_info.start = max18 - new_interval;
            }
          }
        }
      }
    }
    if (scrolling && hit_bound && maintain_focus) {
      return;
    }
    for (const [rng, range_info] of range_state) {
      rng.have_updated_interactively = true;
      if (rng.start != range_info.start || rng.end != range_info.end) {
        rng.setv(range_info);
      }
    }
  }
  _get_weight_to_constrain_interval(rng, range_info) {
    const { min_interval } = rng;
    let { max_interval } = rng;
    if (rng.bounds != null && rng.bounds != "auto") {
      const [min10, max18] = rng.bounds;
      if (min10 != null && max18 != null) {
        const max_interval2 = Math.abs(max18 - min10);
        max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;
      }
    }
    let weight = 1;
    if (min_interval != null || max_interval != null) {
      const old_interval = Math.abs(rng.end - rng.start);
      const new_interval = Math.abs(range_info.end - range_info.start);
      if (min_interval != null && min_interval > 0 && new_interval < min_interval) {
        weight = (old_interval - min_interval) / (old_interval - new_interval);
      }
      if (max_interval != null && max_interval > 0 && new_interval > max_interval) {
        weight = (max_interval - old_interval) / (new_interval - old_interval);
      }
      weight = Math.max(0, Math.min(1, weight));
    }
    return weight;
  }
};
__publicField(RangeManager, "__name__", "RangeManager");

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/state_manager.js
var StateManager = class {
  constructor(parent, initial_state) {
    __publicField(this, "parent");
    __publicField(this, "initial_state");
    __publicField(this, "changed");
    __publicField(this, "history", []);
    __publicField(this, "index", -1);
    this.parent = parent;
    this.initial_state = initial_state;
    this.changed = new Signal0(this.parent, "state_changed");
  }
  _do_state_change(index2) {
    const state = index2 in this.history ? this.history[index2].state : this.initial_state;
    if (state.range != null) {
      this.parent.update_range(state.range);
    }
    if (state.selection != null) {
      this.parent.update_selection(state.selection);
    }
    return state;
  }
  peek() {
    return this.can_undo ? this.history[this.index] : null;
  }
  push(type, new_state) {
    const { history, index: index2 } = this;
    const prev_state = index2 in history ? history[index2].state : {};
    const state = { ...this.initial_state, ...prev_state, ...new_state };
    this.history = this.history.slice(0, this.index + 1);
    this.history.push({ type, state });
    this.index = this.history.length - 1;
    this.changed.emit();
  }
  clear() {
    this.history = [];
    this.index = -1;
    this.changed.emit();
  }
  undo() {
    if (this.can_undo) {
      this.index -= 1;
      const state = this._do_state_change(this.index);
      this.changed.emit();
      return state;
    }
    return null;
  }
  redo() {
    if (this.can_redo) {
      this.index += 1;
      const state = this._do_state_change(this.index);
      this.changed.emit();
      return state;
    }
    return null;
  }
  get can_undo() {
    return this.index >= 0;
  }
  get can_redo() {
    return this.index < this.history.length - 1;
  }
};
__publicField(StateManager, "__name__", "StateManager");

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/plot_canvas.js
import * as plots_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/plots.css.js";
import * as canvas_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/canvas.css.js";
import * as attribution_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/attribution.css.js";
var { max: max15 } = Math;
var PlotView = class extends LayoutDOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "visuals");
    __publicField(this, "_frame");
    __publicField(this, "frame_view");
    __publicField(this, "_canvas");
    __publicField(this, "canvas_view");
    __publicField(this, "_render_count", 0);
    __publicField(this, "repainted", new Signal0(this, "repainted"));
    __publicField(this, "_computed_style", new InlineStyleSheet());
    __publicField(this, "_title");
    __publicField(this, "_toolbar");
    __publicField(this, "_attribution");
    __publicField(this, "_notifications");
    __publicField(this, "_outer_bbox", new BBox());
    __publicField(this, "_inner_bbox", new BBox());
    __publicField(this, "_needs_paint", true);
    __publicField(this, "_invalidated_painters", /* @__PURE__ */ new Set());
    __publicField(this, "_invalidate_all", true);
    __publicField(this, "_state_manager");
    __publicField(this, "_range_manager");
    __publicField(this, "lod_started");
    __publicField(this, "_initial_state");
    __publicField(this, "throttled_paint");
    __publicField(this, "computed_renderers", []);
    /*protected*/
    __publicField(this, "renderer_views", /* @__PURE__ */ new Map());
    /*protected*/
    __publicField(this, "tool_views", /* @__PURE__ */ new Map());
    __publicField(this, "_is_paused", 0);
    __publicField(this, "_needs_notify", false);
    __publicField(this, "_messages", /* @__PURE__ */ new Map());
  }
  get frame() {
    return this.frame_view;
  }
  get canvas() {
    return this.canvas_view;
  }
  stylesheets() {
    return [...super.stylesheets(), plots_css.default, this._computed_style];
  }
  get toolbar_panel() {
    return this._toolbar != null ? this.views.find_one(this._toolbar) : null;
  }
  get state() {
    return this._state_manager;
  }
  set invalidate_dataranges(value2) {
    this._range_manager.invalidate_dataranges = value2;
  }
  get computed_renderer_views() {
    return this.computed_renderers.map((r) => this.renderer_views.get(r)).filter((rv) => rv != null);
  }
  get all_renderer_views() {
    const collected = [];
    for (const rv of this.computed_renderer_views) {
      collected.push(rv);
      if (rv instanceof CompositeRendererView) {
        collected.push(...rv.computed_renderer_views);
      }
    }
    return collected;
  }
  get auto_ranged_renderers() {
    return this.computed_renderer_views.filter(is_auto_ranged);
  }
  get base_font_size() {
    const font_size = getComputedStyle(this.el).fontSize;
    const result = parse_css_font_size(font_size);
    if (result != null) {
      const { value: value2, unit } = result;
      if (unit == "px") {
        return value2;
      }
    }
    return null;
  }
  *children() {
    yield* super.children();
    yield* this.renderer_views.values();
    yield* this.tool_views.values();
  }
  get child_models() {
    return [];
  }
  get is_paused() {
    return this._is_paused != 0;
  }
  pause() {
    this._is_paused += 1;
  }
  unpause(no_render = false) {
    this._is_paused = max15(this._is_paused - 1, 0);
    if (!this.is_paused && !no_render) {
      this.request_repaint();
    }
  }
  notify_finished_after_paint() {
    this._needs_notify = true;
  }
  request_repaint() {
    this.request_paint();
  }
  request_paint(...to_invalidate) {
    this.invalidate_painters(...to_invalidate);
    this.schedule_paint();
  }
  invalidate_painters(...to_invalidate) {
    if (to_invalidate.length == 0) {
      this._invalidate_all = true;
      return;
    }
    for (const item3 of to_invalidate) {
      const view = (() => {
        if (item3 instanceof RendererView) {
          return item3;
        } else {
          return this.views.get_one(item3);
        }
      })();
      this._invalidated_painters.add(view);
    }
  }
  schedule_paint() {
    if (!this.is_paused) {
      const promise = this.throttled_paint();
      this._ready = this._ready.then(() => promise);
    }
  }
  request_layout() {
    this.request_repaint();
  }
  reset() {
    if (this.model.reset_policy == "standard") {
      this.state.clear();
      this.reset_range();
      this.reset_selection();
    }
    this.model.trigger_event(new Reset());
  }
  remove() {
    remove_views(this.renderer_views);
    remove_views(this.tool_views);
    super.remove();
  }
  get_context_menu(xy2) {
    var _a34;
    const { x: x2, y: y2 } = xy2;
    for (const rv of reversed([...this.renderer_views.values()])) {
      if (rv.context_menu != null && ((_a34 = rv.interactive_hit) == null ? void 0 : _a34.call(rv, x2, y2)) == true) {
        return rv.context_menu;
      }
    }
    return super.get_context_menu(xy2);
  }
  initialize() {
    this.pause();
    super.initialize();
    this.lod_started = false;
    this.visuals = new Visuals(this);
    this._initial_state = {
      selection: /* @__PURE__ */ new Map()
      // XXX: initial selection?
    };
    this._frame = new CartesianFrame({
      x_scale: this.model.x_scale,
      y_scale: this.model.y_scale,
      x_range: this.model.x_range,
      y_range: this.model.y_range,
      extra_x_ranges: this.model.extra_x_ranges,
      extra_y_ranges: this.model.extra_y_ranges,
      extra_x_scales: this.model.extra_x_scales,
      extra_y_scales: this.model.extra_y_scales,
      aspect_scale: this.model.aspect_scale,
      match_aspect: this.model.match_aspect
    });
    this._range_manager = new RangeManager(this);
    this._state_manager = new StateManager(this, this._initial_state);
    this.throttled_paint = throttle(() => {
      if (!this.is_destroyed) {
        this.repaint();
      }
    }, 1e3 / 60);
    const { title_location, title: title3 } = this.model;
    if (title_location != null && title3 != null) {
      this._title = title3 instanceof Title ? title3 : new Title({ text: title3 });
    }
    const { toolbar_location, toolbar_inner, toolbar } = this.model;
    if (toolbar_location != null) {
      this._toolbar = new ToolbarPanel({ toolbar });
      toolbar.location = toolbar_location;
      toolbar.inner = toolbar_inner;
    }
    const { hidpi, output_backend } = this.model;
    this._canvas = new Canvas({ hidpi, output_backend });
    this._attribution = new Panel({
      position: new Node2({ target: "frame", symbol: "bottom_right" }),
      anchor: "bottom_right",
      elements: [],
      css_variables: {
        "--max-width": new Node2({ target: "frame", symbol: "width" })
      },
      stylesheets: [attribution_css.default]
    });
    this._notifications = new Panel({
      position: new Node2({ target: this.model, symbol: "top_center" }),
      anchor: "top_center",
      elements: [],
      stylesheets: [`
        :host {
          display: flex;
          flex-direction: column;
          gap: 1em;
          width: max-content;
          max-width: 80%;
        }

        :host:empty {
          display: none;
        }

        :host > div {
          padding: 0.5em;
          border: 1px solid gray;
          border-radius: 0.5em;
          opacity: 0.8;
        }
      `]
    });
  }
  get elements() {
    return [this._canvas, this._frame, this._attribution, this._notifications, ...super.elements];
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.canvas_view = this._element_views.get(this._canvas);
    this.canvas_view.plot_views = [this];
    this.frame_view = this._element_views.get(this._frame);
    await this.build_tool_views();
    await this.build_renderer_views();
    this._range_manager.update_dataranges();
    this._update_touch_action();
  }
  box_sizing() {
    const { width_policy, height_policy, ...sizing } = super.box_sizing();
    const { frame_width, frame_height } = this.model;
    return {
      ...sizing,
      width_policy: frame_width != null && width_policy == "auto" ? "fit" : width_policy,
      height_policy: frame_height != null && height_policy == "auto" ? "fit" : height_policy
    };
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "grid" };
  }
  _update_layout() {
    super._update_layout();
    this._invalidate_all = true;
    this._needs_paint = true;
    const layout = new BorderLayout();
    const { frame_align } = this.model;
    layout.aligns = (() => {
      if (isBoolean(frame_align)) {
        return { left: frame_align, right: frame_align, top: frame_align, bottom: frame_align };
      } else {
        const { left: left2 = true, right: right3 = true, top = true, bottom = true } = frame_align;
        return { left: left2, right: right3, top, bottom };
      }
    })();
    layout.set_sizing({ width_policy: "max", height_policy: "max" });
    if (this.visuals.outline_line.doit) {
      const width = this.visuals.outline_line.line_width.get_value();
      layout.center_border_width = width;
    }
    const outer_above = copy(this.model.above);
    const outer_below = copy(this.model.below);
    const outer_left = copy(this.model.left);
    const outer_right = copy(this.model.right);
    const inner_above = [];
    const inner_below = [];
    const inner_left = [];
    const inner_right = [];
    const get_side = (side, inner3 = false) => {
      switch (side) {
        case "above":
          return inner3 ? inner_above : outer_above;
        case "below":
          return inner3 ? inner_below : outer_below;
        case "left":
          return inner3 ? inner_left : outer_left;
        case "right":
          return inner3 ? inner_right : outer_right;
      }
    };
    const { title_location } = this.model;
    if (title_location != null && this._title != null) {
      get_side(title_location).push(this._title);
    }
    if (this._toolbar != null) {
      const { location } = this._toolbar.toolbar;
      if (!this.model.toolbar_inner) {
        const panels = get_side(location);
        let push_toolbar = true;
        if (this.model.toolbar_sticky) {
          for (let i2 = 0; i2 < panels.length; i2++) {
            const panel = panels[i2];
            if (panel instanceof Title) {
              if (location == "above" || location == "below") {
                panels[i2] = [panel, this._toolbar];
              } else {
                panels[i2] = [this._toolbar, panel];
              }
              push_toolbar = false;
              break;
            }
          }
        }
        if (push_toolbar) {
          panels.push(this._toolbar);
        }
      } else {
        const panels = get_side(location, true);
        panels.push(this._toolbar);
      }
    }
    const set_layout = (side, model2) => {
      var _a34;
      const view = this.views.get_one(model2);
      view.panel = new SidePanel(side);
      (_a34 = view.update_layout) == null ? void 0 : _a34.call(view);
      return view.layout;
    };
    const set_layouts = (side, panels) => {
      const horizontal2 = side == "above" || side == "below";
      const layouts = [];
      for (const panel of panels) {
        if (isArray(panel)) {
          const items = panel.map((subpanel) => {
            const item3 = set_layout(side, subpanel);
            if (item3 == null) {
              return void 0;
            }
            if (subpanel instanceof ToolbarPanel) {
              const dim = horizontal2 ? "width_policy" : "height_policy";
              item3.set_sizing({ ...item3.sizing, [dim]: "min" });
            }
            return item3;
          }).filter((item3) => item3 != null);
          let layout2;
          if (horizontal2) {
            layout2 = new Row(items);
            layout2.set_sizing({ width_policy: "max", height_policy: "min" });
          } else {
            layout2 = new Column(items);
            layout2.set_sizing({ width_policy: "min", height_policy: "max" });
          }
          layout2.absolute = true;
          layouts.push(layout2);
        } else {
          const layout2 = set_layout(side, panel);
          if (layout2 != null) {
            layouts.push(layout2);
          }
        }
      }
      return layouts;
    };
    const min_border = this.model.min_border ?? 0;
    layout.min_border = {
      left: this.model.min_border_left ?? min_border,
      top: this.model.min_border_top ?? min_border,
      right: this.model.min_border_right ?? min_border,
      bottom: this.model.min_border_bottom ?? min_border
    };
    const center_panel = new NodeLayout();
    const top_panel = new VStack();
    const bottom_panel = new VStack();
    const left_panel = new HStack();
    const right_panel = new HStack();
    const inner_top_panel = new VStack();
    const inner_bottom_panel = new VStack();
    const inner_left_panel = new HStack();
    const inner_right_panel = new HStack();
    center_panel.absolute = true;
    top_panel.absolute = true;
    bottom_panel.absolute = true;
    left_panel.absolute = true;
    right_panel.absolute = true;
    inner_top_panel.absolute = true;
    inner_bottom_panel.absolute = true;
    inner_left_panel.absolute = true;
    inner_right_panel.absolute = true;
    center_panel.children = this.model.center.filter((obj) => {
      return obj instanceof Annotation;
    }).map((model2) => {
      var _a34;
      const view = this.views.get_one(model2);
      (_a34 = view.update_layout) == null ? void 0 : _a34.call(view);
      return view.layout;
    }).filter((layout2) => layout2 != null);
    const { frame_width, frame_height } = this.model;
    center_panel.set_sizing({
      ...frame_width != null ? { width_policy: "fixed", width: frame_width } : { width_policy: "fit" },
      ...frame_height != null ? { height_policy: "fixed", height: frame_height } : { height_policy: "fit" }
    });
    center_panel.on_resize((bbox) => this.frame.set_geometry(bbox));
    top_panel.children = reversed(set_layouts("above", outer_above));
    bottom_panel.children = set_layouts("below", outer_below);
    left_panel.children = reversed(set_layouts("left", outer_left));
    right_panel.children = set_layouts("right", outer_right);
    inner_top_panel.children = set_layouts("above", inner_above);
    inner_bottom_panel.children = set_layouts("below", inner_below);
    inner_left_panel.children = set_layouts("left", inner_left);
    inner_right_panel.children = set_layouts("right", inner_right);
    top_panel.set_sizing({
      width_policy: "fit",
      height_policy: "min"
      /*, min_height: layout.min_border.top*/
    });
    bottom_panel.set_sizing({
      width_policy: "fit",
      height_policy: "min"
      /*, min_height: layout.min_width.bottom*/
    });
    left_panel.set_sizing({
      width_policy: "min",
      height_policy: "fit"
      /*, min_width: layout.min_width.left*/
    });
    right_panel.set_sizing({
      width_policy: "min",
      height_policy: "fit"
      /*, min_width: layout.min_width.right*/
    });
    inner_top_panel.set_sizing({ width_policy: "fit", height_policy: "min" });
    inner_bottom_panel.set_sizing({ width_policy: "fit", height_policy: "min" });
    inner_left_panel.set_sizing({ width_policy: "min", height_policy: "fit" });
    inner_right_panel.set_sizing({ width_policy: "min", height_policy: "fit" });
    layout.center_panel = center_panel;
    layout.top_panel = top_panel;
    layout.bottom_panel = bottom_panel;
    layout.left_panel = left_panel;
    layout.right_panel = right_panel;
    if (inner_top_panel.children.length != 0) {
      layout.inner_top_panel = inner_top_panel;
    }
    if (inner_bottom_panel.children.length != 0) {
      layout.inner_bottom_panel = inner_bottom_panel;
    }
    if (inner_left_panel.children.length != 0) {
      layout.inner_left_panel = inner_left_panel;
    }
    if (inner_right_panel.children.length != 0) {
      layout.inner_right_panel = inner_right_panel;
    }
    this.layout = layout;
  }
  _measure_layout() {
    const { frame_width, frame_height } = this.model;
    const frame = {
      width: frame_width == null ? "1fr" : px(frame_width),
      height: frame_height == null ? "1fr" : px(frame_height)
    };
    const { layout } = this;
    const top = layout.top_panel.measure({ width: Infinity, height: Infinity });
    const bottom = layout.bottom_panel.measure({ width: Infinity, height: Infinity });
    const left2 = layout.left_panel.measure({ width: Infinity, height: Infinity });
    const right3 = layout.right_panel.measure({ width: Infinity, height: Infinity });
    const top_height = max15(top.height, layout.min_border.top);
    const bottom_height = max15(bottom.height, layout.min_border.bottom);
    const left_width = max15(left2.width, layout.min_border.left);
    const right_width = max15(right3.width, layout.min_border.right);
    this._computed_style.replace(`
      :host {
        grid-template-rows: ${top_height}px ${frame.height} ${bottom_height}px;
        grid-template-columns: ${left_width}px ${frame.width} ${right_width}px;
      }
    `);
  }
  get axis_views() {
    const views = [];
    for (const [, renderer_view] of this.renderer_views) {
      if (renderer_view instanceof AxisView) {
        views.push(renderer_view);
      }
    }
    return views;
  }
  update_range(range_info, options2) {
    this.pause();
    this._range_manager.update(range_info, options2);
    this.unpause();
  }
  reset_range() {
    this.pause();
    this._range_manager.reset();
    this.unpause();
    this.trigger_ranges_update_event();
  }
  trigger_ranges_update_event(extra_ranges = []) {
    const { x_ranges, y_ranges } = this._range_manager.ranges();
    const ranges = [...x_ranges, ...y_ranges, ...extra_ranges];
    const linked_plots = new Set(ranges.flatMap((r) => [...r.linked_plots]));
    for (const plot_view of linked_plots) {
      const { x_range, y_range } = plot_view.model;
      const event2 = new RangesUpdate(x_range.start, x_range.end, y_range.start, y_range.end);
      plot_view.model.trigger_event(event2);
    }
  }
  get_selection() {
    const selection = /* @__PURE__ */ new Map();
    for (const renderer of this.model.data_renderers) {
      const { selected } = renderer.selection_manager.source;
      selection.set(renderer, selected);
    }
    return selection;
  }
  update_selection(selections) {
    for (const renderer of this.model.data_renderers) {
      const ds = renderer.selection_manager.source;
      if (selections != null) {
        const selection = selections.get(renderer);
        if (selection != null) {
          ds.selected.update(selection, true);
        }
      } else {
        ds.selection_manager.clear();
      }
    }
  }
  reset_selection() {
    this.update_selection(null);
  }
  _invalidate_layout_if_needed() {
    const needs_layout = (() => {
      var _a34;
      for (const panel of this.model.side_panels) {
        const view = this.renderer_views.get(panel);
        if (((_a34 = view.layout) == null ? void 0 : _a34.has_size_changed()) ?? false) {
          this.invalidate_painters(view);
          return true;
        }
      }
      return false;
    })();
    if (needs_layout) {
      this.compute_layout();
    }
  }
  *_compute_renderers() {
    const { above: above3, below: below4, left: left2, right: right3, center, renderers } = this.model;
    yield* renderers;
    yield* above3;
    yield* below4;
    yield* left2;
    yield* right3;
    yield* center;
    if (this._title != null) {
      yield this._title;
    }
    if (this._toolbar != null) {
      yield this._toolbar;
    }
    for (const [, view] of this.tool_views) {
      yield* view.overlays;
    }
  }
  _update_attribution() {
    const attribution = [
      ...this.model.attribution,
      ...this.computed_renderer_views.map((rv) => rv.attribution)
    ].filter((rv) => rv != null);
    const elements = attribution.map((attrib) => isString(attrib) ? new Div({ children: [attrib] }) : attrib);
    this._attribution.elements = elements;
  }
  async _build_renderers() {
    this.computed_renderers = [...this._compute_renderers()];
    const result = await build_views(this.renderer_views, this.computed_renderers, { parent: this });
    this._update_attribution();
    return result;
  }
  async _update_renderers() {
    const { created } = await this._build_renderers();
    const created_renderers = new Set(created);
    for (const renderer_view of this.renderer_views.values()) {
      renderer_view.el.remove();
    }
    for (const renderer_view of this.renderer_views.values()) {
      const is_new = created_renderers.has(renderer_view);
      const target = renderer_view.rendering_target();
      if (is_new) {
        renderer_view.render_to(target);
      } else {
        target.append(renderer_view.el);
      }
    }
    this.r_after_render();
  }
  async build_renderer_views() {
    await this._build_renderers();
  }
  async build_tool_views() {
    const tool_models = flat_map(this.model.toolbar.tools, (item3) => item3 instanceof ToolProxy ? item3.tools : [item3]);
    const { created } = await build_views(this.tool_views, [...tool_models], { parent: this });
    created.map((tool_view) => this.canvas_view.ui_event_bus.register_tool(tool_view));
  }
  connect_signals() {
    super.connect_signals();
    const { x_range, y_range, x_scale, y_scale, extra_x_ranges, extra_y_ranges, extra_x_scales, extra_y_scales, aspect_scale, match_aspect } = this.model.properties;
    this.on_change([
      x_range,
      y_range,
      x_scale,
      y_scale,
      extra_x_ranges,
      extra_y_ranges,
      extra_x_scales,
      extra_y_scales,
      aspect_scale,
      match_aspect
    ], () => {
      const { x_range: x_range2, y_range: y_range2, x_scale: x_scale2, y_scale: y_scale2, extra_x_ranges: extra_x_ranges2, extra_y_ranges: extra_y_ranges2, extra_x_scales: extra_x_scales2, extra_y_scales: extra_y_scales2, aspect_scale: aspect_scale2, match_aspect: match_aspect2 } = this.model;
      this._frame.setv({
        x_range: x_range2,
        y_range: y_range2,
        x_scale: x_scale2,
        y_scale: y_scale2,
        extra_x_ranges: extra_x_ranges2,
        extra_y_ranges: extra_y_ranges2,
        extra_x_scales: extra_x_scales2,
        extra_y_scales: extra_y_scales2,
        aspect_scale: aspect_scale2,
        match_aspect: match_aspect2
      });
    });
    const { above: above3, below: below4, left: left2, right: right3, center, renderers } = this.model.properties;
    const panels = [above3, below4, left2, right3, center];
    this.on_change(renderers, async () => {
      await this._update_renderers();
    });
    this.on_change(panels, async () => {
      await this._update_renderers();
      this.invalidate_layout();
    });
    this.connect(this.model.toolbar.properties.tools.change, async () => {
      await this.build_tool_views();
      await this._update_renderers();
    });
    const { x_ranges, y_ranges } = this.frame;
    for (const [, range2] of x_ranges) {
      this.connect(range2.change, () => {
        this.request_repaint();
      });
    }
    for (const [, range2] of y_ranges) {
      this.connect(range2.change, () => {
        this.request_repaint();
      });
    }
    this.connect(this.model.change, () => this.request_repaint());
    this.connect(this.model.reset, () => this.reset());
    const { toolbar_location } = this.model.properties;
    this.on_change(toolbar_location, async () => {
      const { toolbar_location: toolbar_location2 } = this.model;
      if (this._toolbar != null) {
        if (toolbar_location2 != null) {
          this._toolbar.toolbar.location = toolbar_location2;
        } else {
          this._toolbar = void 0;
          await this._update_renderers();
        }
      } else {
        if (toolbar_location2 != null) {
          const { toolbar, toolbar_inner } = this.model;
          this._toolbar = new ToolbarPanel({ toolbar });
          toolbar.location = toolbar_location2;
          toolbar.inner = toolbar_inner;
          await this._update_renderers();
        }
      }
      this.invalidate_layout();
    });
    const { hold_render } = this.model.properties;
    this.on_change(hold_render, () => {
      if (!this.model.hold_render) {
        this.request_repaint();
      }
    });
    this.model.toolbar.active_changed.connect(() => this._update_touch_action());
  }
  _update_touch_action() {
    const { toolbar } = this.model;
    let has_pan = false;
    let has_scroll = false;
    for (const tool of toolbar.tools) {
      if (tool.active) {
        const { event_types } = tool;
        if (event_types.includes("pan")) {
          has_pan = true;
        }
        if (event_types.includes("scroll")) {
          has_scroll = true;
        }
        if (has_pan && has_scroll) {
          break;
        }
      }
    }
    const touch_action = (() => {
      if (!has_pan && !has_scroll) {
        return "auto";
      } else if (!has_pan) {
        return "pan-x pan-y";
      } else if (!has_scroll) {
        return "pinch-zoom";
      } else {
        return "none";
      }
    })();
    this.canvas.touch_action.replace(`
      .${canvas_css2.events} {
        touch-action: ${touch_action};
      }
    `);
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    if (this.model.visible) {
      for (const [, renderer_view] of this.renderer_views) {
        if (!renderer_view.has_finished()) {
          return false;
        }
      }
    }
    return true;
  }
  _after_layout() {
    var _a34;
    super._after_layout();
    this.unpause(true);
    const left2 = this.layout.left_panel.bbox;
    const right3 = this.layout.right_panel.bbox;
    const center = this.layout.center_panel.bbox;
    const top = this.layout.top_panel.bbox;
    const bottom = this.layout.bottom_panel.bbox;
    const { bbox } = this;
    const top_height = top.bottom;
    const bottom_height = bbox.height - bottom.top;
    const left_width = left2.right;
    const right_width = bbox.width - right3.left;
    this.canvas.style.replace(`
      .bk-layer.bk-events {
        display: grid;
        grid-template-areas:
          ".    above  .    "
          "left center right"
          ".    below  .    ";
        grid-template-rows: ${px(top_height)} ${px(center.height)} ${px(bottom_height)};
        grid-template-columns: ${px(left_width)} ${px(center.width)} ${px(right_width)};
      }
    `);
    for (const [, child_view] of this.renderer_views) {
      if (child_view instanceof AnnotationView) {
        (_a34 = child_view.after_layout) == null ? void 0 : _a34.call(child_view);
      }
    }
    this.model.setv({
      inner_width: Math.round(this.frame.bbox.width),
      inner_height: Math.round(this.frame.bbox.height),
      outer_width: Math.round(this.bbox.width),
      outer_height: Math.round(this.bbox.height)
    }, { no_change: true });
    if (this.model.match_aspect) {
      this.pause();
      this._range_manager.update_dataranges();
      this.unpause(true);
    }
    if (!this._outer_bbox.equals(this.bbox)) {
      this.canvas_view.resize();
      this._outer_bbox = this.bbox;
      this._invalidate_all = true;
      this._needs_paint = true;
    }
    const { inner_bbox } = this.layout;
    if (!this._inner_bbox.equals(inner_bbox)) {
      this._inner_bbox = inner_bbox;
      this._invalidate_all = true;
      this._needs_paint = true;
    }
    if (this._needs_paint) {
      this.paint();
    }
  }
  render() {
    super.render();
    for (const renderer_view of this.computed_renderer_views) {
      const target = renderer_view.rendering_target();
      renderer_view.render_to(target);
    }
  }
  repaint() {
    this._invalidate_layout_if_needed();
    this.paint();
  }
  paint() {
    if (this.is_paused || this.model.hold_render) {
      return;
    }
    if (this.is_displayed) {
      logger.trace(`${this.toString()}.paint()`);
      this._actual_paint();
    } else {
      for (const renderer_view of this.computed_renderer_views) {
        renderer_view.force_finished();
      }
    }
    if (this._needs_notify) {
      this._needs_notify = false;
      this.notify_finished();
    }
  }
  _actual_paint() {
    logger.trace(`${this.toString()}._actual_paint ${this._render_count} start`);
    const { document: document2 } = this.model;
    if (document2 != null) {
      const interactive_duration = document2.interactive_duration();
      if (interactive_duration >= 0 && interactive_duration < this.model.lod_interval) {
        setTimeout(() => {
          if (document2.interactive_duration() > this.model.lod_timeout) {
            document2.interactive_stop();
          }
          this.request_repaint();
        }, this.model.lod_timeout);
      } else {
        document2.interactive_stop();
      }
    }
    if (this._range_manager.invalidate_dataranges) {
      this._range_manager.update_dataranges();
      this._invalidate_layout_if_needed();
    }
    let do_primary = false;
    let do_overlays = false;
    if (this._invalidate_all) {
      do_primary = true;
      do_overlays = true;
    } else {
      for (const painter of this._invalidated_painters) {
        const { level } = painter.model;
        if (level != "overlay") {
          do_primary = true;
        } else {
          do_overlays = true;
        }
        if (do_primary && do_overlays) {
          break;
        }
      }
    }
    this._invalidated_painters.clear();
    this._invalidate_all = false;
    const frame_box = [
      this.frame.bbox.left,
      this.frame.bbox.top,
      this.frame.bbox.width,
      this.frame.bbox.height
    ];
    const { primary, overlays } = this.canvas_view;
    if (do_primary) {
      primary.prepare();
      this.canvas_view.prepare_webgl(frame_box);
      this._paint_empty(primary.ctx, frame_box);
      this._paint_outline(primary.ctx, frame_box);
      this._paint_levels(primary.ctx, "image", frame_box, true);
      this._paint_levels(primary.ctx, "underlay", frame_box, true);
      this._paint_levels(primary.ctx, "glyph", frame_box, true);
      this._paint_levels(primary.ctx, "guide", frame_box, false);
      this._paint_levels(primary.ctx, "annotation", frame_box, false);
      primary.finish();
    }
    if (do_overlays || settings.wireframe) {
      overlays.prepare();
      this._paint_levels(overlays.ctx, "overlay", frame_box, false);
      if (settings.wireframe) {
        this.paint_layout(overlays.ctx, this.layout);
      }
      overlays.finish();
    }
    if (this._initial_state.range == null) {
      this._initial_state.range = this._range_manager.compute_initial() ?? void 0;
    }
    for (const element_view of this.element_views) {
      element_view.reposition();
    }
    this._needs_paint = false;
    this.repainted.emit();
    logger.trace(`${this.toString()}._actual_paint ${this._render_count} end`);
    this._render_count++;
  }
  _paint_levels(ctx, level, clip_region, global_clip) {
    for (const renderer_view of this.computed_renderer_views) {
      if (renderer_view.model.level != level) {
        continue;
      }
      ctx.save();
      if (global_clip || renderer_view.needs_clip) {
        ctx.beginPath();
        ctx.rect(...clip_region);
        ctx.clip();
      }
      renderer_view.paint();
      ctx.restore();
      if (renderer_view.has_webgl) {
        this.canvas_view.blit_webgl(ctx);
      }
    }
  }
  paint_layout(ctx, layout) {
    const { x: x2, y: y2, width, height } = layout.bbox;
    ctx.strokeStyle = "blue";
    ctx.strokeRect(x2, y2, width, height);
    for (const child of layout) {
      ctx.save();
      if (!layout.absolute) {
        ctx.translate(x2, y2);
      }
      this.paint_layout(ctx, child);
      ctx.restore();
    }
  }
  _paint_empty(ctx, frame_box) {
    const [cx, cy, cw, ch] = [0, 0, this.bbox.width, this.bbox.height];
    const [fx, fy, fw, fh] = frame_box;
    if (this.visuals.border_fill.doit) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(cx, cy, cw, ch);
      ctx.rect(fx, fy, fw, fh);
      ctx.clip("evenodd");
      ctx.beginPath();
      ctx.rect(cx, cy, cw, ch);
      this.visuals.border_fill.apply(ctx);
      ctx.restore();
    }
    if (this.visuals.background_fill.doit) {
      this.visuals.background_fill.set_value(ctx);
      ctx.fillRect(fx, fy, fw, fh);
    }
  }
  _paint_outline(ctx, frame_box) {
    if (this.visuals.outline_line.doit) {
      ctx.save();
      this.visuals.outline_line.set_value(ctx);
      let [x0, y0, w, h7] = frame_box;
      if (x0 + w == this.bbox.width) {
        w -= 1;
      }
      if (y0 + h7 == this.bbox.height) {
        h7 -= 1;
      }
      ctx.strokeRect(x0, y0, w, h7);
      ctx.restore();
    }
  }
  export(type = "auto", hidpi = true) {
    const output_backend = (() => {
      switch (type) {
        case "auto":
          return this.canvas_view.model.output_backend;
        case "png":
          return "canvas";
        case "svg":
          return "svg";
      }
    })();
    const composite = new CanvasLayer(output_backend, hidpi);
    const { width, height } = this.bbox;
    composite.resize(width, height);
    if (width != 0 && height != 0) {
      const { canvas: canvas3 } = this.canvas_view.compose();
      composite.ctx.drawImage(canvas3, 0, 0);
    }
    return composite;
  }
  resolve_frame() {
    return this.frame;
  }
  resolve_canvas() {
    return this.canvas;
  }
  resolve_plot() {
    return this;
  }
  resolve_xy(coord) {
    const { x: x2, y: y2 } = coord;
    const sx = this.frame.x_scale.compute(x2);
    const sy = this.frame.y_scale.compute(y2);
    if (this.frame.bbox.contains(sx, sy)) {
      return { x: sx, y: sy };
    } else {
      return { x: NaN, y: NaN };
    }
  }
  resolve_indexed(coord) {
    const { index: i2, renderer } = coord;
    const rv = this.views.find_one(renderer);
    if (rv != null && rv.has_finished()) {
      const [sx, sy] = rv.glyph.scenterxy(i2, NaN, NaN);
      if (this.frame.bbox.contains(sx, sy)) {
        return { x: sx, y: sy };
      }
    }
    return { x: NaN, y: NaN };
  }
  notify_about(message) {
    if (this._messages.has(message)) {
      return;
    }
    const el = new Div({ children: [message] });
    const timer = setTimeout(() => {
      this._messages.delete(message);
      this._notifications.elements = this._notifications.elements.filter((item3) => item3 != el);
    }, 2e3);
    this._messages.set(message, timer);
    this._notifications.elements = [...this._notifications.elements, el];
    logger.info(message);
  }
};
__publicField(PlotView, "__name__", "PlotView");

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/plot.js
var _Plot = class _Plot extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "use_map", false);
    __publicField(this, "reset", new Signal0(this, "reset"));
  }
  add_layout(renderer, side = "center") {
    const renderers = this.properties[side].get_value();
    this.setv({ [side]: [...renderers, renderer] });
  }
  remove_layout(renderer) {
    const del2 = (items) => {
      remove_by(items, (item3) => item3 == renderer);
    };
    del2(this.left);
    del2(this.right);
    del2(this.above);
    del2(this.below);
    del2(this.center);
  }
  get data_renderers() {
    return this.renderers.filter((r) => r instanceof DataRenderer);
  }
  add_renderers(...renderers) {
    this.renderers = [...this.renderers, ...renderers];
  }
  add_glyph(glyph, source2 = new ColumnDataSource(), attrs = {}) {
    const renderer = new GlyphRenderer({ ...attrs, data_source: source2, glyph });
    this.add_renderers(renderer);
    return renderer;
  }
  add_tools(...tools2) {
    const computed_tools = tools2.map((tool) => tool instanceof Tool ? tool : Tool.from_string(tool));
    this.toolbar.tools = [...this.toolbar.tools, ...computed_tools];
  }
  remove_tools(...tools2) {
    this.toolbar.tools = [...difference2(new Set(this.toolbar.tools), new Set(tools2))];
  }
  get panels() {
    return [...this.side_panels, ...this.center];
  }
  get side_panels() {
    const { above: above3, below: below4, left: left2, right: right3 } = this;
    return concat([above3, below4, left2, right3]);
  }
};
__publicField(_Plot, "__name__", "Plot");
_Plot.prototype.default_view = PlotView;
_Plot.mixins([
  ["outline_", Line],
  ["background_", Fill],
  ["border_", Fill]
]);
_Plot.define(({ Bool: Bool2, Float: Float2, Str: Str2, List: List2, Dict: Dict2, Or: Or2, Ref: Ref2, Null: Null2, Nullable: Nullable2, Struct: Struct2, Opt: Opt2 }) => ({
  toolbar: [Ref2(Toolbar), () => new Toolbar()],
  toolbar_location: [Nullable2(Location), "right"],
  toolbar_sticky: [Bool2, true],
  toolbar_inner: [Bool2, false],
  frame_width: [Nullable2(Float2), null],
  frame_height: [Nullable2(Float2), null],
  frame_align: [Or2(Bool2, Struct2({ left: Opt2(Bool2), right: Opt2(Bool2), top: Opt2(Bool2), bottom: Opt2(Bool2) })), true],
  // revise this when https://github.com/microsoft/TypeScript/pull/42425 is merged
  title: [Or2(Ref2(Title), Str2, Null2), "", {
    convert: (title3) => isString(title3) ? new Title({ text: title3 }) : title3
  }],
  title_location: [Nullable2(Location), "above"],
  above: [List2(Or2(Ref2(Annotation), Ref2(Axis))), []],
  below: [List2(Or2(Ref2(Annotation), Ref2(Axis))), []],
  left: [List2(Or2(Ref2(Annotation), Ref2(Axis))), []],
  right: [List2(Or2(Ref2(Annotation), Ref2(Axis))), []],
  center: [List2(Or2(Ref2(Annotation), Ref2(Grid2))), []],
  renderers: [List2(Ref2(Renderer)), []],
  x_range: [Ref2(Range), () => new DataRange1d()],
  y_range: [Ref2(Range), () => new DataRange1d()],
  x_scale: [Ref2(Scale), () => new LinearScale()],
  y_scale: [Ref2(Scale), () => new LinearScale()],
  extra_x_ranges: [Dict2(Ref2(Range)), {}],
  extra_y_ranges: [Dict2(Ref2(Range)), {}],
  extra_x_scales: [Dict2(Ref2(Scale)), {}],
  extra_y_scales: [Dict2(Ref2(Scale)), {}],
  lod_factor: [Float2, 10],
  lod_interval: [Float2, 300],
  lod_threshold: [Nullable2(Float2), 2e3],
  lod_timeout: [Float2, 500],
  hidpi: [Bool2, true],
  output_backend: [OutputBackend, "canvas"],
  min_border: [Nullable2(Float2), 5],
  min_border_top: [Nullable2(Float2), null],
  min_border_left: [Nullable2(Float2), null],
  min_border_bottom: [Nullable2(Float2), null],
  min_border_right: [Nullable2(Float2), null],
  inner_width: [Float2, unset, { readonly: true }],
  inner_height: [Float2, unset, { readonly: true }],
  outer_width: [Float2, unset, { readonly: true }],
  outer_height: [Float2, unset, { readonly: true }],
  match_aspect: [Bool2, false],
  aspect_scale: [Float2, 1],
  reset_policy: [ResetPolicy, "standard"],
  hold_render: [Bool2, false],
  attribution: [List2(Or2(Str2, Ref2(HTML))), []]
}));
_Plot.override({
  width: 600,
  height: 600,
  outline_line_color: "#e5e5e5",
  border_fill_color: "#ffffff",
  background_fill_color: "#ffffff"
});
var Plot = _Plot;

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/gmap_plot_canvas.js
function has_maps_API() {
  return typeof google != "undefined" && typeof google.maps != "undefined";
}
var gmaps_ready = new Signal0({}, "gmaps_ready");
var load_google_api = function(api_key, api_version) {
  window._bokeh_gmaps_callback = () => gmaps_ready.emit();
  const enc = encodeURIComponent;
  const script2 = document.createElement("script");
  script2.type = "text/javascript";
  script2.src = `https://maps.googleapis.com/maps/api/js?v=${enc(api_version)}&key=${enc(api_key)}&callback=_bokeh_gmaps_callback&loading=async`;
  document.body.appendChild(script2);
};
var GMapPlotView = class extends PlotView {
  constructor() {
    super(...arguments);
    __publicField(this, "_tiles_loaded");
    __publicField(this, "zoom_count");
    __publicField(this, "initial_zoom");
    __publicField(this, "initial_lat");
    __publicField(this, "initial_lng");
    __publicField(this, "map_el");
    __publicField(this, "map");
    __publicField(this, "map_types");
    __publicField(this, "_api_key");
  }
  initialize() {
    super.initialize();
    this._tiles_loaded = false;
    this.zoom_count = 0;
    const { zoom, lat, lng } = this.model.map_options;
    this.initial_zoom = zoom;
    this.initial_lat = lat;
    this.initial_lng = lng;
    const decoder = new TextDecoder("utf-8");
    this._api_key = decoder.decode(this.model.api_key);
    if (this._api_key == "") {
      const url2 = "https://developers.google.com/maps/documentation/javascript/get-api-key";
      logger.error(`api_key is required. See ${url2} for more information on how to obtain your own.`);
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.map_el = div({ style: { position: "absolute" } });
    this.canvas_view.underlays_el.append(this.map_el);
    if (!has_maps_API()) {
      if (typeof window._bokeh_gmaps_callback === "undefined") {
        const { api_version } = this.model;
        load_google_api(this._api_key, api_version);
      }
      gmaps_ready.connect(() => {
        this._build_map();
        this.request_repaint();
      });
    } else {
      this._build_map();
    }
  }
  remove() {
    this.map_el.remove();
    super.remove();
  }
  update_range(range_info, options2) {
    if (range_info == null) {
      this.map.setCenter({ lat: this.initial_lat, lng: this.initial_lng });
      this.map.setOptions({ zoom: this.initial_zoom });
      super.reset_range();
    } else if (range_info.sdx != null || range_info.sdy != null) {
      this.map.panBy(range_info.sdx ?? 0, range_info.sdy ?? 0);
      super.update_range(range_info, options2);
    } else if (range_info.factor != null) {
      if (this.zoom_count !== 10) {
        this.zoom_count += 1;
        return;
      }
      this.zoom_count = 0;
      this.pause();
      super.update_range(range_info, options2);
      const zoom_change = range_info.factor < 0 ? -1 : 1;
      const old_map_zoom = this.map.getZoom();
      const bounds = this.map.getBounds();
      if (old_map_zoom != null && bounds != null) {
        const new_map_zoom = old_map_zoom + zoom_change;
        if (new_map_zoom >= 2) {
          this.map.setZoom(new_map_zoom);
          const [proj_xstart, proj_xend] = this._get_projected_bounds(bounds);
          if (proj_xend - proj_xstart < 0) {
            this.map.setZoom(old_map_zoom);
          }
        }
      }
      this.unpause();
    }
    this._set_bokeh_ranges();
  }
  _build_map() {
    const { maps } = google;
    this.map_types = {
      satellite: maps.MapTypeId.SATELLITE,
      terrain: maps.MapTypeId.TERRAIN,
      roadmap: maps.MapTypeId.ROADMAP,
      hybrid: maps.MapTypeId.HYBRID
    };
    const mo = this.model.map_options;
    const map_options = {
      center: new maps.LatLng(mo.lat, mo.lng),
      zoom: mo.zoom,
      disableDefaultUI: true,
      mapTypeId: this.map_types[mo.map_type],
      scaleControl: mo.scale_control,
      tilt: mo.tilt
    };
    if (mo.styles != null) {
      map_options.styles = JSON.parse(mo.styles);
    }
    this.map = new maps.Map(this.map_el, map_options);
    maps.event.addListener(this.map, "idle", () => this._set_bokeh_ranges());
    maps.event.addListener(this.map, "bounds_changed", () => this._set_bokeh_ranges());
    maps.event.addListenerOnce(this.map, "tilesloaded", () => this._render_finished());
    this.connect(this.model.properties.map_options.change, () => this._update_options());
    this.connect(this.model.map_options.properties.styles.change, () => this._update_styling());
    this.connect(this.model.map_options.properties.lat.change, () => this._update_center("lat"));
    this.connect(this.model.map_options.properties.lng.change, () => this._update_center("lng"));
    this.connect(this.model.map_options.properties.zoom.change, () => this._update_zoom());
    this.connect(this.model.map_options.properties.map_type.change, () => this._update_map_type());
    this.connect(this.model.map_options.properties.scale_control.change, () => this._update_scale_control());
    this.connect(this.model.map_options.properties.tilt.change, () => this._update_tilt());
  }
  _render_finished() {
    this._tiles_loaded = true;
    this.notify_finished();
  }
  has_finished() {
    return super.has_finished() && this._tiles_loaded === true;
  }
  _get_latlon_bounds(bounds) {
    const top_right = bounds.getNorthEast();
    const bottom_left = bounds.getSouthWest();
    const xstart = bottom_left.lng();
    const xend = top_right.lng();
    const ystart = bottom_left.lat();
    const yend = top_right.lat();
    return [xstart, xend, ystart, yend];
  }
  _get_projected_bounds(bounds) {
    const [xstart, xend, ystart, yend] = this._get_latlon_bounds(bounds);
    const [proj_xstart, proj_ystart] = wgs84_mercator.compute(xstart, ystart);
    const [proj_xend, proj_yend] = wgs84_mercator.compute(xend, yend);
    return [proj_xstart, proj_xend, proj_ystart, proj_yend];
  }
  _set_bokeh_ranges() {
    const bounds = this.map.getBounds();
    if (bounds != null) {
      const [proj_xstart, proj_xend, proj_ystart, proj_yend] = this._get_projected_bounds(bounds);
      this.frame.x_range.setv({ start: proj_xstart, end: proj_xend });
      this.frame.y_range.setv({ start: proj_ystart, end: proj_yend });
    }
  }
  _update_center(fld) {
    var _a34;
    const center = (_a34 = this.map.getCenter()) == null ? void 0 : _a34.toJSON();
    if (center != null) {
      center[fld] = this.model.map_options[fld];
      this.map.setCenter(center);
      this._set_bokeh_ranges();
    }
  }
  _update_map_type() {
    this.map.setOptions({ mapTypeId: this.map_types[this.model.map_options.map_type] });
  }
  _update_scale_control() {
    this.map.setOptions({ scaleControl: this.model.map_options.scale_control });
  }
  _update_tilt() {
    this.map.setOptions({ tilt: this.model.map_options.tilt });
  }
  _update_options() {
    this._update_styling();
    this._update_center("lat");
    this._update_center("lng");
    this._update_zoom();
    this._update_map_type();
  }
  _update_styling() {
    const { styles: styles3 } = this.model.map_options;
    this.map.setOptions({ styles: styles3 != null ? JSON.parse(styles3) : null });
  }
  _update_zoom() {
    this.map.setOptions({ zoom: this.model.map_options.zoom });
    this._set_bokeh_ranges();
  }
  _after_layout() {
    super._after_layout();
    const { left: left2, top, width, height } = this.frame.bbox;
    this.map_el.style.top = `${top}px`;
    this.map_el.style.left = `${left2}px`;
    this.map_el.style.width = `${width}px`;
    this.map_el.style.height = `${height}px`;
  }
};
__publicField(GMapPlotView, "__name__", "GMapPlotView");

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/gmap_plot.js
var _MapOptions = class _MapOptions extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MapOptions, "__name__", "MapOptions");
_MapOptions.define(({ Int: Int2, Float: Float2 }) => ({
  lat: [Float2],
  lng: [Float2],
  zoom: [Int2, 12]
}));
var MapOptions = _MapOptions;
var _GMapOptions = class _GMapOptions extends MapOptions {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GMapOptions, "__name__", "GMapOptions");
_GMapOptions.define(({ Bool: Bool2, Int: Int2, Str: Str2, Nullable: Nullable2 }) => ({
  map_type: [MapType, "roadmap"],
  scale_control: [Bool2, false],
  styles: [Nullable2(Str2), null],
  tilt: [Int2, 45]
}));
var GMapOptions = _GMapOptions;
var _GMapPlot = class _GMapPlot extends Plot {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "use_map", true);
  }
};
__publicField(_GMapPlot, "__name__", "GMapPlot");
_GMapPlot.prototype.default_view = GMapPlotView;
_GMapPlot.define(({ Str: Str2, Bytes: Bytes2, Ref: Ref2 }) => ({
  map_options: [Ref2(GMapOptions)],
  api_key: [Bytes2],
  api_version: [Str2, "weekly"]
}));
_GMapPlot.override({
  x_range: () => new Range1d(),
  y_range: () => new Range1d(),
  background_fill_alpha: 0
});
var GMapPlot = _GMapPlot;

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/gmap.js
var GMapView = class extends GMapPlotView {
};
__publicField(GMapView, "__name__", "GMapView");
var _GMap = class _GMap extends GMapPlot {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GMap, "__name__", "GMap");
_GMap.prototype.default_view = GMapView;
var GMap = _GMap;

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/grid_plot.js
var GridPlotView = class extends LayoutDOMView {
  constructor() {
    super(...arguments);
    __publicField(this, "_grid_box");
    __publicField(this, "_tool_views", /* @__PURE__ */ new Map());
  }
  get toolbar_view() {
    return this.child_views.find((v) => v.model == this.model.toolbar);
  }
  get grid_box_view() {
    return this.child_views.find((v) => v.model == this._grid_box);
  }
  _update_location() {
    const location = this.model.toolbar_location;
    if (location == null) {
      this.model.toolbar.visible = false;
    } else {
      this.model.toolbar.setv({ visible: true, location });
    }
  }
  initialize() {
    super.initialize();
    this._update_location();
    const { children, rows, cols, spacing } = this.model;
    this._grid_box = new GridBox({ children, rows, cols, spacing, sizing_mode: "inherit" });
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this.build_tool_views();
  }
  connect_signals() {
    super.connect_signals();
    const { toolbar, toolbar_location, children, rows, cols, spacing } = this.model.properties;
    this.on_change(toolbar_location, async () => {
      this._update_location();
      this.invalidate_layout();
    });
    this.on_change(toolbar, async () => {
      await this.update_children();
    });
    this.on_change([children, rows, cols, spacing], async () => {
      const { children: children2, rows: rows2, cols: cols2, spacing: spacing2 } = this.model;
      this._grid_box.setv({ children: children2, rows: rows2, cols: cols2, spacing: spacing2 });
      await this.grid_box_view.ready;
    });
    this.on_change(this.model.toolbar.properties.tools, async () => {
      await this.build_tool_views();
    });
    this.mouseenter.connect(() => {
      this.toolbar_view.set_visibility(true);
    });
    this.mouseleave.connect(() => {
      this.toolbar_view.set_visibility(false);
    });
  }
  remove() {
    remove_views(this._tool_views);
    super.remove();
  }
  async build_tool_views() {
    const tools2 = this.model.toolbar.tools.filter((tool) => tool instanceof ActionTool);
    await build_views(this._tool_views, tools2, { parent: this });
  }
  *children() {
    yield* super.children();
    yield* this._tool_views.values();
  }
  get child_models() {
    return [this.model.toolbar, this._grid_box];
  }
  _intrinsic_display() {
    return { inner: this.model.flow_mode, outer: "flex" };
  }
  _update_layout() {
    super._update_layout();
    const { location } = this.model.toolbar;
    const flex_direction = (() => {
      switch (location) {
        case "above":
          return "column";
        case "below":
          return "column-reverse";
        case "left":
          return "row";
        case "right":
          return "row-reverse";
      }
    })();
    this.style.append(":host", { flex_direction });
  }
};
__publicField(GridPlotView, "__name__", "GridPlotView");
var _GridPlot = class _GridPlot extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_GridPlot, "__name__", "GridPlot");
_GridPlot.prototype.default_view = GridPlotView;
_GridPlot.define(({ List: List2, Ref: Ref2, Nullable: Nullable2 }) => ({
  toolbar: [Ref2(Toolbar), () => new Toolbar()],
  toolbar_location: [Nullable2(Location), "above"],
  children: [List2(GridChild(LayoutDOM)), []],
  rows: [Nullable2(TracksSizing), null],
  cols: [Nullable2(TracksSizing), null],
  spacing: [GridSpacing, 0]
}));
var GridPlot = _GridPlot;

// node_modules/@bokeh/bokehjs/build/js/lib/models/plots/figure.js
var FigureView = class extends PlotView {
};
__publicField(FigureView, "__name__", "FigureView");
var _Figure = class _Figure extends Plot {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Figure, "__name__", "Figure");
_Figure.prototype.default_view = FigureView;
var Figure = _Figure;

// node_modules/@bokeh/bokehjs/build/js/lib/models/random/park_miller_lcg.js
var _ParkMillerLCG = class _ParkMillerLCG extends RandomGenerator {
  constructor(attrs) {
    super(attrs);
  }
  generator() {
    return new LCGRandom(this.seed ?? Date.now());
  }
};
__publicField(_ParkMillerLCG, "__name__", "ParkMillerLCG");
_ParkMillerLCG.define(({ Int: Int2, Nullable: Nullable2 }) => ({
  seed: [Nullable2(Int2), null]
}));
var ParkMillerLCG = _ParkMillerLCG;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/contour_renderer.js
var ContourRendererView = class extends DataRendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "fill_view");
    __publicField(this, "line_view");
  }
  *children() {
    yield* super.children();
    yield this.fill_view;
    yield this.line_view;
  }
  get glyph_view() {
    if (this.fill_view.glyph.data_size > 0) {
      return this.fill_view.glyph;
    } else {
      return this.line_view.glyph;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { parent } = this;
    const { fill_renderer, line_renderer } = this.model;
    this.fill_view = await build_view(fill_renderer, { parent });
    this.line_view = await build_view(line_renderer, { parent });
  }
  remove() {
    this.fill_view.remove();
    this.line_view.remove();
    super.remove();
  }
  _paint() {
    this.fill_view.paint();
    this.line_view.paint();
  }
  hit_test(geometry) {
    return this.fill_view.hit_test(geometry);
  }
};
__publicField(ContourRendererView, "__name__", "ContourRendererView");
var _ContourRenderer = class _ContourRenderer extends DataRenderer {
  constructor(attrs) {
    super(attrs);
  }
  get_selection_manager() {
    return this.fill_renderer.data_source.selection_manager;
  }
};
__publicField(_ContourRenderer, "__name__", "ContourRenderer");
_ContourRenderer.prototype.default_view = ContourRendererView;
_ContourRenderer.define(({ List: List2, Float: Float2, Ref: Ref2 }) => ({
  fill_renderer: [Ref2(GlyphRenderer)],
  line_renderer: [Ref2(GlyphRenderer)],
  levels: [List2(Float2), []]
}));
var ContourRenderer = _ContourRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/renderers/graph_renderer.js
var GraphRendererView = class extends DataRendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "edge_view");
    __publicField(this, "node_view");
  }
  get glyph_view() {
    return this.node_view.glyph;
  }
  *children() {
    yield* super.children();
    yield this.edge_view;
    yield this.node_view;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.apply_coordinates();
    const { parent } = this;
    const { edge_renderer, node_renderer } = this.model;
    this.edge_view = await build_view(edge_renderer, { parent });
    this.node_view = await build_view(node_renderer, { parent });
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.layout_provider.change, async () => {
      this.apply_coordinates();
      await this.edge_view.set_data();
      await this.node_view.set_data();
      this.request_paint();
    });
  }
  apply_coordinates() {
    const { edge_renderer, node_renderer } = this.model;
    const edge_coords = this.model.layout_provider.edge_coordinates;
    const node_coords = this.model.layout_provider.node_coordinates;
    const xs = { expr: edge_coords.x };
    const ys = { expr: edge_coords.y };
    const x2 = { expr: node_coords.x };
    const y2 = { expr: node_coords.y };
    const edge_glyphs = [
      edge_renderer.glyph,
      edge_renderer.hover_glyph,
      edge_renderer.muted_glyph,
      edge_renderer.selection_glyph,
      edge_renderer.nonselection_glyph
    ];
    const node_glyphs = [
      node_renderer.glyph,
      node_renderer.hover_glyph,
      node_renderer.muted_glyph,
      node_renderer.selection_glyph,
      node_renderer.nonselection_glyph
    ];
    for (const glyph of edge_glyphs) {
      if (glyph == null || glyph == "auto") {
        continue;
      }
      if (!(glyph instanceof MultiLine || glyph instanceof Patches)) {
        logger.warn(`${this}.edge_renderer only supports MultiLine and Patches glyphs`);
        continue;
      }
      glyph.properties.xs.internal = true;
      glyph.properties.ys.internal = true;
      glyph.xs = xs;
      glyph.ys = ys;
    }
    for (const glyph of node_glyphs) {
      if (glyph == null || glyph == "auto") {
        continue;
      }
      if (!(glyph instanceof XYGlyph)) {
        logger.warn(`${this}.node_renderer only supports XY glyphs`);
        continue;
      }
      glyph.properties.x.internal = true;
      glyph.properties.y.internal = true;
      glyph.x = x2;
      glyph.y = y2;
    }
  }
  remove() {
    this.edge_view.remove();
    this.node_view.remove();
    super.remove();
  }
  _paint() {
    this.edge_view.paint();
    this.node_view.paint();
  }
  get has_webgl() {
    return this.edge_view.has_webgl || this.node_view.has_webgl;
  }
  hit_test(geometry) {
    return this.model.inspection_policy.hit_test(geometry, this);
  }
};
__publicField(GraphRendererView, "__name__", "GraphRendererView");
var _GraphRenderer = class _GraphRenderer extends DataRenderer {
  constructor(attrs) {
    super(attrs);
  }
  get_selection_manager() {
    return this.node_renderer.data_source.selection_manager;
  }
};
__publicField(_GraphRenderer, "__name__", "GraphRenderer");
_GraphRenderer.prototype.default_view = GraphRendererView;
_GraphRenderer.define(({ Ref: Ref2 }) => ({
  layout_provider: [Ref2(LayoutProvider)],
  node_renderer: [Ref2(GlyphRenderer)],
  edge_renderer: [Ref2(GlyphRenderer)],
  selection_policy: [Ref2(GraphHitTestPolicy), () => new NodesOnly()],
  inspection_policy: [Ref2(GraphHitTestPolicy), () => new NodesOnly()]
}));
var GraphRenderer = _GraphRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/selectors/by_id.js
var ByID = class extends Selector {
  constructor(attrs) {
    super(attrs);
  }
  find_one(target) {
    return target.querySelector(`#${this.query}`);
  }
};
__publicField(ByID, "__name__", "ByID");

// node_modules/@bokeh/bokehjs/build/js/lib/models/selectors/by_class.js
var ByClass = class extends Selector {
  constructor(attrs) {
    super(attrs);
  }
  find_one(target) {
    return target.querySelector(`.${this.query}`);
  }
};
__publicField(ByClass, "__name__", "ByClass");

// node_modules/@bokeh/bokehjs/build/js/lib/models/selectors/by_css.js
var ByCSS = class extends Selector {
  constructor(attrs) {
    super(attrs);
  }
  find_one(target) {
    return target.querySelector(this.query);
  }
};
__publicField(ByCSS, "__name__", "ByCSS");

// node_modules/@bokeh/bokehjs/build/js/lib/models/selectors/by_xpath.js
var ByXPath = class extends Selector {
  constructor(attrs) {
    super(attrs);
  }
  find_one(target) {
    return document.evaluate(this.query, target).iterateNext();
  }
};
__publicField(ByXPath, "__name__", "ByXPath");

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/web_data_source.js
var _WebDataSource = class _WebDataSource extends ColumnDataSource {
  constructor(attrs) {
    super(attrs);
  }
  get_column(name) {
    const data3 = dict(this.data);
    return data3.get(name) ?? [];
  }
  get_length() {
    return super.get_length() ?? 0;
  }
  initialize() {
    super.initialize();
    this.setup();
  }
  async load_data(raw_data, mode, max_size) {
    const { adapter } = this;
    let data3;
    if (adapter != null) {
      data3 = await execute(adapter, this, { response: raw_data });
    } else {
      data3 = raw_data;
    }
    switch (mode) {
      case "replace": {
        break;
      }
      case "append": {
        const old_data = dict(this.data);
        const new_data = dict(data3);
        for (const column of this.columns()) {
          const old_col = Array.from(old_data.get(column) ?? []);
          const new_col = Array.from(new_data.get(column) ?? []);
          const array2 = old_col.concat(new_col);
          new_data.set(column, max_size != null ? array2.slice(-max_size) : array2);
        }
        break;
      }
    }
    this.data = data3;
  }
};
__publicField(_WebDataSource, "__name__", "WebDataSource");
_WebDataSource.define(({ Any: Any2, Int: Int2, Str: Str2, Nullable: Nullable2 }) => ({
  max_size: [Nullable2(Int2), null],
  mode: [UpdateMode, "replace"],
  adapter: [Nullable2(
    Any2
    /*TODO*/
  ), null],
  data_url: [Str2]
}));
var WebDataSource = _WebDataSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/server_sent_data_source.js
var ServerSentDataSource = class extends WebDataSource {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "initialized", false);
  }
  setup() {
    if (!this.initialized) {
      this.initialized = true;
      const source2 = new EventSource(this.data_url);
      source2.onmessage = async (event2) => {
        await this.load_data(JSON.parse(event2.data), this.mode, this.max_size ?? void 0);
      };
    }
  }
};
__publicField(ServerSentDataSource, "__name__", "ServerSentDataSource");

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/ajax_data_source.js
var _AjaxDataSource = class _AjaxDataSource extends WebDataSource {
  constructor(attrs) {
    super(attrs);
    // TODO don't use initializers until https://github.com/bokeh/bokeh/issues/13732 is fixed
    __publicField(this, "interval");
    __publicField(this, "initialized");
    __publicField(this, "last_fetch_time");
  }
  destroy() {
    if (this.interval != null) {
      clearInterval(this.interval);
    }
    super.destroy();
  }
  setup() {
    if (this.initialized !== true) {
      this.initialized = true;
      this.get_data(this.mode);
      if (this.polling_interval != null) {
        const callback = () => this.get_data(this.mode, this.max_size, this.if_modified);
        this.interval = setInterval(callback, this.polling_interval);
      }
    }
  }
  get_data(mode, max_size = null, if_modified = false) {
    const xhr = this.prepare_request();
    xhr.addEventListener("load", () => this.do_load(xhr, mode, max_size ?? void 0));
    xhr.addEventListener("error", () => this.do_error(xhr));
    if (if_modified && this.last_fetch_time != null) {
      xhr.setRequestHeader("If-Modified-Since", this.last_fetch_time.toUTCString());
    }
    xhr.send();
  }
  prepare_request() {
    const xhr = new XMLHttpRequest();
    xhr.open(this.method, this.data_url, true);
    xhr.withCredentials = false;
    xhr.setRequestHeader("Content-Type", this.content_type);
    for (const [name, value2] of entries(this.http_headers)) {
      xhr.setRequestHeader(name, value2);
    }
    return xhr;
  }
  async do_load(xhr, mode, max_size) {
    if (xhr.status == 200) {
      const raw_data = JSON.parse(xhr.responseText);
      this.last_fetch_time = /* @__PURE__ */ new Date();
      await this.load_data(raw_data, mode, max_size);
    }
  }
  do_error(xhr) {
    logger.error(`Failed to fetch JSON from ${this.data_url} with code ${xhr.status}`);
  }
};
__publicField(_AjaxDataSource, "__name__", "AjaxDataSource");
_AjaxDataSource.define(({ Bool: Bool2, Int: Int2, Str: Str2, Dict: Dict2, Nullable: Nullable2 }) => ({
  polling_interval: [Nullable2(Int2), null],
  content_type: [Str2, "application/json"],
  http_headers: [Dict2(Str2), {}],
  method: [HTTPMethod, "POST"],
  if_modified: [Bool2, false]
}));
var AjaxDataSource = _AjaxDataSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/sources/geojson_data_source.js
function orNaN(v) {
  return v != null ? v : NaN;
}
var _GeoJSONDataSource = class _GeoJSONDataSource extends ColumnarDataSource {
  constructor(attrs) {
    super(attrs);
  }
  initialize() {
    super.initialize();
    this._update_data();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.properties.geojson.change, () => this._update_data());
  }
  _update_data() {
    this.data = this.geojson_to_column_data();
  }
  _get_new_list_array(length) {
    return range(0, length).map((_i) => []);
  }
  _get_new_nan_array(length) {
    return range(0, length).map((_i) => NaN);
  }
  _add_properties(item3, data3, i2, item_count) {
    const properties = item3.properties ?? {};
    const data_proxy = dict(data3);
    for (const [property, value2] of dict(properties)) {
      if (!data_proxy.has(property)) {
        data3[property] = this._get_new_nan_array(item_count);
      }
      data3[property][i2] = orNaN(value2);
    }
  }
  _add_geometry(geometry, data3, i2) {
    function flatten(acc, item3) {
      return acc.concat([[NaN, NaN, NaN]]).concat(item3);
    }
    switch (geometry.type) {
      case "Point": {
        const [x2, y2, z] = geometry.coordinates;
        data3.x[i2] = x2;
        data3.y[i2] = y2;
        data3.z[i2] = orNaN(z);
        break;
      }
      case "LineString": {
        const { coordinates } = geometry;
        for (let j = 0; j < coordinates.length; j++) {
          const [x2, y2, z] = coordinates[j];
          data3.xs[i2][j] = x2;
          data3.ys[i2][j] = y2;
          data3.zs[i2][j] = orNaN(z);
        }
        break;
      }
      case "Polygon": {
        if (geometry.coordinates.length > 1) {
          logger.warn("Bokeh does not support Polygons with holes in, only exterior ring used.");
        }
        const exterior_ring = geometry.coordinates[0];
        for (let j = 0; j < exterior_ring.length; j++) {
          const [x2, y2, z] = exterior_ring[j];
          data3.xs[i2][j] = x2;
          data3.ys[i2][j] = y2;
          data3.zs[i2][j] = orNaN(z);
        }
        break;
      }
      case "MultiPoint": {
        logger.warn("MultiPoint not supported in Bokeh");
        break;
      }
      case "MultiLineString": {
        const coordinates = geometry.coordinates.reduce(flatten);
        for (let j = 0; j < coordinates.length; j++) {
          const [x2, y2, z] = coordinates[j];
          data3.xs[i2][j] = x2;
          data3.ys[i2][j] = y2;
          data3.zs[i2][j] = orNaN(z);
        }
        break;
      }
      case "MultiPolygon": {
        const exterior_rings = [];
        for (const polygon of geometry.coordinates) {
          if (polygon.length > 1) {
            logger.warn("Bokeh does not support Polygons with holes in, only exterior ring used.");
          }
          exterior_rings.push(polygon[0]);
        }
        const coordinates = exterior_rings.reduce(flatten);
        for (let j = 0; j < coordinates.length; j++) {
          const [x2, y2, z] = coordinates[j];
          data3.xs[i2][j] = x2;
          data3.ys[i2][j] = y2;
          data3.zs[i2][j] = orNaN(z);
        }
        break;
      }
      default:
        throw new Error(`Invalid GeoJSON geometry type: ${geometry.type}`);
    }
  }
  geojson_to_column_data() {
    const geojson = JSON.parse(this.geojson);
    let items;
    switch (geojson.type) {
      case "GeometryCollection": {
        if (is_undefined(geojson.geometries)) {
          throw new Error("No geometries found in GeometryCollection");
        }
        if (geojson.geometries.length === 0) {
          throw new Error("geojson.geometries must have one or more items");
        }
        items = geojson.geometries;
        break;
      }
      case "FeatureCollection": {
        if (is_undefined(geojson.features)) {
          throw new Error("No features found in FeaturesCollection");
        }
        if (geojson.features.length == 0) {
          throw new Error("geojson.features must have one or more items");
        }
        items = geojson.features;
        break;
      }
      default:
        throw new Error("Bokeh only supports type GeometryCollection and FeatureCollection at top level");
    }
    let item_count = 0;
    for (const item3 of items) {
      const geometry = item3.type === "Feature" ? item3.geometry : item3;
      if (geometry.type == "GeometryCollection") {
        item_count += geometry.geometries.length;
      } else {
        item_count += 1;
      }
    }
    const data3 = {
      x: this._get_new_nan_array(item_count),
      y: this._get_new_nan_array(item_count),
      z: this._get_new_nan_array(item_count),
      xs: this._get_new_list_array(item_count),
      ys: this._get_new_list_array(item_count),
      zs: this._get_new_list_array(item_count)
    };
    let arr_index = 0;
    for (const item3 of items) {
      const geometry = item3.type == "Feature" ? item3.geometry : item3;
      if (geometry.type == "GeometryCollection") {
        for (const g of geometry.geometries) {
          this._add_geometry(g, data3, arr_index);
          if (item3.type === "Feature") {
            this._add_properties(item3, data3, arr_index, item_count);
          }
          arr_index += 1;
        }
      } else {
        this._add_geometry(geometry, data3, arr_index);
        if (item3.type === "Feature") {
          this._add_properties(item3, data3, arr_index, item_count);
        }
        arr_index += 1;
      }
    }
    return data3;
  }
};
__publicField(_GeoJSONDataSource, "__name__", "GeoJSONDataSource");
_GeoJSONDataSource.define(({ Str: Str2 }) => ({
  geojson: [Str2]
}));
_GeoJSONDataSource.internal(({ Unknown: Unknown2, Dict: Dict2, Arrayable: Arrayable2 }) => ({
  data: [Dict2(Arrayable2(Unknown2)), {}]
}));
var GeoJSONDataSource = _GeoJSONDataSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/tile_source.js
var _TileSource = class _TileSource extends Model {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tiles");
  }
  initialize() {
    super.initialize();
    this.tiles = /* @__PURE__ */ new Map();
    this._normalize_case();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.change, () => this._clear_cache());
  }
  string_lookup_replace(str, lookup) {
    let result_str = str;
    for (const [key, value2] of entries(lookup)) {
      result_str = result_str.replace(`{${key}}`, value2);
    }
    return result_str;
  }
  _normalize_case() {
    const url2 = this.url.replace("{x}", "{X}").replace("{y}", "{Y}").replace("{z}", "{Z}").replace("{q}", "{Q}").replace("{xmin}", "{XMIN}").replace("{ymin}", "{YMIN}").replace("{xmax}", "{XMAX}").replace("{ymax}", "{YMAX}");
    this.url = url2;
  }
  _clear_cache() {
    this.tiles = /* @__PURE__ */ new Map();
  }
  tile_xyz_to_key(x2, y2, z) {
    return `${x2}:${y2}:${z}`;
  }
  key_to_tile_xyz(key) {
    const [x2, y2, z] = key.split(":").map((c) => parseInt(c));
    return [x2, y2, z];
  }
  sort_tiles_from_center(tiles, tile_extent) {
    const [txmin, tymin, txmax, tymax] = tile_extent;
    const center_x = (txmax - txmin) / 2 + txmin;
    const center_y = (tymax - tymin) / 2 + tymin;
    tiles.sort(function(a2, b2) {
      const a_distance = Math.sqrt((center_x - a2[0]) ** 2 + (center_y - a2[1]) ** 2);
      const b_distance = Math.sqrt((center_x - b2[0]) ** 2 + (center_y - b2[1]) ** 2);
      return a_distance - b_distance;
    });
  }
  get_image_url(x2, y2, z) {
    const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
    return image_url.replace("{X}", x2.toString()).replace("{Y}", y2.toString()).replace("{Z}", z.toString());
  }
};
__publicField(_TileSource, "__name__", "TileSource");
_TileSource.define(({
  Float: Float2,
  Str: Str2,
  Dict: Dict2,
  Nullable: Nullable2
  /*, Null, Or, Ref*/
}) => ({
  url: [Str2, ""],
  tile_size: [Float2, 256],
  max_zoom: [Float2, 30],
  min_zoom: [Float2, 0],
  extra_url_vars: [Dict2(Str2), {}],
  attribution: [Str2, ""],
  // Or(Str, Ref(DOMElement), Null), null ],
  x_origin_offset: [Float2],
  y_origin_offset: [Float2],
  initial_resolution: [Nullable2(Float2), null]
}));
var TileSource = _TileSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/tile_utils.js
function meters_to_geographic(mx, my) {
  return wgs84_mercator.invert(mx, my);
}
function meters_extent_to_geographic(extent) {
  const [m_xmin, m_ymin, m_xmax, m_ymax] = extent;
  const [g_xmin, g_ymin] = meters_to_geographic(m_xmin, m_ymin);
  const [g_xmax, g_ymax] = meters_to_geographic(m_xmax, m_ymax);
  return [g_xmin, g_ymin, g_xmax, g_ymax];
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/mercator_tile_source.js
var _MercatorTileSource = class _MercatorTileSource extends TileSource {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_resolutions");
  }
  initialize() {
    super.initialize();
    this._resolutions = range(this.min_zoom, this.max_zoom + 1).map((z) => this.get_resolution(z));
  }
  _computed_initial_resolution() {
    if (this.initial_resolution != null) {
      return this.initial_resolution;
    } else {
      return 2 * Math.PI * 6378137 / this.tile_size;
    }
  }
  is_valid_tile(x2, y2, z) {
    if (!this.wrap_around) {
      if (x2 < 0 || x2 >= 2 ** z) {
        return false;
      }
    }
    if (y2 < 0 || y2 >= 2 ** z) {
      return false;
    }
    return true;
  }
  parent_by_tile_xyz(x2, y2, z) {
    const quadkey = this.tile_xyz_to_quadkey(x2, y2, z);
    const parent_quadkey = quadkey.substring(0, quadkey.length - 1);
    return this.quadkey_to_tile_xyz(parent_quadkey);
  }
  get_resolution(level) {
    return this._computed_initial_resolution() / 2 ** level;
  }
  get_resolution_by_extent(extent, height, width) {
    const x_rs = (extent[2] - extent[0]) / width;
    const y_rs = (extent[3] - extent[1]) / height;
    return [x_rs, y_rs];
  }
  get_level_by_extent(extent, height, width) {
    const x_rs = (extent[2] - extent[0]) / width;
    const y_rs = (extent[3] - extent[1]) / height;
    const resolution = Math.max(x_rs, y_rs);
    let i2 = 0;
    for (const r of this._resolutions) {
      if (resolution > r) {
        if (i2 == 0) {
          return 0;
        }
        if (i2 > 0) {
          return i2 - 1;
        }
      }
      i2 += 1;
    }
    return i2 - 1;
  }
  get_closest_level_by_extent(extent, height, width) {
    const x_rs = (extent[2] - extent[0]) / width;
    const y_rs = (extent[3] - extent[1]) / height;
    const resolution = Math.max(x_rs, y_rs);
    const closest2 = this._resolutions.reduce(function(previous, current) {
      if (Math.abs(current - resolution) < Math.abs(previous - resolution)) {
        return current;
      } else {
        return previous;
      }
    });
    return this._resolutions.indexOf(closest2);
  }
  snap_to_zoom_level(extent, height, width, level) {
    const [xmin, ymin, xmax, ymax] = extent;
    const desired_res = this._resolutions[level];
    let desired_x_delta = width * desired_res;
    let desired_y_delta = height * desired_res;
    if (!this.snap_to_zoom) {
      const xscale = (xmax - xmin) / desired_x_delta;
      const yscale = (ymax - ymin) / desired_y_delta;
      if (xscale > yscale) {
        desired_x_delta = xmax - xmin;
        desired_y_delta = desired_y_delta * xscale;
      } else {
        desired_x_delta = desired_x_delta * yscale;
        desired_y_delta = ymax - ymin;
      }
    }
    const x_adjust = (desired_x_delta - (xmax - xmin)) / 2;
    const y_adjust = (desired_y_delta - (ymax - ymin)) / 2;
    return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];
  }
  tms_to_wmts(x2, y2, z) {
    return [x2, 2 ** z - 1 - y2, z];
  }
  wmts_to_tms(x2, y2, z) {
    return [x2, 2 ** z - 1 - y2, z];
  }
  pixels_to_meters(px2, py, level) {
    const res = this.get_resolution(level);
    const mx = px2 * res - this.x_origin_offset;
    const my = py * res - this.y_origin_offset;
    return [mx, my];
  }
  meters_to_pixels(mx, my, level) {
    const res = this.get_resolution(level);
    const px2 = (mx + this.x_origin_offset) / res;
    const py = (my + this.y_origin_offset) / res;
    return [px2, py];
  }
  pixels_to_tile(px2, py) {
    let tx = Math.ceil(px2 / this.tile_size);
    tx = tx === 0 ? tx : tx - 1;
    const ty = Math.max(Math.ceil(py / this.tile_size) - 1, 0);
    return [tx, ty];
  }
  pixels_to_raster(px2, py, level) {
    const mapSize = this.tile_size << level;
    return [px2, mapSize - py];
  }
  meters_to_tile(mx, my, level) {
    const [px2, py] = this.meters_to_pixels(mx, my, level);
    return this.pixels_to_tile(px2, py);
  }
  get_tile_meter_bounds(tx, ty, level) {
    const [xmin, ymin] = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level);
    const [xmax, ymax] = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level);
    return [xmin, ymin, xmax, ymax];
  }
  get_tile_geographic_bounds(tx, ty, level) {
    const bounds = this.get_tile_meter_bounds(tx, ty, level);
    const [minLon, minLat, maxLon, maxLat] = meters_extent_to_geographic(bounds);
    return [minLon, minLat, maxLon, maxLat];
  }
  get_tiles_by_extent(extent, level, tile_border = 1) {
    const [xmin, ymin, xmax, ymax] = extent;
    let [txmin, tymin] = this.meters_to_tile(xmin, ymin, level);
    let [txmax, tymax] = this.meters_to_tile(xmax, ymax, level);
    txmin -= tile_border;
    tymin -= tile_border;
    txmax += tile_border;
    tymax += tile_border;
    const tiles = [];
    for (let ty = tymax; ty >= tymin; ty--) {
      for (let tx = txmin; tx <= txmax; tx++) {
        if (this.is_valid_tile(tx, ty, level)) {
          tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);
        }
      }
    }
    this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);
    return tiles;
  }
  quadkey_to_tile_xyz(quadKey) {
    let tileX = 0;
    let tileY = 0;
    const tileZ = quadKey.length;
    for (let i2 = tileZ; i2 > 0; i2--) {
      const value2 = quadKey.charAt(tileZ - i2);
      const mask = 1 << i2 - 1;
      switch (value2) {
        case "0":
          continue;
        case "1":
          tileX |= mask;
          break;
        case "2":
          tileY |= mask;
          break;
        case "3":
          tileX |= mask;
          tileY |= mask;
          break;
        default:
          throw new TypeError(`Invalid Quadkey: ${quadKey}`);
      }
    }
    return [tileX, tileY, tileZ];
  }
  tile_xyz_to_quadkey(x2, y2, z) {
    let quadkey = "";
    for (let i2 = z; i2 > 0; i2--) {
      const mask = 1 << i2 - 1;
      let digit = 0;
      if ((x2 & mask) !== 0) {
        digit += 1;
      }
      if ((y2 & mask) !== 0) {
        digit += 2;
      }
      quadkey += digit.toString();
    }
    return quadkey;
  }
  children_by_tile_xyz(x2, y2, z) {
    const quadkey = this.tile_xyz_to_quadkey(x2, y2, z);
    const child_tile_xyz = [];
    for (let i2 = 0; i2 <= 3; i2++) {
      const [x3, y3, z2] = this.quadkey_to_tile_xyz(quadkey + i2.toString());
      const b2 = this.get_tile_meter_bounds(x3, y3, z2);
      child_tile_xyz.push([x3, y3, z2, b2]);
    }
    return child_tile_xyz;
  }
  get_closest_parent_by_tile_xyz(x2, y2, z) {
    const world_x = this.calculate_world_x_by_tile_xyz(x2, y2, z);
    [x2, y2, z] = this.normalize_xyz(x2, y2, z);
    let quadkey = this.tile_xyz_to_quadkey(x2, y2, z);
    while (quadkey.length > 0) {
      quadkey = quadkey.substring(0, quadkey.length - 1);
      [x2, y2, z] = this.quadkey_to_tile_xyz(quadkey);
      [x2, y2, z] = this.denormalize_xyz(x2, y2, z, world_x);
      if (this.tiles.has(this.tile_xyz_to_key(x2, y2, z))) {
        return [x2, y2, z];
      }
    }
    return [0, 0, 0];
  }
  normalize_xyz(x2, y2, z) {
    if (this.wrap_around) {
      const tile_count = 2 ** z;
      return [(x2 % tile_count + tile_count) % tile_count, y2, z];
    } else {
      return [x2, y2, z];
    }
  }
  denormalize_xyz(x2, y2, z, world_x) {
    return [x2 + world_x * 2 ** z, y2, z];
  }
  denormalize_meters(meters_x, meters_y, _level, world_x) {
    return [meters_x + world_x * 2 * Math.PI * 6378137, meters_y];
  }
  calculate_world_x_by_tile_xyz(x2, _y, z) {
    return Math.floor(x2 / 2 ** z);
  }
};
__publicField(_MercatorTileSource, "__name__", "MercatorTileSource");
_MercatorTileSource.define(({ Bool: Bool2 }) => ({
  snap_to_zoom: [Bool2, false],
  wrap_around: [Bool2, true]
}));
_MercatorTileSource.override({
  x_origin_offset: 2003750834e-2,
  y_origin_offset: 2003750834e-2,
  initial_resolution: 156543.03392804097
});
var MercatorTileSource = _MercatorTileSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/bbox_tile_source.js
var _BBoxTileSource = class _BBoxTileSource extends MercatorTileSource {
  constructor(attrs) {
    super(attrs);
  }
  get_image_url(x2, y2, z) {
    const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
    let xmax, xmin, ymax, ymin;
    if (this.use_latlon) {
      [xmin, ymin, xmax, ymax] = this.get_tile_geographic_bounds(x2, y2, z);
    } else {
      [xmin, ymin, xmax, ymax] = this.get_tile_meter_bounds(x2, y2, z);
    }
    return image_url.replace("{XMIN}", xmin.toString()).replace("{YMIN}", ymin.toString()).replace("{XMAX}", xmax.toString()).replace("{YMAX}", ymax.toString());
  }
};
__publicField(_BBoxTileSource, "__name__", "BBoxTileSource");
_BBoxTileSource.define(({ Bool: Bool2 }) => ({
  use_latlon: [Bool2, false]
}));
var BBoxTileSource = _BBoxTileSource;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/quadkey_tile_source.js
var QUADKEYTileSource = class extends MercatorTileSource {
  constructor(attrs) {
    super(attrs);
  }
  get_image_url(x2, y2, z) {
    const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
    const [wx, wy, wz] = this.tms_to_wmts(x2, y2, z);
    const quadKey = this.tile_xyz_to_quadkey(wx, wy, wz);
    return image_url.replace("{Q}", quadKey);
  }
};
__publicField(QUADKEYTileSource, "__name__", "QUADKEYTileSource");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/wmts_tile_source.js
var WMTSTileSource = class extends MercatorTileSource {
  constructor(attrs) {
    super(attrs);
  }
  get_image_url(x2, y2, z) {
    const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
    const [wx, wy, wz] = this.tms_to_wmts(x2, y2, z);
    return image_url.replace("{X}", wx.toString()).replace("{Y}", wy.toString()).replace("{Z}", wz.toString());
  }
};
__publicField(WMTSTileSource, "__name__", "WMTSTileSource");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/tile_renderer.js
var TileRendererView = class extends RendererView {
  constructor() {
    super(...arguments);
    __publicField(this, "_tiles", null);
    __publicField(this, "extent");
    __publicField(this, "initial_extent");
    __publicField(this, "_last_height");
    __publicField(this, "_last_width");
    __publicField(this, "map_initialized", false);
    __publicField(this, "render_timer");
    __publicField(this, "prefetch_timer");
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.request_paint());
    this.connect(this.model.tile_source.change, () => this.request_paint());
  }
  force_finished() {
    super.force_finished();
    if (this._tiles == null) {
      this._tiles = [];
    }
  }
  get_extent() {
    const { x_range, y_range } = this;
    const x_start = x_range.start;
    const y_start = y_range.start;
    const x_end = x_range.end;
    const y_end = y_range.end;
    assert(isFinite(x_start));
    assert(isFinite(y_start));
    assert(isFinite(x_end));
    assert(isFinite(y_end));
    return [x_start, y_start, x_end, y_end];
  }
  get map_plot() {
    return this.plot_model;
  }
  get map_canvas() {
    return this.layer.ctx;
  }
  get map_frame() {
    return this.plot_view.frame;
  }
  get x_range() {
    return this.map_plot.x_range;
  }
  get y_range() {
    return this.map_plot.y_range;
  }
  _set_data() {
    this.extent = this.get_extent();
    this._last_height = void 0;
    this._last_width = void 0;
  }
  get attribution() {
    return new HTML({ html: [this.model.tile_source.attribution] });
  }
  _map_data() {
    this.initial_extent = this.get_extent();
    const zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame.bbox.height, this.map_frame.bbox.width);
    const new_extent = this.model.tile_source.snap_to_zoom_level(this.initial_extent, this.map_frame.bbox.height, this.map_frame.bbox.width, zoom_level);
    this.x_range.start = new_extent[0];
    this.y_range.start = new_extent[1];
    this.x_range.end = new_extent[2];
    this.y_range.end = new_extent[3];
    if (this.x_range instanceof Range1d) {
      this.x_range.reset_start = new_extent[0];
      this.x_range.reset_end = new_extent[2];
    }
    if (this.y_range instanceof Range1d) {
      this.y_range.reset_start = new_extent[1];
      this.y_range.reset_end = new_extent[3];
    }
  }
  _create_tile(x2, y2, z, bounds, cache_only = false) {
    const quadkey = this.model.tile_source.tile_xyz_to_quadkey(x2, y2, z);
    const cache_key = this.model.tile_source.tile_xyz_to_key(x2, y2, z);
    if (this.model.tile_source.tiles.has(cache_key)) {
      return;
    }
    const [nx, ny, nz] = this.model.tile_source.normalize_xyz(x2, y2, z);
    const src = this.model.tile_source.get_image_url(nx, ny, nz);
    const tile = {
      img: void 0,
      tile_coords: [x2, y2, z],
      normalized_coords: [nx, ny, nz],
      quadkey,
      cache_key,
      bounds,
      loaded: false,
      finished: false,
      x_coord: bounds[0],
      y_coord: bounds[3]
    };
    this.model.tile_source.tiles.set(cache_key, tile);
    if (this._tiles == null) {
      this._tiles = [];
    }
    this._tiles.push(tile);
    new ImageLoader(src, {
      loaded: (img2) => {
        Object.assign(tile, { img: img2, loaded: true });
        if (cache_only) {
          tile.finished = true;
          this.notify_finished();
        } else {
          this.request_paint();
        }
      },
      failed() {
        tile.finished = true;
      }
    });
  }
  _enforce_aspect_ratio() {
    if (this._last_height !== this.map_frame.bbox.height || this._last_width !== this.map_frame.bbox.width) {
      const extent = this.get_extent();
      const zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame.bbox.height, this.map_frame.bbox.width);
      const new_extent = this.model.tile_source.snap_to_zoom_level(extent, this.map_frame.bbox.height, this.map_frame.bbox.width, zoom_level);
      this.x_range.setv({ start: new_extent[0], end: new_extent[2] });
      this.y_range.setv({ start: new_extent[1], end: new_extent[3] });
      this.extent = new_extent;
      this._last_height = this.map_frame.bbox.height;
      this._last_width = this.map_frame.bbox.width;
    }
  }
  has_finished() {
    if (!super.has_finished()) {
      return false;
    }
    if (this._tiles == null) {
      return false;
    }
    for (const tile of this._tiles) {
      if (!tile.finished) {
        return false;
      }
    }
    return true;
  }
  _paint() {
    if (!this.map_initialized) {
      this._set_data();
      this._map_data();
      this.map_initialized = true;
    }
    this._enforce_aspect_ratio();
    this._update();
    if (this.prefetch_timer != null) {
      clearTimeout(this.prefetch_timer);
    }
    this.prefetch_timer = setTimeout(this._prefetch_tiles.bind(this), 500);
    if (this.has_finished()) {
      this.notify_finished();
    }
  }
  _draw_tile(tile_key) {
    const tile_data = this.model.tile_source.tiles.get(tile_key);
    if (tile_data != null && tile_data.loaded) {
      const [[sxmin], [symin]] = this.coordinates.map_to_screen([tile_data.bounds[0]], [tile_data.bounds[3]]);
      const [[sxmax], [symax]] = this.coordinates.map_to_screen([tile_data.bounds[2]], [tile_data.bounds[1]]);
      const sw = sxmax - sxmin;
      const sh = symax - symin;
      const sx = sxmin;
      const sy = symin;
      const old_smoothing = this.map_canvas.imageSmoothingEnabled;
      this.map_canvas.imageSmoothingEnabled = this.model.smoothing;
      this.map_canvas.drawImage(tile_data.img, sx, sy, sw, sh);
      this.map_canvas.imageSmoothingEnabled = old_smoothing;
      tile_data.finished = true;
    }
  }
  _set_rect() {
    const outline_width = this.plot_model.outline_line_width;
    const l = this.map_frame.bbox.left + outline_width / 2;
    const t = this.map_frame.bbox.top + outline_width / 2;
    const w = this.map_frame.bbox.width - outline_width;
    const h7 = this.map_frame.bbox.height - outline_width;
    this.map_canvas.rect(l, t, w, h7);
    this.map_canvas.clip();
  }
  _render_tiles(tile_keys) {
    this.map_canvas.save();
    this._set_rect();
    this.map_canvas.globalAlpha = this.model.alpha;
    for (const tile_key of tile_keys) {
      this._draw_tile(tile_key);
    }
    this.map_canvas.restore();
  }
  _prefetch_tiles() {
    const { tile_source } = this.model;
    const extent = this.get_extent();
    const h7 = this.map_frame.bbox.height;
    const w = this.map_frame.bbox.width;
    const zoom_level = this.model.tile_source.get_level_by_extent(extent, h7, w);
    const tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);
    for (let t = 0, end = Math.min(10, tiles.length); t < end; t++) {
      const [x2, y2, z] = tiles[t];
      const children = this.model.tile_source.children_by_tile_xyz(x2, y2, z);
      for (const c of children) {
        const [cx, cy, cz, cbounds] = c;
        if (tile_source.tiles.has(tile_source.tile_xyz_to_key(cx, cy, cz))) {
          continue;
        } else {
          this._create_tile(cx, cy, cz, cbounds, true);
        }
      }
    }
  }
  _fetch_tiles(tiles) {
    for (const tile of tiles) {
      const [x2, y2, z, bounds] = tile;
      this._create_tile(x2, y2, z, bounds);
    }
  }
  _update() {
    const { tile_source } = this.model;
    const { min_zoom } = tile_source;
    const { max_zoom } = tile_source;
    let extent = this.get_extent();
    const zooming_out = this.extent[2] - this.extent[0] < extent[2] - extent[0];
    const h7 = this.map_frame.bbox.height;
    const w = this.map_frame.bbox.width;
    let zoom_level = tile_source.get_level_by_extent(extent, h7, w);
    let snap_back = false;
    if (zoom_level < min_zoom) {
      extent = this.extent;
      zoom_level = min_zoom;
      snap_back = true;
    } else if (zoom_level > max_zoom) {
      extent = this.extent;
      zoom_level = max_zoom;
      snap_back = true;
    }
    if (snap_back) {
      this.x_range.setv({ start: extent[0], end: extent[2] });
      this.y_range.setv({ start: extent[1], end: extent[3] });
    }
    this.extent = extent;
    const tiles = tile_source.get_tiles_by_extent(extent, zoom_level);
    const need_load = [];
    const cached = [];
    const parents = [];
    const children = [];
    for (const t of tiles) {
      const [x2, y2, z] = t;
      const key = tile_source.tile_xyz_to_key(x2, y2, z);
      const tile = tile_source.tiles.get(key);
      if (tile != null && tile.loaded) {
        cached.push(key);
      } else {
        if (this.model.render_parents) {
          const [px2, py, pz] = tile_source.get_closest_parent_by_tile_xyz(x2, y2, z);
          const parent_key = tile_source.tile_xyz_to_key(px2, py, pz);
          const parent_tile = tile_source.tiles.get(parent_key);
          if (parent_tile != null && parent_tile.loaded && !includes(parents, parent_key)) {
            parents.push(parent_key);
          }
          if (zooming_out) {
            const child_tiles = tile_source.children_by_tile_xyz(x2, y2, z);
            for (const [cx, cy, cz] of child_tiles) {
              const child_key = tile_source.tile_xyz_to_key(cx, cy, cz);
              if (tile_source.tiles.has(child_key)) {
                children.push(child_key);
              }
            }
          }
        }
      }
      if (tile == null) {
        need_load.push(t);
      }
    }
    this._render_tiles(parents);
    this._render_tiles(children);
    this._render_tiles(cached);
    if (this.render_timer != null) {
      clearTimeout(this.render_timer);
    }
    this.render_timer = setTimeout(() => this._fetch_tiles(need_load), 65);
  }
};
__publicField(TileRendererView, "__name__", "TileRendererView");
var _TileRenderer = class _TileRenderer extends Renderer {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TileRenderer, "__name__", "TileRenderer");
_TileRenderer.prototype.default_view = TileRendererView;
_TileRenderer.define(({ Bool: Bool2, Float: Float2, Ref: Ref2 }) => ({
  alpha: [Float2, 1],
  smoothing: [Bool2, true],
  tile_source: [Ref2(TileSource), () => new WMTSTileSource()],
  render_parents: [Bool2, true]
}));
_TileRenderer.override({
  level: "image"
});
var TileRenderer = _TileRenderer;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tiles/tms_tile_source.js
var TMSTileSource = class extends MercatorTileSource {
  constructor(attrs) {
    super(attrs);
  }
  get_image_url(x2, y2, z) {
    const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);
    return image_url.replace("{X}", x2.toString()).replace("{Y}", y2.toString()).replace("{Z}", z.toString());
  }
};
__publicField(TMSTileSource, "__name__", "TMSTileSource");

// node_modules/@bokeh/bokehjs/build/js/lib/models/textures/texture.js
var _Texture = class _Texture extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Texture, "__name__", "Texture");
_Texture.define(() => ({
  repetition: [TextureRepetition, "repeat"]
}));
var Texture = _Texture;

// node_modules/@bokeh/bokehjs/build/js/lib/models/textures/canvas_texture.js
var _CanvasTexture = class _CanvasTexture extends Texture {
  constructor(attrs) {
    super(attrs);
  }
  get func() {
    const code2 = use_strict(this.code);
    return new Function("ctx", "color", "scale", "weight", code2);
  }
  get_pattern(color, scale, weight) {
    const canvas3 = document.createElement("canvas");
    canvas3.width = scale;
    canvas3.height = scale;
    const pattern_ctx = canvas3.getContext("2d");
    this.func.call(this, pattern_ctx, color, scale, weight);
    return canvas3;
  }
};
__publicField(_CanvasTexture, "__name__", "CanvasTexture");
_CanvasTexture.define(({ Str: Str2 }) => ({
  code: [Str2]
}));
var CanvasTexture = _CanvasTexture;

// node_modules/@bokeh/bokehjs/build/js/lib/models/textures/image_url_texture.js
var _ImageURLTexture = class _ImageURLTexture extends Texture {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_loader");
  }
  initialize() {
    super.initialize();
    this._loader = new ImageLoader(this.url);
  }
  get_pattern(_color, _scale, _weight) {
    const { _loader } = this;
    return this._loader.finished ? _loader.image : _loader.promise;
  }
};
__publicField(_ImageURLTexture, "__name__", "ImageURLTexture");
_ImageURLTexture.define(({ Str: Str2 }) => ({
  url: [Str2]
}));
var ImageURLTexture = _ImageURLTexture;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/icons/icon.js
var IconView = class extends UIElementView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => this.render());
  }
};
__publicField(IconView, "__name__", "IconView");
var _Icon = class _Icon extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Icon, "__name__", "Icon");
_Icon.define(({ Float: Float2, Or: Or2, CSSLength }) => ({
  size: [Or2(Float2, CSSLength), "1em"]
}));
var Icon = _Icon;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/icons/builtin_icon.js
import icons_css9 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var BuiltinIconView = class extends IconView {
  constructor() {
    super(...arguments);
    __publicField(this, "_style", new InlineStyleSheet());
  }
  stylesheets() {
    return [...super.stylesheets(), icons_css9, this._style];
  }
  render() {
    super.render();
    const icon3 = `var(--bokeh-icon-${this.model.icon_name})`;
    const color = color2css(this.model.color);
    const size2 = (() => {
      const { size: size3 } = this.model;
      return isNumber(size3) ? `${size3}px` : size3;
    })();
    this._style.replace(`
      :host {
        display: inline-block;
        vertical-align: middle;
        width: ${size2};
        height: ${size2};
        background-color: ${color};
        mask-image: ${icon3};
        mask-size: contain;
        mask-repeat: no-repeat;
        -webkit-mask-image: ${icon3};
        -webkit-mask-size: contain;
        -webkit-mask-repeat: no-repeat;
      }
    `);
  }
};
__publicField(BuiltinIconView, "__name__", "BuiltinIconView");
var _BuiltinIcon = class _BuiltinIcon extends Icon {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BuiltinIcon, "__name__", "BuiltinIcon");
_BuiltinIcon.prototype.default_view = BuiltinIconView;
_BuiltinIcon.define(({ Str: Str2, Color: Color2 }) => ({
  icon_name: [Str2],
  color: [Color2, "gray"]
}));
var BuiltinIcon = _BuiltinIcon;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/icons/svg_icon.js
var SVGIconView = class extends IconView {
  constructor() {
    super(...arguments);
    __publicField(this, "_style", new InlineStyleSheet());
  }
  stylesheets() {
    return [...super.stylesheets(), this._style];
  }
  render() {
    super.render();
    const size2 = (() => {
      const { size: size3 } = this.model;
      return isNumber(size3) ? `${size3}px` : size3;
    })();
    this._style.replace(`
      :host {
        display: inline-block;
        vertical-align: middle;
      }
      :host svg {
        width: ${size2};
        height: ${size2};
      }
    `);
    const parser = new DOMParser();
    const doc = parser.parseFromString(this.model.svg, "image/svg+xml");
    this.shadow_el.append(doc.documentElement);
  }
};
__publicField(SVGIconView, "__name__", "SVGIconView");
var _SVGIcon = class _SVGIcon extends Icon {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_SVGIcon, "__name__", "SVGIcon");
_SVGIcon.prototype.default_view = SVGIconView;
_SVGIcon.define(({ Str: Str2 }) => ({
  svg: [Str2]
}));
var SVGIcon = _SVGIcon;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/icons/tabler_icon.js
var _TablerIconView = class _TablerIconView extends IconView {
  constructor() {
    super(...arguments);
    __publicField(this, "_tabler", new ImportedStyleSheet(`${_TablerIconView._url}/tabler-icons.min.css`));
    __publicField(this, "_style", new InlineStyleSheet());
  }
  stylesheets() {
    return [...super.stylesheets(), _TablerIconView._fonts, this._tabler, this._style];
  }
  render() {
    super.render();
    const size2 = (() => {
      const { size: size3 } = this.model;
      return isNumber(size3) ? `${size3}px` : size3;
    })();
    this._style.replace(`
      :host {
        display: inline-block;
        vertical-align: middle;
        font-size: ${size2};
      }
    `);
    const icon3 = span({ class: ["ti", `ti-${this.model.icon_name}`] });
    this.shadow_el.appendChild(icon3);
  }
};
__publicField(_TablerIconView, "__name__", "TablerIconView");
__publicField(_TablerIconView, "_url", "https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest");
__publicField(_TablerIconView, "_fonts", new GlobalInlineStyleSheet(`    /*!
    * Tabler Icons 1.68.0 by tabler - https://tabler.io
    * License - https://github.com/tabler/tabler-icons/blob/master/LICENSE
    */
  @font-face {
    font-family: "tabler-icons";
    font-style: normal;
    font-weight: 400;
    src: url("${_TablerIconView._url}/fonts/tabler-icons.eot");
    src: url("${_TablerIconView._url}/fonts/tabler-icons.eot?#iefix") format("embedded-opentype"),
         url("${_TablerIconView._url}/fonts/tabler-icons.woff2") format("woff2"),
         url("${_TablerIconView._url}/fonts/tabler-icons.woff") format("woff"),
         url("${_TablerIconView._url}/fonts/tabler-icons.ttf") format("truetype"),
         url("${_TablerIconView._url}/fonts/tabler-icons.svg#tabler-icons") format("svg");
  }

  @media screen and (-webkit-min-device-pixel-ratio: 0) {
    @font-face {
      font-family: "tabler-icons";
      src: url("${_TablerIconView._url}/fonts/tabler-icons.svg#tabler-icons") format("svg");
    }
  }
`));
var TablerIconView = _TablerIconView;
var _TablerIcon = class _TablerIcon extends Icon {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TablerIcon, "__name__", "TablerIcon");
_TablerIcon.prototype.default_view = TablerIconView;
_TablerIcon.define(({ Str: Str2 }) => ({
  icon_name: [Str2]
}));
var TablerIcon = _TablerIcon;

// node_modules/@bokeh/bokehjs/build/js/lib/models/ui/examiner.js
import examiner_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/examiner.css.js";
import pretty_css, * as pretty2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/pretty.css.js";
var HTMLPrinter = class {
  constructor(click, max_items = 5, max_depth = 3) {
    __publicField(this, "click");
    __publicField(this, "max_items");
    __publicField(this, "max_depth");
    __publicField(this, "visited", /* @__PURE__ */ new WeakSet());
    __publicField(this, "depth", 0);
    this.click = click;
    this.max_items = max_items;
    this.max_depth = max_depth;
  }
  to_html(obj) {
    if (isObject(obj)) {
      if (this.visited.has(obj)) {
        return span("<circular>");
      } else {
        this.visited.add(obj);
      }
    }
    if (obj == null) {
      return this.null();
    } else if (isBoolean(obj)) {
      return this.boolean(obj);
    } else if (isNumber(obj)) {
      return this.number(obj);
    } else if (isString(obj)) {
      return this.string(obj);
    } else if (isSymbol(obj)) {
      return this.symbol(obj);
    } else if (obj instanceof Model) {
      return this.model(obj);
    } else if (obj instanceof Property) {
      return this.property(obj);
    } else if (isPlainObject(obj)) {
      return this.object(obj);
    } else if (isArray(obj)) {
      return this.array(obj);
    } else if (isIterable(obj)) {
      return this.iterable(obj);
    } else {
      return span(to_string(obj));
    }
  }
  null() {
    return span({ class: pretty2.nullish }, "null");
  }
  token(val) {
    return span({ class: pretty2.token }, val);
  }
  boolean(val) {
    return span({ class: pretty2.boolean }, `${val}`);
  }
  number(val) {
    return span({ class: pretty2.number }, `${val}`);
  }
  string(val) {
    const sq = val.includes("'");
    const dq = val.includes('"');
    const str = (() => {
      if (sq && dq) {
        return `\`${val.replace(/`/g, "\\`")}\``;
      } else if (dq) {
        return `'${val}'`;
      } else {
        return `"${val}"`;
      }
    })();
    return span({ class: pretty2.string }, str);
  }
  symbol(val) {
    return span({ class: pretty2.symbol }, val.toString());
  }
  array(obj) {
    const T = this.token;
    const items = [];
    let i2 = 0;
    for (const entry2 of obj) {
      items.push(this.to_html(entry2));
      if (i2++ > this.max_items) {
        items.push(span("…"));
        break;
      }
    }
    return span({ class: pretty2.array }, T("["), ...interleave(items, () => T(", ")), T("]"));
  }
  iterable(obj) {
    const T = this.token;
    const tag = Object(obj)[Symbol.toStringTag] ?? "Object";
    const items = this.array([...obj]);
    return span({ class: pretty2.iterable }, `${tag}`, T("("), items, T(")"));
  }
  object(obj) {
    const T = this.token;
    const items = [];
    let i2 = 0;
    for (const [key, val] of entries(obj)) {
      items.push(span(`${key}`, T(": "), this.to_html(val)));
      if (i2++ > this.max_items) {
        items.push(span("…"));
        break;
      }
    }
    return span({ class: pretty2.object }, T("{"), ...interleave(items, () => T(", ")), T("}"));
  }
  model(obj) {
    const T = this.token;
    const el = span({ class: pretty2.model }, obj.constructor.__qualified__, T("("), this.to_html(obj.id), T(")"));
    const { click } = this;
    if (click != null) {
      el.classList.add("ref");
      el.addEventListener("click", () => click(obj));
    }
    return el;
  }
  property(obj) {
    const model2 = this.model(obj.obj);
    const attr2 = span({ class: pretty2.attr }, obj.attr);
    return span(model2, this.token("."), attr2);
  }
};
__publicField(HTMLPrinter, "__name__", "HTMLPrinter");
var ExaminerView = class extends UIElementView {
  constructor() {
    super(...arguments);
    __publicField(this, "prev_listener", null);
    __publicField(this, "watched_props", /* @__PURE__ */ new Set());
  }
  stylesheets() {
    return [...super.stylesheets(), pretty_css, examiner_css];
  }
  render() {
    super.render();
    if (this.prev_listener != null) {
      diagnostics.disconnect(this.prev_listener);
    }
    const models_list = [];
    const props_list = [];
    const watches_list = [];
    const animations = /* @__PURE__ */ new WeakMap();
    const listener = (obj) => {
      if (!(obj instanceof Property)) {
        return;
      }
      function highlight(el) {
        const prev = animations.get(el);
        if (prev != null) {
          prev.cancel();
        }
        const anim = el.animate([
          { backgroundColor: "#def189" },
          { backgroundColor: "initial" }
        ], { duration: 2e3 });
        animations.set(el, anim);
      }
      function update(prop, prop_el, value_el) {
        prop_el.classList.toggle("dirty", prop.dirty);
        empty2(value_el);
        const value2 = prop.is_unset ? span("unset") : to_html(prop.get_value());
        value_el.appendChild(value2);
        highlight(value_el);
      }
      for (const [model2, model_el] of models_list) {
        if (model2 == obj.obj) {
          highlight(model_el);
        }
      }
      for (const [prop, prop_el] of props_list) {
        if (prop == obj) {
          const [, , , value_el] = prop_el.children;
          update(prop, prop_el, value_el);
          break;
        }
      }
      for (const [prop, prop_el] of watches_list) {
        if (prop == obj) {
          const [, value_el] = prop_el.children;
          update(prop, prop_el, value_el);
          break;
        }
      }
    };
    diagnostics.connect(listener);
    const models_tb_el = (() => {
      const filter_el = input({ class: "filter", type: "text", placeholder: "Filter" });
      filter_el.addEventListener("keyup", () => {
        const text2 = filter_el.value;
        for (const [model2, el] of models_list) {
          const show3 = model2.constructor.__qualified__.includes(text2);
          el.classList.toggle("hidden", !show3);
        }
      });
      return div({ class: "toolbar" }, filter_el);
    })();
    const initial_cb_el = input({ type: "checkbox", checked: true });
    const internal_cb_el = input({ type: "checkbox", checked: true });
    const update_prop_visibility = () => {
      for (const [prop, prop_el] of props_list) {
        const show_initial = initial_cb_el.checked;
        const show_internal = internal_cb_el.checked;
        const hidden2 = !prop.dirty && !show_initial || prop.internal && !show_internal;
        prop_el.classList.toggle("hidden", hidden2);
      }
    };
    initial_cb_el.addEventListener("change", () => update_prop_visibility());
    internal_cb_el.addEventListener("change", () => update_prop_visibility());
    const props_tb_el = (() => {
      const filter_el = input({ class: "filter", type: "text", placeholder: "Filter" });
      const group_el = span({ class: "checkbox" }, input({ type: "checkbox", checked: true }), span("Group"));
      const initial_el = span({ class: "checkbox" }, initial_cb_el, span("Initial?"));
      const internal_el = span({ class: "checkbox" }, internal_cb_el, span("Internal?"));
      filter_el.addEventListener("keyup", () => {
        const text2 = filter_el.value;
        for (const [prop, el] of props_list) {
          const show3 = prop.attr.includes(text2);
          el.classList.toggle("hidden", !show3);
        }
      });
      return div({ class: "toolbar" }, filter_el, group_el, initial_el, internal_el);
    })();
    const watches_tb_el = (() => {
      const filter_el = input({ class: "filter", type: "text", placeholder: "Filter" });
      filter_el.addEventListener("keyup", () => {
        const text2 = filter_el.value;
        for (const [prop, el] of watches_list) {
          const show3 = prop.attr.includes(text2);
          el.classList.toggle("hidden", !show3);
        }
      });
      return div({ class: "toolbar" }, filter_el);
    })();
    const models_list_el = div({ class: "models-list" });
    const props_list_el = div({ class: "props-list" });
    const watches_list_el = div({ class: "watches-list" });
    const models_panel_el = div({ class: "models-panel" }, models_tb_el, models_list_el);
    const props_panel_el = div({ class: "props-panel" }, props_tb_el, props_list_el);
    const watches_panel_el = div({ class: "watches-panel" }, watches_tb_el, watches_list_el);
    const column_el = div({ class: "col", style: { width: "100%" } }, watches_panel_el, props_panel_el);
    const examiner_el = div({ class: "examiner" }, models_panel_el, column_el);
    function click(obj) {
      if (obj instanceof Model) {
        render_props(obj);
      }
    }
    function to_html(obj) {
      const printer = new HTMLPrinter(click);
      return printer.to_html(obj);
    }
    const render_models = (models, doc) => {
      clear(models_list);
      empty2(models_list_el);
      const roots = doc != null ? new Set(doc.roots()) : /* @__PURE__ */ new Set();
      for (const model2 of models) {
        const root = roots.has(model2) ? span({ class: "tag" }, "root") : null;
        const ref_el = span({ class: "model-ref", tabIndex: 0 }, to_html(model2), root);
        ref_el.addEventListener("keydown", (event2) => {
          if (event2.key == "Enter") {
            render_props(model2);
          }
        });
        models_list.push([model2, ref_el]);
        models_list_el.appendChild(ref_el);
      }
    };
    const render_props = (model2) => {
      clear(props_list);
      empty2(props_list_el);
      for (const [item3, el] of models_list) {
        el.classList.toggle("active", model2 == item3);
      }
      const bases = (() => {
        const bases2 = [];
        let proto = Object.getPrototypeOf(model2);
        do {
          bases2.push([proto.constructor, keys(proto._props)]);
          proto = Object.getPrototypeOf(proto);
        } while (proto.constructor != HasProps);
        bases2.reverse();
        const cumulative = [];
        for (const [, attrs] of bases2) {
          attrs.splice(0, cumulative.length);
          cumulative.push(...attrs);
        }
        return bases2;
      })();
      const connections = receivers_for_sender.get(model2) ?? [];
      for (const [base2, attrs] of bases) {
        if (attrs.length == 0) {
          continue;
        }
        const expander_el = span({ class: ["expander"] });
        const base_el = div({ class: "base" }, expander_el, "inherited from", " ", span({ class: "monospace" }, base2.__qualified__));
        props_list_el.appendChild(base_el);
        const props_group = [];
        for (const attr2 of attrs) {
          const prop = model2.property(attr2);
          const kind = prop.kind.toString();
          const value2 = prop.is_unset ? span("unset") : to_html(prop.get_value());
          const internal_el = prop.internal ? span({ class: "tag" }, "internal") : null;
          const listeners = connections.filter((connection) => connection.signal == prop.change).length;
          const listeners_el = listeners != 0 ? span({ class: "tag" }, `${listeners}`) : null;
          const watched = this.watched_props.has(prop);
          const watch_el = input({ type: "checkbox", checked: watched });
          const attr_el = div({ class: "prop-attr", tabIndex: 0 }, watch_el, span({ class: "attr" }, attr2), internal_el);
          const conns_el = div({ class: "prop-conns" }, listeners_el);
          const kind_el = div({ class: "prop-kind" }, kind);
          const value_el = div({ class: "prop-value" }, value2);
          const dirty = prop.dirty ? "dirty" : null;
          const internal = prop.internal ? "internal" : null;
          const show_initial = initial_cb_el.checked;
          const show_internal = internal_cb_el.checked;
          const hidden2 = !prop.dirty && !show_initial || prop.internal && !show_internal ? "hidden" : null;
          const prop_el = div({ class: ["prop", dirty, internal, hidden2] }, attr_el, conns_el, kind_el, value_el);
          props_group.push(prop_el);
          props_list.push([prop, prop_el]);
          props_list_el.appendChild(prop_el);
          watch_el.addEventListener("change", () => {
            this.watched_props[watch_el.checked ? "add" : "delete"](prop);
            render_watches();
          });
        }
        base_el.addEventListener("click", () => {
          expander_el.classList.toggle("closed");
          for (const el of props_group) {
            el.classList.toggle("closed");
          }
        });
      }
    };
    const render_watches = () => {
      clear(watches_list);
      empty2(watches_list_el);
      if (this.watched_props.size == 0) {
        const empty_el = div({ class: "nothing" }, "No watched properties");
        watches_list_el.appendChild(empty_el);
      } else {
        for (const prop of this.watched_props) {
          const attr_el = span(to_html(prop));
          const value_el = span(prop.is_unset ? span("unset") : to_html(prop.get_value()));
          const prop_el = div({ class: ["prop", prop.dirty ? "dirty" : null] }, attr_el, value_el);
          watches_list.push([prop, prop_el]);
          watches_list_el.appendChild(prop_el);
        }
      }
    };
    this.shadow_el.appendChild(examiner_el);
    const { target } = this.model;
    if (target != null) {
      const models = target.references();
      const { document: document2 } = target;
      render_models(models, document2);
      render_props(target);
    } else {
      const { document: document2 } = this.model;
      if (document2 != null) {
        const models = document2._all_models.values();
        render_models(models, document2);
        const roots = document2.roots();
        if (roots.length != 0) {
          const [root] = roots;
          render_props(root);
        }
      }
    }
    render_watches();
  }
};
__publicField(ExaminerView, "__name__", "ExaminerView");
var _Examiner = class _Examiner extends UIElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Examiner, "__name__", "Examiner");
_Examiner.prototype.default_view = ExaminerView;
_Examiner.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  target: [Nullable2(Ref2(HasProps)), null]
}));
var Examiner = _Examiner;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/copy_tool.js
import { tool_icon_copy } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var CopyToolView = class extends ActionToolView {
  async copy() {
    const blob = await this.parent.export().to_blob();
    const item3 = new ClipboardItem({ [blob.type]: blob });
    await navigator.clipboard.write([item3]);
  }
  doit() {
    void this.copy();
  }
};
__publicField(CopyToolView, "__name__", "CopyToolView");
var _CopyTool = class _CopyTool extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Copy");
    __publicField(this, "tool_icon", tool_icon_copy);
  }
};
__publicField(_CopyTool, "__name__", "CopyTool");
_CopyTool.prototype.default_view = CopyToolView;
_CopyTool.register_alias("copy", () => new _CopyTool());
var CopyTool = _CopyTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/custom_action.js
import * as icons from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var CustomActionView = class extends ActionToolView {
  doit() {
    const { callback } = this.model;
    if (callback != null) {
      void execute(callback, this.model);
    }
  }
};
__publicField(CustomActionView, "__name__", "CustomActionView");
var _CustomAction = class _CustomAction extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Custom Action");
    __publicField(this, "tool_icon", icons.tool_icon_unknown);
  }
};
__publicField(_CustomAction, "__name__", "CustomAction");
_CustomAction.prototype.default_view = CustomActionView;
_CustomAction.define(({ Any: Any2, Nullable: Nullable2 }) => ({
  callback: [Nullable2(
    Any2
    /*TODO*/
  ), null]
}));
_CustomAction.override({
  description: "Perform a Custom Action"
});
var CustomAction = _CustomAction;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/fullscreen_tool.js
import * as icons2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var request_fullscreen = (() => {
  if (typeof Element.prototype.webkitRequestFullscreen !== "undefined") {
    return (el, options2) => el.webkitRequestFullscreen(options2);
  } else {
    return (el, options2) => el.requestFullscreen(options2);
  }
})();
var FullscreenToolView = class extends ActionToolView {
  async fullscreen() {
    if (document.fullscreenElement != null) {
      await document.exitFullscreen();
    } else {
      await request_fullscreen(this.parent.el);
    }
  }
  doit() {
    void this.fullscreen();
  }
};
__publicField(FullscreenToolView, "__name__", "FullscreenToolView");
var _FullscreenTool = class _FullscreenTool extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Fullscreen");
    __publicField(this, "tool_icon", icons2.tool_icon_fullscreen);
  }
};
__publicField(_FullscreenTool, "__name__", "FullscreenTool");
_FullscreenTool.prototype.default_view = FullscreenToolView;
_FullscreenTool.register_alias("fullscreen", () => new _FullscreenTool());
var FullscreenTool = _FullscreenTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/examine_tool.js
import * as icons3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
import pretty_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/pretty.css.js";
var ExamineToolView = class extends ActionToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_dialog");
  }
  *children() {
    yield* super.children();
    yield this._dialog;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const target = this.parent.model;
    const printer = new HTMLPrinter();
    const dialog2 = new Dialog({
      stylesheets: [pretty_css2],
      title: new HTML({ html: div("Examine ", printer.to_html(target)) }),
      content: new Examiner({ target }),
      visible: false,
      close_action: "hide"
    });
    this._dialog = await build_view(dialog2, { parent: this.parent });
  }
  doit() {
    this._dialog.open();
  }
};
__publicField(ExamineToolView, "__name__", "ExamineToolView");
var _ExamineTool = class _ExamineTool extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Examine");
    __publicField(this, "tool_icon", icons3.tool_icon_settings);
  }
  // TODO: better icon
};
__publicField(_ExamineTool, "__name__", "ExamineTool");
_ExamineTool.prototype.default_view = ExamineToolView;
_ExamineTool.register_alias("examine", () => new _ExamineTool());
var ExamineTool = _ExamineTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/plot_action_tool.js
var PlotActionToolView = class extends ActionToolView {
  get plot_view() {
    return this.parent;
  }
};
__publicField(PlotActionToolView, "__name__", "PlotActionToolView");
var PlotActionTool = class extends ActionTool {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(PlotActionTool, "__name__", "PlotActionTool");

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/click_pan_tool.js
import * as icons5 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/pan_tool.js
import * as icons4 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
function update_ranges(scales, p0, p1) {
  const r = /* @__PURE__ */ new Map();
  for (const [, scale] of scales) {
    const [start2, end] = scale.r_invert(p0, p1);
    r.set(scale.source_range, { start: start2, end });
  }
  return r;
}
var PanToolView = class extends GestureToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "last_dx");
    __publicField(this, "last_dy");
    __publicField(this, "v_axis_only");
    __publicField(this, "h_axis_only");
    __publicField(this, "pan_info");
  }
  cursor(sx, sy) {
    const axis_view = this.plot_view.axis_views.find((view) => view.bbox.contains(sx, sy));
    if (axis_view != null) {
      switch (axis_view.dimension) {
        case 0:
          return "ew-resize";
        case 1:
          return "ns-resize";
      }
    } else if (this.plot_view.frame.bbox.contains(sx, sy)) {
      return "move";
    } else {
      return super.cursor(sx, sy);
    }
  }
  _pan_start(ev) {
    var _a34;
    this.last_dx = 0;
    this.last_dy = 0;
    const { sx, sy } = ev;
    const bbox = this.plot_view.frame.bbox;
    if (!bbox.contains(sx, sy)) {
      const hr2 = bbox.h_range;
      const vr = bbox.v_range;
      if (sx < hr2.start || sx > hr2.end) {
        this.v_axis_only = true;
      }
      if (sy < vr.start || sy > vr.end) {
        this.h_axis_only = true;
      }
    }
    (_a34 = this.model.document) == null ? void 0 : _a34.interactive_start(this.plot_view.model);
  }
  _pan(ev) {
    var _a34;
    this._update(ev.dx, ev.dy);
    (_a34 = this.model.document) == null ? void 0 : _a34.interactive_start(this.plot_view.model);
  }
  _pan_end(_e) {
    this.h_axis_only = false;
    this.v_axis_only = false;
    if (this.pan_info != null) {
      this.plot_view.state.push("pan", { range: this.pan_info });
    }
    this.plot_view.trigger_ranges_update_event();
  }
  _update(dx, dy) {
    const frame = this.plot_view.frame;
    const new_dx = dx - this.last_dx;
    const new_dy = dy - this.last_dy;
    const hr2 = frame.bbox.h_range;
    const sx_low = hr2.start - new_dx;
    const sx_high = hr2.end - new_dx;
    const vr = frame.bbox.v_range;
    const sy_low = vr.start - new_dy;
    const sy_high = vr.end - new_dy;
    const dims = this.model.dimensions;
    let sx0;
    let sx1;
    let sdx;
    if ((dims == "width" || dims == "both") && !this.v_axis_only) {
      sx0 = sx_low;
      sx1 = sx_high;
      sdx = -new_dx;
    } else {
      sx0 = hr2.start;
      sx1 = hr2.end;
      sdx = 0;
    }
    let sy0;
    let sy1;
    let sdy;
    if ((dims == "height" || dims == "both") && !this.h_axis_only) {
      sy0 = sy_low;
      sy1 = sy_high;
      sdy = -new_dy;
    } else {
      sy0 = vr.start;
      sy1 = vr.end;
      sdy = 0;
    }
    this.last_dx = dx;
    this.last_dy = dy;
    const { x_scales, y_scales } = frame;
    const xrs = update_ranges(x_scales, sx0, sx1);
    const yrs = update_ranges(y_scales, sy0, sy1);
    this.pan_info = { xrs, yrs, sdx, sdy };
    this.plot_view.update_range(this.pan_info, { panning: true });
  }
};
__publicField(PanToolView, "__name__", "PanToolView");
var _PanTool = class _PanTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Pan");
    __publicField(this, "event_type", "pan");
    __publicField(this, "default_order", 10);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
  get computed_icon() {
    const icon3 = super.computed_icon;
    if (icon3 != null) {
      return icon3;
    } else {
      switch (this.dimensions) {
        case "both":
          return `.${icons4.tool_icon_pan}`;
        case "width":
          return `.${icons4.tool_icon_x_pan}`;
        case "height":
          return `.${icons4.tool_icon_y_pan}`;
      }
    }
  }
  get menu() {
    return [
      {
        icon: icons4.tool_icon_pan,
        tooltip: "Pan in both dimensions",
        active: () => this.dimensions == "both",
        handler: () => {
          this.dimensions = "both";
          this.active = true;
        }
      },
      {
        icon: icons4.tool_icon_x_pan,
        tooltip: "Pan in x-dimension",
        active: () => this.dimensions == "width",
        handler: () => {
          this.dimensions = "width";
          this.active = true;
        }
      },
      {
        icon: icons4.tool_icon_y_pan,
        tooltip: "Pan in y-dimension",
        active: () => this.dimensions == "height",
        handler: () => {
          this.dimensions = "height";
          this.active = true;
        }
      }
    ];
  }
};
__publicField(_PanTool, "__name__", "PanTool");
_PanTool.prototype.default_view = PanToolView;
_PanTool.define(() => ({
  dimensions: [Dimensions, "both"]
}));
_PanTool.register_alias("pan", () => new _PanTool({ dimensions: "both" }));
_PanTool.register_alias("xpan", () => new _PanTool({ dimensions: "width" }));
_PanTool.register_alias("ypan", () => new _PanTool({ dimensions: "height" }));
var PanTool = _PanTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/click_pan_tool.js
var ClickPanToolView = class extends PlotActionToolView {
  doit() {
    const direction = (() => {
      switch (this.model.direction) {
        case "left":
        case "west":
          return { x: -1, y: 0 };
        case "right":
        case "east":
          return { x: 1, y: 0 };
        case "up":
        case "north":
          return { x: 0, y: -1 };
        case "down":
        case "south":
          return { x: 0, y: 1 };
      }
    })();
    const { frame } = this.plot_view;
    const { factor } = this.model;
    const x_offset = direction.x * factor * frame.bbox.width;
    const y_offset = direction.y * factor * frame.bbox.height;
    const bbox = frame.bbox.translate(x_offset, y_offset);
    const xrs = update_ranges(frame.x_scales, bbox.x0, bbox.x1);
    const yrs = update_ranges(frame.y_scales, bbox.y0, bbox.y1);
    this.plot_view.update_range({ xrs, yrs }, { panning: true });
  }
};
__publicField(ClickPanToolView, "__name__", "ClickPanToolView");
var _ClickPanTool = class _ClickPanTool extends PlotActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Click Pan");
  }
  get tooltip() {
    return `Pan ${this.direction}`;
  }
  get computed_icon() {
    const icon3 = super.computed_icon;
    if (icon3 != null) {
      return icon3;
    } else {
      switch (this.direction) {
        case "left":
        case "west":
          return `.${icons5.tool_icon_pan_left}`;
        case "right":
        case "east":
          return `.${icons5.tool_icon_pan_right}`;
        case "up":
        case "north":
          return `.${icons5.tool_icon_pan_up}`;
        case "down":
        case "south":
          return `.${icons5.tool_icon_pan_down}`;
      }
    }
  }
};
__publicField(_ClickPanTool, "__name__", "ClickPanTool");
_ClickPanTool.prototype.default_view = ClickPanToolView;
_ClickPanTool.define(() => ({
  direction: [PanDirection],
  factor: [Float, 0.1]
}));
_ClickPanTool.register_alias("pan_left", () => new _ClickPanTool({ direction: "left" }));
_ClickPanTool.register_alias("pan_right", () => new _ClickPanTool({ direction: "right" }));
_ClickPanTool.register_alias("pan_up", () => new _ClickPanTool({ direction: "up" }));
_ClickPanTool.register_alias("pan_down", () => new _ClickPanTool({ direction: "down" }));
_ClickPanTool.register_alias("pan_west", () => new _ClickPanTool({ direction: "west" }));
_ClickPanTool.register_alias("pan_east", () => new _ClickPanTool({ direction: "east" }));
_ClickPanTool.register_alias("pan_north", () => new _ClickPanTool({ direction: "north" }));
_ClickPanTool.register_alias("pan_south", () => new _ClickPanTool({ direction: "south" }));
var ClickPanTool = _ClickPanTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/redo_tool.js
import { tool_icon_redo } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var RedoToolView = class extends PlotActionToolView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.plot_view.state.changed, () => this.model.disabled = !this.plot_view.state.can_redo);
  }
  doit() {
    const state = this.plot_view.state.redo();
    if ((state == null ? void 0 : state.range) != null) {
      this.plot_view.trigger_ranges_update_event();
    }
  }
};
__publicField(RedoToolView, "__name__", "RedoToolView");
var _RedoTool = class _RedoTool extends PlotActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Redo");
    __publicField(this, "tool_icon", tool_icon_redo);
  }
};
__publicField(_RedoTool, "__name__", "RedoTool");
_RedoTool.prototype.default_view = RedoToolView;
_RedoTool.override({
  disabled: true
});
_RedoTool.register_alias("redo", () => new _RedoTool());
var RedoTool = _RedoTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/reset_tool.js
import { tool_icon_reset } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ResetToolView = class extends PlotActionToolView {
  doit() {
    this.plot_view.reset();
  }
};
__publicField(ResetToolView, "__name__", "ResetToolView");
var _ResetTool = class _ResetTool extends PlotActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Reset");
    __publicField(this, "tool_icon", tool_icon_reset);
  }
};
__publicField(_ResetTool, "__name__", "ResetTool");
_ResetTool.prototype.default_view = ResetToolView;
_ResetTool.register_alias("reset", () => new _ResetTool());
var ResetTool = _ResetTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/save_tool.js
import * as icons6 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var SaveToolView = class extends ActionToolView {
  async _export() {
    return this.parent.export().to_blob();
  }
  async copy() {
    const blob = await this._export();
    const item3 = new ClipboardItem({ [blob.type]: blob });
    await navigator.clipboard.write([item3]);
  }
  async save(name) {
    const blob = await this._export();
    const link2 = document.createElement("a");
    link2.href = URL.createObjectURL(blob);
    link2.download = name;
    link2.target = "_blank";
    link2.dispatchEvent(new MouseEvent("click"));
  }
  async open() {
    const blob = await this._export();
    const url2 = URL.createObjectURL(blob);
    open(url2);
  }
  doit(action = "save") {
    switch (action) {
      case "save": {
        const filename = this.model.filename ?? prompt("Enter filename", "bokeh_plot");
        if (filename != null) {
          void this.save(filename);
        }
        break;
      }
      case "copy": {
        void this.copy();
        break;
      }
      case "open": {
        void this.open();
        break;
      }
    }
  }
};
__publicField(SaveToolView, "__name__", "SaveToolView");
var _SaveTool = class _SaveTool extends ActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Save");
    __publicField(this, "tool_icon", icons6.tool_icon_save);
  }
  get menu() {
    return [
      {
        icon: icons6.tool_icon_copy,
        tooltip: "Copy image to clipboard",
        if: () => typeof ClipboardItem !== "undefined",
        handler: () => {
          this.do.emit("copy");
        }
      },
      {
        icon: icons6.tool_icon_open,
        tooltip: "Open image in a new tab",
        handler: () => {
          this.do.emit("open");
        }
      }
    ];
  }
};
__publicField(_SaveTool, "__name__", "SaveTool");
_SaveTool.prototype.default_view = SaveToolView;
_SaveTool.define(({ Str: Str2, Nullable: Nullable2 }) => ({
  filename: [Nullable2(Str2), null]
}));
_SaveTool.register_alias("save", () => new _SaveTool());
var SaveTool = _SaveTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/undo_tool.js
import { tool_icon_undo } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var UndoToolView = class extends PlotActionToolView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.plot_view.state.changed, () => this.model.disabled = !this.plot_view.state.can_undo);
  }
  doit() {
    const state = this.plot_view.state.undo();
    if ((state == null ? void 0 : state.range) != null) {
      this.plot_view.trigger_ranges_update_event();
    }
  }
};
__publicField(UndoToolView, "__name__", "UndoToolView");
var _UndoTool = class _UndoTool extends PlotActionTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Undo");
    __publicField(this, "tool_icon", tool_icon_undo);
  }
};
__publicField(_UndoTool, "__name__", "UndoTool");
_UndoTool.prototype.default_view = UndoToolView;
_UndoTool.override({
  disabled: true
});
_UndoTool.register_alias("undo", () => new _UndoTool());
var UndoTool = _UndoTool;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/zoom.js
function scale_interval(range2, factor, center) {
  assert(Math.abs(factor) < 1);
  const [min10, max18] = minmax(range2.start, range2.end);
  const x2 = center ?? (max18 + min10) / 2;
  const x0 = min10 - (min10 - x2) * factor;
  const x1 = max18 - (max18 - x2) * factor;
  return [x0, x1];
}
function rescale(scales, factor, center) {
  const output2 = /* @__PURE__ */ new Map();
  for (const scale of scales) {
    const [v0, v1] = scale_interval(scale.target_range, factor, center);
    const [start2, end] = scale.r_invert(v0, v1);
    output2.set(scale.source_range, { start: start2, end });
  }
  return output2;
}
function scale_range(x_scales, y_scales, _x_target, _y_range, factor, x_axis = true, y_axis = true, center) {
  const x_factor = x_axis ? factor : 0;
  const xrs = rescale(x_scales, x_factor, center == null ? void 0 : center.x);
  const y_factor = y_axis ? factor : 0;
  const yrs = rescale(y_scales, y_factor, center == null ? void 0 : center.y);
  return { xrs, yrs, factor };
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/zoom_base_tool.js
var ZoomBaseToolView = class extends PlotActionToolView {
  doit() {
    var _a34;
    const { dimensions } = this.model;
    const x_axis = dimensions == "width" || dimensions == "both";
    const y_axis = dimensions == "height" || dimensions == "both";
    const { frame } = this.plot_view;
    const { x_target, y_target } = frame;
    const x_frame_scales = new Map(frame.x_scales);
    const y_frame_scales = new Map(frame.y_scales);
    const { renderers } = this.model;
    if (renderers != "auto") {
      const x_range_names = /* @__PURE__ */ new Set();
      const y_range_names = /* @__PURE__ */ new Set();
      for (const renderer of renderers) {
        if (renderer.coordinates == null) {
          x_range_names.add(renderer.x_range_name);
          y_range_names.add(renderer.y_range_name);
        }
      }
      for (const name of x_frame_scales.keys()) {
        if (!x_range_names.has(name)) {
          x_frame_scales.delete(name);
        }
      }
      for (const name of y_frame_scales.keys()) {
        if (!y_range_names.has(name)) {
          y_frame_scales.delete(name);
        }
      }
    }
    const x_scales = [...x_frame_scales.values()];
    const y_scales = [...y_frame_scales.values()];
    const data_renderers = renderers != "auto" ? renderers : this.plot_view.model.data_renderers;
    for (const renderer of data_renderers) {
      if (renderer.coordinates == null) {
        continue;
      }
      const rv = this.plot_view.views.get_one(renderer);
      const process = (scale, dim) => {
        const { level } = this.model;
        for (let i2 = 0; i2 < level; i2++) {
          if (scale instanceof CompositeScale) {
            scale = scale.source_scale;
          } else {
            logger.warn(`can't reach sub-coordinate level ${level} for ${scale} in ${dim} dimension; stopped at ${i2}`);
            break;
          }
        }
        if (scale instanceof CompositeScale) {
          return scale.target_scale;
        } else {
          return scale;
        }
      };
      const { x_scale, y_scale } = rv.coordinates;
      x_scales.push(process(x_scale, "x"));
      y_scales.push(process(y_scale, "y"));
    }
    const zoom_info = scale_range(x_scales, y_scales, x_target, y_target, this.factor, x_axis, y_axis);
    this.plot_view.state.push("zoom_out", { range: zoom_info });
    this.plot_view.update_range(zoom_info, { scrolling: true, maintain_focus: this.model.maintain_focus });
    (_a34 = this.model.document) == null ? void 0 : _a34.interactive_start(this.plot_view.model);
    this.plot_view.trigger_ranges_update_event();
  }
};
__publicField(ZoomBaseToolView, "__name__", "ZoomBaseToolView");
var _ZoomBaseTool = class _ZoomBaseTool extends PlotActionTool {
  constructor(attrs) {
    super(attrs);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
};
__publicField(_ZoomBaseTool, "__name__", "ZoomBaseTool");
_ZoomBaseTool.define(({ Percent: Percent2, Or: Or2, List: List2, Ref: Ref2, Auto: Auto2, NonNegative: NonNegative2, Int: Int2 }) => ({
  factor: [Percent2, 0.1],
  dimensions: [Dimensions, "both"],
  renderers: [Or2(List2(Ref2(DataRenderer)), Auto2), "auto"],
  level: [NonNegative2(Int2), 0]
}));
var ZoomBaseTool = _ZoomBaseTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/zoom_in_tool.js
import { tool_icon_zoom_in } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ZoomInToolView = class extends ZoomBaseToolView {
  get factor() {
    return this.model.factor;
  }
};
__publicField(ZoomInToolView, "__name__", "ZoomInToolView");
var _ZoomInTool = class _ZoomInTool extends ZoomBaseTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "maintain_focus", true);
    __publicField(this, "tool_name", "Zoom In");
    __publicField(this, "tool_icon", tool_icon_zoom_in);
  }
};
__publicField(_ZoomInTool, "__name__", "ZoomInTool");
_ZoomInTool.prototype.default_view = ZoomInToolView;
_ZoomInTool.register_alias("zoom_in", () => new _ZoomInTool({ dimensions: "both" }));
_ZoomInTool.register_alias("xzoom_in", () => new _ZoomInTool({ dimensions: "width" }));
_ZoomInTool.register_alias("yzoom_in", () => new _ZoomInTool({ dimensions: "height" }));
var ZoomInTool = _ZoomInTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/actions/zoom_out_tool.js
import { tool_icon_zoom_out } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ZoomOutToolView = class extends ZoomBaseToolView {
  get factor() {
    const { factor } = this.model;
    return -factor / (1 - factor);
  }
};
__publicField(ZoomOutToolView, "__name__", "ZoomOutToolView");
var _ZoomOutTool = class _ZoomOutTool extends ZoomBaseTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "maintain_focus");
    __publicField(this, "tool_name", "Zoom Out");
    __publicField(this, "tool_icon", tool_icon_zoom_out);
  }
};
__publicField(_ZoomOutTool, "__name__", "ZoomOutTool");
_ZoomOutTool.prototype.default_view = ZoomOutToolView;
_ZoomOutTool.define(({ Bool: Bool2 }) => ({
  maintain_focus: [Bool2, true]
}));
_ZoomOutTool.register_alias("zoom_out", () => new _ZoomOutTool({ dimensions: "both" }));
_ZoomOutTool.register_alias("xzoom_out", () => new _ZoomOutTool({ dimensions: "width" }));
_ZoomOutTool.register_alias("yzoom_out", () => new _ZoomOutTool({ dimensions: "height" }));
var ZoomOutTool = _ZoomOutTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/edit_tool.js
var EditToolView = class extends GestureToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_basepoint");
    __publicField(this, "_mouse_in_frame", true);
  }
  _select_mode(ev) {
    const { shift, ctrl: ctrl2 } = ev.modifiers;
    if (!shift && !ctrl2) {
      return "replace";
    } else if (shift && !ctrl2) {
      return "append";
    } else if (!shift && ctrl2) {
      return "intersect";
    } else if (shift && ctrl2) {
      return "subtract";
    } else {
      unreachable();
    }
  }
  _move_enter(_e) {
    this._mouse_in_frame = true;
  }
  _move_exit(_e) {
    this._mouse_in_frame = false;
  }
  _map_drag(sx, sy, renderer) {
    const frame = this.plot_view.frame;
    if (!frame.bbox.contains(sx, sy)) {
      return null;
    }
    const renderer_view = this.plot_view.views.find_one(renderer);
    if (renderer_view == null) {
      return null;
    }
    const x2 = renderer_view.coordinates.x_scale.invert(sx);
    const y2 = renderer_view.coordinates.y_scale.invert(sy);
    return [x2, y2];
  }
  _delete_selected(renderer) {
    const cds = renderer.data_source;
    const indices = cds.selected.indices;
    indices.sort();
    for (const column of cds.columns()) {
      const values2 = cds.get_array(column);
      for (let index2 = 0; index2 < indices.length; index2++) {
        const ind = indices[index2];
        values2.splice(ind - index2, 1);
      }
    }
    this._emit_cds_changes(cds);
  }
  _pop_glyphs(cds, num_objects) {
    const columns2 = cds.columns();
    if (num_objects == 0 || columns2.length == 0) {
      return;
    }
    const data3 = dict(cds.data);
    for (const column of columns2) {
      let array2 = cds.get_array(column);
      const drop = array2.length - num_objects + 1;
      if (drop < 1) {
        continue;
      }
      if (!isArray(array2)) {
        array2 = Array.from(array2);
        data3.set(column, array2);
      }
      array2.splice(0, drop);
    }
  }
  _emit_cds_changes(cds, redraw = true, clear2 = true, emit = true) {
    if (clear2) {
      cds.selection_manager.clear();
    }
    if (redraw) {
      cds.change.emit();
    }
    if (emit) {
      const { data: data3 } = cds;
      cds.setv({ data: data3 }, { check_eq: false });
    }
  }
  _drag_points(ev, renderers, dim = "both") {
    if (this._basepoint == null) {
      return;
    }
    const [bx, by] = this._basepoint;
    for (const renderer of renderers) {
      const basepoint = this._map_drag(bx, by, renderer);
      const point = this._map_drag(ev.sx, ev.sy, renderer);
      if (point == null || basepoint == null) {
        continue;
      }
      const [x2, y2] = point;
      const [px2, py] = basepoint;
      const [dx, dy] = [x2 - px2, y2 - py];
      const { glyph } = renderer;
      const cds = renderer.data_source;
      const data3 = dict(cds.data);
      const xkey = isField(glyph.x) ? glyph.x.field : null;
      const ykey = isField(glyph.y) ? glyph.y.field : null;
      for (const index2 of cds.selected.indices) {
        if (xkey != null && (dim == "width" || dim == "both")) {
          const column = data3.get(xkey) ?? [];
          column[index2] += dx;
        }
        if (ykey != null && (dim == "height" || dim == "both")) {
          const column = data3.get(ykey) ?? [];
          column[index2] += dy;
        }
      }
      cds.change.emit();
    }
    this._basepoint = [ev.sx, ev.sy];
  }
  _pad_empty_columns(cds, coord_columns) {
    const { inferred_defaults } = cds;
    const default_values = dict(cds.default_values);
    const default_overrides = dict(this.model.default_overrides);
    for (const column of cds.columns()) {
      if (!includes(coord_columns, column)) {
        const default_value = (() => {
          if (default_overrides.has(column)) {
            return default_overrides.get(column);
          } else if (default_values.has(column)) {
            return default_values.get(column);
          } else if (inferred_defaults.has(column)) {
            return inferred_defaults.get(column);
          } else {
            return this.model.empty_value;
          }
        })();
        cds.get_array(column).push(default_value);
      }
    }
  }
  _select_event(ev, mode, renderers) {
    const frame = this.plot_view.frame;
    const { sx, sy } = ev;
    if (!frame.bbox.contains(sx, sy)) {
      return [];
    }
    const geometry = { type: "point", sx, sy };
    const selected = [];
    for (const renderer of renderers) {
      const sm = renderer.get_selection_manager();
      const cds = renderer.data_source;
      const view = this.plot_view.views.find_one(renderer);
      if (view != null) {
        const did_hit = sm.select([view], geometry, true, mode);
        if (did_hit) {
          selected.push(renderer);
        }
        cds.properties.selected.change.emit();
      }
    }
    return selected;
  }
};
__publicField(EditToolView, "__name__", "EditToolView");
var _EditTool = class _EditTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_EditTool, "__name__", "EditTool");
_EditTool.define(({ Unknown: Unknown2, Dict: Dict2 }) => ({
  default_overrides: [Dict2(Unknown2), {}],
  empty_value: [Unknown2, 0]
}));
var EditTool = _EditTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/box_edit_tool.js
import { tool_icon_box_edit } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var BoxEditToolView = class extends EditToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_draw_basepoint");
    __publicField(this, "_recent_renderers", []);
  }
  _tap(ev) {
    if (this._draw_basepoint != null || this._basepoint != null) {
      return;
    }
    this._recent_renderers = this._select_event(ev, this._select_mode(ev), this.model.renderers);
  }
  _keyup(ev) {
    if (!this.model.active || !this._mouse_in_frame) {
      return;
    }
    for (const renderer of this.model.renderers) {
      if (ev.key == "Backspace") {
        this._delete_selected(renderer);
      } else if (ev.key == "Escape") {
        const cds = renderer.data_source;
        cds.selection_manager.clear();
      }
    }
  }
  _set_extent([sx0, sx1], [sy0, sy1], append, emit = false) {
    const renderer = this._recent_renderers[0] ?? this.model.renderers[0];
    const renderer_view = this.plot_view.views.find_one(renderer);
    if (renderer_view == null) {
      return;
    }
    const { glyph } = renderer;
    const cds = renderer.data_source;
    const data3 = dict(cds.data);
    const [dx0, dx1] = renderer_view.coordinates.x_scale.r_invert(sx0, sx1);
    const [dy0, dy1] = renderer_view.coordinates.y_scale.r_invert(sy0, sy1);
    const fields = (() => {
      if (glyph instanceof Rect) {
        const { x: x2, y: y2, width, height } = glyph;
        if (isField(x2) && isField(y2) && isField(width) && isField(height)) {
          return {
            [x2.field]: (dx0 + dx1) / 2,
            [y2.field]: (dy0 + dy1) / 2,
            [width.field]: dx1 - dx0,
            [height.field]: dy1 - dy0
          };
        }
      } else if (glyph instanceof Block) {
        const { x: x2, y: y2, width, height } = glyph;
        if (isField(x2) && isField(y2) && isField(width) && isField(height)) {
          return {
            [x2.field]: dx0,
            [y2.field]: dy0,
            [width.field]: dx1 - dx0,
            [height.field]: dy1 - dy0
          };
        }
      } else if (glyph instanceof Quad) {
        const { right: right3, bottom, left: left2, top } = glyph;
        if (isField(right3) && isField(bottom) && isField(left2) && isField(top)) {
          return {
            [right3.field]: dx1,
            [bottom.field]: dy0,
            [left2.field]: dx0,
            [top.field]: dy1
          };
        }
      } else if (glyph instanceof HBar) {
        const { left: left2, y: y2, height, right: right3 } = glyph;
        if (isField(left2) && isField(y2) && isField(height) && isField(right3)) {
          return {
            [left2.field]: dx0,
            [y2.field]: (dy0 + dy1) / 2,
            [height.field]: dy1 - dy0,
            [right3.field]: dx1
          };
        }
      } else if (glyph instanceof VBar) {
        const { x: x2, bottom, width, top } = glyph;
        if (isField(x2) && isField(bottom) && isField(width) && isField(top)) {
          return {
            [x2.field]: (dx0 + dx1) / 2,
            [bottom.field]: dy0,
            [width.field]: dx1 - dx0,
            [top.field]: dy1
          };
        }
      } else if (glyph instanceof HStrip) {
        const { y0, y1 } = glyph;
        if (isField(y0) && isField(y1)) {
          return {
            [y0.field]: dy0,
            [y1.field]: dy1
          };
        }
      } else if (glyph instanceof VStrip) {
        const { x0, x1 } = glyph;
        if (isField(x0) && isField(x1)) {
          return {
            [x0.field]: dx0,
            [x1.field]: dx1
          };
        }
      } else {
        unreachable(`'${glyph.type}' is not supported"`);
      }
      return null;
    })();
    if (fields == null) {
      return;
    }
    if (append) {
      this._pop_glyphs(cds, this.model.num_objects);
      for (const [key, val] of entries(fields)) {
        cds.get_array(key).push(val);
      }
      this._pad_empty_columns(cds, keys(fields));
    } else {
      const length = cds.get_length();
      if (length == null) {
        return;
      }
      const index2 = length - 1;
      for (const [key, val] of entries(fields)) {
        data3.get(key)[index2] = val;
      }
    }
    this._emit_cds_changes(cds, true, false, emit);
  }
  _update_box(ev, append = false, emit = false) {
    if (this._draw_basepoint == null) {
      return;
    }
    const curpoint = [ev.sx, ev.sy];
    const frame = this.plot_view.frame;
    const dims = this.model.dimensions;
    const [sxlim, sylim] = this.model._get_dim_limits(this._draw_basepoint, curpoint, frame, dims);
    this._set_extent(sxlim, sylim, append, emit);
  }
  _press(ev) {
    if (!this.model.active) {
      return;
    }
    if (this._draw_basepoint != null) {
      this._update_box(ev, false, true);
      this._draw_basepoint = null;
    } else {
      this._draw_basepoint = [ev.sx, ev.sy];
      this._select_event(ev, "append", this.model.renderers);
      this._update_box(ev, true, false);
    }
  }
  _move(ev) {
    this._update_box(ev, false, false);
  }
  _pan_start(ev) {
    if (ev.modifiers.shift) {
      if (this._draw_basepoint != null) {
        return;
      }
      this._draw_basepoint = [ev.sx, ev.sy];
      this._update_box(ev, true, false);
    } else {
      if (this._basepoint != null) {
        return;
      }
      this._recent_renderers = this._select_event(ev, "append", this.model.renderers);
      this._basepoint = [ev.sx, ev.sy];
    }
  }
  _pan(ev, append = false, emit = false) {
    if (ev.modifiers.shift) {
      if (this._draw_basepoint == null) {
        return;
      }
      this._update_box(ev, append, emit);
    } else {
      if (this._basepoint == null) {
        return;
      }
      this._drag_points(ev, this.model.renderers);
    }
  }
  _drag_points(ev, renderers, dim = "both") {
    if (this._basepoint == null) {
      return;
    }
    const [bx, by] = this._basepoint;
    for (const renderer of renderers) {
      const basepoint = this._map_drag(bx, by, renderer);
      const point = this._map_drag(ev.sx, ev.sy, renderer);
      if (point == null || basepoint == null) {
        continue;
      }
      const [x2, y2] = point;
      const [px2, py] = basepoint;
      const dx = dim == "width" || dim == "both" ? x2 - px2 : 0;
      const dy = dim == "height" || dim == "both" ? y2 - py : 0;
      const { glyph } = renderer;
      const cds = renderer.data_source;
      const data3 = dict(cds.data);
      const fields = {};
      if (glyph instanceof XYGlyph) {
        const { x: x3, y: y3 } = glyph;
        if (isField(x3)) {
          fields[x3.field] = dx;
        }
        if (isField(y3)) {
          fields[y3.field] = dy;
        }
      } else if (glyph instanceof Block) {
        const { x: x3, y: y3 } = glyph;
        if (isField(x3)) {
          fields[x3.field] = dx;
        }
        if (isField(y3)) {
          fields[y3.field] = dy;
        }
      } else if (glyph instanceof Quad) {
        const { right: right3, bottom, left: left2, top } = glyph;
        if (isField(left2) && isField(right3)) {
          fields[left2.field] = dx;
          fields[right3.field] = dx;
        }
        if (isField(top) && isField(bottom)) {
          fields[top.field] = dy;
          fields[bottom.field] = dy;
        }
      } else if (glyph instanceof HBar) {
        const { left: left2, right: right3, y: y3 } = glyph;
        if (isField(left2) && isField(right3)) {
          fields[left2.field] = dx;
          fields[right3.field] = dx;
        }
        if (isField(y3)) {
          fields[y3.field] = dy;
        }
      } else if (glyph instanceof VBar) {
        const { x: x3, top, bottom } = glyph;
        if (isField(x3)) {
          fields[x3.field] = dx;
        }
        if (isField(top) && isField(bottom)) {
          fields[top.field] = dy;
          fields[bottom.field] = dy;
        }
      } else if (glyph instanceof HStrip) {
        const { y0, y1 } = glyph;
        if (isField(y0) && isField(y1)) {
          fields[y0.field] = dy;
          fields[y1.field] = dy;
        }
      } else if (glyph instanceof VStrip) {
        const { x0, x1 } = glyph;
        if (isField(x0) && isField(x1)) {
          fields[x0.field] = dx;
          fields[x1.field] = dx;
        }
      } else {
        unreachable(`'${glyph.type}' is not supported"`);
      }
      for (const index2 of cds.selected.indices) {
        for (const [key, val] of entries(fields)) {
          const column = data3.get(key) ?? [];
          column[index2] += val;
        }
      }
      cds.change.emit();
    }
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan_end(ev) {
    this._pan(ev, false, true);
    if (ev.modifiers.shift) {
      this._draw_basepoint = null;
    } else {
      this._basepoint = null;
      for (const renderer of this.model.renderers) {
        this._emit_cds_changes(renderer.data_source, false, true, true);
      }
    }
  }
};
__publicField(BoxEditToolView, "__name__", "BoxEditToolView");
var _BoxEditTool = class _BoxEditTool extends EditTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Box Edit Tool");
    __publicField(this, "tool_icon", tool_icon_box_edit);
    __publicField(this, "event_type", ["tap", "press", "pan", "move"]);
    __publicField(this, "default_order", 1);
  }
};
__publicField(_BoxEditTool, "__name__", "BoxEditTool");
_BoxEditTool.prototype.default_view = BoxEditToolView;
_BoxEditTool.define(({ Int: Int2, List: List2, Ref: Ref2 }) => ({
  dimensions: [Dimensions, "both"],
  num_objects: [Int2, 0],
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
var BoxEditTool = _BoxEditTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/freehand_draw_tool.js
import { tool_icon_freehand_draw } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var FreehandDrawToolView = class extends EditToolView {
  _draw(ev, mode, emit = false) {
    if (!this.model.active) {
      return;
    }
    const renderer = this.model.renderers[0];
    const point = this._map_drag(ev.sx, ev.sy, renderer);
    if (point == null) {
      return;
    }
    const [x2, y2] = point;
    const { glyph, data_source } = renderer;
    const xkey = isField(glyph.xs) ? glyph.xs.field : null;
    const ykey = isField(glyph.ys) ? glyph.ys.field : null;
    const data3 = dict(data_source.data);
    if (mode == "new") {
      this._pop_glyphs(data_source, this.model.num_objects);
      if (xkey != null) {
        data_source.get_array(xkey).push([x2]);
      }
      if (ykey != null) {
        data_source.get_array(ykey).push([y2]);
      }
      this._pad_empty_columns(data_source, [xkey, ykey]);
    } else if (mode == "add") {
      if (xkey != null) {
        const column = data3.get(xkey) ?? [];
        const xidx = column.length - 1;
        let xs = data_source.get_array(xkey)[xidx];
        if (!isArray(xs)) {
          xs = Array.from(xs);
          column[xidx] = xs;
        }
        xs.push(x2);
      }
      if (ykey != null) {
        const column = data3.get(ykey) ?? [];
        const yidx = column.length - 1;
        let ys = data_source.get_array(ykey)[yidx];
        if (!isArray(ys)) {
          ys = Array.from(ys);
          column[yidx] = ys;
        }
        ys.push(y2);
      }
    }
    this._emit_cds_changes(data_source, true, true, emit);
  }
  _pan_start(ev) {
    this._draw(ev, "new");
  }
  _pan(ev) {
    this._draw(ev, "add");
  }
  _pan_end(ev) {
    this._draw(ev, "add", true);
  }
  _tap(ev) {
    this._select_event(ev, this._select_mode(ev), this.model.renderers);
  }
  _keyup(ev) {
    if (!this.model.active || !this._mouse_in_frame) {
      return;
    }
    for (const renderer of this.model.renderers) {
      if (ev.key == "Escape") {
        renderer.data_source.selection_manager.clear();
      } else if (ev.key == "Backspace") {
        this._delete_selected(renderer);
      }
    }
  }
};
__publicField(FreehandDrawToolView, "__name__", "FreehandDrawToolView");
var _FreehandDrawTool = class _FreehandDrawTool extends EditTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Freehand Draw Tool");
    __publicField(this, "tool_icon", tool_icon_freehand_draw);
    __publicField(this, "event_type", ["pan", "tap"]);
    __publicField(this, "default_order", 3);
  }
};
__publicField(_FreehandDrawTool, "__name__", "FreehandDrawTool");
_FreehandDrawTool.prototype.default_view = FreehandDrawToolView;
_FreehandDrawTool.define(({ Int: Int2, List: List2, Ref: Ref2 }) => ({
  num_objects: [Int2, 0],
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
_FreehandDrawTool.register_alias("freehand_draw", () => new _FreehandDrawTool());
var FreehandDrawTool = _FreehandDrawTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/line_tool.js
var LineToolView = class extends EditToolView {
  _set_intersection(x2, y2) {
    const point_glyph = this.model.intersection_renderer.glyph;
    const point_cds = this.model.intersection_renderer.data_source;
    const data3 = dict(point_cds.data);
    const pxkey = isField(point_glyph.x) ? point_glyph.x.field : null;
    const pykey = isField(point_glyph.y) ? point_glyph.y.field : null;
    if (pxkey != null) {
      if (isArray(x2)) {
        data3.set(pxkey, x2);
      } else {
        point_glyph.x = { value: x2 };
      }
    }
    if (pykey != null) {
      if (isArray(y2)) {
        data3.set(pykey, y2);
      } else {
        point_glyph.y = { value: y2 };
      }
    }
    this._emit_cds_changes(point_cds, true, true, false);
  }
  _hide_intersections() {
    this._set_intersection([], []);
  }
};
__publicField(LineToolView, "__name__", "LineToolView");
var _LineTool = class _LineTool extends EditTool {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_LineTool, "__name__", "LineTool");
_LineTool.define(({ Ref: Ref2 }) => ({
  intersection_renderer: [Ref2(GlyphRenderer)]
}));
var LineTool = _LineTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/line_edit_tool.js
import { tool_icon_line_edit } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var LineEditToolView = class extends LineToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_selected_renderer");
    __publicField(this, "_drawing", false);
  }
  _press(ev) {
    if (!this.model.active) {
      return;
    }
    const renderers = this.model.renderers;
    for (const renderer of renderers) {
      const line_selected = this._select_event(ev, "replace", [renderer]);
      if (line_selected.length == 1) {
        this._selected_renderer = renderer;
      }
    }
    this._show_intersections();
    this._update_line_cds();
  }
  _show_intersections() {
    if (!this.model.active) {
      return;
    }
    if (this._selected_renderer == null) {
      return;
    }
    const renderers = this.model.renderers;
    if (renderers.length == 0) {
      this._set_intersection([], []);
      this._selected_renderer = null;
      this._drawing = false;
      return;
    }
    const { glyph } = this._selected_renderer;
    if (!isField(glyph.x) || !isField(glyph.y)) {
      return;
    }
    const [xkey, ykey] = [glyph.x.field, glyph.y.field];
    const cds = this._selected_renderer.data_source;
    const x2 = cds.get_array(xkey);
    const y2 = cds.get_array(ykey);
    this._set_intersection(x2, y2);
  }
  _tap(ev) {
    const renderer = this.model.intersection_renderer;
    const point = this._map_drag(ev.sx, ev.sy, renderer);
    if (point == null) {
      return;
    } else if (this._drawing && this._selected_renderer != null) {
      const mode2 = this._select_mode(ev);
      const selected_points = this._select_event(ev, mode2, [renderer]);
      if (selected_points.length == 0) {
        return;
      }
    }
    const mode = this._select_mode(ev);
    this._select_event(ev, mode, [renderer]);
    this._select_event(ev, mode, this.model.renderers);
  }
  _update_line_cds() {
    if (this._selected_renderer == null) {
      return;
    }
    const point_glyph = this.model.intersection_renderer.glyph;
    const point_cds = this.model.intersection_renderer.data_source;
    const data3 = dict(point_cds.data);
    const pxkey = isField(point_glyph.x) ? point_glyph.x.field : null;
    const pykey = isField(point_glyph.y) ? point_glyph.y.field : null;
    if (pxkey != null && pykey != null) {
      const x2 = data3.get(pxkey);
      const y2 = data3.get(pykey);
      if (x2 != null) {
        dict(this._selected_renderer.data_source.data).set(pxkey, x2);
      }
      if (y2 != null) {
        dict(this._selected_renderer.data_source.data).set(pykey, y2);
      }
    }
    this._emit_cds_changes(this._selected_renderer.data_source, true, true, false);
  }
  _pan_start(ev) {
    this._select_event(ev, "append", [this.model.intersection_renderer]);
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan(ev) {
    if (this._basepoint == null) {
      return;
    }
    this._drag_points(ev, [this.model.intersection_renderer], this.model.dimensions);
    if (this._selected_renderer != null) {
      this._selected_renderer.data_source.change.emit();
    }
  }
  _pan_end(ev) {
    if (this._basepoint == null) {
      return;
    }
    this._drag_points(ev, [this.model.intersection_renderer]);
    this._emit_cds_changes(this.model.intersection_renderer.data_source, false, true, true);
    if (this._selected_renderer != null) {
      this._emit_cds_changes(this._selected_renderer.data_source);
    }
    this._basepoint = null;
  }
  activate() {
    this._drawing = true;
  }
  deactivate() {
    if (this._selected_renderer == null) {
      return;
    } else if (this._drawing) {
      this._drawing = false;
    }
    this._hide_intersections();
  }
};
__publicField(LineEditToolView, "__name__", "LineEditToolView");
var _LineEditTool = class _LineEditTool extends LineTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Line Edit Tool");
    __publicField(this, "tool_icon", tool_icon_line_edit);
    __publicField(this, "event_type", ["tap", "press", "pan", "move"]);
    __publicField(this, "default_order", 4);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
};
__publicField(_LineEditTool, "__name__", "LineEditTool");
_LineEditTool.prototype.default_view = LineEditToolView;
_LineEditTool.define(({ List: List2, Ref: Ref2 }) => ({
  dimensions: [Dimensions, "both"],
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
var LineEditTool = _LineEditTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/point_draw_tool.js
import { tool_icon_point_draw } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var PointDrawToolView = class extends EditToolView {
  _tap(ev) {
    const renderers = this._select_event(ev, this._select_mode(ev), this.model.renderers);
    if (renderers.length != 0 || !this.model.add) {
      return;
    }
    const renderer = this.model.renderers[0];
    const point = this._map_drag(ev.sx, ev.sy, renderer);
    if (point == null) {
      return;
    }
    const { glyph, data_source } = renderer;
    const xkey = isField(glyph.x) ? glyph.x.field : null;
    const ykey = isField(glyph.y) ? glyph.y.field : null;
    const [x2, y2] = point;
    this._pop_glyphs(data_source, this.model.num_objects);
    if (xkey != null) {
      data_source.get_array(xkey).push(x2);
    }
    if (ykey != null) {
      data_source.get_array(ykey).push(y2);
    }
    this._pad_empty_columns(data_source, [xkey, ykey]);
    const { data: data3 } = data_source;
    data_source.setv({ data: data3 }, { check_eq: false });
  }
  _keyup(ev) {
    if (!this.model.active || !this._mouse_in_frame) {
      return;
    }
    for (const renderer of this.model.renderers) {
      if (ev.key == "Backspace") {
        this._delete_selected(renderer);
      } else if (ev.key == "Escape") {
        renderer.data_source.selection_manager.clear();
      }
    }
  }
  _pan_start(ev) {
    if (!this.model.drag) {
      return;
    }
    this._select_event(ev, "append", this.model.renderers);
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan(ev) {
    if (!this.model.drag || this._basepoint == null) {
      return;
    }
    this._drag_points(ev, this.model.renderers);
  }
  _pan_end(ev) {
    if (!this.model.drag) {
      return;
    }
    this._pan(ev);
    for (const renderer of this.model.renderers) {
      this._emit_cds_changes(renderer.data_source, false, true, true);
    }
    this._basepoint = null;
  }
};
__publicField(PointDrawToolView, "__name__", "PointDrawToolView");
var _PointDrawTool = class _PointDrawTool extends EditTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Point Draw Tool");
    __publicField(this, "tool_icon", tool_icon_point_draw);
    __publicField(this, "event_type", ["tap", "pan", "move"]);
    __publicField(this, "default_order", 2);
  }
};
__publicField(_PointDrawTool, "__name__", "PointDrawTool");
_PointDrawTool.prototype.default_view = PointDrawToolView;
_PointDrawTool.define(({ Bool: Bool2, Int: Int2, List: List2, Ref: Ref2 }) => ({
  add: [Bool2, true],
  drag: [Bool2, true],
  num_objects: [Int2, 0],
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
var PointDrawTool = _PointDrawTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/poly_tool.js
var PolyToolView = class extends EditToolView {
  _set_vertices(xs, ys) {
    const { vertex_renderer } = this.model;
    assert(vertex_renderer != null);
    const point_glyph = vertex_renderer.glyph;
    const point_cds = vertex_renderer.data_source;
    const pxkey = isField(point_glyph.x) ? point_glyph.x.field : null;
    const pykey = isField(point_glyph.y) ? point_glyph.y.field : null;
    const data3 = dict(point_cds.data);
    if (pxkey != null) {
      if (isArray(xs)) {
        data3.set(pxkey, xs);
      } else {
        point_glyph.x = { value: xs };
      }
    }
    if (pykey != null) {
      if (isArray(ys)) {
        data3.set(pykey, ys);
      } else {
        point_glyph.y = { value: ys };
      }
    }
    this._emit_cds_changes(point_cds, true, true, false);
  }
  _hide_vertices() {
    this._set_vertices([], []);
  }
  _snap_to_vertex(ev, x2, y2) {
    if (this.model.vertex_renderer != null) {
      const vertex_selected = this._select_event(ev, "replace", [this.model.vertex_renderer]);
      const point_ds = this.model.vertex_renderer.data_source;
      const point_glyph = this.model.vertex_renderer.glyph;
      const pxkey = isField(point_glyph.x) ? point_glyph.x.field : null;
      const pykey = isField(point_glyph.y) ? point_glyph.y.field : null;
      if (vertex_selected.length != 0) {
        const index2 = point_ds.selected.indices[0];
        const data3 = dict(point_ds.data);
        if (pxkey != null) {
          x2 = data3.get(pxkey)[index2];
        }
        if (pykey != null) {
          y2 = data3.get(pykey)[index2];
        }
        point_ds.selection_manager.clear();
      }
    }
    return [x2, y2];
  }
};
__publicField(PolyToolView, "__name__", "PolyToolView");
var _PolyTool = class _PolyTool extends EditTool {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PolyTool, "__name__", "PolyTool");
_PolyTool.define(({ Ref: Ref2, Nullable: Nullable2 }) => ({
  vertex_renderer: [Nullable2(Ref2(GlyphRenderer)), null]
}));
var PolyTool = _PolyTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/poly_draw_tool.js
import { tool_icon_poly_draw } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var PolyDrawToolView = class extends PolyToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_drawing", false);
    __publicField(this, "_initialized", false);
  }
  _tap(ev) {
    if (this._drawing) {
      this._draw(ev, "add", true);
    } else {
      this._select_event(ev, this._select_mode(ev), this.model.renderers);
    }
  }
  _draw(ev, mode, emit = false) {
    const renderer = this.model.renderers[0];
    const point = this._map_drag(ev.sx, ev.sy, renderer);
    if (!this._initialized) {
      this.activate();
    }
    if (point == null) {
      return;
    }
    const [x2, y2] = this._snap_to_vertex(ev, ...point);
    const cds = renderer.data_source;
    const data3 = dict(cds.data);
    const glyph = renderer.glyph;
    const xkey = isField(glyph.xs) ? glyph.xs.field : null;
    const ykey = isField(glyph.ys) ? glyph.ys.field : null;
    if (mode == "new") {
      this._pop_glyphs(cds, this.model.num_objects);
      if (xkey != null) {
        cds.get_array(xkey).push([x2, x2]);
      }
      if (ykey != null) {
        cds.get_array(ykey).push([y2, y2]);
      }
      this._pad_empty_columns(cds, [xkey, ykey]);
    } else if (mode == "edit") {
      if (xkey != null) {
        const column = data3.get(xkey) ?? [];
        const xs = column[column.length - 1];
        xs[xs.length - 1] = x2;
      }
      if (ykey != null) {
        const column = data3.get(ykey) ?? [];
        const ys = column[column.length - 1];
        ys[ys.length - 1] = y2;
      }
    } else if (mode == "add") {
      if (xkey != null) {
        const column = data3.get(xkey) ?? [];
        const xidx = column.length - 1;
        let xs = cds.get_array(xkey)[xidx];
        const nx = xs[xs.length - 1];
        xs[xs.length - 1] = x2;
        if (!isArray(xs)) {
          xs = Array.from(xs);
          column[xidx] = xs;
        }
        xs.push(nx);
      }
      if (ykey != null) {
        const column = data3.get(ykey) ?? [];
        const yidx = column.length - 1;
        let ys = cds.get_array(ykey)[yidx];
        const ny = ys[ys.length - 1];
        ys[ys.length - 1] = y2;
        if (!isArray(ys)) {
          ys = Array.from(ys);
          column[yidx] = ys;
        }
        ys.push(ny);
      }
    }
    this._emit_cds_changes(cds, true, false, emit);
  }
  _show_vertices() {
    if (!this.model.active) {
      return;
    }
    const xs = [];
    const ys = [];
    for (let i2 = 0; i2 < this.model.renderers.length; i2++) {
      const renderer = this.model.renderers[i2];
      const { glyph, data_source } = renderer;
      const xkey = isField(glyph.xs) ? glyph.xs.field : null;
      const ykey = isField(glyph.ys) ? glyph.ys.field : null;
      if (xkey != null) {
        for (const array2 of data_source.get_array(xkey)) {
          xs.push(...array2);
        }
      }
      if (ykey != null) {
        for (const array2 of data_source.get_array(ykey)) {
          ys.push(...array2);
        }
      }
      if (this._drawing && i2 == this.model.renderers.length - 1) {
        xs.splice(xs.length - 1, 1);
        ys.splice(ys.length - 1, 1);
      }
    }
    this._set_vertices(xs, ys);
  }
  _press(ev) {
    if (!this.model.active) {
      return;
    }
    if (this._drawing) {
      this._drawing = false;
      this._draw(ev, "edit", true);
    } else {
      this._drawing = true;
      this._draw(ev, "new", true);
    }
  }
  _move(ev) {
    if (this._drawing) {
      this._draw(ev, "edit");
    }
  }
  _remove() {
    const renderer = this.model.renderers[0];
    const { glyph, data_source } = renderer;
    const xkey = isField(glyph.xs) ? glyph.xs.field : null;
    const ykey = isField(glyph.ys) ? glyph.ys.field : null;
    const data3 = dict(data_source.data);
    if (xkey != null) {
      const column = data3.get(xkey) ?? [];
      const xidx = column.length - 1;
      const xs = data_source.get_array(xkey)[xidx];
      xs.splice(xs.length - 1, 1);
    }
    if (ykey != null) {
      const column = data3.get(ykey) ?? [];
      const yidx = column.length - 1;
      const ys = data_source.get_array(ykey)[yidx];
      ys.splice(ys.length - 1, 1);
    }
    this._emit_cds_changes(data_source);
  }
  _keyup(ev) {
    if (!this.model.active || !this._mouse_in_frame) {
      return;
    }
    for (const renderer of this.model.renderers) {
      if (ev.key == "Backspace") {
        this._delete_selected(renderer);
      } else if (ev.key == "Escape") {
        if (this._drawing) {
          this._remove();
          this._drawing = false;
        }
        renderer.data_source.selection_manager.clear();
      }
    }
  }
  _pan_start(ev) {
    if (!this.model.drag) {
      return;
    }
    this._select_event(ev, "append", this.model.renderers);
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan(ev) {
    if (this._basepoint == null || !this.model.drag) {
      return;
    }
    const [bx, by] = this._basepoint;
    for (const renderer of this.model.renderers) {
      const basepoint = this._map_drag(bx, by, renderer);
      const point = this._map_drag(ev.sx, ev.sy, renderer);
      if (point == null || basepoint == null) {
        continue;
      }
      const cds = renderer.data_source;
      const { glyph } = renderer;
      const xkey = isField(glyph.xs) ? glyph.xs.field : null;
      const ykey = isField(glyph.ys) ? glyph.ys.field : null;
      if (xkey == null && ykey == null) {
        continue;
      }
      const [x2, y2] = point;
      const [px2, py] = basepoint;
      const [dx, dy] = [x2 - px2, y2 - py];
      const data3 = dict(cds.data);
      for (const index2 of cds.selected.indices) {
        let length, xs, ys;
        if (xkey != null) {
          const column = data3.get(xkey) ?? [];
          xs = column[index2];
        }
        if (ykey != null) {
          const column = data3.get(ykey) ?? [];
          ys = column[index2];
          length = ys.length;
        } else {
          length = xs.length;
        }
        for (let i2 = 0; i2 < length; i2++) {
          if (xs) {
            xs[i2] += dx;
          }
          if (ys) {
            ys[i2] += dy;
          }
        }
      }
      cds.change.emit();
    }
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan_end(ev) {
    if (!this.model.drag) {
      return;
    }
    this._pan(ev);
    for (const renderer of this.model.renderers) {
      this._emit_cds_changes(renderer.data_source);
    }
    this._basepoint = null;
  }
  activate() {
    if (this.model.vertex_renderer == null || !this.model.active) {
      return;
    }
    this._show_vertices();
    if (!this._initialized) {
      for (const renderer of this.model.renderers) {
        const cds = renderer.data_source;
        cds.connect(cds.properties.data.change, () => this._show_vertices());
      }
    }
    this._initialized = true;
  }
  deactivate() {
    if (this._drawing) {
      this._remove();
      this._drawing = false;
    }
    if (this.model.vertex_renderer != null) {
      this._hide_vertices();
    }
  }
};
__publicField(PolyDrawToolView, "__name__", "PolyDrawToolView");
var _PolyDrawTool = class _PolyDrawTool extends PolyTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Polygon Draw Tool");
    __publicField(this, "tool_icon", tool_icon_poly_draw);
    __publicField(this, "event_type", ["pan", "tap", "press", "move"]);
    __publicField(this, "default_order", 3);
  }
};
__publicField(_PolyDrawTool, "__name__", "PolyDrawTool");
_PolyDrawTool.prototype.default_view = PolyDrawToolView;
_PolyDrawTool.define(({ Bool: Bool2, Int: Int2, List: List2, Ref: Ref2 }) => ({
  drag: [Bool2, true],
  num_objects: [Int2, 0],
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
var PolyDrawTool = _PolyDrawTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/edit/poly_edit_tool.js
import { tool_icon_poly_edit } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var PolyEditToolView = class extends PolyToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_selected_renderer");
    __publicField(this, "_drawing", false);
    __publicField(this, "_cur_index", null);
  }
  _press(ev) {
    if (this.model.vertex_renderer == null || !this.model.active) {
      return;
    }
    const point = this._map_drag(ev.sx, ev.sy, this.model.vertex_renderer);
    if (point == null) {
      return;
    }
    const [x2, y2] = point;
    const vertex_selected = this._select_event(ev, "replace", [this.model.vertex_renderer]);
    const point_cds = this.model.vertex_renderer.data_source;
    const point_glyph = this.model.vertex_renderer.glyph;
    const pxkey = isField(point_glyph.x) ? point_glyph.x.field : null;
    const pykey = isField(point_glyph.y) ? point_glyph.y.field : null;
    if (vertex_selected.length != 0 && this._selected_renderer != null) {
      const index2 = point_cds.selected.indices[0];
      if (this._drawing) {
        this._drawing = false;
        point_cds.selection_manager.clear();
      } else {
        point_cds.selected.indices = [index2 + 1];
        if (pxkey != null) {
          point_cds.get_array(pxkey).splice(index2 + 1, 0, x2);
        }
        if (pykey != null) {
          point_cds.get_array(pykey).splice(index2 + 1, 0, y2);
        }
        this._drawing = true;
      }
      point_cds.change.emit();
      this._emit_cds_changes(this._selected_renderer.data_source);
    } else {
      this._show_vertices(ev);
    }
  }
  _show_vertices(ev) {
    if (!this.model.active) {
      return;
    }
    if (this.model.renderers.length == 0) {
      return;
    }
    const vsync_renderer = this.model.renderers[0];
    const vsync_updater = () => this._update_vertices(vsync_renderer);
    const vsync_ds = vsync_renderer.data_source;
    const renderers = this._select_event(ev, "replace", this.model.renderers);
    if (renderers.length == 0) {
      this._set_vertices([], []);
      this._selected_renderer = null;
      this._drawing = false;
      this._cur_index = null;
      vsync_ds.disconnect(vsync_ds.properties.data.change, vsync_updater);
      return;
    }
    vsync_ds.connect(vsync_ds.properties.data.change, vsync_updater);
    this._cur_index = renderers[0].data_source.selected.indices[0];
    this._update_vertices(renderers[0]);
  }
  _update_vertices(renderer) {
    const { glyph } = renderer;
    const xkey = isField(glyph.xs) ? glyph.xs.field : null;
    const ykey = isField(glyph.ys) ? glyph.ys.field : null;
    const data3 = dict(renderer.data_source.data);
    const index2 = this._cur_index;
    if (this._drawing) {
      return;
    }
    if (index2 == null && (xkey != null || ykey != null)) {
      return;
    }
    let xs;
    let ys;
    if (xkey != null && index2 != null) {
      const column = data3.get(xkey) ?? [];
      xs = column[index2];
      if (!isArray(xs)) {
        column[index2] = xs = Array.from(xs);
      }
    } else {
      assert(isValue(glyph.xs));
      xs = glyph.xs.value;
    }
    if (ykey != null && index2 != null) {
      const column = data3.get(ykey) ?? [];
      ys = column[index2];
      if (!isArray(ys)) {
        column[index2] = ys = Array.from(ys);
      }
    } else {
      assert(isValue(glyph.ys));
      ys = glyph.ys.value;
    }
    this._selected_renderer = renderer;
    this._set_vertices(xs, ys);
  }
  _move(ev) {
    if (this._drawing && this._selected_renderer != null) {
      const renderer = this.model.vertex_renderer;
      if (renderer == null) {
        return;
      }
      const cds = renderer.data_source;
      const data3 = dict(cds.data);
      const { glyph } = renderer;
      const point = this._map_drag(ev.sx, ev.sy, renderer);
      if (point == null) {
        return;
      }
      let [x2, y2] = point;
      const indices = cds.selected.indices;
      [x2, y2] = this._snap_to_vertex(ev, x2, y2);
      cds.selected.indices = indices;
      const xkey = isField(glyph.x) ? glyph.x.field : null;
      const ykey = isField(glyph.y) ? glyph.y.field : null;
      const index2 = indices[0];
      if (xkey != null) {
        data3.get(xkey)[index2] = x2;
      }
      if (ykey != null) {
        data3.get(ykey)[index2] = y2;
      }
      cds.change.emit();
      this._selected_renderer.data_source.change.emit();
    }
  }
  _tap(ev) {
    const renderer = this.model.vertex_renderer;
    if (renderer == null) {
      return;
    }
    const point = this._map_drag(ev.sx, ev.sy, renderer);
    if (point == null) {
      return;
    } else if (this._drawing && this._selected_renderer != null) {
      let [x2, y2] = point;
      const cds = renderer.data_source;
      const { glyph } = renderer;
      const xkey = isField(glyph.x) ? glyph.x.field : null;
      const ykey = isField(glyph.y) ? glyph.y.field : null;
      const indices = cds.selected.indices;
      [x2, y2] = this._snap_to_vertex(ev, x2, y2);
      const index2 = indices[0];
      cds.selected.indices = [index2 + 1];
      if (xkey != null) {
        const xs = cds.get_array(xkey);
        const nx = xs[index2];
        xs[index2] = x2;
        xs.splice(index2 + 1, 0, nx);
      }
      if (ykey != null) {
        const ys = cds.get_array(ykey);
        const ny = ys[index2];
        ys[index2] = y2;
        ys.splice(index2 + 1, 0, ny);
      }
      cds.change.emit();
      this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);
      return;
    }
    const mode = this._select_mode(ev);
    this._select_event(ev, mode, [renderer]);
    this._select_event(ev, mode, this.model.renderers);
  }
  _remove_vertex() {
    if (!this._drawing || this._selected_renderer == null) {
      return;
    }
    const renderer = this.model.vertex_renderer;
    if (renderer == null) {
      return;
    }
    const { glyph, data_source } = renderer;
    const index2 = data_source.selected.indices[0];
    const xkey = isField(glyph.x) ? glyph.x.field : null;
    const ykey = isField(glyph.y) ? glyph.y.field : null;
    if (xkey != null) {
      data_source.get_array(xkey).splice(index2, 1);
    }
    if (ykey != null) {
      data_source.get_array(ykey).splice(index2, 1);
    }
    data_source.change.emit();
    this._emit_cds_changes(this._selected_renderer.data_source);
  }
  _pan_start(ev) {
    if (this.model.vertex_renderer == null) {
      return;
    }
    this._select_event(ev, "append", [this.model.vertex_renderer]);
    this._basepoint = [ev.sx, ev.sy];
  }
  _pan(ev) {
    if (this._basepoint == null) {
      return;
    }
    if (this.model.vertex_renderer == null) {
      return;
    }
    this._drag_points(ev, [this.model.vertex_renderer]);
    if (this._selected_renderer != null) {
      this._selected_renderer.data_source.change.emit();
    }
  }
  _pan_end(ev) {
    if (this._basepoint == null) {
      return;
    }
    if (this.model.vertex_renderer == null) {
      return;
    }
    this._drag_points(ev, [this.model.vertex_renderer]);
    this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);
    if (this._selected_renderer != null) {
      this._emit_cds_changes(this._selected_renderer.data_source);
    }
    this._basepoint = null;
  }
  _keyup(ev) {
    if (!this.model.active || !this._mouse_in_frame) {
      return;
    }
    let renderers;
    if (this._selected_renderer != null) {
      const { vertex_renderer } = this.model;
      renderers = vertex_renderer != null ? [vertex_renderer] : [];
    } else {
      renderers = this.model.renderers;
    }
    for (const renderer of renderers) {
      if (ev.key == "Backspace") {
        this._delete_selected(renderer);
        if (this._selected_renderer != null) {
          this._emit_cds_changes(this._selected_renderer.data_source);
        }
      } else if (ev.key == "Escape") {
        if (this._drawing) {
          this._remove_vertex();
          this._drawing = false;
        } else if (this._selected_renderer != null) {
          this._hide_vertices();
        }
        renderer.data_source.selection_manager.clear();
      }
    }
  }
  deactivate() {
    if (this._selected_renderer == null) {
      return;
    } else if (this._drawing) {
      this._remove_vertex();
      this._drawing = false;
    }
    this._hide_vertices();
  }
};
__publicField(PolyEditToolView, "__name__", "PolyEditToolView");
var _PolyEditTool = class _PolyEditTool extends PolyTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Poly Edit Tool");
    __publicField(this, "tool_icon", tool_icon_poly_edit);
    __publicField(this, "event_type", ["tap", "press", "pan", "move"]);
    __publicField(this, "default_order", 4);
  }
};
__publicField(_PolyEditTool, "__name__", "PolyEditTool");
_PolyEditTool.prototype.default_view = PolyEditToolView;
_PolyEditTool.define(({ List: List2, Ref: Ref2 }) => ({
  renderers: [List2(Ref2(GlyphRenderer)), []]
}));
var PolyEditTool = _PolyEditTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/select_tool.js
import * as icons7 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var _SelectToolView = class _SelectToolView extends GestureToolView {
  connect_signals() {
    super.connect_signals();
    this.model.invert.connect(() => this._invert_selection());
    this.model.clear.connect(() => this._clear_selection());
  }
  get computed_renderers() {
    const { renderers } = this.model;
    const all_renderers = this.plot_view.model.data_renderers;
    return compute_renderers(renderers, all_renderers);
  }
  _computed_renderers_by_data_source() {
    const renderers_by_source = /* @__PURE__ */ new Map();
    for (const r of this.computed_renderers) {
      let source2;
      if (r instanceof GlyphRenderer) {
        source2 = r.data_source;
      } else if (r instanceof GraphRenderer) {
        source2 = r.node_renderer.data_source;
      } else {
        continue;
      }
      const renderers = renderers_by_source.get(source2) ?? [];
      renderers_by_source.set(source2, [...renderers, r]);
    }
    return renderers_by_source;
  }
  _clear_overlay() {
  }
  _clear_other_overlays() {
    for (const view of this.plot_view.tool_views.values()) {
      if (view instanceof _SelectToolView && view != this) {
        view._clear_overlay();
      }
    }
  }
  _clear_selection() {
    const { computed_renderers } = this;
    const selection_managers = uniq(computed_renderers.map((r) => r.selection_manager));
    for (const selection_manager of selection_managers) {
      selection_manager.clear();
    }
    this.plot_view.request_paint(...computed_renderers);
  }
  _invert_selection() {
    const { computed_renderers } = this;
    const selection_managers = uniq(computed_renderers.map((r) => r.selection_manager));
    for (const selection_manager of selection_managers) {
      selection_manager.invert();
    }
    this.plot_view.request_paint(...computed_renderers);
  }
  _select_mode(modifiers) {
    const { shift, ctrl: ctrl2 } = modifiers;
    if (!shift && !ctrl2) {
      return this.model.mode;
    } else if (shift && !ctrl2) {
      return "append";
    } else if (!shift && ctrl2) {
      return "intersect";
    } else if (shift && ctrl2) {
      return "subtract";
    } else {
      unreachable();
    }
  }
  _keyup(ev) {
    if (!this.model.active) {
      return;
    }
    if (ev.key == "Escape") {
      this._clear_selection();
    }
  }
  _emit_selection_event(geometry, final = true) {
    const { x_scale, y_scale } = this.plot_view.frame;
    const geometry_data = (() => {
      switch (geometry.type) {
        case "point": {
          const { sx, sy } = geometry;
          const x2 = x_scale.invert(sx);
          const y2 = y_scale.invert(sy);
          return { ...geometry, x: x2, y: y2 };
        }
        case "span": {
          const { sx, sy } = geometry;
          const x2 = x_scale.invert(sx);
          const y2 = y_scale.invert(sy);
          return { ...geometry, x: x2, y: y2 };
        }
        case "rect": {
          const { sx0, sx1, sy0, sy1 } = geometry;
          const [x0, x1] = x_scale.r_invert(sx0, sx1);
          const [y0, y1] = y_scale.r_invert(sy0, sy1);
          return { ...geometry, x0, y0, x1, y1 };
        }
        case "poly": {
          const { sx, sy } = geometry;
          const x2 = x_scale.v_invert(sx);
          const y2 = y_scale.v_invert(sy);
          return { ...geometry, x: x2, y: y2 };
        }
      }
    })();
    this.plot_view.model.trigger_event(new SelectionGeometry(geometry_data, final));
  }
};
__publicField(_SelectToolView, "__name__", "SelectToolView");
var SelectToolView = _SelectToolView;
var _SelectTool = class _SelectTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "invert", new Signal0(this, "invert"));
    __publicField(this, "clear", new Signal0(this, "clear"));
  }
  get menu() {
    return [
      {
        icon: icons7.tool_icon_replace_mode,
        tooltip: "Replace the current selection",
        active: () => this.mode == "replace",
        handler: () => {
          this.mode = "replace";
          this.active = true;
        }
      },
      {
        icon: icons7.tool_icon_append_mode,
        tooltip: "Append to the current selection (Shift)",
        active: () => this.mode == "append",
        handler: () => {
          this.mode = "append";
          this.active = true;
        }
      },
      {
        icon: icons7.tool_icon_intersect_mode,
        tooltip: "Intersect with the current selection (Ctrl)",
        active: () => this.mode == "intersect",
        handler: () => {
          this.mode = "intersect";
          this.active = true;
        }
      },
      {
        icon: icons7.tool_icon_subtract_mode,
        tooltip: "Subtract from the current selection (Shift+Ctrl)",
        active: () => this.mode == "subtract",
        handler: () => {
          this.mode = "subtract";
          this.active = true;
        }
      },
      {
        icon: icons7.tool_icon_xor_mode,
        tooltip: "Symmetric difference with the current selection",
        active: () => this.mode == "xor",
        handler: () => {
          this.mode = "xor";
          this.active = true;
        }
      },
      null,
      {
        icon: icons7.tool_icon_invert_selection,
        tooltip: "Invert the current selection",
        handler: () => {
          this.invert.emit();
        }
      },
      {
        icon: icons7.tool_icon_clear_selection,
        tooltip: "Clear the current selection and/or selection overlay (Esc)",
        handler: () => {
          this.clear.emit();
        }
      }
    ];
  }
};
__publicField(_SelectTool, "__name__", "SelectTool");
_SelectTool.define(({ List: List2, Ref: Ref2, Or: Or2, Auto: Auto2 }) => ({
  renderers: [Or2(List2(Ref2(DataRenderer)), Auto2), "auto"]
}));
var SelectTool = _SelectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/region_select_tool.js
var RegionSelectToolView = class extends SelectToolView {
  get overlays() {
    return [...super.overlays, this.model.overlay];
  }
  _is_continuous(modifiers) {
    return this.model.continuous != modifiers.alt;
  }
  _select(geometry, final, mode) {
    const renderers_by_source = this._computed_renderers_by_data_source();
    for (const [, renderers] of renderers_by_source) {
      const sm = renderers[0].get_selection_manager();
      const r_views = [];
      for (const r of renderers) {
        const r_view = this.plot_view.views.find_one(r);
        if (r_view != null) {
          r_views.push(r_view);
        }
      }
      sm.select(r_views, geometry, final, mode);
    }
    this._emit_selection_event(geometry, final);
  }
  _clear_overlay() {
    super._clear_overlay();
    this.model.overlay.clear();
  }
};
__publicField(RegionSelectToolView, "__name__", "RegionSelectToolView");
var _RegionSelectTool = class _RegionSelectTool extends SelectTool {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RegionSelectTool, "__name__", "RegionSelectTool");
_RegionSelectTool.define(({ Bool: Bool2 }) => ({
  mode: [RegionSelectionMode, "replace"],
  continuous: [Bool2, false],
  persistent: [Bool2, false],
  greedy: [Bool2, false]
}));
var RegionSelectTool = _RegionSelectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/box_select_tool.js
import * as icons8 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var BoxSelectToolView = class extends RegionSelectToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_base_point");
  }
  connect_signals() {
    super.connect_signals();
    const { pan } = this.model.overlay;
    this.connect(pan, ([phase, ev]) => {
      if (phase == "pan" && this._is_continuous(ev) || phase == "pan:end") {
        const { left: left2, top, right: right3, bottom } = this.model.overlay;
        if (!(left2 instanceof Coordinate) && !(top instanceof Coordinate) && !(right3 instanceof Coordinate) && !(bottom instanceof Coordinate)) {
          const screen = this._compute_lrtb({ left: left2, right: right3, top, bottom });
          this._do_select([screen.left, screen.right], [screen.top, screen.bottom], false, this._select_mode(ev));
        }
      }
    });
    const { active: active8 } = this.model.properties;
    this.on_change(active8, () => {
      if (!this.model.active && !this.model.persistent) {
        this._clear_overlay();
      }
    });
  }
  _compute_limits(curpoint) {
    const frame = this.plot_view.frame;
    const dims = this.model.dimensions;
    let base_point = this._base_point;
    if (this.model.origin == "center") {
      const [cx, cy] = base_point;
      const [dx, dy] = curpoint;
      base_point = [cx - (dx - cx), cy - (dy - cy)];
    }
    return this.model._get_dim_limits(base_point, curpoint, frame, dims);
  }
  _mappers() {
    const mapper = (units, scale, view, canvas4) => {
      switch (units) {
        case "canvas":
          return canvas4;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    };
    const { overlay } = this.model;
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = frame;
    const { x_view, y_view } = frame.bbox;
    const { x_screen, y_screen } = canvas3.bbox;
    return {
      left: mapper(overlay.left_units, x_scale, x_view, x_screen),
      right: mapper(overlay.right_units, x_scale, x_view, x_screen),
      top: mapper(overlay.top_units, y_scale, y_view, y_screen),
      bottom: mapper(overlay.bottom_units, y_scale, y_view, y_screen)
    };
  }
  _compute_lrtb({ left: left2, right: right3, top, bottom }) {
    const lrtb = this._mappers();
    return {
      left: lrtb.left.compute(left2),
      right: lrtb.right.compute(right3),
      top: lrtb.top.compute(top),
      bottom: lrtb.bottom.compute(bottom)
    };
  }
  _invert_lrtb({ left: left2, right: right3, top, bottom }) {
    const lrtb = this._mappers();
    return {
      left: lrtb.left.invert(left2),
      right: lrtb.right.invert(right3),
      top: lrtb.top.invert(top),
      bottom: lrtb.bottom.invert(bottom)
    };
  }
  _pan_start(ev) {
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    this._clear_other_overlays();
    this._base_point = [sx, sy];
  }
  _pan(ev) {
    if (this._base_point == null) {
      return;
    }
    const { sx, sy } = ev;
    const [sxlim, sylim] = this._compute_limits([sx, sy]);
    const [[left2, right3], [top, bottom]] = [sxlim, sylim];
    this.model.overlay.update(this._invert_lrtb({ left: left2, right: right3, top, bottom }));
    if (this._is_continuous(ev.modifiers)) {
      this._do_select(sxlim, sylim, false, this._select_mode(ev.modifiers));
    }
  }
  _pan_end(ev) {
    if (this._base_point == null) {
      return;
    }
    const { sx, sy } = ev;
    const [sxlim, sylim] = this._compute_limits([sx, sy]);
    this._do_select(sxlim, sylim, true, this._select_mode(ev.modifiers));
    if (!this.model.persistent) {
      this._clear_overlay();
    }
    this._base_point = null;
    this.plot_view.state.push("box_select", { selection: this.plot_view.get_selection() });
  }
  get _is_selecting() {
    return this._base_point != null;
  }
  _stop() {
    this._clear_overlay();
    this._base_point = null;
  }
  _keyup(ev) {
    if (!this.model.active) {
      return;
    }
    if (ev.key == "Escape") {
      if (this._is_selecting) {
        this._stop();
        return;
      }
      if (this.model.overlay.visible) {
        this._clear_overlay();
        return;
      }
    }
    super._keyup(ev);
  }
  _clear_selection() {
    if (this.model.overlay.visible) {
      this._clear_overlay();
    } else {
      super._clear_selection();
    }
  }
  _do_select([sx0, sx1], [sy0, sy1], final, mode = "replace") {
    const { greedy } = this.model;
    const geometry = { type: "rect", sx0, sx1, sy0, sy1, greedy };
    this._select(geometry, final, mode);
  }
};
__publicField(BoxSelectToolView, "__name__", "BoxSelectToolView");
var DEFAULT_BOX_OVERLAY = () => {
  return new BoxAnnotation({
    syncable: false,
    level: "overlay",
    visible: false,
    editable: true,
    left: NaN,
    right: NaN,
    top: NaN,
    bottom: NaN,
    top_units: "data",
    left_units: "data",
    bottom_units: "data",
    right_units: "data",
    fill_color: "lightgrey",
    fill_alpha: 0.5,
    line_color: "black",
    line_alpha: 1,
    line_width: 2,
    line_dash: [4, 4]
  });
};
var _BoxSelectTool = class _BoxSelectTool extends RegionSelectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Box Select");
    __publicField(this, "event_type", "pan");
    __publicField(this, "default_order", 30);
  }
  initialize() {
    super.initialize();
    const [resizable, movable] = (() => {
      switch (this.dimensions) {
        case "width":
          return ["x", "x"];
        case "height":
          return ["y", "y"];
        case "both":
          return ["all", "both"];
      }
    })();
    const symmetric = this.origin == "center";
    this.overlay.setv({ resizable, movable, symmetric });
  }
  get computed_icon() {
    const icon3 = super.computed_icon;
    if (icon3 != null) {
      return icon3;
    } else {
      switch (this.dimensions) {
        case "both":
          return `.${icons8.tool_icon_box_select}`;
        case "width":
          return `.${icons8.tool_icon_x_box_select}`;
        case "height":
          return `.${icons8.tool_icon_y_box_select}`;
      }
    }
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
};
__publicField(_BoxSelectTool, "__name__", "BoxSelectTool");
_BoxSelectTool.prototype.default_view = BoxSelectToolView;
_BoxSelectTool.define(({ Ref: Ref2 }) => ({
  dimensions: [Dimensions, "both"],
  overlay: [Ref2(BoxAnnotation), DEFAULT_BOX_OVERLAY],
  origin: [BoxOrigin, "corner"]
}));
_BoxSelectTool.register_alias("box_select", () => new _BoxSelectTool());
_BoxSelectTool.register_alias("xbox_select", () => new _BoxSelectTool({ dimensions: "width" }));
_BoxSelectTool.register_alias("ybox_select", () => new _BoxSelectTool({ dimensions: "height" }));
var BoxSelectTool = _BoxSelectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/box_zoom_tool.js
import * as icons9 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var BoxZoomToolView = class extends GestureToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_base_point", null);
  }
  get overlays() {
    return [...super.overlays, this.model.overlay];
  }
  _match_aspect([bx, by], [cx, cy], frame) {
    const a2 = frame.bbox.aspect;
    const hend = frame.bbox.h_range.end;
    const hstart = frame.bbox.h_range.start;
    const vend = frame.bbox.v_range.end;
    const vstart = frame.bbox.v_range.start;
    let vw = Math.abs(bx - cx);
    let vh = Math.abs(by - cy);
    const va = vh == 0 ? 0 : vw / vh;
    const [xmod] = va >= a2 ? [1, va / a2] : [a2 / va, 1];
    let left2;
    let right3;
    if (bx <= cx) {
      left2 = bx;
      right3 = bx + vw * xmod;
      if (right3 > hend) {
        right3 = hend;
      }
    } else {
      right3 = bx;
      left2 = bx - vw * xmod;
      if (left2 < hstart) {
        left2 = hstart;
      }
    }
    vw = Math.abs(right3 - left2);
    let top;
    let bottom;
    if (by <= cy) {
      bottom = by;
      top = by + vw / a2;
      if (top > vend) {
        top = vend;
      }
    } else {
      top = by;
      bottom = by - vw / a2;
      if (bottom < vstart) {
        bottom = vstart;
      }
    }
    vh = Math.abs(top - bottom);
    if (bx <= cx) {
      right3 = bx + a2 * vh;
    } else {
      left2 = bx - a2 * vh;
    }
    return [[left2, right3], [bottom, top]];
  }
  _compute_limits(base_point, curr_point) {
    const { frame } = this.plot_view;
    if (this.model.origin == "center") {
      const [cx, cy] = base_point;
      const [dx, dy] = curr_point;
      base_point = [cx - (dx - cx), cy - (dy - cy)];
    }
    const dims = (() => {
      const { dimensions } = this.model;
      if (dimensions == "auto") {
        const [bx, by] = base_point;
        const [cx, cy] = curr_point;
        const dx = Math.abs(bx - cx);
        const dy = Math.abs(by - cy);
        const tol2 = 5;
        if (dx < tol2 && dy > tol2) {
          return "height";
        } else if (dx > tol2 && dy < tol2) {
          return "width";
        } else {
          return "both";
        }
      } else {
        return dimensions;
      }
    })();
    if (this.model.match_aspect && dims == "both") {
      return this._match_aspect(base_point, curr_point, frame);
    } else {
      return this.model._get_dim_limits(base_point, curr_point, frame, dims);
    }
  }
  _pan_start(ev) {
    const { sx, sy } = ev;
    if (this.plot_view.frame.bbox.contains(sx, sy)) {
      this._base_point = [sx, sy];
    }
  }
  _pan(ev) {
    if (this._base_point == null) {
      return;
    }
    const [[left2, right3], [top, bottom]] = this._compute_limits(this._base_point, [ev.sx, ev.sy]);
    this.model.overlay.update({ left: left2, right: right3, top, bottom });
  }
  _pan_end(ev) {
    if (this._base_point == null) {
      return;
    }
    const [sx, sy] = this._compute_limits(this._base_point, [ev.sx, ev.sy]);
    this._update(sx, sy);
    this._stop();
  }
  _stop() {
    this.model.overlay.clear();
    this._base_point = null;
  }
  _keydown(ev) {
    if (ev.key == "Escape") {
      this._stop();
    }
  }
  _doubletap(_ev) {
    var _a34;
    const { state } = this.plot_view;
    if (((_a34 = state.peek()) == null ? void 0 : _a34.type) == "box_zoom") {
      state.undo();
    }
  }
  _update([sx0, sx1], [sy0, sy1]) {
    if (Math.abs(sx1 - sx0) <= 5 || Math.abs(sy1 - sy0) <= 5) {
      return;
    }
    const { x_scales, y_scales } = this.plot_view.frame;
    const xrs = /* @__PURE__ */ new Map();
    for (const [, scale] of x_scales) {
      const [start2, end] = scale.r_invert(sx0, sx1);
      xrs.set(scale.source_range, { start: start2, end });
    }
    const yrs = /* @__PURE__ */ new Map();
    for (const [, scale] of y_scales) {
      const [start2, end] = scale.r_invert(sy0, sy1);
      yrs.set(scale.source_range, { start: start2, end });
    }
    const zoom_info = { xrs, yrs };
    this.plot_view.state.push("box_zoom", { range: zoom_info });
    this.plot_view.update_range(zoom_info);
    this.plot_view.trigger_ranges_update_event();
  }
};
__publicField(BoxZoomToolView, "__name__", "BoxZoomToolView");
var DEFAULT_BOX_OVERLAY2 = () => {
  return new BoxAnnotation({
    syncable: false,
    level: "overlay",
    visible: false,
    editable: false,
    left: NaN,
    right: NaN,
    top: NaN,
    bottom: NaN,
    top_units: "canvas",
    left_units: "canvas",
    bottom_units: "canvas",
    right_units: "canvas",
    fill_color: "lightgrey",
    fill_alpha: 0.5,
    line_color: "black",
    line_alpha: 1,
    line_width: 2,
    line_dash: [4, 4]
  });
};
var _BoxZoomTool = class _BoxZoomTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Box Zoom");
    __publicField(this, "event_type", ["pan", "doubletap"]);
    __publicField(this, "default_order", 20);
  }
  get event_role() {
    return "pan";
  }
  get computed_icon() {
    const icon3 = super.computed_icon;
    if (icon3 != null) {
      return icon3;
    } else {
      switch (this.dimensions) {
        case "both":
          return `.${icons9.tool_icon_box_zoom}`;
        case "width":
          return `.${icons9.tool_icon_x_box_zoom}`;
        case "height":
          return `.${icons9.tool_icon_y_box_zoom}`;
        case "auto":
          return `.${icons9.tool_icon_auto_box_zoom}`;
      }
    }
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
  get menu() {
    return [
      {
        icon: icons9.tool_icon_box_zoom,
        tooltip: "Box zoom in both dimensions",
        active: () => this.dimensions == "both",
        handler: () => {
          this.dimensions = "both";
          this.active = true;
        }
      },
      {
        icon: icons9.tool_icon_x_box_zoom,
        tooltip: "Box zoom in x-dimension",
        active: () => this.dimensions == "width",
        handler: () => {
          this.dimensions = "width";
          this.active = true;
        }
      },
      {
        icon: icons9.tool_icon_y_box_zoom,
        tooltip: "Box zoom in y-dimension",
        active: () => this.dimensions == "height",
        handler: () => {
          this.dimensions = "height";
          this.active = true;
        }
      },
      {
        icon: icons9.tool_icon_auto_box_zoom,
        tooltip: "Automatic mode (box zoom in x, y or both dimensions, depending on the mouse gesture)",
        active: () => this.dimensions == "auto",
        handler: () => {
          this.dimensions = "auto";
          this.active = true;
        }
      }
    ];
  }
};
__publicField(_BoxZoomTool, "__name__", "BoxZoomTool");
_BoxZoomTool.prototype.default_view = BoxZoomToolView;
_BoxZoomTool.define(({ Bool: Bool2, Ref: Ref2, Or: Or2, Auto: Auto2 }) => ({
  dimensions: [Or2(Dimensions, Auto2), "both"],
  overlay: [Ref2(BoxAnnotation), DEFAULT_BOX_OVERLAY2],
  match_aspect: [Bool2, false],
  origin: [BoxOrigin, "corner"]
}));
_BoxZoomTool.register_alias("box_zoom", () => new _BoxZoomTool({ dimensions: "both" }));
_BoxZoomTool.register_alias("xbox_zoom", () => new _BoxZoomTool({ dimensions: "width" }));
_BoxZoomTool.register_alias("ybox_zoom", () => new _BoxZoomTool({ dimensions: "height" }));
_BoxZoomTool.register_alias("auto_box_zoom", () => new _BoxZoomTool({ dimensions: "auto" }));
var BoxZoomTool = _BoxZoomTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/poly_select_tool.js
import { tool_icon_polygon_select } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var PolySelectToolView = class extends RegionSelectToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_is_selecting", false);
  }
  _mappers() {
    const mapper = (units, scale, view, canvas4) => {
      switch (units) {
        case "canvas":
          return canvas4;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    };
    const { overlay } = this.model;
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = frame;
    const { x_view, y_view } = frame.bbox;
    const { x_screen, y_screen } = canvas3.bbox;
    return {
      x: mapper(overlay.xs_units, x_scale, x_view, x_screen),
      y: mapper(overlay.ys_units, y_scale, y_view, y_screen)
    };
  }
  _v_compute(xs, ys) {
    const { x: x2, y: y2 } = this._mappers();
    return [x2.v_compute(xs), y2.v_compute(ys)];
  }
  _v_invert(sxs, sys) {
    const { x: x2, y: y2 } = this._mappers();
    return [x2.v_invert(sxs), y2.v_invert(sys)];
  }
  connect_signals() {
    super.connect_signals();
    const { pan } = this.model.overlay;
    this.connect(pan, ([phase, ev]) => {
      if (phase == "pan" && this._is_continuous(ev) || phase == "pan:end" && !this._is_selecting) {
        const { xs, ys } = this.model.overlay;
        const [sxs, sys] = this._v_compute(xs, ys);
        this._do_select(sxs, sys, false, this._select_mode(ev));
      }
    });
    const { active: active8 } = this.model.properties;
    this.on_change(active8, () => {
      if (!this.model.active && !this.model.persistent) {
        this._clear_overlay();
      }
    });
  }
  _tap(ev) {
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    this._clear_other_overlays();
    const [sxs, sys] = (() => {
      if (this._is_selecting) {
        const { xs: xs2, ys: ys2 } = this.model.overlay;
        const [sxs2, sys2] = this._v_compute(xs2, ys2);
        return [[...sxs2], [...sys2]];
      } else {
        this._is_selecting = true;
        return [[], []];
      }
    })();
    sxs.push(sx);
    sys.push(sy);
    const [xs, ys] = this._v_invert(sxs, sys);
    this.model.overlay.update({ xs, ys });
    if (this._is_continuous(ev.modifiers)) {
      this._do_select(sxs, sys, true, this._select_mode(ev.modifiers));
    }
  }
  _finish_selection(ev) {
    this._is_selecting = false;
    const { xs, ys } = this.model.overlay;
    const [sxs, sys] = this._v_compute(xs, ys);
    this._do_select(sxs, sys, true, this._select_mode(ev));
    this.plot_view.state.push("poly_select", { selection: this.plot_view.get_selection() });
    if (!this.model.persistent) {
      this._clear_overlay();
    }
  }
  _press(ev) {
    this._finish_selection(ev.modifiers);
  }
  _keyup(ev) {
    if (!this.model.active) {
      return;
    }
    if (ev.key == "Enter") {
      this._finish_selection(ev.modifiers);
      return;
    }
    if (ev.key == "Escape") {
      if (this.model.overlay.visible) {
        this._clear_overlay();
        return;
      }
    }
    super._keyup(ev);
  }
  _clear_selection() {
    if (this.model.overlay.visible) {
      this._clear_overlay();
    } else {
      this._is_selecting = false;
      super._clear_selection();
    }
  }
  _clear_overlay() {
    this._is_selecting = false;
    super._clear_overlay();
  }
  _do_select(sx, sy, final, mode) {
    const { greedy } = this.model;
    const geometry = { type: "poly", sx, sy, greedy };
    this._select(geometry, final, mode);
  }
};
__publicField(PolySelectToolView, "__name__", "PolySelectToolView");
var DEFAULT_POLY_OVERLAY = () => {
  return new PolyAnnotation({
    syncable: false,
    level: "overlay",
    visible: false,
    editable: true,
    xs_units: "data",
    ys_units: "data",
    fill_color: "lightgrey",
    fill_alpha: 0.5,
    line_color: "black",
    line_alpha: 1,
    line_width: 2,
    line_dash: [4, 4]
  });
};
var _PolySelectTool = class _PolySelectTool extends RegionSelectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Poly Select");
    __publicField(this, "tool_icon", tool_icon_polygon_select);
    __publicField(this, "event_type", "tap");
    __publicField(this, "default_order", 11);
  }
};
__publicField(_PolySelectTool, "__name__", "PolySelectTool");
_PolySelectTool.prototype.default_view = PolySelectToolView;
_PolySelectTool.define(({ Ref: Ref2 }) => ({
  overlay: [Ref2(PolyAnnotation), DEFAULT_POLY_OVERLAY]
}));
_PolySelectTool.register_alias("poly_select", () => new _PolySelectTool());
var PolySelectTool = _PolySelectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/lasso_select_tool.js
import { tool_icon_lasso_select } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var LassoSelectToolView = class extends RegionSelectToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_is_selecting", false);
  }
  _mappers() {
    const mapper = (units, scale, view, canvas4) => {
      switch (units) {
        case "canvas":
          return canvas4;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    };
    const { overlay } = this.model;
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = frame;
    const { x_view, y_view } = frame.bbox;
    const { x_screen, y_screen } = canvas3.bbox;
    return {
      x: mapper(overlay.xs_units, x_scale, x_view, x_screen),
      y: mapper(overlay.ys_units, y_scale, y_view, y_screen)
    };
  }
  _v_compute(xs, ys) {
    const { x: x2, y: y2 } = this._mappers();
    return [x2.v_compute(xs), y2.v_compute(ys)];
  }
  _v_invert(sxs, sys) {
    const { x: x2, y: y2 } = this._mappers();
    return [x2.v_invert(sxs), y2.v_invert(sys)];
  }
  connect_signals() {
    super.connect_signals();
    const { pan } = this.model.overlay;
    this.connect(pan, ([phase, ev]) => {
      if (phase == "pan" && this._is_continuous(ev) || phase == "pan:end") {
        const { xs, ys } = this.model.overlay;
        const [sxs, sys] = this._v_compute(xs, ys);
        this._do_select(sxs, sys, false, this._select_mode(ev));
      }
    });
    const { active: active8 } = this.model.properties;
    this.on_change(active8, () => {
      if (!this.model.active && !this.model.persistent) {
        this._clear_overlay();
      }
    });
  }
  _pan_start(ev) {
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    this._clear_other_overlays();
    this._is_selecting = true;
    const [xs, ys] = this._v_invert([sx], [sy]);
    this.model.overlay.update({ xs, ys });
  }
  _pan(ev) {
    assert(this._is_selecting);
    const [sxs, sys] = (() => {
      const { xs: xs2, ys: ys2 } = this.model.overlay;
      const [sxs2, sys2] = this._v_compute(xs2, ys2);
      return [[...sxs2], [...sys2]];
    })();
    const [sx, sy] = this.plot_view.frame.bbox.clip(ev.sx, ev.sy);
    sxs.push(sx);
    sys.push(sy);
    const [xs, ys] = this._v_invert(sxs, sys);
    this.model.overlay.update({ xs, ys });
    if (this._is_continuous(ev.modifiers)) {
      this._do_select(sxs, sys, false, this._select_mode(ev.modifiers));
    }
  }
  _pan_end(ev) {
    assert(this._is_selecting);
    this._is_selecting = false;
    const { xs, ys } = this.model.overlay;
    const [sxs, sys] = this._v_compute(xs, ys);
    this._do_select(sxs, sys, true, this._select_mode(ev.modifiers));
    this.plot_view.state.push("lasso_select", { selection: this.plot_view.get_selection() });
    if (!this.model.persistent) {
      this._clear_overlay();
    }
  }
  _keyup(ev) {
    if (!this.model.active) {
      return;
    }
    if (ev.key == "Escape") {
      if (this.model.overlay.visible) {
        this._clear_overlay();
        return;
      }
    }
    super._keyup(ev);
  }
  _clear_selection() {
    if (this.model.overlay.visible) {
      this._clear_overlay();
    } else {
      super._clear_selection();
    }
  }
  _do_select(sx, sy, final, mode) {
    const { greedy } = this.model;
    const geometry = { type: "poly", sx, sy, greedy };
    this._select(geometry, final, mode);
  }
};
__publicField(LassoSelectToolView, "__name__", "LassoSelectToolView");
var _LassoSelectTool = class _LassoSelectTool extends RegionSelectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Lasso Select");
    __publicField(this, "tool_icon", tool_icon_lasso_select);
    __publicField(this, "event_type", "pan");
    __publicField(this, "default_order", 12);
  }
};
__publicField(_LassoSelectTool, "__name__", "LassoSelectTool");
_LassoSelectTool.prototype.default_view = LassoSelectToolView;
_LassoSelectTool.define(({ Ref: Ref2 }) => ({
  overlay: [Ref2(PolyAnnotation), DEFAULT_POLY_OVERLAY]
}));
_LassoSelectTool.override({
  continuous: true
});
_LassoSelectTool.register_alias("lasso_select", () => new _LassoSelectTool());
var LassoSelectTool = _LassoSelectTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/range_tool.js
import { tool_icon_range } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var StartGesture = Enum("pan", "tap", "none");
var RangeToolView = class extends GestureToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_base_point");
  }
  get overlays() {
    return [...super.overlays, this.model.overlay];
  }
  initialize() {
    super.initialize();
    this.model.update_overlay_from_ranges();
  }
  connect_signals() {
    super.connect_signals();
    const update_overlay = () => this.model.update_overlay_from_ranges();
    this.on_transitive_change(this.model.properties.x_range, update_overlay);
    this.on_transitive_change(this.model.properties.y_range, update_overlay);
    this.model.overlay.pan.connect(([state, _2]) => {
      if (state == "pan") {
        this.model.update_ranges_from_overlay();
      } else if (state == "pan:end") {
        const ranges = [this.model.x_range, this.model.y_range].filter((r) => r != null);
        this.parent.trigger_ranges_update_event(ranges);
      }
    });
    const { active: active8, x_interaction, y_interaction } = this.model.properties;
    this.on_change([active8, x_interaction, y_interaction], () => {
      this.model.update_constraints();
    });
  }
  _mappers() {
    const mapper = (units, scale, view, canvas4) => {
      switch (units) {
        case "canvas":
          return canvas4;
        case "screen":
          return view;
        case "data":
          return scale;
      }
    };
    const { overlay } = this.model;
    const { frame, canvas: canvas3 } = this.plot_view;
    const { x_scale, y_scale } = frame;
    const { x_view, y_view } = frame.bbox;
    const { x_screen, y_screen } = canvas3.bbox;
    return {
      left: mapper(overlay.left_units, x_scale, x_view, x_screen),
      right: mapper(overlay.right_units, x_scale, x_view, x_screen),
      top: mapper(overlay.top_units, y_scale, y_view, y_screen),
      bottom: mapper(overlay.bottom_units, y_scale, y_view, y_screen)
    };
  }
  _invert_lrtb({ left: left2, right: right3, top, bottom }) {
    const lrtb = this._mappers();
    const { x_range, y_range } = this.model;
    const has_x = x_range != null;
    const has_y = y_range != null;
    return {
      left: has_x ? lrtb.left.invert(left2) : this.model.nodes.left,
      right: has_x ? lrtb.right.invert(right3) : this.model.nodes.right,
      top: has_y ? lrtb.top.invert(top) : this.model.nodes.top,
      bottom: has_y ? lrtb.bottom.invert(bottom) : this.model.nodes.bottom
    };
  }
  _compute_limits(curr_point) {
    const dims = (() => {
      const { x_range, y_range } = this.model;
      const has_x = x_range != null;
      const has_y = y_range != null;
      if (has_x && has_y) {
        return "both";
      } else if (has_x) {
        return "width";
      } else if (has_y) {
        return "height";
      } else {
        unreachable();
      }
    })();
    assert(this._base_point != null);
    let base_point = this._base_point;
    if (this.model.overlay.symmetric) {
      const [cx, cy] = base_point;
      const [dx, dy] = curr_point;
      base_point = [cx - (dx - cx), cy - (dy - cy)];
    }
    const { frame } = this.plot_view;
    return this.model._get_dim_limits(base_point, curr_point, frame, dims);
  }
  _tap(ev) {
    assert(this.model.start_gesture == "tap");
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    if (this._base_point == null) {
      this._base_point = [sx, sy];
    } else {
      this._update_overlay(sx, sy);
      this._base_point = null;
    }
  }
  _move(ev) {
    if (this._base_point != null && this.model.start_gesture == "tap") {
      const { sx, sy } = ev;
      this._update_overlay(sx, sy);
    }
  }
  _pan_start(ev) {
    assert(this.model.start_gesture == "pan");
    assert(this._base_point == null);
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    this._base_point = [sx, sy];
  }
  _update_overlay(sx, sy) {
    const [sxlim, sylim] = this._compute_limits([sx, sy]);
    const [[left2, right3], [top, bottom]] = [sxlim, sylim];
    this.model.overlay.update(this._invert_lrtb({ left: left2, right: right3, top, bottom }));
    this.model.update_ranges_from_overlay();
  }
  _pan(ev) {
    if (this._base_point == null) {
      return;
    }
    const { sx, sy } = ev;
    this._update_overlay(sx, sy);
  }
  _pan_end(ev) {
    if (this._base_point == null) {
      return;
    }
    const { sx, sy } = ev;
    this._update_overlay(sx, sy);
    this._base_point = null;
  }
  get _is_selecting() {
    return this._base_point != null;
  }
  _stop() {
    this._base_point = null;
  }
  _keyup(ev) {
    if (!this.model.active) {
      return;
    }
    if (ev.key == "Escape" && this._is_selecting) {
      this._stop();
    }
  }
};
__publicField(RangeToolView, "__name__", "RangeToolView");
var DEFAULT_RANGE_OVERLAY = () => {
  return new BoxAnnotation({
    syncable: false,
    level: "overlay",
    visible: true,
    editable: true,
    propagate_hover: true,
    left: NaN,
    right: NaN,
    top: NaN,
    bottom: NaN,
    left_limit: Node2.frame.left,
    right_limit: Node2.frame.right,
    top_limit: Node2.frame.top,
    bottom_limit: Node2.frame.bottom,
    fill_color: "lightgrey",
    fill_alpha: 0.5,
    line_color: "black",
    line_alpha: 1,
    line_width: 0.5,
    line_dash: [2, 2]
  });
};
var _RangeTool = class _RangeTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "nodes", Node2.frame.freeze());
    __publicField(this, "tool_name", "Range Tool");
    __publicField(this, "tool_icon", tool_icon_range);
    __publicField(this, "default_order", 40);
  }
  initialize() {
    super.initialize();
    this.update_constraints();
  }
  update_constraints() {
    this.overlay.editable = this.active;
    const has_x = this.x_range != null && this.x_interaction;
    const has_y = this.y_range != null && this.y_interaction;
    if (has_x && has_y) {
      this.overlay.movable = "both";
      this.overlay.resizable = "all";
    } else if (has_x) {
      this.overlay.movable = "x";
      this.overlay.resizable = "x";
    } else if (has_y) {
      this.overlay.movable = "y";
      this.overlay.resizable = "y";
    } else {
      this.overlay.movable = "none";
      this.overlay.resizable = "none";
    }
    const { x_range, y_range } = this;
    if (x_range != null) {
      this.overlay.min_width = x_range.min_interval ?? 0;
      this.overlay.max_width = x_range.max_interval ?? Infinity;
    }
    if (y_range != null) {
      this.overlay.min_height = y_range.min_interval ?? 0;
      this.overlay.max_height = y_range.max_interval ?? Infinity;
    }
  }
  update_ranges_from_overlay() {
    const { left: left2, right: right3, top, bottom } = this.overlay;
    const { x_range, y_range } = this;
    const affected_plots = /* @__PURE__ */ new Set();
    const xrs = /* @__PURE__ */ new Map();
    const yrs = /* @__PURE__ */ new Map();
    if (x_range != null && this.x_interaction) {
      assert(isNumber(left2) && isNumber(right3));
      xrs.set(x_range, { start: left2, end: right3 });
      for (const plot of x_range.linked_plots) {
        affected_plots.add(plot);
      }
    }
    if (y_range != null && this.y_interaction) {
      assert(isNumber(bottom) && isNumber(top));
      yrs.set(y_range, { start: bottom, end: top });
      for (const plot of y_range.linked_plots) {
        affected_plots.add(plot);
      }
    }
    for (const plot of affected_plots) {
      plot.update_range({ xrs, yrs }, { panning: true, scrolling: true });
    }
  }
  update_overlay_from_ranges() {
    const { x_range, y_range } = this;
    const has_x = x_range != null;
    const has_y = y_range != null;
    this.overlay.update({
      left: has_x ? x_range.start : this.nodes.left,
      right: has_x ? x_range.end : this.nodes.right,
      top: has_y ? y_range.end : this.nodes.top,
      bottom: has_y ? y_range.start : this.nodes.bottom
    });
    if (!has_x && !has_y) {
      logger.warn("RangeTool not configured with any Ranges.");
      this.overlay.clear();
    }
  }
  get event_type() {
    switch (this.start_gesture) {
      case "pan":
        return "pan";
      case "tap":
        return ["tap", "move"];
      case "none":
        return [];
    }
  }
  supports_auto() {
    return true;
  }
  tool_button() {
    return new OnOffButton({ tool: this });
  }
};
__publicField(_RangeTool, "__name__", "RangeTool");
_RangeTool.prototype.default_view = RangeToolView;
_RangeTool.define(({ Bool: Bool2, Ref: Ref2, Nullable: Nullable2 }) => ({
  x_range: [Nullable2(Ref2(Range)), null],
  y_range: [Nullable2(Ref2(Range)), null],
  x_interaction: [Bool2, true],
  y_interaction: [Bool2, true],
  overlay: [Ref2(BoxAnnotation), DEFAULT_RANGE_OVERLAY],
  start_gesture: [StartGesture, "none"]
}));
_RangeTool.override({
  active: true
});
var RangeTool = _RangeTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/common.js
var Modifiers = PartialStruct({ shift: Bool, ctrl: Bool, alt: Bool });
function satisfies_modifiers(expected, received) {
  const { alt, ctrl: ctrl2, shift } = expected;
  if (shift != null && shift != received.shift) {
    return false;
  }
  if (ctrl2 != null && ctrl2 != received.ctrl) {
    return false;
  }
  if (alt != null && alt != received.alt) {
    return false;
  }
  return true;
}
function print_modifiers(modifiers) {
  const { alt, ctrl: ctrl2, shift } = modifiers;
  const result = [];
  if (alt === true) {
    result.push("alt");
  }
  if (ctrl2 === true) {
    result.push("ctrl");
  }
  if (shift === true) {
    result.push("shift");
  }
  return result.join(" + ");
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/tap_tool.js
import { tool_icon_tap_select, tool_icon_toggle_mode } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var TapToolView = class extends SelectToolView {
  _tap(ev) {
    const is_tap = this.model.gesture == "tap";
    if (is_tap) {
      this._handle_tap(ev);
    }
    return is_tap;
  }
  _doubletap(ev) {
    const is_doubletap = this.model.gesture == "doubletap";
    if (is_doubletap) {
      this._handle_tap(ev);
    }
    return is_doubletap;
  }
  _handle_tap(ev) {
    if (!satisfies_modifiers(this.model.modifiers, ev.modifiers)) {
      return;
    }
    const { sx, sy } = ev;
    const { frame } = this.plot_view;
    if (!frame.bbox.contains(sx, sy)) {
      return;
    }
    this._clear_other_overlays();
    const geometry = { type: "point", sx, sy };
    if (this.model.behavior == "select") {
      this._select(geometry, true, this._select_mode(ev.modifiers));
    } else {
      this._inspect(geometry, ev.modifiers);
    }
  }
  _select(geometry, final, mode) {
    const renderers_by_source = this._computed_renderers_by_data_source();
    for (const [, renderers] of renderers_by_source) {
      const sm = renderers[0].get_selection_manager();
      const r_views = renderers.map((r) => this.plot_view.views.find_one(r)).filter((r) => r != null);
      const did_hit = sm.select(r_views, geometry, final, mode);
      if (did_hit) {
        const [rv] = r_views;
        this._emit_callback(rv, geometry, sm.source);
      }
    }
    this._emit_selection_event(geometry);
    this.plot_view.state.push("tap", { selection: this.plot_view.get_selection() });
  }
  _inspect(geometry, modifiers) {
    for (const r of this.computed_renderers) {
      const rv = this.plot_view.views.find_one(r);
      if (rv == null) {
        continue;
      }
      const sm = r.get_selection_manager();
      const did_hit = sm.inspect(rv, geometry);
      if (did_hit) {
        this._emit_callback(rv, geometry, sm.source, modifiers);
      }
    }
  }
  _emit_callback(rv, geometry, source2, modifiers) {
    const { callback } = this.model;
    if (callback != null) {
      const x2 = rv.coordinates.x_scale.invert(geometry.sx);
      const y2 = rv.coordinates.y_scale.invert(geometry.sy);
      const data3 = {
        geometries: { ...geometry, x: x2, y: y2 },
        source: source2,
        event: { modifiers }
      };
      void execute(callback, this.model, data3);
    }
  }
};
__publicField(TapToolView, "__name__", "TapToolView");
var _TapTool = class _TapTool extends SelectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Tap");
    __publicField(this, "tool_icon", tool_icon_tap_select);
    __publicField(this, "event_type", "tap");
    __publicField(this, "default_order", 10);
  }
  get menu() {
    const menu5 = super.menu;
    if (menu5 == null) {
      return null;
    } else {
      return prepend(menu5, {
        icon: tool_icon_toggle_mode,
        tooltip: "Toggle the current selection",
        active: () => this.mode == "toggle",
        handler: () => {
          this.mode = "toggle";
          this.active = true;
        }
      });
    }
  }
};
__publicField(_TapTool, "__name__", "TapTool");
_TapTool.prototype.default_view = TapToolView;
_TapTool.define(({ Any: Any2, Nullable: Nullable2 }) => ({
  mode: [SelectionMode, "toggle"],
  behavior: [TapBehavior, "select"],
  gesture: [TapGesture, "tap"],
  modifiers: [Modifiers, {}],
  callback: [Nullable2(
    Any2
    /*TODO*/
  ), null]
}));
_TapTool.register_alias("click", () => new _TapTool({ behavior: "inspect" }));
_TapTool.register_alias("tap", () => new _TapTool());
_TapTool.register_alias("doubletap", () => new _TapTool({ gesture: "doubletap" }));
var TapTool = _TapTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/wheel_pan_tool.js
import { tool_icon_wheel_pan } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var WheelPanToolView = class extends GestureToolView {
  _scroll(ev) {
    const { modifiers } = this.model;
    if (!satisfies_modifiers(modifiers, ev.modifiers)) {
      this.plot_view.notify_about(`use ${print_modifiers(modifiers)} + scroll to pan`);
      return false;
    }
    const factor = clamp(this.model.speed * ev.delta, -0.9, 0.9);
    this._update_ranges(factor);
    return true;
  }
  _update_ranges(factor) {
    var _a34;
    const { frame } = this.plot_view;
    const hr2 = frame.bbox.h_range;
    const vr = frame.bbox.v_range;
    const [sx_low, sx_high] = [hr2.start, hr2.end];
    const [sy_low, sy_high] = [vr.start, vr.end];
    let sx0;
    let sx1;
    let sy0;
    let sy1;
    switch (this.model.dimension) {
      case "height": {
        const sy_range = Math.abs(sy_high - sy_low);
        sx0 = sx_low;
        sx1 = sx_high;
        sy0 = sy_low - sy_range * factor;
        sy1 = sy_high - sy_range * factor;
        break;
      }
      case "width": {
        const sx_range = Math.abs(sx_high - sx_low);
        sx0 = sx_low - sx_range * factor;
        sx1 = sx_high - sx_range * factor;
        sy0 = sy_low;
        sy1 = sy_high;
        break;
      }
    }
    const { x_scales, y_scales } = frame;
    const xrs = update_ranges(x_scales, sx0, sx1);
    const yrs = update_ranges(y_scales, sy0, sy1);
    const pan_info = { xrs, yrs, factor };
    this.plot_view.state.push("wheel_pan", { range: pan_info });
    this.plot_view.update_range(pan_info, { scrolling: true });
    (_a34 = this.model.document) == null ? void 0 : _a34.interactive_start(this.plot_view.model, () => this.plot_view.trigger_ranges_update_event());
  }
};
__publicField(WheelPanToolView, "__name__", "WheelPanToolView");
var _WheelPanTool = class _WheelPanTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Wheel Pan");
    __publicField(this, "tool_icon", tool_icon_wheel_pan);
    __publicField(this, "event_type", "scroll");
    __publicField(this, "default_order", 12);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimension);
  }
  supports_auto() {
    const { alt, ctrl: ctrl2, shift } = this.modifiers;
    return alt != null || ctrl2 != null || shift != null;
  }
};
__publicField(_WheelPanTool, "__name__", "WheelPanTool");
_WheelPanTool.prototype.default_view = WheelPanToolView;
_WheelPanTool.define(() => ({
  dimension: [Dimension, "width"],
  modifiers: [Modifiers, {}]
}));
_WheelPanTool.internal(({ Float: Float2 }) => ({
  speed: [Float2, 1 / 1e3]
}));
_WheelPanTool.register_alias("xwheel_pan", () => new _WheelPanTool({ dimension: "width" }));
_WheelPanTool.register_alias("ywheel_pan", () => new _WheelPanTool({ dimension: "height" }));
var WheelPanTool = _WheelPanTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/gestures/wheel_zoom_tool.js
import { tool_icon_wheel_zoom } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var ZoomTogether = Enum("none", "cross", "all");
var Renderers = Or(List(Ref(DataRenderer)), Auto);
var WheelZoomToolView = class extends GestureToolView {
  _scroll(ev) {
    const { modifiers } = this.model;
    if (!satisfies_modifiers(modifiers, ev.modifiers)) {
      this.plot_view.notify_about(`use ${print_modifiers(modifiers)} + scroll to zoom`);
      return false;
    }
    const { sx, sy, delta } = ev;
    this.zoom(sx, sy, delta);
    return true;
  }
  _pinch(ev) {
    const { sx, sy, scale } = ev;
    const delta = scale >= 1 ? (scale - 1) * 20 : -20 / scale;
    this.zoom(sx, sy, delta);
  }
  zoom(sx, sy, delta) {
    var _a34;
    const axis_view = this.plot_view.axis_views.find((view) => view.bbox.contains(sx, sy));
    if (axis_view != null && !this.model.zoom_on_axis) {
      return;
    }
    const { frame } = this.plot_view;
    if (axis_view == null && !frame.bbox.contains(sx, sy)) {
      return;
    }
    const [x_frame_scales_, y_frame_scales_] = (() => {
      const x_frame = [...frame.x_scales.values()];
      const y_frame = [...frame.y_scales.values()];
      if (axis_view == null) {
        return [x_frame, y_frame];
      } else {
        const { zoom_together } = this.model;
        if (zoom_together == "all") {
          if (axis_view.dimension == 0) {
            return [x_frame, []];
          } else {
            return [[], y_frame];
          }
        } else {
          const { x_scale, y_scale } = axis_view.coordinates;
          switch (zoom_together) {
            case "cross": {
              return [[x_scale], [y_scale]];
            }
            case "none": {
              if (axis_view.dimension == 0) {
                return [[x_scale], []];
              } else {
                return [[], [y_scale]];
              }
            }
          }
        }
      }
    })();
    const data_renderers = (() => {
      const { renderers } = this.model;
      const data_renderers2 = new Set(renderers != "auto" ? renderers : this.plot_view.model.data_renderers);
      if (!this.model.hit_test) {
        return data_renderers2;
      } else {
        const collected_renderers = /* @__PURE__ */ new Set();
        const hit_renderers = /* @__PURE__ */ new Set();
        for (const renderer of data_renderers2) {
          if (renderer.coordinates == null) {
            collected_renderers.add(renderer);
            continue;
          }
          const geometry = (() => {
            switch (this.model.hit_test_mode) {
              case "point":
                return { type: "point", sx, sy };
              case "hline":
                return { type: "span", sx, sy, direction: "v" };
              case "vline":
                return { type: "span", sx, sy, direction: "h" };
            }
          })();
          const rv = this.plot_view.views.get_one(renderer);
          const did_hit = rv.hit_test(geometry);
          if (did_hit != null && !did_hit.is_empty()) {
            hit_renderers.add(rv.model);
          }
        }
        if (hit_renderers.size != 0) {
          const { hit_test_behavior } = this.model;
          if (hit_test_behavior == "only_hit") {
            for (const hit of hit_renderers) {
              collected_renderers.add(hit);
            }
          } else {
            for (const group of hit_test_behavior.query_groups(hit_renderers, data_renderers2)) {
              for (const renderer of group) {
                if (renderer instanceof DataRenderer && data_renderers2.has(renderer)) {
                  collected_renderers.add(renderer);
                }
              }
            }
          }
        }
        return [...collected_renderers];
      }
    })();
    const x_frame_scales = new Set(x_frame_scales_);
    const y_frame_scales = new Set(y_frame_scales_);
    const x_renderer_scales = /* @__PURE__ */ new Set();
    const y_renderer_scales = /* @__PURE__ */ new Set();
    for (const renderer of data_renderers) {
      if (renderer.coordinates == null) {
        continue;
      }
      const rv = this.plot_view.views.get_one(renderer);
      const { x_scale, y_scale } = rv.coordinates;
      if (x_scale instanceof CompositeScale) {
        if (x_frame_scales.has(x_scale.target_scale)) {
          x_renderer_scales.add(x_scale);
        }
      }
      if (y_scale instanceof CompositeScale) {
        if (y_frame_scales.has(y_scale.target_scale)) {
          y_renderer_scales.add(y_scale);
        }
      }
    }
    const [x_all_scales, y_all_scales] = (() => {
      if (this.model.renderers == "auto") {
        return [
          /* @__PURE__ */ new Set([...x_frame_scales, ...x_renderer_scales]),
          /* @__PURE__ */ new Set([...y_frame_scales, ...y_renderer_scales])
        ];
      } else {
        return [
          x_renderer_scales,
          y_renderer_scales
        ];
      }
    })();
    const subcoord = { x: false, y: false };
    const traverse = (scale, dim) => {
      const { level } = this.model;
      for (let i2 = 0; i2 < level; i2++) {
        if (scale instanceof CompositeScale) {
          subcoord[dim] = true;
          scale = scale.source_scale;
        } else {
          logger.warn(`can't reach sub-coordinate level ${level} for ${scale} in ${dim} dimension; stopped at ${i2}`);
          break;
        }
      }
      if (scale instanceof CompositeScale) {
        return scale.target_scale;
      } else {
        return scale;
      }
    };
    const x_scales = /* @__PURE__ */ new Set();
    const y_scales = /* @__PURE__ */ new Set();
    for (const x_scale of x_all_scales) {
      x_scales.add(traverse(x_scale, "x"));
    }
    for (const y_scale of y_all_scales) {
      y_scales.add(traverse(y_scale, "y"));
    }
    const center = (() => {
      const x2 = subcoord.x ? null : sx;
      const y2 = subcoord.y ? null : sy;
      if (axis_view != null) {
        return axis_view.dimension == 0 ? { x: x2, y: null } : { x: null, y: y2 };
      } else {
        return { x: x2, y: y2 };
      }
    })();
    const dims = this.model.dimensions;
    const x_axis = dims == "width" || dims == "both";
    const y_axis = dims == "height" || dims == "both";
    const { x_target, y_target } = frame;
    const factor = clamp(this.model.speed * delta, -0.95, 0.95);
    const zoom_info = scale_range(x_scales, y_scales, x_target, y_target, factor, x_axis, y_axis, center);
    this.plot_view.state.push("wheel_zoom", { range: zoom_info });
    const { maintain_focus } = this.model;
    this.plot_view.update_range(zoom_info, { scrolling: true, maintain_focus });
    (_a34 = this.model.document) == null ? void 0 : _a34.interactive_start(this.plot_view.model, () => this.plot_view.trigger_ranges_update_event());
  }
};
__publicField(WheelZoomToolView, "__name__", "WheelZoomToolView");
var _WheelZoomTool = class _WheelZoomTool extends GestureTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Wheel Zoom");
    __publicField(this, "tool_icon", tool_icon_wheel_zoom);
    __publicField(this, "event_type", "scroll");
    __publicField(this, "default_order", 10);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
  supports_auto() {
    const { alt, ctrl: ctrl2, shift } = this.modifiers;
    return alt != null || ctrl2 != null || shift != null;
  }
};
__publicField(_WheelZoomTool, "__name__", "WheelZoomTool");
_WheelZoomTool.prototype.default_view = WheelZoomToolView;
_WheelZoomTool.define(({ Bool: Bool2, Float: Float2, NonNegative: NonNegative2, Int: Int2, Ref: Ref2, Or: Or2 }) => ({
  dimensions: [Dimensions, "both"],
  renderers: [Renderers, "auto"],
  level: [NonNegative2(Int2), 0],
  hit_test: [Bool2, false],
  hit_test_mode: [Enum("point", "hline", "vline"), "point"],
  hit_test_behavior: [Or2(Ref2(GroupBy), Enum("only_hit")), "only_hit"],
  maintain_focus: [Bool2, true],
  zoom_on_axis: [Bool2, true],
  zoom_together: [ZoomTogether, "all"],
  speed: [Float2, 1 / 600],
  modifiers: [Modifiers, {}]
}));
_WheelZoomTool.register_alias("wheel_zoom", () => new _WheelZoomTool({ dimensions: "both" }));
_WheelZoomTool.register_alias("xwheel_zoom", () => new _WheelZoomTool({ dimensions: "width" }));
_WheelZoomTool.register_alias("ywheel_zoom", () => new _WheelZoomTool({ dimensions: "height" }));
var WheelZoomTool = _WheelZoomTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/crosshair_tool.js
import { tool_icon_crosshair } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var CrosshairToolView = class extends InspectToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_spans");
  }
  get overlays() {
    return [...super.overlays, ...this._spans];
  }
  initialize() {
    super.initialize();
    this._update_overlays();
  }
  connect_signals() {
    super.connect_signals();
    const { overlay, dimensions, line_color, line_width, line_alpha } = this.model.properties;
    this.on_change([overlay, dimensions, line_color, line_width, line_alpha], () => {
      this._update_overlays();
    });
  }
  _update_overlays() {
    const { overlay } = this.model;
    if (overlay == "auto") {
      let span2 = function(dimension) {
        return new Span2({
          dimension,
          location_units: "canvas",
          level: "overlay",
          line_color,
          line_width,
          line_alpha
        });
      };
      const { dimensions, line_color, line_alpha, line_width } = this.model;
      switch (dimensions) {
        case "width": {
          this._spans = [span2("width")];
          break;
        }
        case "height": {
          this._spans = [span2("height")];
          break;
        }
        case "both": {
          this._spans = [span2("width"), span2("height")];
          break;
        }
      }
    } else if (isArray(overlay)) {
      this._spans = [...overlay];
    } else {
      this._spans = [overlay];
    }
  }
  _move(ev) {
    if (!this.model.active) {
      return;
    }
    const { sx, sy } = ev;
    if (!this.plot_view.frame.bbox.contains(sx, sy)) {
      this._update_spans(NaN, NaN);
    } else {
      this._update_spans(sx, sy);
    }
  }
  _move_exit(_e) {
    this._update_spans(NaN, NaN);
  }
  _update_spans(sx, sy) {
    const { frame } = this.plot_view;
    function invert(span2, sx2, sy2) {
      const { dimension } = span2;
      switch (span2.location_units) {
        case "canvas": {
          return dimension == "width" ? sy2 : sx2;
        }
        case "screen": {
          const { xview, yview } = frame.bbox;
          return dimension == "width" ? yview.invert(sy2) : xview.invert(sx2);
        }
        case "data": {
          const { x_scale, y_scale } = frame;
          return dimension == "width" ? y_scale.invert(sy2) : x_scale.invert(sx2);
        }
      }
    }
    for (const span2 of this._spans) {
      span2.location = invert(span2, sx, sy);
    }
  }
};
__publicField(CrosshairToolView, "__name__", "CrosshairToolView");
var _CrosshairTool = class _CrosshairTool extends InspectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Crosshair");
    __publicField(this, "tool_icon", tool_icon_crosshair);
  }
  get tooltip() {
    return this._get_dim_tooltip(this.dimensions);
  }
};
__publicField(_CrosshairTool, "__name__", "CrosshairTool");
_CrosshairTool.prototype.default_view = CrosshairToolView;
_CrosshairTool.define(({ Alpha, Float: Float2, Color: Color2, Auto: Auto2, Tuple: Tuple2, Ref: Ref2, Or: Or2 }) => ({
  overlay: [Or2(Auto2, Ref2(Span2), Tuple2(Ref2(Span2), Ref2(Span2))), "auto"],
  dimensions: [Dimensions, "both"],
  line_color: [Color2, "black"],
  line_width: [Float2, 1],
  line_alpha: [Alpha, 1]
}));
_CrosshairTool.register_alias("crosshair", () => new _CrosshairTool());
_CrosshairTool.register_alias("xcrosshair", () => new _CrosshairTool({ dimensions: "width" }));
_CrosshairTool.register_alias("ycrosshair", () => new _CrosshairTool({ dimensions: "height" }));
var CrosshairTool = _CrosshairTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/customjs_hover.js
var _CustomJSHover = class _CustomJSHover extends Model {
  constructor(attrs) {
    super(attrs);
  }
  get values() {
    return values(this.args);
  }
  /*protected*/
  _make_code(valname, formatname, varsname, fn) {
    return new Function(...keys(this.args), valname, formatname, varsname, use_strict(fn));
  }
  format(value2, format7, special_vars) {
    const formatter = this._make_code("value", "format", "special_vars", this.code);
    return formatter(...this.values, value2, format7, special_vars);
  }
};
__publicField(_CustomJSHover, "__name__", "CustomJSHover");
_CustomJSHover.define(({ Unknown: Unknown2, Str: Str2, Dict: Dict2 }) => ({
  args: [Dict2(Unknown2), {}],
  code: [Str2, ""]
}));
var CustomJSHover = _CustomJSHover;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/hover_tool.js
import { tool_icon_hover } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
import * as styles from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tooltips.css.js";

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/placeholder.js
var Formatter = Or(BuiltinFormatter, Ref(CustomJS), Ref(CustomJSHover));
var PlaceholderView = class extends DOMElementView2 {
};
__publicField(PlaceholderView, "__name__", "PlaceholderView");
__publicField(PlaceholderView, "tag_name", "span");
var Placeholder = class extends DOMElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Placeholder, "__name__", "Placeholder");

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/action.js
var ActionView = class extends View {
};
__publicField(ActionView, "__name__", "ActionView");
var Action = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Action, "__name__", "Action");
__publicField(Action, "__module__", "bokeh.models.dom");

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/template.js
var TemplateView = class extends DOMElementView2 {
  constructor() {
    super(...arguments);
    __publicField(this, "action_views", /* @__PURE__ */ new Map());
  }
  *children() {
    yield* super.children();
    yield* this.action_views.values();
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await build_views(this.action_views, this.model.actions, { parent: this });
  }
  remove() {
    remove_views(this.action_views);
    super.remove();
  }
  update(source2, i2, vars, formatters) {
    traverse_views([this], (view) => {
      if (view instanceof PlaceholderView) {
        view.update(source2, i2, vars, formatters);
      }
    });
    for (const action of this.action_views.values()) {
      action.update(source2, i2, vars);
    }
  }
};
__publicField(TemplateView, "__name__", "TemplateView");
var _Template = class _Template extends DOMElement {
};
__publicField(_Template, "__name__", "Template");
_Template.prototype.default_view = TemplateView;
_Template.define(({ List: List2, Ref: Ref2 }) => ({
  actions: [List2(Ref2(Action)), []]
}));
var Template = _Template;

// node_modules/@bokeh/bokehjs/build/js/lib/models/tools/inspectors/hover_tool.js
function _nearest_line_hit(i2, geometry, dx, dy) {
  const p1 = { x: dx[i2], y: dy[i2] };
  const p2 = { x: dx[i2 + 1], y: dy[i2 + 1] };
  const { sx, sy } = geometry;
  const [d1, d2] = function() {
    if (geometry.type == "span") {
      if (geometry.direction == "h") {
        return [Math.abs(p1.x - sx), Math.abs(p2.x - sx)];
      } else {
        return [Math.abs(p1.y - sy), Math.abs(p2.y - sy)];
      }
    }
    const s2 = { x: sx, y: sy };
    const d12 = dist_2_pts(p1, s2);
    const d22 = dist_2_pts(p2, s2);
    return [d12, d22];
  }();
  return d1 < d2 ? [[p1.x, p1.y], i2] : [[p2.x, p2.y], i2 + 1];
}
function _line_hit(xs, ys, i2) {
  return [[xs[i2], ys[i2]], i2];
}
var COLOR_RE = /\$color(\[.*\])?:(\w*)/;
var SWATCH_RE = /\$swatch:(\w*)/;
var HoverToolView = class extends InspectToolView {
  constructor() {
    super(...arguments);
    __publicField(this, "_current_sxy", null);
    __publicField(this, "ttmodels", /* @__PURE__ */ new Map());
    __publicField(this, "_ttviews", /* @__PURE__ */ new Map());
    __publicField(this, "_template_el");
    __publicField(this, "_template_view");
  }
  *children() {
    yield* super.children();
    yield* this._ttviews.values();
    if (this._template_view != null) {
      yield this._template_view;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._update_ttmodels();
    const { tooltips: tooltips2 } = this.model;
    if (tooltips2 instanceof DOMElement) {
      this._template_view = await build_view(tooltips2, { parent: this.plot_view.canvas });
      this._template_view.render();
    }
  }
  remove() {
    var _a34;
    (_a34 = this._template_view) == null ? void 0 : _a34.remove();
    remove_views(this._ttviews);
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const plot_renderers = this.plot_view.model.properties.renderers;
    const { renderers, tooltips: tooltips2 } = this.model.properties;
    this.on_change(tooltips2, () => delete this._template_el);
    this.on_change([plot_renderers, renderers, tooltips2], async () => await this._update_ttmodels());
    this.connect(this.plot_view.repainted, () => {
      if (this.model.active && this._current_sxy != null) {
        const [sx, sy] = this._current_sxy;
        this._inspect(sx, sy);
      }
    });
  }
  async _update_ttmodels() {
    const { ttmodels } = this;
    ttmodels.clear();
    const { tooltips: tooltips2 } = this.model;
    if (tooltips2 == null) {
      return;
    }
    const { computed_renderers } = this;
    for (const r of computed_renderers) {
      const tooltip = new Tooltip({
        content: document.createElement("div"),
        attachment: this.model.attachment,
        show_arrow: this.model.show_arrow,
        interactive: false,
        visible: true,
        position: null
      });
      if (r instanceof GlyphRenderer) {
        ttmodels.set(r, tooltip);
      } else if (r instanceof GraphRenderer) {
        ttmodels.set(r.node_renderer, tooltip);
        ttmodels.set(r.edge_renderer, tooltip);
      }
    }
    await build_views(this._ttviews, [...ttmodels.values()], { parent: this.plot_view });
    const glyph_renderers = [...function* () {
      for (const r of computed_renderers) {
        if (r instanceof GlyphRenderer) {
          yield r;
        } else if (r instanceof GraphRenderer) {
          yield r.node_renderer;
          yield r.edge_renderer;
        }
      }
    }()];
    const slot2 = this._slots.get(this.update);
    if (slot2 != null) {
      const except = new Set(glyph_renderers.map((r) => r.data_source));
      Signal.disconnect_receiver(this, slot2, except);
    }
    for (const r of glyph_renderers) {
      this.connect(r.data_source.inspect, this.update);
    }
  }
  get computed_renderers() {
    const { renderers } = this.model;
    const all_renderers = this.plot_view.model.data_renderers;
    return compute_renderers(renderers, all_renderers);
  }
  _clear() {
    this._inspect(Infinity, Infinity);
    for (const [, tooltip] of this.ttmodels) {
      tooltip.clear();
    }
  }
  _move(ev) {
    if (!this.model.active) {
      return;
    }
    const { sx, sy } = ev;
    if (!this.plot_view.frame.bbox.contains(sx, sy)) {
      this._clear();
    } else {
      this._current_sxy = [sx, sy];
      this._inspect(sx, sy);
    }
  }
  _move_exit() {
    this._current_sxy = null;
    this._clear();
  }
  _inspect(sx, sy) {
    const geometry = (() => {
      if (this.model.mode == "mouse") {
        return { type: "point", sx, sy };
      } else {
        const direction = this.model.mode == "vline" ? "h" : "v";
        return { type: "span", direction, sx, sy };
      }
    })();
    for (const r of this.computed_renderers) {
      const sm = r.get_selection_manager();
      const rview = this.plot_view.views.find_one(r);
      if (rview != null) {
        sm.inspect(rview, geometry);
      }
    }
    this._emit_callback(geometry);
  }
  _update(renderer, geometry, tooltip) {
    var _a34, _b4;
    const selection_manager = renderer.get_selection_manager();
    const fullset_indices = selection_manager.inspectors.get(renderer);
    const subset_indices = renderer.view.convert_selection_to_subset(fullset_indices);
    if (fullset_indices.is_empty() && fullset_indices.view == null) {
      tooltip.clear();
      return;
    }
    const ds = selection_manager.source;
    const renderer_view = this.plot_view.views.find_one(renderer);
    if (renderer_view == null) {
      return;
    }
    const { sx, sy } = geometry;
    const xscale = renderer_view.coordinates.x_scale;
    const yscale = renderer_view.coordinates.y_scale;
    const x2 = xscale.invert(sx);
    const y2 = yscale.invert(sy);
    const { glyph } = renderer_view;
    const tooltips2 = [];
    if (glyph instanceof PatchView) {
      const [snap_sx, snap_sy] = [sx, sy];
      const [snap_x, snap_y] = [x2, y2];
      const vars = {
        index: null,
        glyph_view: glyph,
        type: glyph.model.type,
        x: x2,
        y: y2,
        sx,
        sy,
        snap_x,
        snap_y,
        snap_sx,
        snap_sy,
        name: renderer.name
      };
      const rendered = this._render_tooltips(ds, vars);
      tooltips2.push([snap_sx, snap_sy, rendered]);
    } else if (glyph instanceof HAreaStepView || glyph instanceof HAreaView || glyph instanceof VAreaStepView || glyph instanceof VAreaView) {
      for (const i2 of subset_indices.line_indices) {
        const [snap_x, snap_y] = [x2, y2];
        const [snap_sx, snap_sy] = [sx, sy];
        const vars = {
          index: i2,
          glyph_view: glyph,
          type: glyph.model.type,
          x: x2,
          y: y2,
          sx,
          sy,
          snap_x,
          snap_y,
          snap_sx,
          snap_sy,
          name: renderer.name,
          indices: subset_indices.line_indices
        };
        const rendered = this._render_tooltips(ds, vars);
        tooltips2.push([snap_sx, snap_sy, rendered]);
      }
    } else if (glyph instanceof LineView) {
      const { line_policy } = this.model;
      for (const i2 of subset_indices.line_indices) {
        const [[snap_x, snap_y], [snap_sx, snap_sy], ii] = (() => {
          const { x: x3, y: y3 } = glyph;
          switch (line_policy) {
            case "interp": {
              const [snap_x2, snap_y2] = glyph.get_interpolation_hit(i2, geometry);
              const snap_sxy = [xscale.compute(snap_x2), yscale.compute(snap_y2)];
              return [[snap_x2, snap_y2], snap_sxy, i2];
            }
            case "prev": {
              const [snap_sxy, ii2] = _line_hit(glyph.sx, glyph.sy, i2);
              return [[x3[i2 + 1], y3[i2 + 1]], snap_sxy, ii2];
            }
            case "next": {
              const [snap_sxy, ii2] = _line_hit(glyph.sx, glyph.sy, i2 + 1);
              return [[x3[i2 + 1], y3[i2 + 1]], snap_sxy, ii2];
            }
            case "nearest": {
              const [snap_sxy, ii2] = _nearest_line_hit(i2, geometry, glyph.sx, glyph.sy);
              return [[x3[ii2], y3[ii2]], snap_sxy, ii2];
            }
            case "none": {
              const xscale2 = renderer_view.coordinates.x_scale;
              const yscale2 = renderer_view.coordinates.y_scale;
              const x4 = xscale2.invert(sx);
              const y4 = yscale2.invert(sy);
              return [[x4, y4], [sx, sy], i2];
            }
          }
        })();
        const vars = {
          index: ii,
          glyph_view: glyph,
          type: glyph.model.type,
          x: x2,
          y: y2,
          sx,
          sy,
          snap_x,
          snap_y,
          snap_sx,
          snap_sy,
          name: renderer.name,
          indices: subset_indices.line_indices
        };
        const rendered = this._render_tooltips(ds, vars);
        tooltips2.push([snap_sx, snap_sy, rendered]);
      }
    } else if (glyph instanceof ImageBaseView) {
      for (const image_index of fullset_indices.image_indices) {
        const [snap_sx, snap_sy] = [sx, sy];
        const [snap_x, snap_y] = [x2, y2];
        const vars = {
          index: image_index.index,
          glyph_view: glyph,
          type: glyph.model.type,
          x: x2,
          y: y2,
          sx,
          sy,
          snap_x,
          snap_y,
          snap_sx,
          snap_sy,
          name: renderer.name,
          image_index
        };
        const rendered = this._render_tooltips(ds, vars);
        tooltips2.push([snap_sx, snap_sy, rendered]);
      }
    } else {
      for (const i2 of subset_indices.indices) {
        if (glyph instanceof MultiLineView && subset_indices.multiline_indices.size != 0) {
          const { line_policy } = this.model;
          for (const j of subset_indices.multiline_indices.get(i2) ?? []) {
            const [[snap_x, snap_y], [snap_sx, snap_sy], jj] = (() => {
              if (line_policy == "interp") {
                const [snap_x2, snap_y2] = glyph.get_interpolation_hit(i2, j, geometry);
                const snap_sxy = [xscale.compute(snap_x2), yscale.compute(snap_y2)];
                return [[snap_x2, snap_y2], snap_sxy, j];
              }
              const [xs, ys] = [glyph.xs.get(i2), glyph.ys.get(i2)];
              if (line_policy == "prev") {
                const [snap_sxy, jj2] = _line_hit(glyph.sxs.get(i2), glyph.sys.get(i2), j);
                return [[xs[j], ys[j]], snap_sxy, jj2];
              }
              if (line_policy == "next") {
                const [snap_sxy, jj2] = _line_hit(glyph.sxs.get(i2), glyph.sys.get(i2), j + 1);
                return [[xs[j], ys[j]], snap_sxy, jj2];
              }
              if (line_policy == "nearest") {
                const [snap_sxy, jj2] = _nearest_line_hit(j, geometry, glyph.sxs.get(i2), glyph.sys.get(i2));
                return [[xs[jj2], ys[jj2]], snap_sxy, jj2];
              }
              unreachable();
            })();
            const index2 = renderer.view.convert_indices_from_subset([i2])[0];
            const vars = {
              index: index2,
              glyph_view: glyph,
              type: glyph.model.type,
              x: x2,
              y: y2,
              sx,
              sy,
              snap_x,
              snap_y,
              snap_sx,
              snap_sy,
              name: renderer.name,
              indices: subset_indices.multiline_indices,
              segment_index: jj
            };
            const rendered = this._render_tooltips(ds, vars);
            tooltips2.push([snap_sx, snap_sy, rendered]);
          }
        } else {
          const snap_x = (_a34 = glyph.x) == null ? void 0 : _a34[i2];
          const snap_y = (_b4 = glyph.y) == null ? void 0 : _b4[i2];
          const { point_policy, anchor: anchor2 } = this.model;
          const [snap_sx, snap_sy] = function() {
            if (point_policy == "snap_to_data") {
              const pt = glyph.get_anchor_point(anchor2, i2, [sx, sy]);
              if (pt != null) {
                return [pt.x, pt.y];
              }
              const ptc = glyph.get_anchor_point("center", i2, [sx, sy]);
              if (ptc != null) {
                return [ptc.x, ptc.y];
              }
              return [sx, sy];
            }
            return [sx, sy];
          }();
          const index2 = renderer.view.convert_indices_from_subset([i2])[0];
          const vars = {
            index: index2,
            glyph_view: glyph,
            type: glyph.model.type,
            x: x2,
            y: y2,
            sx,
            sy,
            snap_x,
            snap_y,
            snap_sx,
            snap_sy,
            name: renderer.name,
            indices: subset_indices.indices
          };
          const rendered = this._render_tooltips(ds, vars);
          tooltips2.push([snap_sx, snap_sy, rendered]);
        }
      }
    }
    const { bbox } = this.plot_view.frame;
    const in_frame = tooltips2.filter(([sx2, sy2]) => bbox.contains(sx2, sy2));
    if (in_frame.length == 0) {
      tooltip.clear();
    } else {
      const { content: content2 } = tooltip;
      assert(content2 instanceof Node);
      empty2(content2);
      for (const [, , node] of in_frame) {
        if (node != null) {
          content2.appendChild(node);
        }
      }
      const [x3, y3] = in_frame[in_frame.length - 1];
      tooltip.show({ x: x3, y: y3 });
    }
  }
  update([renderer, { geometry }]) {
    if (!this.model.active) {
      return;
    }
    if (!(geometry.type == "point" || geometry.type == "span")) {
      return;
    }
    if (this.model.muted_policy == "ignore" && renderer.muted) {
      return;
    }
    const tooltip = this.ttmodels.get(renderer);
    if (is_undefined(tooltip)) {
      return;
    }
    this._update(renderer, geometry, tooltip);
  }
  _emit_callback(geometry) {
    const { callback } = this.model;
    if (callback == null) {
      return;
    }
    for (const renderer of this.computed_renderers) {
      if (!(renderer instanceof GlyphRenderer)) {
        continue;
      }
      const glyph_renderer_view = this.plot_view.views.find_one(renderer);
      if (glyph_renderer_view == null) {
        continue;
      }
      const { x_scale, y_scale } = glyph_renderer_view.coordinates;
      const x2 = x_scale.invert(geometry.sx);
      const y2 = y_scale.invert(geometry.sy);
      const index2 = renderer.data_source.inspected;
      void execute(callback, this.model, {
        geometry: { x: x2, y: y2, ...geometry },
        renderer,
        index: index2
      });
    }
  }
  _create_template(tooltips2) {
    const rows = div({ style: { display: "table", borderSpacing: "2px" } });
    for (const [label3] of tooltips2) {
      const row2 = div({ style: { display: "table-row" } });
      rows.appendChild(row2);
      const label_cell = div({ style: { display: "table-cell" }, class: styles.tooltip_row_label }, label3.length != 0 ? `${label3}: ` : "");
      row2.appendChild(label_cell);
      const value_el = span();
      value_el.dataset.value = "";
      const swatch_el = span({ class: styles.tooltip_color_block }, " ");
      swatch_el.dataset.swatch = "";
      undisplay(swatch_el);
      const value_cell = div({ style: { display: "table-cell" }, class: styles.tooltip_row_value }, value_el, swatch_el);
      row2.appendChild(value_cell);
    }
    return rows;
  }
  _render_template(template2, tooltips2, ds, index2, vars) {
    const el = template2.cloneNode(true);
    const value_els = el.querySelectorAll("[data-value]");
    const swatch_els = el.querySelectorAll("[data-swatch]");
    for (const [[, value2], j] of enumerate(tooltips2)) {
      const swatch_match = value2.match(SWATCH_RE);
      const color_match = value2.match(COLOR_RE);
      if (swatch_match == null && color_match == null) {
        const content2 = replace_placeholders(value2.replace("$~", "$data_"), ds, index2, this.model.formatters, vars);
        if (isString(content2)) {
          value_els[j].textContent = content2;
        } else {
          for (const el2 of content2) {
            value_els[j].appendChild(el2);
          }
        }
        continue;
      }
      if (swatch_match != null) {
        const [, colname] = swatch_match;
        const column = ds.get_column(colname);
        if (column == null) {
          value_els[j].textContent = `${colname} unknown`;
        } else {
          const color = isNumber(index2) ? column[index2] : null;
          if (color != null) {
            swatch_els[j].style.backgroundColor = color2css(color);
            display(swatch_els[j]);
          }
        }
      }
      if (color_match != null) {
        const [, opts = "", colname] = color_match;
        const column = ds.get_column(colname);
        if (column == null) {
          value_els[j].textContent = `${colname} unknown`;
          continue;
        }
        const hex2 = opts.indexOf("hex") >= 0;
        const swatch2 = opts.indexOf("swatch") >= 0;
        const color = isNumber(index2) ? column[index2] : null;
        if (color == null) {
          value_els[j].textContent = "(null)";
          continue;
        }
        value_els[j].textContent = hex2 ? color2hex(color) : color2css(color);
        if (swatch2) {
          swatch_els[j].style.backgroundColor = color2css(color);
          display(swatch_els[j]);
        }
      }
    }
    return el;
  }
  _render_tooltips(ds, vars) {
    const { tooltips: tooltips2 } = this.model;
    const i2 = is_undefined(vars.image_index) ? vars.index : vars.image_index;
    if (isString(tooltips2)) {
      const content2 = replace_placeholders({ html: tooltips2 }, ds, i2, this.model.formatters, vars);
      return div(content2);
    } else if (isFunction(tooltips2)) {
      return tooltips2(ds, vars);
    } else if (tooltips2 instanceof DOMElement) {
      const { _template_view } = this;
      assert(_template_view != null);
      this._update_template(_template_view, ds, i2, vars);
      return _template_view.el.cloneNode(true);
    } else if (tooltips2 != null) {
      const template2 = this._template_el ?? (this._template_el = this._create_template(tooltips2));
      return this._render_template(template2, tooltips2, ds, i2, vars);
    } else {
      return null;
    }
  }
  _update_template(template_view, ds, i2, vars) {
    const { formatters } = this.model;
    if (template_view instanceof TemplateView) {
      template_view.update(ds, i2, vars, formatters);
    } else {
      traverse_views([template_view], (view) => {
        if (view instanceof PlaceholderView) {
          view.update(ds, i2, vars, formatters);
        }
      });
    }
  }
};
__publicField(HoverToolView, "__name__", "HoverToolView");
var _HoverTool = class _HoverTool extends InspectTool {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "tool_name", "Hover");
    __publicField(this, "tool_icon", tool_icon_hover);
  }
};
__publicField(_HoverTool, "__name__", "HoverTool");
_HoverTool.prototype.default_view = HoverToolView;
_HoverTool.define(({ Any: Any2, Bool: Bool2, Str: Str2, List: List2, Tuple: Tuple2, Dict: Dict2, Or: Or2, Ref: Ref2, Func, Auto: Auto2, Nullable: Nullable2 }) => ({
  tooltips: [Nullable2(Or2(Ref2(DOMElement), Str2, List2(Tuple2(Str2, Str2)), Func())), [
    ["index", "$index"],
    ["data (x, y)", "($x, $y)"],
    ["screen (x, y)", "($sx, $sy)"]
  ]],
  formatters: [Dict2(Or2(Ref2(CustomJSHover), BuiltinFormatter)), {}],
  renderers: [Or2(List2(Ref2(DataRenderer)), Auto2), "auto"],
  mode: [HoverMode, "mouse"],
  muted_policy: [MutedPolicy, "show"],
  point_policy: [PointPolicy, "snap_to_data"],
  line_policy: [LinePolicy, "nearest"],
  show_arrow: [Bool2, true],
  anchor: [Anchor, "center"],
  attachment: [TooltipAttachment, "horizontal"],
  callback: [Nullable2(
    Any2
    /*TODO*/
  ), null]
}));
_HoverTool.register_alias("hover", () => new _HoverTool());
var HoverTool = _HoverTool;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/index.js
var dom_exports2 = {};
__export(dom_exports2, {
  Action: () => Action,
  ColorRef: () => ColorRef,
  DOMElement: () => DOMElement,
  DOMNode: () => DOMNode,
  Div: () => Div,
  GlobalImportedStyleSheet: () => GlobalImportedStyleSheet2,
  GlobalInlineStyleSheet: () => GlobalInlineStyleSheet2,
  HTML: () => HTML,
  ImportedStyleSheet: () => ImportedStyleSheet2,
  Index: () => Index2,
  InlineStyleSheet: () => InlineStyleSheet2,
  Placeholder: () => Placeholder,
  Span: () => Span3,
  Styles: () => Styles,
  Table: () => Table,
  TableRow: () => TableRow,
  Template: () => Template,
  Text: () => Text3,
  ToggleGroup: () => ToggleGroup,
  ValueOf: () => ValueOf,
  ValueRef: () => ValueRef
});

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/value_ref.js
var ValueRefView = class extends PlaceholderView {
  update(source2, i2, vars, _formatters) {
    const { field, format: format7, formatter } = this.model;
    const value2 = _get_column_value(field, source2, i2);
    const render2 = (output2) => {
      if (output2 == null) {
        this.el.textContent = MISSING;
      } else if (output2 instanceof Node) {
        this.el.replaceChildren(output2);
      } else if (isArray(output2)) {
        this.el.replaceChildren(...output2.map((item3) => item3 instanceof Node ? item3 : `${item3}`));
      } else {
        this.el.textContent = `${output2}`;
      }
    };
    if (formatter instanceof CustomJS) {
      void (async () => {
        const output2 = await execute(formatter, this.model, { value: value2, format: format7, vars });
        render2(output2);
      })();
    } else {
      const output2 = (() => {
        if (format7 == null) {
          return DEFAULT_FORMATTERS.basic(value2, "", vars);
        } else {
          if (formatter instanceof CustomJSHover) {
            return formatter.format(value2, format7, vars);
          } else {
            return DEFAULT_FORMATTERS[formatter](value2, format7, vars);
          }
        }
      })();
      render2(output2);
    }
  }
};
__publicField(ValueRefView, "__name__", "ValueRefView");
var _ValueRef = class _ValueRef extends Placeholder {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ValueRef, "__name__", "ValueRef");
_ValueRef.prototype.default_view = ValueRefView;
_ValueRef.define(({ Str: Str2, Nullable: Nullable2 }) => ({
  field: [Str2],
  format: [Nullable2(Str2), null],
  formatter: [Formatter, "raw"]
}));
var ValueRef = _ValueRef;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/color_ref.js
import * as styles2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/tooltips.css.js";
var ColorRefView = class extends ValueRefView {
  constructor() {
    super(...arguments);
    __publicField(this, "value_el");
    __publicField(this, "swatch_el");
  }
  render() {
    super.render();
    this.value_el = span();
    this.swatch_el = span({ class: styles2.tooltip_color_block }, " ");
    this.el.appendChild(this.value_el);
    this.el.appendChild(this.swatch_el);
  }
  update(source2, i2, _vars, _formatters) {
    const value2 = _get_column_value(this.model.field, source2, i2);
    const text2 = value2 == null ? "???" : `${value2}`;
    this.el.textContent = text2;
  }
};
__publicField(ColorRefView, "__name__", "ColorRefView");
var _ColorRef = class _ColorRef extends ValueRef {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ColorRef, "__name__", "ColorRef");
_ColorRef.prototype.default_view = ColorRefView;
_ColorRef.define(({ Bool: Bool2 }) => ({
  hex: [Bool2, true],
  swatch: [Bool2, true]
}));
var ColorRef = _ColorRef;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/index_.js
var IndexView = class extends PlaceholderView {
  update(_source, i2, _vars, _formatters) {
    this.el.textContent = i2 == null ? "(null)" : `${i2}`;
  }
};
__publicField(IndexView, "__name__", "IndexView");
var _Index = class _Index extends Placeholder {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Index, "__name__", "Index");
_Index.prototype.default_view = IndexView;
var Index2 = _Index;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/toggle_group.js
var ToggleGroupView = class extends ActionView {
  update(_source, i2, _vars) {
    for (const [group, j] of enumerate(this.model.groups)) {
      group.visible = i2 == j;
    }
  }
};
__publicField(ToggleGroupView, "__name__", "ToggleGroupView");
var _ToggleGroup = class _ToggleGroup extends Action {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToggleGroup, "__name__", "ToggleGroup");
_ToggleGroup.prototype.default_view = ToggleGroupView;
_ToggleGroup.define(({ List: List2, Ref: Ref2 }) => ({
  groups: [List2(Ref2(RendererGroup)), []]
}));
var ToggleGroup = _ToggleGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/dom/value_of.js
var ValueOfView = class extends DOMElementView2 {
  connect_signals() {
    super.connect_signals();
    const { obj, attr: attr2 } = this.model;
    if (attr2 in obj.properties) {
      this.on_change(obj.properties[attr2], () => this.render());
    }
  }
  render() {
    super.render();
    this.el.style.display = "contents";
    const text2 = (() => {
      const { obj, attr: attr2 } = this.model;
      if (attr2 in obj.properties) {
        const value2 = obj.properties[attr2].get_value();
        return to_string(value2);
      } else {
        return `<not found: ${obj.type}.${attr2}>`;
      }
    })();
    this.el.textContent = text2;
  }
};
__publicField(ValueOfView, "__name__", "ValueOfView");
var _ValueOf = class _ValueOf extends DOMElement {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ValueOf, "__name__", "ValueOf");
_ValueOf.prototype.default_view = ValueOfView;
_ValueOf.define(({ Str: Str2, Ref: Ref2 }) => ({
  obj: [Ref2(HasProps)],
  attr: [Str2]
}));
var ValueOf = _ValueOf;

// node_modules/@bokeh/bokehjs/build/js/lib/models/main.js
register_models(models_exports);
register_models(dom_exports2);

// node_modules/@bokeh/bokehjs/build/js/lib/api/linalg.js
var linalg_exports = {};
__export(linalg_exports, {
  AbstractRandom: () => AbstractRandom,
  Comparator: () => Comparator,
  EqNotImplemented: () => EqNotImplemented,
  LCGRandom: () => LCGRandom,
  MAX_INT32: () => MAX_INT32,
  Random: () => Random,
  SimilarComparator: () => SimilarComparator,
  SystemRandom: () => SystemRandom,
  _union: () => _union,
  argmax: () => argmax,
  argmin: () => argmin,
  argsort: () => argsort,
  clear: () => clear,
  concat: () => concat,
  contains: () => contains,
  copy: () => copy,
  cumsum: () => cumsum,
  difference: () => difference,
  elementwise: () => elementwise,
  entries: () => entries,
  equals: () => equals,
  escape: () => escape,
  every: () => every,
  extend: () => extend,
  find: () => find,
  find_index: () => find_index,
  find_last: () => find_last,
  find_last_index: () => find_last_index,
  head: () => head,
  includes: () => includes,
  insert_text_on_position: () => insert_text_on_position,
  intersection: () => intersection,
  isArray: () => isArray,
  isArrayOf: () => isArrayOf,
  isArrayable: () => isArrayable,
  isArrayableOf: () => isArrayableOf,
  isBasicObject: () => isBasicObject,
  isBoolean: () => isBoolean,
  isDict: () => isDict,
  isFunction: () => isFunction,
  isInteger: () => isInteger,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  isPrimitive: () => isPrimitive,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTypedArray: () => isTypedArray,
  is_Numerical: () => is_Numerical,
  is_defined: () => is_defined,
  is_empty: () => is_empty,
  is_equal: () => is_equal,
  is_nullish: () => is_nullish,
  is_similar: () => is_similar,
  is_structurally_equal: () => is_structurally_equal,
  is_undefined: () => is_undefined,
  keys: () => keys,
  last: () => last,
  linspace: () => linspace,
  map: () => map,
  max: () => max,
  max_by: () => max_by,
  min: () => min,
  min_by: () => min_by,
  np: () => np,
  nth: () => nth,
  pairwise: () => pairwise,
  random: () => random,
  range: () => range,
  reduce: () => reduce,
  remove: () => remove2,
  remove_at: () => remove_at,
  remove_by: () => remove_by,
  repeat: () => repeat,
  resize: () => resize,
  reversed: () => reversed,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sort_by: () => sort_by,
  sorted_index: () => sorted_index,
  split: () => split,
  sum: () => sum,
  symmetric_difference: () => symmetric_difference,
  to_fixed: () => to_fixed,
  transpose: () => transpose,
  unescape: () => unescape,
  union: () => union,
  uniq: () => uniq,
  uniq_by: () => uniq_by,
  unique_id: () => unique_id,
  unzip: () => unzip,
  use_strict: () => use_strict,
  uuid4: () => uuid4,
  values: () => values,
  wildcard: () => wildcard,
  zip: () => zip
});
function is_Numerical(x2) {
  return isNumber(x2) || is_Floating(x2) || is_NDArray(x2) || isArrayable(x2);
}
var np;
(function(np2) {
  np2.pi = Math.PI;
  function arange(start2, end, step = 1) {
    const array2 = range(start2, end, step);
    return ndarray(array2, { shape: [array2.length], dtype: "float64" });
  }
  np2.arange = arange;
  function linspace2(start2, end, num = 100) {
    const array2 = linspace(start2, end, num);
    return ndarray(array2, { shape: [array2.length], dtype: "float64" });
  }
  np2.linspace = linspace2;
  function mean(x2) {
    return sum3(x2) / x2.length;
  }
  np2.mean = mean;
  function std(x2) {
    const mu = mean(x2);
    return Math.sqrt(sum3(map(x2, (xi) => (xi - mu) ** 2)) / x2.length);
  }
  np2.std = std;
  function sum3(x2) {
    return sum(x2);
  }
  np2.sum = sum3;
  function diff(x2) {
    const m = x2.length - 1;
    const r = new Float64Array(m);
    for (let i2 = 0; i2 < m; i2++) {
      r[i2] = x2[i2 + 1] - x2[i2];
    }
    return ndarray(r.buffer, { shape: [m], dtype: "float64" });
  }
  np2.diff = diff;
  function sin3(x2) {
    if (isNumber(x2)) {
      return Math.sin(x2);
    } else if (is_Floating(x2)) {
      return Math.sin(x2[float]());
    } else {
      return map(x2, (v) => Math.sin(v));
    }
  }
  np2.sin = sin3;
  function cos3(x2) {
    if (isNumber(x2)) {
      return Math.cos(x2);
    } else if (is_Floating(x2)) {
      return Math.cos(x2[float]());
    } else {
      return map(x2, (v) => Math.cos(v));
    }
  }
  np2.cos = cos3;
  function exp(x2) {
    if (isNumber(x2)) {
      return Math.exp(x2);
    } else if (is_Floating(x2)) {
      return Math.exp(x2[float]());
    } else {
      return map(x2, (v) => Math.exp(v));
    }
  }
  np2.exp = exp;
  function sqrt5(x2) {
    if (isNumber(x2)) {
      return Math.sqrt(x2);
    } else if (is_Floating(x2)) {
      return Math.sqrt(x2[float]());
    } else {
      return map(x2, (v) => Math.sqrt(v));
    }
  }
  np2.sqrt = sqrt5;
  function factorial2(x2) {
    if (isNumber(x2)) {
      return factorial(x2);
    } else if (is_Floating(x2)) {
      return factorial(x2[float]());
    } else {
      return map(x2, factorial);
    }
  }
  np2.factorial = factorial2;
  function hermite2(n2) {
    const poly = hermite(n2);
    return (x2) => {
      if (isNumber(x2)) {
        return eval_poly(poly, x2);
      } else if (is_Floating(x2)) {
        return eval_poly(poly, x2[float]());
      } else {
        return map(x2, (v) => eval_poly(poly, v));
      }
    };
  }
  np2.hermite = hermite2;
  function pos(x2) {
    if (isNumber(x2)) {
      return +x2;
    } else if (is_Floating(x2)) {
      return +x2[float]();
    } else {
      return map(x2, (v) => +v);
    }
  }
  np2.pos = pos;
  function neg(x2) {
    if (isNumber(x2)) {
      return -x2;
    } else if (is_Floating(x2)) {
      return -x2[float]();
    } else {
      return map(x2, (v) => -v);
    }
  }
  np2.neg = neg;
  function add2(x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    if (x_num && y_num) {
      return x2 + y2;
    } else if (x_num && !y_num) {
      return map(y2, (yi) => x2 + yi);
    } else if (!x_num && y_num) {
      return map(x2, (xi) => xi + y2);
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => xi + y2[i2]);
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  np2.add = add2;
  function sub2(x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    if (x_num && y_num) {
      return x2 - y2;
    } else if (x_num && !y_num) {
      return map(y2, (yi) => x2 - yi);
    } else if (!x_num && y_num) {
      return map(x2, (xi) => xi - y2);
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => xi - y2[i2]);
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  np2.sub = sub2;
  function mul(x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    if (x_num && y_num) {
      return x2 * y2;
    } else if (x_num && !y_num) {
      return map(y2, (yi) => x2 * yi);
    } else if (!x_num && y_num) {
      return map(x2, (xi) => xi * y2);
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => xi * y2[i2]);
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  np2.mul = mul;
  function div2(x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    if (x_num && y_num) {
      return x2 / y2;
    } else if (x_num && !y_num) {
      return map(y2, (yi) => x2 / yi);
    } else if (!x_num && y_num) {
      return map(x2, (xi) => xi / y2);
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => xi / y2[i2]);
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  np2.div = div2;
  function pow(x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    if (x_num && y_num) {
      return x2 ** y2;
    } else if (x_num && !y_num) {
      return map(y2, (yi) => x2 ** yi);
    } else if (!x_num && y_num) {
      return map(x2, (xi) => xi ** y2);
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => xi ** y2[i2]);
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  np2.pow = pow;
  function cmp(x0, y0, op) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    const int2 = (v) => v ? 1 : 0;
    if (x_num && y_num) {
      return int2(x2 >= y2);
    } else if (x_num && !y_num) {
      return map(y2, (yi) => int2(op(x2, yi)));
    } else if (!x_num && y_num) {
      return map(x2, (xi) => int2(op(xi, y2)));
    } else if (is_NDArray(x2) && is_NDArray(y2)) {
      if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
        return map(x2, (xi, i2) => int2(op(xi, y2[i2])));
      } else {
        throw new Error("shape or dtype mismatch");
      }
    } else {
      throw new Error("not implemented");
    }
  }
  function ge(x0, y0) {
    return cmp(x0, y0, (x2, y2) => x2 >= y2);
  }
  np2.ge = ge;
  function le(x0, y0) {
    return cmp(x0, y0, (x2, y2) => x2 <= y2);
  }
  np2.le = le;
  function gt(x0, y0) {
    return cmp(x0, y0, (x2, y2) => x2 > y2);
  }
  np2.gt = gt;
  function lt(x0, y0) {
    return cmp(x0, y0, (x2, y2) => x2 < y2);
  }
  np2.lt = lt;
  function where(condition, x0, y0) {
    const x2 = is_Floating(x0) ? x0[float]() : x0;
    const y2 = is_Floating(y0) ? y0[float]() : y0;
    const x_num = isNumber(x2);
    const y_num = isNumber(y2);
    const fn = (() => {
      if (x_num && y_num) {
        return (cond_i) => cond_i != 0 ? x2 : y2;
      } else if (x_num && !y_num) {
        return (cond_i, i2) => cond_i != 0 ? x2 : y2[i2];
      } else if (!x_num && y_num) {
        return (cond_i, i2) => cond_i != 0 ? x2[i2] : y2;
      } else if (is_NDArray(x2) && is_NDArray(y2)) {
        if (is_equal(x2.shape, y2.shape) && x2.dtype == y2.dtype) {
          return (cond_i, i2) => cond_i != 0 ? x2[i2] : y2[i2];
        } else {
          throw new Error("shape or dtype mismatch");
        }
      } else {
        throw new Error("not implemented");
      }
    })();
    return map(condition, fn);
  }
  np2.where = where;
  function histogram(array2, options2) {
    const { density, bins } = options2;
    const edges = ndarray(bins, { dtype: "float64", shape: [bins.length] });
    const hist = ndarray(bin_counts(array2, edges), { dtype: "float64", shape: [edges.length - 1] });
    if (density) {
      const normed = div2(div2(hist, diff(edges)), sum3(hist));
      return [normed, edges];
    } else {
      return [hist, edges];
    }
  }
  np2.histogram = histogram;
  let random2;
  (function(random3) {
    class RandomGenerator2 {
      constructor(seed) {
        __publicField(this, "_random");
        this._random = new Random(seed ?? Date.now());
      }
      normal(loc, scale, size2) {
        const array2 = this._random.normals(loc, scale, size2);
        return ndarray(array2.buffer, { shape: [size2], dtype: "float64" });
      }
    }
    __publicField(RandomGenerator2, "__name__", "RandomGenerator");
    random3.RandomGenerator = RandomGenerator2;
    function default_rng(seed) {
      return new RandomGenerator2(seed);
    }
    random3.default_rng = default_rng;
  })(random2 = np2.random || (np2.random = {}));
})(np || (np = {}));

// node_modules/@bokeh/bokehjs/build/js/lib/api/charts.js
var charts_exports = {};
__export(charts_exports, {
  bar: () => bar,
  pie: () => pie
});

// node_modules/@bokeh/bokehjs/build/js/lib/api/palettes.js
var palettes_exports = {};
__export(palettes_exports, {
  Accent: () => Accent,
  Accent3: () => Accent3,
  Accent4: () => Accent4,
  Accent5: () => Accent5,
  Accent6: () => Accent6,
  Accent7: () => Accent7,
  Accent8: () => Accent8,
  Blues: () => Blues,
  Blues3: () => Blues3,
  Blues4: () => Blues4,
  Blues5: () => Blues5,
  Blues6: () => Blues6,
  Blues7: () => Blues7,
  Blues8: () => Blues8,
  Blues9: () => Blues9,
  Bokeh: () => Bokeh,
  Bokeh3: () => Bokeh3,
  Bokeh4: () => Bokeh4,
  Bokeh5: () => Bokeh5,
  Bokeh6: () => Bokeh6,
  Bokeh7: () => Bokeh7,
  Bokeh8: () => Bokeh8,
  BrBG: () => BrBG,
  BrBG10: () => BrBG10,
  BrBG11: () => BrBG11,
  BrBG3: () => BrBG3,
  BrBG4: () => BrBG4,
  BrBG5: () => BrBG5,
  BrBG6: () => BrBG6,
  BrBG7: () => BrBG7,
  BrBG8: () => BrBG8,
  BrBG9: () => BrBG9,
  Bright: () => Bright,
  Bright3: () => Bright3,
  Bright4: () => Bright4,
  Bright5: () => Bright5,
  Bright6: () => Bright6,
  Bright7: () => Bright7,
  BuGn: () => BuGn,
  BuGn3: () => BuGn3,
  BuGn4: () => BuGn4,
  BuGn5: () => BuGn5,
  BuGn6: () => BuGn6,
  BuGn7: () => BuGn7,
  BuGn8: () => BuGn8,
  BuGn9: () => BuGn9,
  BuPu: () => BuPu,
  BuPu3: () => BuPu3,
  BuPu4: () => BuPu4,
  BuPu5: () => BuPu5,
  BuPu6: () => BuPu6,
  BuPu7: () => BuPu7,
  BuPu8: () => BuPu8,
  BuPu9: () => BuPu9,
  BuRd: () => BuRd,
  BuRd3: () => BuRd3,
  BuRd4: () => BuRd4,
  BuRd5: () => BuRd5,
  BuRd6: () => BuRd6,
  BuRd7: () => BuRd7,
  BuRd8: () => BuRd8,
  BuRd9: () => BuRd9,
  Category10: () => Category10,
  Category10_10: () => Category10_10,
  Category10_3: () => Category10_3,
  Category10_4: () => Category10_4,
  Category10_5: () => Category10_5,
  Category10_6: () => Category10_6,
  Category10_7: () => Category10_7,
  Category10_8: () => Category10_8,
  Category10_9: () => Category10_9,
  Category20: () => Category20,
  Category20_10: () => Category20_10,
  Category20_11: () => Category20_11,
  Category20_12: () => Category20_12,
  Category20_13: () => Category20_13,
  Category20_14: () => Category20_14,
  Category20_15: () => Category20_15,
  Category20_16: () => Category20_16,
  Category20_17: () => Category20_17,
  Category20_18: () => Category20_18,
  Category20_19: () => Category20_19,
  Category20_20: () => Category20_20,
  Category20_3: () => Category20_3,
  Category20_4: () => Category20_4,
  Category20_5: () => Category20_5,
  Category20_6: () => Category20_6,
  Category20_7: () => Category20_7,
  Category20_8: () => Category20_8,
  Category20_9: () => Category20_9,
  Category20b: () => Category20b,
  Category20b_10: () => Category20b_10,
  Category20b_11: () => Category20b_11,
  Category20b_12: () => Category20b_12,
  Category20b_13: () => Category20b_13,
  Category20b_14: () => Category20b_14,
  Category20b_15: () => Category20b_15,
  Category20b_16: () => Category20b_16,
  Category20b_17: () => Category20b_17,
  Category20b_18: () => Category20b_18,
  Category20b_19: () => Category20b_19,
  Category20b_20: () => Category20b_20,
  Category20b_3: () => Category20b_3,
  Category20b_4: () => Category20b_4,
  Category20b_5: () => Category20b_5,
  Category20b_6: () => Category20b_6,
  Category20b_7: () => Category20b_7,
  Category20b_8: () => Category20b_8,
  Category20b_9: () => Category20b_9,
  Category20c: () => Category20c,
  Category20c_10: () => Category20c_10,
  Category20c_11: () => Category20c_11,
  Category20c_12: () => Category20c_12,
  Category20c_13: () => Category20c_13,
  Category20c_14: () => Category20c_14,
  Category20c_15: () => Category20c_15,
  Category20c_16: () => Category20c_16,
  Category20c_17: () => Category20c_17,
  Category20c_18: () => Category20c_18,
  Category20c_19: () => Category20c_19,
  Category20c_20: () => Category20c_20,
  Category20c_3: () => Category20c_3,
  Category20c_4: () => Category20c_4,
  Category20c_5: () => Category20c_5,
  Category20c_6: () => Category20c_6,
  Category20c_7: () => Category20c_7,
  Category20c_8: () => Category20c_8,
  Category20c_9: () => Category20c_9,
  Cividis: () => Cividis,
  Cividis10: () => Cividis10,
  Cividis11: () => Cividis11,
  Cividis256: () => Cividis256,
  Cividis3: () => Cividis3,
  Cividis4: () => Cividis4,
  Cividis5: () => Cividis5,
  Cividis6: () => Cividis6,
  Cividis7: () => Cividis7,
  Cividis8: () => Cividis8,
  Cividis9: () => Cividis9,
  Colorblind: () => Colorblind,
  Colorblind3: () => Colorblind3,
  Colorblind4: () => Colorblind4,
  Colorblind5: () => Colorblind5,
  Colorblind6: () => Colorblind6,
  Colorblind7: () => Colorblind7,
  Colorblind8: () => Colorblind8,
  Dark2: () => Dark2,
  Dark2_3: () => Dark2_3,
  Dark2_4: () => Dark2_4,
  Dark2_5: () => Dark2_5,
  Dark2_6: () => Dark2_6,
  Dark2_7: () => Dark2_7,
  Dark2_8: () => Dark2_8,
  DarkText: () => DarkText,
  GnBu: () => GnBu,
  GnBu3: () => GnBu3,
  GnBu4: () => GnBu4,
  GnBu5: () => GnBu5,
  GnBu6: () => GnBu6,
  GnBu7: () => GnBu7,
  GnBu8: () => GnBu8,
  GnBu9: () => GnBu9,
  Greens: () => Greens,
  Greens3: () => Greens3,
  Greens4: () => Greens4,
  Greens5: () => Greens5,
  Greens6: () => Greens6,
  Greens7: () => Greens7,
  Greens8: () => Greens8,
  Greens9: () => Greens9,
  Greys: () => Greys,
  Greys10: () => Greys10,
  Greys11: () => Greys11,
  Greys256: () => Greys256,
  Greys3: () => Greys3,
  Greys4: () => Greys4,
  Greys5: () => Greys5,
  Greys6: () => Greys6,
  Greys7: () => Greys7,
  Greys8: () => Greys8,
  Greys9: () => Greys92,
  HighContrast: () => HighContrast,
  HighContrast3: () => HighContrast3,
  Inferno: () => Inferno,
  Inferno10: () => Inferno10,
  Inferno11: () => Inferno11,
  Inferno256: () => Inferno256,
  Inferno3: () => Inferno3,
  Inferno4: () => Inferno4,
  Inferno5: () => Inferno5,
  Inferno6: () => Inferno6,
  Inferno7: () => Inferno7,
  Inferno8: () => Inferno8,
  Inferno9: () => Inferno9,
  Iridescent: () => Iridescent,
  Iridescent10: () => Iridescent10,
  Iridescent11: () => Iridescent11,
  Iridescent12: () => Iridescent12,
  Iridescent13: () => Iridescent13,
  Iridescent14: () => Iridescent14,
  Iridescent15: () => Iridescent15,
  Iridescent16: () => Iridescent16,
  Iridescent17: () => Iridescent17,
  Iridescent18: () => Iridescent18,
  Iridescent19: () => Iridescent19,
  Iridescent20: () => Iridescent20,
  Iridescent21: () => Iridescent21,
  Iridescent22: () => Iridescent22,
  Iridescent23: () => Iridescent23,
  Iridescent3: () => Iridescent3,
  Iridescent4: () => Iridescent4,
  Iridescent5: () => Iridescent5,
  Iridescent6: () => Iridescent6,
  Iridescent7: () => Iridescent7,
  Iridescent8: () => Iridescent8,
  Iridescent9: () => Iridescent9,
  Light: () => Light,
  Light3: () => Light3,
  Light4: () => Light4,
  Light5: () => Light5,
  Light6: () => Light6,
  Light7: () => Light7,
  Light8: () => Light8,
  Light9: () => Light9,
  Magma: () => Magma,
  Magma10: () => Magma10,
  Magma11: () => Magma11,
  Magma256: () => Magma256,
  Magma3: () => Magma3,
  Magma4: () => Magma4,
  Magma5: () => Magma5,
  Magma6: () => Magma6,
  Magma7: () => Magma7,
  Magma8: () => Magma8,
  Magma9: () => Magma9,
  MediumContrast: () => MediumContrast,
  MediumContrast3: () => MediumContrast3,
  MediumContrast4: () => MediumContrast4,
  MediumContrast5: () => MediumContrast5,
  MediumContrast6: () => MediumContrast6,
  Muted: () => Muted,
  Muted3: () => Muted3,
  Muted4: () => Muted4,
  Muted5: () => Muted5,
  Muted6: () => Muted6,
  Muted7: () => Muted7,
  Muted8: () => Muted8,
  Muted9: () => Muted9,
  OrRd: () => OrRd,
  OrRd3: () => OrRd3,
  OrRd4: () => OrRd4,
  OrRd5: () => OrRd5,
  OrRd6: () => OrRd6,
  OrRd7: () => OrRd7,
  OrRd8: () => OrRd8,
  OrRd9: () => OrRd9,
  Oranges: () => Oranges,
  Oranges3: () => Oranges3,
  Oranges4: () => Oranges4,
  Oranges5: () => Oranges5,
  Oranges6: () => Oranges6,
  Oranges7: () => Oranges7,
  Oranges8: () => Oranges8,
  Oranges9: () => Oranges9,
  PRGn: () => PRGn,
  PRGn10: () => PRGn10,
  PRGn11: () => PRGn11,
  PRGn3: () => PRGn3,
  PRGn4: () => PRGn4,
  PRGn5: () => PRGn5,
  PRGn6: () => PRGn6,
  PRGn7: () => PRGn7,
  PRGn8: () => PRGn8,
  PRGn9: () => PRGn9,
  Paired: () => Paired,
  Paired10: () => Paired10,
  Paired11: () => Paired11,
  Paired12: () => Paired12,
  Paired3: () => Paired3,
  Paired4: () => Paired4,
  Paired5: () => Paired5,
  Paired6: () => Paired6,
  Paired7: () => Paired7,
  Paired8: () => Paired8,
  Paired9: () => Paired9,
  PaleTextBackground: () => PaleTextBackground,
  Pastel1: () => Pastel1,
  Pastel1_3: () => Pastel1_3,
  Pastel1_4: () => Pastel1_4,
  Pastel1_5: () => Pastel1_5,
  Pastel1_6: () => Pastel1_6,
  Pastel1_7: () => Pastel1_7,
  Pastel1_8: () => Pastel1_8,
  Pastel1_9: () => Pastel1_9,
  Pastel2: () => Pastel2,
  Pastel2_3: () => Pastel2_3,
  Pastel2_4: () => Pastel2_4,
  Pastel2_5: () => Pastel2_5,
  Pastel2_6: () => Pastel2_6,
  Pastel2_7: () => Pastel2_7,
  Pastel2_8: () => Pastel2_8,
  PiYG: () => PiYG,
  PiYG10: () => PiYG10,
  PiYG11: () => PiYG11,
  PiYG3: () => PiYG3,
  PiYG4: () => PiYG4,
  PiYG5: () => PiYG5,
  PiYG6: () => PiYG6,
  PiYG7: () => PiYG7,
  PiYG8: () => PiYG8,
  PiYG9: () => PiYG9,
  Plasma: () => Plasma,
  Plasma10: () => Plasma10,
  Plasma11: () => Plasma11,
  Plasma256: () => Plasma256,
  Plasma3: () => Plasma3,
  Plasma4: () => Plasma4,
  Plasma5: () => Plasma5,
  Plasma6: () => Plasma6,
  Plasma7: () => Plasma7,
  Plasma8: () => Plasma8,
  Plasma9: () => Plasma9,
  PuBu: () => PuBu,
  PuBu3: () => PuBu3,
  PuBu4: () => PuBu4,
  PuBu5: () => PuBu5,
  PuBu6: () => PuBu6,
  PuBu7: () => PuBu7,
  PuBu8: () => PuBu8,
  PuBu9: () => PuBu9,
  PuBuGn: () => PuBuGn,
  PuBuGn3: () => PuBuGn3,
  PuBuGn4: () => PuBuGn4,
  PuBuGn5: () => PuBuGn5,
  PuBuGn6: () => PuBuGn6,
  PuBuGn7: () => PuBuGn7,
  PuBuGn8: () => PuBuGn8,
  PuBuGn9: () => PuBuGn9,
  PuOr: () => PuOr,
  PuOr10: () => PuOr10,
  PuOr11: () => PuOr11,
  PuOr3: () => PuOr3,
  PuOr4: () => PuOr4,
  PuOr5: () => PuOr5,
  PuOr6: () => PuOr6,
  PuOr7: () => PuOr7,
  PuOr8: () => PuOr8,
  PuOr9: () => PuOr9,
  PuRd: () => PuRd,
  PuRd3: () => PuRd3,
  PuRd4: () => PuRd4,
  PuRd5: () => PuRd5,
  PuRd6: () => PuRd6,
  PuRd7: () => PuRd7,
  PuRd8: () => PuRd8,
  PuRd9: () => PuRd9,
  Purples: () => Purples,
  Purples3: () => Purples3,
  Purples4: () => Purples4,
  Purples5: () => Purples5,
  Purples6: () => Purples6,
  Purples7: () => Purples7,
  Purples8: () => Purples8,
  Purples9: () => Purples9,
  RdBu: () => RdBu,
  RdBu10: () => RdBu10,
  RdBu11: () => RdBu11,
  RdBu3: () => RdBu3,
  RdBu4: () => RdBu4,
  RdBu5: () => RdBu5,
  RdBu6: () => RdBu6,
  RdBu7: () => RdBu7,
  RdBu8: () => RdBu8,
  RdBu9: () => RdBu9,
  RdGy: () => RdGy,
  RdGy10: () => RdGy10,
  RdGy11: () => RdGy11,
  RdGy3: () => RdGy3,
  RdGy4: () => RdGy4,
  RdGy5: () => RdGy5,
  RdGy6: () => RdGy6,
  RdGy7: () => RdGy7,
  RdGy8: () => RdGy8,
  RdGy9: () => RdGy9,
  RdPu: () => RdPu,
  RdPu3: () => RdPu3,
  RdPu4: () => RdPu4,
  RdPu5: () => RdPu5,
  RdPu6: () => RdPu6,
  RdPu7: () => RdPu7,
  RdPu8: () => RdPu8,
  RdPu9: () => RdPu9,
  RdYlBu: () => RdYlBu,
  RdYlBu10: () => RdYlBu10,
  RdYlBu11: () => RdYlBu11,
  RdYlBu3: () => RdYlBu3,
  RdYlBu4: () => RdYlBu4,
  RdYlBu5: () => RdYlBu5,
  RdYlBu6: () => RdYlBu6,
  RdYlBu7: () => RdYlBu7,
  RdYlBu8: () => RdYlBu8,
  RdYlBu9: () => RdYlBu9,
  RdYlGn: () => RdYlGn,
  RdYlGn10: () => RdYlGn10,
  RdYlGn11: () => RdYlGn11,
  RdYlGn3: () => RdYlGn3,
  RdYlGn4: () => RdYlGn4,
  RdYlGn5: () => RdYlGn5,
  RdYlGn6: () => RdYlGn6,
  RdYlGn7: () => RdYlGn7,
  RdYlGn8: () => RdYlGn8,
  RdYlGn9: () => RdYlGn9,
  Reds: () => Reds,
  Reds3: () => Reds3,
  Reds4: () => Reds4,
  Reds5: () => Reds5,
  Reds6: () => Reds6,
  Reds7: () => Reds7,
  Reds8: () => Reds8,
  Reds9: () => Reds9,
  Set1: () => Set1,
  Set1_3: () => Set1_3,
  Set1_4: () => Set1_4,
  Set1_5: () => Set1_5,
  Set1_6: () => Set1_6,
  Set1_7: () => Set1_7,
  Set1_8: () => Set1_8,
  Set1_9: () => Set1_9,
  Set2: () => Set2,
  Set2_3: () => Set2_3,
  Set2_4: () => Set2_4,
  Set2_5: () => Set2_5,
  Set2_6: () => Set2_6,
  Set2_7: () => Set2_7,
  Set2_8: () => Set2_8,
  Set3: () => Set3,
  Set3_10: () => Set3_10,
  Set3_11: () => Set3_11,
  Set3_12: () => Set3_12,
  Set3_3: () => Set3_3,
  Set3_4: () => Set3_4,
  Set3_5: () => Set3_5,
  Set3_6: () => Set3_6,
  Set3_7: () => Set3_7,
  Set3_8: () => Set3_8,
  Set3_9: () => Set3_9,
  Spectral: () => Spectral,
  Spectral10: () => Spectral10,
  Spectral11: () => Spectral11,
  Spectral3: () => Spectral3,
  Spectral4: () => Spectral4,
  Spectral5: () => Spectral5,
  Spectral6: () => Spectral6,
  Spectral7: () => Spectral7,
  Spectral8: () => Spectral8,
  Spectral9: () => Spectral9,
  Sunset: () => Sunset,
  Sunset10: () => Sunset10,
  Sunset11: () => Sunset11,
  Sunset3: () => Sunset3,
  Sunset4: () => Sunset4,
  Sunset5: () => Sunset5,
  Sunset6: () => Sunset6,
  Sunset7: () => Sunset7,
  Sunset8: () => Sunset8,
  Sunset9: () => Sunset9,
  TolPRGn: () => TolPRGn,
  TolPRGn3: () => TolPRGn3,
  TolPRGn4: () => TolPRGn4,
  TolPRGn5: () => TolPRGn5,
  TolPRGn6: () => TolPRGn6,
  TolPRGn7: () => TolPRGn7,
  TolPRGn8: () => TolPRGn8,
  TolPRGn9: () => TolPRGn9,
  TolRainbow: () => TolRainbow,
  TolRainbow10: () => TolRainbow10,
  TolRainbow11: () => TolRainbow11,
  TolRainbow12: () => TolRainbow12,
  TolRainbow13: () => TolRainbow13,
  TolRainbow14: () => TolRainbow14,
  TolRainbow15: () => TolRainbow15,
  TolRainbow16: () => TolRainbow16,
  TolRainbow17: () => TolRainbow17,
  TolRainbow18: () => TolRainbow18,
  TolRainbow19: () => TolRainbow19,
  TolRainbow20: () => TolRainbow20,
  TolRainbow21: () => TolRainbow21,
  TolRainbow22: () => TolRainbow22,
  TolRainbow23: () => TolRainbow23,
  TolRainbow3: () => TolRainbow3,
  TolRainbow4: () => TolRainbow4,
  TolRainbow5: () => TolRainbow5,
  TolRainbow6: () => TolRainbow6,
  TolRainbow7: () => TolRainbow7,
  TolRainbow8: () => TolRainbow8,
  TolRainbow9: () => TolRainbow9,
  TolYlOrBr: () => TolYlOrBr,
  TolYlOrBr3: () => TolYlOrBr3,
  TolYlOrBr4: () => TolYlOrBr4,
  TolYlOrBr5: () => TolYlOrBr5,
  TolYlOrBr6: () => TolYlOrBr6,
  TolYlOrBr7: () => TolYlOrBr7,
  TolYlOrBr8: () => TolYlOrBr8,
  TolYlOrBr9: () => TolYlOrBr9,
  Turbo: () => Turbo,
  Turbo10: () => Turbo10,
  Turbo11: () => Turbo11,
  Turbo256: () => Turbo256,
  Turbo3: () => Turbo3,
  Turbo4: () => Turbo4,
  Turbo5: () => Turbo5,
  Turbo6: () => Turbo6,
  Turbo7: () => Turbo7,
  Turbo8: () => Turbo8,
  Turbo9: () => Turbo9,
  Vibrant: () => Vibrant,
  Vibrant3: () => Vibrant3,
  Vibrant4: () => Vibrant4,
  Vibrant5: () => Vibrant5,
  Vibrant6: () => Vibrant6,
  Vibrant7: () => Vibrant7,
  Viridis: () => Viridis,
  Viridis10: () => Viridis10,
  Viridis11: () => Viridis11,
  Viridis256: () => Viridis256,
  Viridis3: () => Viridis3,
  Viridis4: () => Viridis4,
  Viridis5: () => Viridis5,
  Viridis6: () => Viridis6,
  Viridis7: () => Viridis7,
  Viridis8: () => Viridis8,
  Viridis9: () => Viridis9,
  YlGn: () => YlGn,
  YlGn3: () => YlGn3,
  YlGn4: () => YlGn4,
  YlGn5: () => YlGn5,
  YlGn6: () => YlGn6,
  YlGn7: () => YlGn7,
  YlGn8: () => YlGn8,
  YlGn9: () => YlGn9,
  YlGnBu: () => YlGnBu,
  YlGnBu3: () => YlGnBu3,
  YlGnBu4: () => YlGnBu4,
  YlGnBu5: () => YlGnBu5,
  YlGnBu6: () => YlGnBu6,
  YlGnBu7: () => YlGnBu7,
  YlGnBu8: () => YlGnBu8,
  YlGnBu9: () => YlGnBu9,
  YlOrBr: () => YlOrBr,
  YlOrBr3: () => YlOrBr3,
  YlOrBr4: () => YlOrBr4,
  YlOrBr5: () => YlOrBr5,
  YlOrBr6: () => YlOrBr6,
  YlOrBr7: () => YlOrBr7,
  YlOrBr8: () => YlOrBr8,
  YlOrBr9: () => YlOrBr9,
  YlOrRd: () => YlOrRd,
  YlOrRd3: () => YlOrRd3,
  YlOrRd4: () => YlOrRd4,
  YlOrRd5: () => YlOrRd5,
  YlOrRd6: () => YlOrRd6,
  YlOrRd7: () => YlOrRd7,
  YlOrRd8: () => YlOrRd8,
  YlOrRd9: () => YlOrRd9,
  bokeh: () => bokeh,
  brewer: () => brewer,
  cividis: () => cividis,
  colorblind: () => colorblind,
  d3: () => d3,
  grey: () => grey2,
  inferno: () => inferno,
  interp_palette: () => interp_palette,
  linear_palette: () => linear_palette,
  magma: () => magma,
  mpl: () => mpl,
  plasma: () => plasma,
  tol: () => tol,
  turbo: () => turbo,
  varying_alpha_palette: () => varying_alpha_palette,
  viridis: () => viridis
});
var YlGn3 = [832787711, 2916978431, 4160535039];
var YlGn4 = [595870719, 2026273279, 3269892607, 4294954239];
var YlGn5 = [6830079, 832787711, 2026273279, 3269892607, 4294954239];
var YlGn6 = [6830079, 832787711, 2026273279, 2916978431, 3656426495, 4294954239];
var YlGn7 = [5911295, 595870719, 1101749759, 2026273279, 2916978431, 3656426495, 4294954239];
var YlGn8 = [5911295, 595870719, 1101749759, 2026273279, 2916978431, 3656426495, 4160535039, 4294960639];
var YlGn9 = [4532735, 6830079, 595870719, 1101749759, 2026273279, 2916978431, 3656426495, 4160535039, 4294960639];
var YlGnBu3 = [746567935, 2144189439, 3992498687];
var YlGnBu4 = [576628991, 1102497023, 2715464959, 4294954239];
var YlGnBu5 = [624203007, 746567935, 1102497023, 2715464959, 4294954239];
var YlGnBu6 = [624203007, 746567935, 1102497023, 2144189439, 3353982207, 4294954239];
var YlGnBu7 = [204244223, 576628991, 496091391, 1102497023, 2144189439, 3353982207, 4294954239];
var YlGnBu8 = [204244223, 576628991, 496091391, 1102497023, 2144189439, 3353982207, 3992498687, 4294957567];
var YlGnBu9 = [136141055, 624203007, 576628991, 496091391, 1102497023, 2144189439, 3353982207, 3992498687, 4294957567];
var GnBu3 = [1134742271, 2833102335, 3774077951];
var GnBu4 = [730644223, 2077017343, 3135552767, 4042909951];
var GnBu5 = [141077759, 1134742271, 2077017343, 3135552767, 4042909951];
var GnBu6 = [141077759, 1134742271, 2077017343, 2833102335, 3438003711, 4042909951];
var GnBu7 = [140025599, 730644223, 1320408063, 2077017343, 2833102335, 3438003711, 4042909951];
var GnBu8 = [140025599, 730644223, 1320408063, 2077017343, 2833102335, 3438003711, 3774077951, 4160549119];
var GnBu9 = [138445311, 141077759, 730644223, 1320408063, 2077017343, 2833102335, 3438003711, 3774077951, 4160549119];
var BuGn3 = [748838911, 2581121535, 3858102783];
var BuGn4 = [596329983, 1724032255, 3001213695, 3992517631];
var BuGn5 = [7154943, 748838911, 1724032255, 3001213695, 3992517631];
var BuGn6 = [7154943, 748838911, 1724032255, 2581121535, 3438077695, 3992517631];
var BuGn7 = [5776639, 596329983, 1101952767, 1724032255, 2581121535, 3438077695, 3992517631];
var BuGn8 = [5776639, 596329983, 1101952767, 1724032255, 2581121535, 3438077695, 3858102783, 4160552447];
var BuGn9 = [4463615, 7154943, 596329983, 1101952767, 1724032255, 2581121535, 3438077695, 3858102783, 4160552447];
var PuBuGn3 = [479238655, 2797460479, 3974295807];
var PuBuGn4 = [42044159, 1739182079, 3184124415, 4142921727];
var PuBuGn5 = [23878143, 479238655, 1739182079, 3184124415, 4142921727];
var PuBuGn6 = [23878143, 479238655, 1739182079, 2797460479, 3503417087, 4142921727];
var PuBuGn7 = [23351551, 42044159, 915456255, 1739182079, 2797460479, 3503417087, 4142921727];
var PuBuGn8 = [23351551, 42044159, 915456255, 1739182079, 2797460479, 3503417087, 3974295807, 4294441983];
var PuBuGn9 = [21378815, 23878143, 42044159, 915456255, 1739182079, 2797460479, 3503417087, 3974295807, 4294441983];
var PuBu3 = [730644223, 2797460479, 3974623999];
var PuBu4 = [91271423, 1957285887, 3184124415, 4058969855];
var PuBu5 = [73043455, 730644223, 1957285887, 3184124415, 4058969855];
var PuBu6 = [73043455, 730644223, 1957285887, 2797460479, 3503417087, 4058969855];
var PuBu7 = [55475199, 91271423, 915456255, 1957285887, 2797460479, 3503417087, 4058969855];
var PuBu8 = [55475199, 91271423, 915456255, 1957285887, 2797460479, 3503417087, 3974623999, 4294441983];
var PuBu9 = [37247231, 73043455, 91271423, 915456255, 1957285887, 2797460479, 3503417087, 3974623999, 4294441983];
var BuPu3 = [2287380479, 2663176959, 3773625599];
var BuPu4 = [2286001663, 2358691583, 3016614911, 3992517631];
var BuPu5 = [2165275903, 2287380479, 2358691583, 3016614911, 3992517631];
var BuPu6 = [2165275903, 2287380479, 2358691583, 2663176959, 3218335487, 3992517631];
var BuPu7 = [1845586943, 2286001663, 2355868159, 2358691583, 2663176959, 3218335487, 3992517631];
var BuPu8 = [1845586943, 2286001663, 2355868159, 2358691583, 2663176959, 3218335487, 3773625599, 4160552447];
var BuPu9 = [1291865087, 2165275903, 2286001663, 2355868159, 2358691583, 2663176959, 3218335487, 3773625599, 4160552447];
var RdPu3 = [3306916607, 4204770815, 4259372543];
var RdPu4 = [2919333631, 4150829567, 4222925311, 4276871935];
var RdPu5 = [2046916607, 3306916607, 4150829567, 4222925311, 4276871935];
var RdPu6 = [2046916607, 3306916607, 4150829567, 4204770815, 4240818431, 4276871935];
var RdPu7 = [2046916607, 2919333631, 3711211519, 4150829567, 4204770815, 4240818431, 4276871935];
var RdPu8 = [2046916607, 2919333631, 3711211519, 4150829567, 4204770815, 4240818431, 4259372543, 4294439935];
var RdPu9 = [1224764159, 2046916607, 2919333631, 3711211519, 4150829567, 4204770815, 4240818431, 4259372543, 4294439935];
var PuRd3 = [3709630463, 3381970943, 3890343935];
var PuRd4 = [3457308415, 3747983615, 3619019007, 4058969855];
var PuRd5 = [2550154239, 3709630463, 3747983615, 3619019007, 4058969855];
var PuRd6 = [2550154239, 3709630463, 3747983615, 3381970943, 3568950015, 4058969855];
var PuRd7 = [2432712703, 3457308415, 3878259455, 3747983615, 3381970943, 3568950015, 4058969855];
var PuRd8 = [2432712703, 3457308415, 3878259455, 3747983615, 3381970943, 3568950015, 3890343935, 4160027135];
var PuRd9 = [1728061439, 2550154239, 3457308415, 3878259455, 3747983615, 3381970943, 3568950015, 3890343935, 4160027135];
var OrRd3 = [3813291007, 4256924927, 4276668671];
var OrRd4 = [3610255359, 4237122047, 4258040575, 4277197311];
var OrRd5 = [3003121919, 3813291007, 4237122047, 4258040575, 4277197311];
var OrRd6 = [3003121919, 3813291007, 4237122047, 4256924927, 4258569983, 4277197311];
var OrRd7 = [2566914303, 3610255359, 4016392447, 4237122047, 4256924927, 4258569983, 4277197311];
var OrRd8 = [2566914303, 3610255359, 4016392447, 4237122047, 4256924927, 4258569983, 4276668671, 4294438143];
var OrRd9 = [2130706687, 3003121919, 3610255359, 4016392447, 4237122047, 4256924927, 4258569983, 4276668671, 4294438143];
var YlOrRd3 = [4030406911, 4273097983, 4293763327];
var YlOrRd4 = [3810139391, 4253891839, 4274806015, 4294947583];
var YlOrRd5 = [3170903807, 4030406911, 4253891839, 4274806015, 4294947583];
var YlOrRd6 = [3170903807, 4030406911, 4253891839, 4273097983, 4275664639, 4294947583];
var YlOrRd7 = [2969577215, 3810139391, 4232981247, 4253891839, 4273097983, 4275664639, 4294947583];
var YlOrRd8 = [2969577215, 3810139391, 4232981247, 4253891839, 4273097983, 4275664639, 4293763327, 4294954239];
var YlOrRd9 = [2147493631, 3170903807, 3810139391, 4232981247, 4253891839, 4273097983, 4275664639, 4293763327, 4294954239];
var YlOrBr3 = [3646885631, 4274278399, 4294425855];
var YlOrBr4 = [3427533567, 4271450623, 4275670783, 4294956287];
var YlOrBr5 = [2570323199, 3646885631, 4271450623, 4275670783, 4294956287];
var YlOrBr6 = [2570323199, 3646885631, 4271450623, 4274278399, 4276326911, 4294956287];
var YlOrBr7 = [2351760639, 3427533567, 3966768383, 4271450623, 4274278399, 4276326911, 4294956287];
var YlOrBr8 = [2351760639, 3427533567, 3966768383, 4271450623, 4274278399, 4276326911, 4294425855, 4294960639];
var YlOrBr9 = [1713702655, 2570323199, 3427533567, 3966768383, 4271450623, 4274278399, 4276326911, 4294425855, 4294960639];
var Purples3 = [1969992191, 3166559487, 4025349631];
var Purples4 = [1783735295, 2660944127, 3419005695, 4075878399];
var Purples5 = [1411878911, 1969992191, 2660944127, 3419005695, 4075878399];
var Purples6 = [1411878911, 1969992191, 2660944127, 3166559487, 3671780351, 4075878399];
var Purples7 = [1242859263, 1783735295, 2155723519, 2660944127, 3166559487, 3671780351, 4075878399];
var Purples8 = [1242859263, 1783735295, 2155723519, 2660944127, 3166559487, 3671780351, 4025349631, 4244372991];
var Purples9 = [1056996863, 1411878911, 1783735295, 2155723519, 2660944127, 3166559487, 3671780351, 4025349631, 4244372991];
var Blues3 = [830651903, 2664096255, 3740006399];
var Blues4 = [561100287, 1806620415, 3185043455, 4025745407];
var Blues5 = [139566335, 830651903, 1806620415, 3185043455, 4025745407];
var Blues6 = [139566335, 830651903, 1806620415, 2664096255, 3336302591, 4025745407];
var Blues7 = [138777855, 561100287, 1116915455, 1806620415, 2664096255, 3336302591, 4025745407];
var Blues8 = [138777855, 561100287, 1116915455, 1806620415, 2664096255, 3336302591, 3740006399, 4160487423];
var Blues9 = [137391103, 139566335, 561100287, 1116915455, 1806620415, 2664096255, 3336302591, 3740006399, 4160487423];
var Greens3 = [832787711, 2715393023, 3858096383];
var Greens4 = [596329983, 1959032575, 3135550463, 3992513023];
var Greens5 = [7154943, 832787711, 1959032575, 3135550463, 3992513023];
var Greens6 = [7154943, 832787711, 1959032575, 2715393023, 3353985279, 3992513023];
var Greens7 = [5911295, 596329983, 1101749759, 1959032575, 2715393023, 3353985279, 3992513023];
var Greens8 = [5911295, 596329983, 1101749759, 1959032575, 2715393023, 3353985279, 3858096383, 4160550399];
var Greens9 = [4463615, 7154943, 596329983, 1101749759, 1959032575, 2715393023, 3353985279, 3858096383, 4160550399];
var Oranges3 = [3864333823, 4256066559, 4276539135];
var Oranges4 = [3645309439, 4253891839, 4257121791, 4277001983];
var Oranges5 = [2788557823, 3864333823, 4253891839, 4257121791, 4277001983];
var Oranges6 = [2788557823, 3864333823, 4253891839, 4256066559, 4258308863, 4277001983];
var Oranges7 = [2351760639, 3645374975, 4050195455, 4253891839, 4256066559, 4258308863, 4277001983];
var Oranges8 = [2351760639, 3645374975, 4050195455, 4253891839, 4256066559, 4258308863, 4276539135, 4294306815];
var Oranges9 = [2133263615, 2788557823, 3645374975, 4050195455, 4253891839, 4256066559, 4258308863, 4276539135, 4294306815];
var Reds3 = [3727501055, 4237456127, 4276146943];
var Reds4 = [3407355391, 4218047231, 4239299071, 4276476415];
var Reds5 = [2769229311, 3727501055, 4218047231, 4239299071, 4276476415];
var Reds6 = [2769229311, 3727501055, 4218047231, 4237456127, 4240155135, 4276476415];
var Reds7 = [2566917631, 3407355391, 4013632767, 4218047231, 4237456127, 4240155135, 4276476415];
var Reds8 = [2566917631, 3407355391, 4013632767, 4218047231, 4237456127, 4240155135, 4276146943, 4294308095];
var Reds9 = [1728056831, 2769229311, 3407355391, 4013632767, 4218047231, 4237456127, 4240155135, 4276146943, 4294308095];
var Greys3 = [1667458047, 3183328767, 4042322175];
var Greys4 = [1381126911, 2526451455, 3435973887, 4160223231];
var Greys5 = [623191551, 1667458047, 2526451455, 3435973887, 4160223231];
var Greys6 = [623191551, 1667458047, 2526451455, 3183328767, 3654932991, 4160223231];
var Greys7 = [623191551, 1381126911, 1936946175, 2526451455, 3183328767, 3654932991, 4160223231];
var Greys8 = [623191551, 1381126911, 1936946175, 2526451455, 3183328767, 3654932991, 4042322175, 4294967295];
var Greys92 = [255, 623191551, 1381126911, 1936946175, 2526451455, 3183328767, 3654932991, 4042322175, 4294967295];
var Greys10 = [255, 471604479, 943208703, 1431655935, 1903260159, 2374864383, 2863311615, 3334915839, 3806520063, 4294967295];
var Greys11 = [255, 421075455, 858993663, 1280068863, 1717987071, 2139062271, 2576980479, 2998055679, 3435973887, 3857049087, 4294967295];
var Greys256 = [
  255,
  16843263,
  33686271,
  50529279,
  67372287,
  84215295,
  101058303,
  117901311,
  134744319,
  151587327,
  168430335,
  185273343,
  202116351,
  218959359,
  235802367,
  252645375,
  269488383,
  286331391,
  303174399,
  320017407,
  336860415,
  353703423,
  370546431,
  387389439,
  404232447,
  421075455,
  437918463,
  454761471,
  471604479,
  488447487,
  505290495,
  522133503,
  538976511,
  555819519,
  572662527,
  589505535,
  606348543,
  623191551,
  640034559,
  656877567,
  673720575,
  690563583,
  707406591,
  724249599,
  741092607,
  757935615,
  774778623,
  791621631,
  808464639,
  825307647,
  842150655,
  858993663,
  875836671,
  892679679,
  909522687,
  926365695,
  943208703,
  960051711,
  976894719,
  993737727,
  1010580735,
  1027423743,
  1044266751,
  1061109759,
  1077952767,
  1094795775,
  1111638783,
  1128481791,
  1145324799,
  1162167807,
  1179010815,
  1195853823,
  1212696831,
  1229539839,
  1246382847,
  1263225855,
  1280068863,
  1296911871,
  1313754879,
  1330597887,
  1347440895,
  1364283903,
  1381126911,
  1397969919,
  1414812927,
  1431655935,
  1448498943,
  1465341951,
  1482184959,
  1499027967,
  1515870975,
  1532713983,
  1549556991,
  1566399999,
  1583243007,
  1600086015,
  1616929023,
  1633772031,
  1650615039,
  1667458047,
  1684301055,
  1701144063,
  1717987071,
  1734830079,
  1751673087,
  1768516095,
  1785359103,
  1802202111,
  1819045119,
  1835888127,
  1852731135,
  1869574143,
  1886417151,
  1903260159,
  1920103167,
  1936946175,
  1953789183,
  1970632191,
  1987475199,
  2004318207,
  2021161215,
  2038004223,
  2054847231,
  2071690239,
  2088533247,
  2105376255,
  2122219263,
  2139062271,
  2155905279,
  2172748287,
  2189591295,
  2206434303,
  2223277311,
  2240120319,
  2256963327,
  2273806335,
  2290649343,
  2307492351,
  2324335359,
  2341178367,
  2358021375,
  2374864383,
  2391707391,
  2408550399,
  2425393407,
  2442236415,
  2459079423,
  2475922431,
  2492765439,
  2509608447,
  2526451455,
  2543294463,
  2560137471,
  2576980479,
  2593823487,
  2610666495,
  2627509503,
  2644352511,
  2661195519,
  2678038527,
  2694881535,
  2711724543,
  2728567551,
  2745410559,
  2762253567,
  2779096575,
  2795939583,
  2812782591,
  2829625599,
  2846468607,
  2863311615,
  2880154623,
  2896997631,
  2913840639,
  2930683647,
  2947526655,
  2964369663,
  2981212671,
  2998055679,
  3014898687,
  3031741695,
  3048584703,
  3065427711,
  3082270719,
  3099113727,
  3115956735,
  3132799743,
  3149642751,
  3166485759,
  3183328767,
  3200171775,
  3217014783,
  3233857791,
  3250700799,
  3267543807,
  3284386815,
  3301229823,
  3318072831,
  3334915839,
  3351758847,
  3368601855,
  3385444863,
  3402287871,
  3419130879,
  3435973887,
  3452816895,
  3469659903,
  3486502911,
  3503345919,
  3520188927,
  3537031935,
  3553874943,
  3570717951,
  3587560959,
  3604403967,
  3621246975,
  3638089983,
  3654932991,
  3671775999,
  3688619007,
  3705462015,
  3722305023,
  3739148031,
  3755991039,
  3772834047,
  3789677055,
  3806520063,
  3823363071,
  3840206079,
  3857049087,
  3873892095,
  3890735103,
  3907578111,
  3924421119,
  3941264127,
  3958107135,
  3974950143,
  3991793151,
  4008636159,
  4025479167,
  4042322175,
  4059165183,
  4076008191,
  4092851199,
  4109694207,
  4126537215,
  4143380223,
  4160223231,
  4177066239,
  4193909247,
  4210752255,
  4227595263,
  4244438271,
  4261281279,
  4278124287,
  4294967295
];
var PuOr3 = [2576270335, 4160223231, 4054008063];
var PuOr4 = [1581029887, 2997605119, 4256719871, 3865117183];
var PuOr5 = [1581029887, 2997605119, 4160223231, 4256719871, 3865117183];
var PuOr6 = [1411877119, 2576270335, 3638225919, 4276139775, 4054008063, 3008890623];
var PuOr7 = [1411877119, 2576270335, 3638225919, 4160223231, 4276139775, 4054008063, 3008890623];
var PuOr8 = [1411877119, 2155064575, 2997605119, 3638225919, 4276139775, 4256719871, 3766621439, 3008890623];
var PuOr9 = [1411877119, 2155064575, 2997605119, 3638225919, 4160223231, 4276139775, 4256719871, 3766621439, 3008890623];
var PuOr10 = [754994175, 1411877119, 2155064575, 2997605119, 3638225919, 4276139775, 4256719871, 3766621439, 3008890623, 2134575359];
var PuOr11 = [754994175, 1411877119, 2155064575, 2997605119, 3638225919, 4160223231, 4276139775, 4256719871, 3766621439, 3008890623, 2134575359];
var BrBG3 = [1521790207, 4126537215, 3635635711];
var BrBG4 = [25522687, 2160968191, 3754065407, 2791381759];
var BrBG5 = [25522687, 2160968191, 4126537215, 3754065407, 2791381759];
var BrBG6 = [23486207, 1521790207, 3354060287, 4142449663, 3635635711, 2354121471];
var BrBG7 = [23486207, 1521790207, 3354060287, 4126537215, 4142449663, 3635635711, 2354121471];
var BrBG8 = [23486207, 899125247, 2160968191, 3354060287, 4142449663, 3754065407, 3212914175, 2354121471];
var BrBG9 = [23486207, 899125247, 2160968191, 3354060287, 4126537215, 4142449663, 3754065407, 3212914175, 2354121471];
var BrBG10 = [3944703, 23486207, 899125247, 2160968191, 3354060287, 4142449663, 3754065407, 3212914175, 2354121471, 1412433407];
var BrBG11 = [3944703, 23486207, 899125247, 2160968191, 3354060287, 4126537215, 4142449663, 3754065407, 3212914175, 2354121471, 1412433407];
var PRGn3 = [2143255551, 4160223231, 2945303551];
var PRGn4 = [8927231, 2799411455, 3265646591, 2066912511];
var PRGn5 = [8927231, 2799411455, 4160223231, 3265646591, 2066912511];
var PRGn6 = [460863487, 2143255551, 3656438783, 3889490175, 2945303551, 1982497791];
var PRGn7 = [460863487, 2143255551, 3656438783, 4160223231, 3889490175, 2945303551, 1982497791];
var PRGn8 = [460863487, 1521377791, 2799411455, 3656438783, 3889490175, 3265646591, 2574298111, 1982497791];
var PRGn9 = [460863487, 1521377791, 2799411455, 3656438783, 4160223231, 3889490175, 3265646591, 2574298111, 1982497791];
var PRGn10 = [4463615, 460863487, 1521377791, 2799411455, 3656438783, 3889490175, 3265646591, 2574298111, 1982497791, 1073761279];
var PRGn11 = [4463615, 460863487, 1521377791, 2799411455, 3656438783, 4160223231, 3889490175, 3265646591, 2574298111, 1982497791, 1073761279];
var PiYG3 = [2715249407, 4160223231, 3919825407];
var PiYG4 = [1303127807, 3101787903, 4055292671, 3491531775];
var PiYG5 = [1303127807, 3101787903, 4160223231, 4055292671, 3491531775];
var PiYG6 = [1301422591, 2715249407, 3874869503, 4259377151, 3919825407, 3306913279];
var PiYG7 = [1301422591, 2715249407, 3874869503, 4160223231, 4259377151, 3919825407, 3306913279];
var PiYG8 = [1301422591, 2143044095, 3101787903, 3874869503, 4259377151, 4055292671, 3732385535, 3306913279];
var PiYG9 = [1301422591, 2143044095, 3101787903, 3874869503, 4160223231, 4259377151, 4055292671, 3732385535, 3306913279];
var PiYG10 = [660871679, 1301422591, 2143044095, 3101787903, 3874869503, 4259377151, 4055292671, 3732385535, 3306913279, 2382451455];
var PiYG11 = [660871679, 1301422591, 2143044095, 3101787903, 3874869503, 4160223231, 4259377151, 4055292671, 3732385535, 3306913279, 2382451455];
var RdBu3 = [1739182079, 4160223231, 4018823935];
var RdBu4 = [91336959, 2462441215, 4104487679, 3389006079];
var RdBu5 = [91336959, 2462441215, 4160223231, 4104487679, 3389006079];
var RdBu6 = [560377087, 1739182079, 3521507583, 4259039231, 4018823935, 2987928575];
var RdBu7 = [560377087, 1739182079, 3521507583, 4160223231, 4259039231, 4018823935, 2987928575];
var RdBu8 = [560377087, 1133757439, 2462441215, 3521507583, 4259039231, 4104487679, 3596635647, 2987928575];
var RdBu9 = [560377087, 1133757439, 2462441215, 3521507583, 4160223231, 4259039231, 4104487679, 3596635647, 2987928575];
var RdBu10 = [87056895, 560377087, 1133757439, 2462441215, 3521507583, 4259039231, 4104487679, 3596635647, 2987928575, 1728061439];
var RdBu11 = [87056895, 560377087, 1133757439, 2462441215, 3521507583, 4160223231, 4259039231, 4104487679, 3596635647, 2987928575, 1728061439];
var RdGy3 = [2576980479, 4294967295, 4018823935];
var RdGy4 = [1077952767, 3132799743, 4104487679, 3389006079];
var RdGy5 = [1077952767, 3132799743, 4294967295, 4104487679, 3389006079];
var RdGy6 = [1296911871, 2576980479, 3772834047, 4259039231, 4018823935, 2987928575];
var RdGy7 = [1296911871, 2576980479, 3772834047, 4294967295, 4259039231, 4018823935, 2987928575];
var RdGy8 = [1296911871, 2273806335, 3132799743, 3772834047, 4259039231, 4104487679, 3596635647, 2987928575];
var RdGy9 = [1296911871, 2273806335, 3132799743, 3772834047, 4294967295, 4259039231, 4104487679, 3596635647, 2987928575];
var RdGy10 = [437918463, 1296911871, 2273806335, 3132799743, 3772834047, 4259039231, 4104487679, 3596635647, 2987928575, 1728061439];
var RdGy11 = [437918463, 1296911871, 2273806335, 3132799743, 3772834047, 4294967295, 4259039231, 4104487679, 3596635647, 2987928575, 1728061439];
var RdYlBu3 = [2445270015, 4294950911, 4237122047];
var RdYlBu4 = [746305279, 2883185151, 4256063999, 3608747263];
var RdYlBu5 = [746305279, 2883185151, 4294950911, 4256063999, 3608747263];
var RdYlBu6 = [1165341951, 2445270015, 3774085375, 4276130047, 4237122047, 3610257407];
var RdYlBu7 = [1165341951, 2445270015, 3774085375, 4294950911, 4276130047, 4237122047, 3610257407];
var RdYlBu8 = [1165341951, 1957548543, 2883185151, 3774085375, 4276130047, 4256063999, 4100801535, 3610257407];
var RdYlBu9 = [1165341951, 1957548543, 2883185151, 3774085375, 4294950911, 4276130047, 4256063999, 4100801535, 3610257407];
var RdYlBu10 = [825660927, 1165341951, 1957548543, 2883185151, 3774085375, 4276130047, 4256063999, 4100801535, 3610257407, 2768250623];
var RdYlBu11 = [825660927, 1165341951, 1957548543, 2883185151, 3774085375, 4294950911, 4276130047, 4256063999, 4100801535, 3610257407, 2768250623];
var Spectral3 = [2580911359, 4294950911, 4237122047];
var Spectral4 = [730053375, 2883429631, 4256063999, 3608747263];
var Spectral5 = [730053375, 2883429631, 4294950911, 4256063999, 3608747263];
var Spectral6 = [847822335, 2580911359, 3874855167, 4276128767, 4237122047, 3577630719];
var Spectral7 = [847822335, 2580911359, 3874855167, 4294950911, 4276128767, 4237122047, 3577630719];
var Spectral8 = [847822335, 1724032511, 2883429631, 3874855167, 4276128767, 4256063999, 4100801535, 3577630719];
var Spectral9 = [847822335, 1724032511, 2883429631, 3874855167, 4294950911, 4276128767, 4256063999, 4100801535, 3577630719];
var Spectral10 = [1582277375, 847822335, 1724032511, 2883429631, 3874855167, 4276128767, 4256063999, 4100801535, 3577630719, 2650882815];
var Spectral11 = [1582277375, 847822335, 1724032511, 2883429631, 3874855167, 4294950911, 4276128767, 4256063999, 4100801535, 3577630719, 2650882815];
var RdYlGn3 = [2446287103, 4294950911, 4237122047];
var RdYlGn4 = [446054911, 2799266559, 4256063999, 3608747263];
var RdYlGn5 = [446054911, 2799266559, 4294950911, 4256063999, 3608747263];
var RdYlGn6 = [446189823, 2446287103, 3656354815, 4276128767, 4237122047, 3610257407];
var RdYlGn7 = [446189823, 2446287103, 3656354815, 4294950911, 4276128767, 4237122047, 3610257407];
var RdYlGn8 = [446189823, 1723687935, 2799266559, 3656354815, 4276128767, 4256063999, 4100801535, 3610257407];
var RdYlGn9 = [446189823, 1723687935, 2799266559, 3656354815, 4294950911, 4276128767, 4256063999, 4100801535, 3610257407];
var RdYlGn10 = [6830079, 446189823, 1723687935, 2799266559, 3656354815, 4276128767, 4256063999, 4100801535, 3610257407, 2768250623];
var RdYlGn11 = [6830079, 446189823, 1723687935, 2799266559, 3656354815, 4294950911, 4276128767, 4256063999, 4100801535, 3610257407, 2768250623];
var Bokeh3 = [3960821759, 4031915007, 4138277887];
var Bokeh4 = [...Bokeh3, 2781690367];
var Bokeh5 = [...Bokeh4, 548558079];
var Bokeh6 = [...Bokeh5, 11185919];
var Bokeh7 = [...Bokeh6, 2301135359];
var Bokeh8 = [...Bokeh6, 1234752511, 2301135359];
var Inferno3 = [1023, 3124123135, 4244546815];
var Inferno4 = [1023, 2015129087, 3983025663, 4244546815];
var Inferno5 = [1023, 1427074559, 3124123135, 4186704383, 4244546815];
var Inferno6 = [1023, 1091135487, 2468702207, 3696245247, 4221831935, 4244546815];
var Inferno7 = [1023, 839474687, 2015129087, 3124123135, 3983025663, 4222818559, 4244546815];
var Inferno8 = [1023, 655053567, 1662283519, 2653512703, 3527885567, 4118550015, 4206831103, 4244546815];
var Inferno9 = [1023, 520898559, 1427074559, 2283891455, 3124123135, 3814208255, 4186704383, 4173935103, 4244546815];
var Inferno10 = [1023, 436945151, 1242262271, 2015129087, 2754371839, 3443673087, 3983025663, 4221110015, 4157553407, 4244546815];
var Inferno11 = [1023, 369834495, 1091135487, 1779920639, 2468702207, 3124123135, 3696245247, 4067760895, 4221831935, 4141171455, 4244546815];
var Inferno256 = [
  1023,
  1279,
  1791,
  16779263,
  16845311,
  16845823,
  33623807,
  33689855,
  50467583,
  67310847,
  67311359,
  84154623,
  100932607,
  117775871,
  134619135,
  151396863,
  168240127,
  185018111,
  218638591,
  235416319,
  252259839,
  269037567,
  302658303,
  319436031,
  336279295,
  369834495,
  386612223,
  420167423,
  436945151,
  470565887,
  487343615,
  520898559,
  537676543,
  571165951,
  604720895,
  638275839,
  655053567,
  688608511,
  722097919,
  755652863,
  772430591,
  805985535,
  839474687,
  873029631,
  889807103,
  923361791,
  956916479,
  990471423,
  1007248895,
  1040803583,
  1074358015,
  1091135487,
  1124755711,
  1158310399,
  1175087615,
  1208707839,
  1242262271,
  1259105279,
  1292659711,
  1326279935,
  1343057151,
  1376677119,
  1393454591,
  1427074559,
  1460628991,
  1477471743,
  1511091711,
  1527869183,
  1561489151,
  1595043583,
  1611886335,
  1645506303,
  1662283519,
  1695903487,
  1712680703,
  1746300671,
  1779920639,
  1796697855,
  1830317823,
  1847095039,
  1880715007,
  1914269183,
  1931111935,
  1964731903,
  1981509119,
  2015129087,
  2048683519,
  2065526015,
  2099080447,
  2115923199,
  2149542911,
  2166320127,
  2199940095,
  2233494271,
  2250337023,
  2283891455,
  2300733951,
  2334288383,
  2367908351,
  2384750847,
  2418305279,
  2435147775,
  2468702207,
  2502321919,
  2519099135,
  2552718847,
  2569561343,
  2603115775,
  2619958271,
  2653512703,
  2687132415,
  2703974911,
  2737529343,
  2754371839,
  2787926015,
  2804768767,
  2838388479,
  2871942655,
  2888785151,
  2922404863,
  2939247615,
  2972801791,
  2989644287,
  3023263999,
  3040040959,
  3073660671,
  3090503423,
  3124123135,
  3140965631,
  3174519807,
  3191362303,
  3208204799,
  3241824511,
  3258667007,
  3292286719,
  3309129215,
  3342748927,
  3359525887,
  3376368383,
  3409988095,
  3426830591,
  3443673087,
  3477358335,
  3494200575,
  3511043071,
  3527885567,
  3561505279,
  3578347775,
  3595190271,
  3612032767,
  3645718015,
  3662560255,
  3679402751,
  3696245247,
  3713153279,
  3729995775,
  3746838271,
  3763746047,
  3797365759,
  3814208255,
  3831116287,
  3847958783,
  3864801023,
  3864931839,
  3881774335,
  3898682367,
  3915524863,
  3932432639,
  3949275135,
  3966183167,
  3983025663,
  3983156223,
  4000064255,
  4016906751,
  4033814527,
  4033879807,
  4050787839,
  4067695871,
  4067760895,
  4084668927,
  4084799743,
  4101641983,
  4118550015,
  4118680831,
  4135588607,
  4135653887,
  4152561919,
  4152692479,
  4169600511,
  4169665791,
  4169796607,
  4186704383,
  4186835199,
  4186966271,
  4203808767,
  4203939583,
  4204070655,
  4204201727,
  4221110015,
  4221241087,
  4221372159,
  4221437951,
  4221569023,
  4221700351,
  4221831935,
  4221963263,
  4222094847,
  4222226175,
  4222357759,
  4222489343,
  4222620927,
  4222686975,
  4222818559,
  4222950143,
  4223081727,
  4223213311,
  4206567935,
  4206699519,
  4206831103,
  4206962943,
  4190317311,
  4190448895,
  4190580735,
  4173935103,
  4174066943,
  4174198783,
  4157553407,
  4157684991,
  4141039615,
  4141171455,
  4124526079,
  4124657919,
  4108012543,
  4108079103,
  4091433727,
  4091565823,
  4091697663,
  4075052543,
  4075184383,
  4058539263,
  4058605823,
  4058737919,
  4058870015,
  4058936575,
  4059068927,
  4059201023,
  4076044799,
  4076111359,
  4093020671,
  4109864447,
  4126708223,
  4143617535,
  4160461311,
  4194082303,
  4210925823,
  4244546815
];
var Magma3 = [1023, 3040246271, 4227645439];
var Magma4 = [1023, 1897890303, 4032847359, 4227645439];
var Magma5 = [1023, 1326545919, 3040246271, 4219887871, 4227645439];
var Magma6 = [1023, 990867455, 2351530239, 3712575743, 4255083775, 4227645439];
var Magma7 = [1023, 722558719, 1897890303, 3040246271, 4032847359, 4272846591, 4227645439];
var Magma8 = [1023, 571560191, 1561820927, 2536275967, 3510791935, 4168441087, 4273569791, 4227645439];
var Magma9 = [1023, 454051071, 1326545919, 2166718975, 3040246271, 3847250943, 4219887871, 4274161407, 4227645439];
var Magma10 = [1023, 386874623, 1125086719, 1897890303, 2653847295, 3409867263, 4032847359, 4237518591, 4274490367, 4227645439];
var Magma11 = [1023, 336410111, 990867455, 1662615551, 2351530239, 3040246271, 3712575743, 4134427647, 4255083775, 4258107647, 4227645439];
var Magma256 = [
  1023,
  1279,
  1791,
  16779263,
  16845311,
  16845823,
  33689087,
  33689599,
  50532863,
  67310591,
  67376639,
  84154367,
  100997631,
  117775359,
  134618623,
  151461887,
  168239871,
  185083135,
  201926399,
  218769663,
  235547391,
  252390655,
  269234175,
  286011903,
  302855167,
  336410111,
  353253631,
  370031359,
  386874623,
  403652607,
  437273087,
  454051071,
  470828799,
  504383999,
  521227263,
  538004991,
  571560191,
  588337919,
  621893119,
  638670847,
  672225791,
  705780991,
  722558719,
  756048127,
  789603071,
  806381055,
  839935999,
  873490687,
  890202879,
  923757823,
  957312767,
  990867455,
  1007645183,
  1041199871,
  1074754559,
  1108309247,
  1125086719,
  1158641407,
  1192196095,
  1209039103,
  1242593791,
  1259371007,
  1292991231,
  1326545919,
  1343388671,
  1376943359,
  1393786111,
  1427340799,
  1460960767,
  1477803775,
  1511358207,
  1528200959,
  1561820927,
  1578598399,
  1612218367,
  1628995583,
  1662615551,
  1696235775,
  1713012991,
  1746632959,
  1763475711,
  1797030143,
  1813872895,
  1847493119,
  1864270335,
  1897890303,
  1931444735,
  1948287487,
  1981907455,
  1998684671,
  2032304639,
  2049081855,
  2082701823,
  2116321791,
  2133099007,
  2166718975,
  2183496191,
  2217116159,
  2233893375,
  2267513343,
  2301133311,
  2317910527,
  2351530239,
  2368307455,
  2401927423,
  2435481855,
  2452324607,
  2485879039,
  2502721791,
  2536275967,
  2569895935,
  2586673151,
  2620293119,
  2653847295,
  2670690047,
  2704244479,
  2737864447,
  2754641407,
  2788261375,
  2805038591,
  2838658303,
  2872278271,
  2889055231,
  2922675199,
  2956229631,
  2973072127,
  3006626559,
  3040246271,
  3057023487,
  3090643199,
  3107420415,
  3141040127,
  3174660095,
  3191437055,
  3225056767,
  3258611199,
  3275453695,
  3309073663,
  3325850623,
  3359470335,
  3393090303,
  3409867263,
  3443486975,
  3460329727,
  3493949439,
  3510791935,
  3544346111,
  3561188863,
  3594808575,
  3611651071,
  3645270783,
  3662113279,
  3695733247,
  3712575743,
  3729418239,
  3763037951,
  3779880703,
  3796723199,
  3830342911,
  3847250943,
  3864093439,
  3880936191,
  3897844223,
  3931463935,
  3948306687,
  3965214719,
  3982057471,
  3998965503,
  3999096319,
  4015939071,
  4032847359,
  4049689855,
  4066598143,
  4083506431,
  4083637247,
  4100479999,
  4117388287,
  4117519359,
  4134427647,
  4134558719,
  4151401471,
  4151532799,
  4168441087,
  4168572159,
  4185480447,
  4185611775,
  4185742847,
  4202651391,
  4202716927,
  4202848255,
  4219756799,
  4219887871,
  4220019199,
  4220150527,
  4237059071,
  4237190143,
  4237321471,
  4237452799,
  4237518591,
  4254427135,
  4254558463,
  4254689791,
  4254821119,
  4254952447,
  4255083775,
  4255215359,
  4255281151,
  4255412479,
  4272321023,
  4272452607,
  4272583935,
  4272715263,
  4272846591,
  4272912639,
  4273043967,
  4273175551,
  4273306879,
  4273438207,
  4273569791,
  4273701119,
  4273767167,
  4273898495,
  4274030079,
  4274161407,
  4274292991,
  4274424319,
  4274490367,
  4274621951,
  4274753279,
  4258107647,
  4258239231,
  4258370559,
  4258436607,
  4258568191,
  4258699519,
  4258831103,
  4258962687,
  4259094015,
  4259160063,
  4259291647,
  4259423231,
  4242777599,
  4242908927,
  4242974975,
  4243106559,
  4243238143,
  4243369727,
  4243501311,
  4243632639,
  4243698687,
  4243830271,
  4243961855,
  4227316223,
  4227447807,
  4227513855,
  4227645439
];
var Plasma3 = [201819903, 3393616127, 4026016255];
var Plasma4 = [201819903, 2602016511, 3967308799, 4026016255];
var Plasma5 = [201819903, 2080548863, 3393616127, 4153623039, 4026016255];
var Plasma6 = [201819903, 1778427903, 2955579391, 3764675071, 4238751231, 4026016255];
var Plasma7 = [201819903, 1543546367, 2602016511, 3393616127, 3967308799, 4256313343, 4026016255];
var Plasma8 = [201819903, 1375839231, 2299045375, 3090319871, 3663358207, 4085729535, 4256902143, 4026016255];
var Plasma9 = [201819903, 1241686271, 2080548863, 2820839167, 3393616127, 3849018623, 4153623039, 4257425663, 4026016255];
var Plasma10 = [201819903, 1157865215, 1912645887, 2602016511, 3157689855, 3612765439, 3967308799, 4204608255, 4240910079, 4026016255];
var Plasma11 = [201819903, 1073978623, 1778427903, 2400035839, 2955579391, 3393616127, 3764675071, 4051848447, 4238751231, 4241237503, 4026016255];
var Plasma256 = [
  201819903,
  268929023,
  319195647,
  352750335,
  403082239,
  453414143,
  486968831,
  520457983,
  554012671,
  587567359,
  621122047,
  654676735,
  688231423,
  721786111,
  755275007,
  788829695,
  822384383,
  855939071,
  872716543,
  906270975,
  939825663,
  973380351,
  990092031,
  1023646719,
  1057201407,
  1073978623,
  1107533311,
  1141087999,
  1157865215,
  1191354367,
  1224908799,
  1241686271,
  1275240959,
  1308795391,
  1325572863,
  1359061759,
  1375839231,
  1409393663,
  1442948095,
  1459725567,
  1493279999,
  1509991935,
  1543546367,
  1577100799,
  1593878271,
  1627432703,
  1644209919,
  1677764607,
  1694541823,
  1728096255,
  1744873471,
  1778427903,
  1811982591,
  1828759807,
  1862314239,
  1879091455,
  1912645887,
  1929423103,
  1962977535,
  1979820287,
  2013374719,
  2030151935,
  2063771903,
  2080548863,
  2114168831,
  2130946047,
  2164566015,
  2181343231,
  2214962943,
  2231805695,
  2248648447,
  2282202623,
  2299045375,
  2332665087,
  2349507839,
  2383193343,
  2400035839,
  2416878591,
  2450498303,
  2467340799,
  2500960767,
  2517803263,
  2534646015,
  2568265727,
  2585108223,
  2602016511,
  2635636223,
  2652478719,
  2669321215,
  2686163967,
  2719783679,
  2736626175,
  2753468671,
  2770311167,
  2803996671,
  2820839167,
  2837681663,
  2854524159,
  2888143871,
  2904986367,
  2921828863,
  2938671359,
  2955579391,
  2972422143,
  2989264639,
  3022884351,
  3039726847,
  3056569343,
  3073411839,
  3090319871,
  3107162367,
  3124004863,
  3140847359,
  3157689855,
  3174532351,
  3191374847,
  3208217343,
  3225125375,
  3241967871,
  3258810623,
  3275653119,
  3292495615,
  3309338111,
  3326180607,
  3343023103,
  3359931135,
  3376773631,
  3393616127,
  3410458623,
  3427301119,
  3444143615,
  3460986367,
  3477828863,
  3494736895,
  3511579391,
  3511644671,
  3528487167,
  3545329663,
  3562172159,
  3579014655,
  3595922943,
  3612765439,
  3612830719,
  3629673215,
  3646515711,
  3663358207,
  3680200703,
  3697108735,
  3697174271,
  3714016767,
  3730859263,
  3747701759,
  3747767039,
  3764675071,
  3781517567,
  3798360319,
  3815202815,
  3815268095,
  3832176127,
  3849018623,
  3849083903,
  3865926399,
  3882769151,
  3899677183,
  3899742463,
  3916584959,
  3933427455,
  3933492735,
  3950400767,
  3967243519,
  3967308799,
  3984151295,
  3984282111,
  4001124607,
  4017967103,
  4018032383,
  4034940415,
  4035005951,
  4051848447,
  4068756479,
  4068821759,
  4085664255,
  4085729535,
  4102637567,
  4102703103,
  4119545599,
  4119676415,
  4136518911,
  4136584191,
  4136715007,
  4153557503,
  4153623039,
  4170531071,
  4170596351,
  4170727167,
  4187569663,
  4187634943,
  4204542975,
  4204608255,
  4204739327,
  4204804607,
  4221712639,
  4221777919,
  4221843199,
  4238751231,
  4238816767,
  4238947583,
  4239012863,
  4239143679,
  4239208959,
  4256117247,
  4256182527,
  4256313343,
  4256378623,
  4256509439,
  4256574975,
  4256705791,
  4256771071,
  4256902143,
  4256967423,
  4257098239,
  4257229311,
  4257294591,
  4257425663,
  4257490943,
  4257621759,
  4240910079,
  4241041151,
  4241171967,
  4241237503,
  4241368575,
  4224722175,
  4224787711,
  4224918783,
  4208272639,
  4208338175,
  4208469247,
  4191757567,
  4191888639,
  4175242495,
  4175373567,
  4158661887,
  4158793215,
  4142147071,
  4142212607,
  4125566719,
  4125697791,
  4108986111,
  4092339967,
  4092471039,
  4075824895,
  4075890431,
  4059244287,
  4042597887,
  4042662911,
  4026016255
];
var Viridis3 = [1140937983, 546278655, 4259783935];
var Viridis4 = [1140937983, 812092927, 901216511, 4259783935];
var Viridis5 = [1140937983, 995199743, 546278655, 1539859199, 4259783935];
var Viridis6 = [1140937983, 1078167551, 695766783, 581403903, 2043761151, 4259783935];
var Viridis7 = [1140937983, 1144619775, 812092927, 546278655, 901216511, 2379629823, 4259783935];
var Viridis8 = [1140937983, 1177648895, 911903999, 662605567, 513837055, 1237413375, 2648259327, 4259783935];
var Viridis9 = [1140937983, 1194031871, 995199743, 745639679, 546278655, 665682175, 1539859199, 2866492159, 4259783935];
var Viridis10 = [1140937983, 1193768959, 1045006847, 812092927, 629313279, 513575423, 901216511, 1808620031, 3000839423, 4259783935];
var Viridis11 = [1140937983, 1210283263, 1078167551, 878611967, 695766783, 546278655, 581403903, 1119777279, 2043761151, 3135121407, 4259783935];
var Viridis256 = [
  1140937983,
  1141003775,
  1141069823,
  1157978367,
  1158044415,
  1158175743,
  1175018751,
  1175150335,
  1175216127,
  1175347711,
  1192190719,
  1192322047,
  1192388095,
  1192519423,
  1192585215,
  1192651263,
  1192782591,
  1209625599,
  1209691391,
  1209822975,
  1209888767,
  1209954559,
  1210085887,
  1210151679,
  1210217471,
  1210283263,
  1193637375,
  1193703167,
  1193768959,
  1193834751,
  1193966079,
  1194031871,
  1194097663,
  1177386239,
  1177517311,
  1177583103,
  1177648895,
  1160937471,
  1161068543,
  1161134335,
  1161200127,
  1144488447,
  1144619775,
  1127908351,
  1127973887,
  1128039679,
  1111327999,
  1111393791,
  1111524863,
  1094813439,
  1094878975,
  1078167551,
  1078233087,
  1061521407,
  1061652735,
  1044941055,
  1045006847,
  1028295167,
  1028360703,
  1028426239,
  1011714815,
  1011780351,
  995134207,
  995199743,
  978488319,
  978553855,
  961842175,
  961907711,
  945196031,
  945261823,
  928550143,
  928615679,
  911903999,
  911969535,
  895257855,
  895323391,
  878611967,
  878677503,
  861965823,
  862031359,
  845319679,
  845385215,
  828673535,
  828739071,
  828804607,
  812092927,
  812158463,
  795446783,
  795512319,
  778800895,
  778866431,
  778931967,
  762220287,
  762285823,
  745574143,
  745639679,
  745705215,
  728993535,
  729059071,
  712347391,
  712412927,
  712478463,
  695766783,
  695832319,
  679120639,
  679120639,
  679186175,
  662474495,
  662540031,
  662605567,
  645893887,
  645959423,
  646024959,
  629313279,
  629378559,
  612666879,
  612732415,
  612797951,
  596086271,
  596151807,
  596217343,
  579440127,
  579505663,
  579571199,
  562859519,
  562924799,
  562990335,
  546278655,
  546344191,
  546409727,
  529698047,
  529763327,
  529828863,
  529894399,
  529959935,
  513247999,
  513313535,
  513379071,
  513379071,
  513444351,
  513509887,
  513575423,
  513640703,
  513706239,
  513771775,
  513837055,
  530679807,
  530745087,
  530810623,
  547653119,
  547718655,
  564561407,
  564626687,
  581403903,
  598246399,
  598311679,
  615154431,
  631996927,
  648839679,
  665682175,
  682524671,
  699367423,
  716209919,
  733052415,
  749829631,
  783449343,
  800291839,
  817134335,
  850754303,
  867596799,
  901216511,
  918059007,
  951678719,
  968455935,
  1002075647,
  1035695359,
  1052537855,
  1086157567,
  1119777279,
  1153331455,
  1170173951,
  1203793663,
  1237413375,
  1271033087,
  1304587263,
  1338206719,
  1371826431,
  1405446143,
  1439065855,
  1472620031,
  1506239743,
  1539859199,
  1590256127,
  1623810303,
  1657430015,
  1691049471,
  1741446399,
  1775000575,
  1808620031,
  1842239743,
  1892570879,
  1926190591,
  1959810303,
  2010141439,
  2043761151,
  2094157823,
  2127711999,
  2178108671,
  2211662847,
  2262059519,
  2295678975,
  2346010367,
  2379629823,
  2429961215,
  2463580671,
  2513911807,
  2547531519,
  2597862655,
  2648259327,
  2681813247,
  2732210175,
  2782541311,
  2816160767,
  2866492159,
  2916888831,
  2950442751,
  3000839423,
  3051170815,
  3084724735,
  3135121407,
  3185452799,
  3219072255,
  3269403391,
  3319734783,
  3353354239,
  3403685631,
  3454017023,
  3487636735,
  3537968127,
  3571522303,
  3621919231,
  3672250623,
  3705805055,
  3756202239,
  3789756671,
  3840088319,
  3890485759,
  3924040191,
  3974372095,
  4007992319,
  4058324223,
  4091879167,
  4142276607,
  4175831551,
  4209386239,
  4259783935
];
var Cividis3 = [2116863, 2071689471, 4293477887];
var Cividis4 = [2116863, 1448897791, 2795271679, 4293477887];
var Cividis5 = [2116863, 1078750207, 2071689471, 3165548287, 4293477887];
var Cividis6 = [2116863, 826567679, 1718120703, 2509207807, 3401148927, 4293477887];
var Cividis7 = [2116863, 574450943, 1448897791, 2071689471, 2795271679, 3552601599, 4293477887];
var Cividis8 = [2116863, 356085247, 1230203903, 1819112191, 2374531327, 2997252863, 3653657087, 4293477887];
var Cividis9 = [2116863, 20279039, 1078750207, 1600351999, 2071689471, 2610132991, 3165548287, 3754647039, 4293477887];
var Cividis10 = [2116863, 3370751, 927427583, 1448897791, 1869640703, 2307225855, 2795271679, 3283381503, 3821886463, 4293477887];
var Cividis11 = [2116863, 3239935, 826567679, 1297443839, 1718120703, 2071689471, 2509207807, 2929947647, 3401148927, 3872414207, 4293477887];
var Cividis256 = [
  2116863,
  2117375,
  2183423,
  2249215,
  2315263,
  2315775,
  2381567,
  2447615,
  2513663,
  2513919,
  2579967,
  2646015,
  2646527,
  2712575,
  2778367,
  2778879,
  2844927,
  2910975,
  2977023,
  2977279,
  3043071,
  3043327,
  3108863,
  3108863,
  3174399,
  3239935,
  3239935,
  3305215,
  3370751,
  3436287,
  3436287,
  20279039,
  104230655,
  171404799,
  238513663,
  305688063,
  356085247,
  389639679,
  440036607,
  473656575,
  507276543,
  540830975,
  574450943,
  608070911,
  641625343,
  658468095,
  692087807,
  725707775,
  742484991,
  776104959,
  792947711,
  826567679,
  843344895,
  860187647,
  893807615,
  910584831,
  927427583,
  944270335,
  977890303,
  994667519,
  1011510271,
  1028353023,
  1045130239,
  1078750207,
  1095592959,
  1112435711,
  1129212927,
  1146055679,
  1162898431,
  1179675647,
  1196518399,
  1213361151,
  1230203903,
  1246981119,
  1263823871,
  1280666623,
  1297443839,
  1314286591,
  1331129599,
  1347972351,
  1364749567,
  1381592319,
  1398435071,
  1415212287,
  1432055039,
  1448897791,
  1465740799,
  1482518015,
  1499360767,
  1516203519,
  1532980735,
  1549823487,
  1566666495,
  1583509247,
  1600286463,
  1600351999,
  1617194751,
  1634037759,
  1650814975,
  1667657727,
  1684500479,
  1701277695,
  1718120703,
  1734963455,
  1751806207,
  1751806207,
  1768649215,
  1785491967,
  1802334719,
  1819112191,
  1835954943,
  1852797695,
  1869574911,
  1869640703,
  1886483455,
  1903326207,
  1920103679,
  1936946431,
  1953789439,
  1970632191,
  1970632191,
  1987475199,
  2004317951,
  2021160703,
  2037938175,
  2054780927,
  2071623679,
  2071689471,
  2088466687,
  2105309439,
  2122152191,
  2138994943,
  2155772159,
  2172614911,
  2189457663,
  2206300415,
  2223077631,
  2239920383,
  2256763135,
  2273605887,
  2290448639,
  2307225855,
  2324068607,
  2340911359,
  2357754111,
  2374531327,
  2391374079,
  2408216831,
  2425059583,
  2441902335,
  2458679551,
  2475522303,
  2492365055,
  2509207807,
  2525984767,
  2542827519,
  2559670271,
  2576513023,
  2593355775,
  2610132991,
  2626975743,
  2643818495,
  2660660991,
  2677503743,
  2694346495,
  2711123711,
  2727966463,
  2744808959,
  2761651711,
  2778494463,
  2795271679,
  2812114431,
  2828956927,
  2845799679,
  2862642431,
  2879485183,
  2896262143,
  2913104895,
  2929947647,
  2946790399,
  2963632895,
  2980475647,
  2997252863,
  3030872575,
  3047715327,
  3064558079,
  3081400575,
  3098243327,
  3115020543,
  3131863039,
  3148705791,
  3165548287,
  3182391039,
  3199233791,
  3216076287,
  3232853503,
  3249695999,
  3266538751,
  3283381503,
  3317001215,
  3333843967,
  3350686463,
  3367529215,
  3384306175,
  3401148927,
  3417991423,
  3434834175,
  3451676671,
  3468519423,
  3502139135,
  3518981887,
  3535824383,
  3552601599,
  3569444095,
  3586286591,
  3603129343,
  3619971839,
  3636814335,
  3653657087,
  3687276799,
  3704119551,
  3720962047,
  3737804543,
  3754647039,
  3771424255,
  3788266751,
  3821886463,
  3838729215,
  3855571711,
  3872414207,
  3889256703,
  3906099199,
  3922941695,
  3956561663,
  3973404159,
  3990246655,
  4007089151,
  4023931647,
  4040774143,
  4057616639,
  4091236351,
  4108078847,
  4124921343,
  4141763839,
  4158606335,
  4192225791,
  4209002751,
  4225845247,
  4242687743,
  4259530239,
  4293149695,
  4293214975,
  4293280511,
  4293346303,
  4293412095,
  4293477887
];
var Turbo3 = [806501375, 2717662719, 7996418];
var Turbo4 = [806501375, 451196671, 4189731071, 7996418];
var Turbo5 = [806501375, 716828159, 2717662719, 4219478783, 7996418];
var Turbo6 = [806501375, 1050410751, 1190626303, 3789305855, 4015657471, 7996418];
var Turbo7 = [806501375, 1166342655, 451196671, 2717662719, 4189731071, 3846572799, 7996418];
var Turbo8 = [806501375, 1182133759, 483252223, 1643932927, 3488232703, 4271582719, 3678013439, 7996418];
var Turbo9 = [806501375, 1181278463, 716828159, 804297471, 2717662719, 3973134847, 4219478783, 3526362623, 7996418];
var Turbo10 = [806501375, 1163974399, 917043711, 451196671, 1912430591, 3320787967, 4189731071, 4134213887, 3408593919, 7996418];
var Turbo11 = [806501375, 1146670079, 1050410751, 416664831, 1190626303, 2717662719, 3789305855, 4255527423, 4015657471, 3307602687, 7996418];
var Turbo256 = [
  806501375,
  823476991,
  840452863,
  874205695,
  891181311,
  908156927,
  925066751,
  942042367,
  959017727,
  975993343,
  992968703,
  1009944063,
  1010142207,
  1027052031,
  1044027135,
  1061002495,
  1077977599,
  1078175487,
  1095085055,
  1095282943,
  1112258047,
  1129233151,
  1129365247,
  1129562879,
  1146537983,
  1146670079,
  1163644671,
  1163842303,
  1163974399,
  1164171775,
  1181146623,
  1181278463,
  1181475839,
  1181607679,
  1181804799,
  1182002175,
  1182133759,
  1182331135,
  1182462719,
  1182659839,
  1182791423,
  1182988543,
  1166342655,
  1166539775,
  1166671103,
  1150090751,
  1133444607,
  1116864255,
  1100218111,
  1083637503,
  1066991359,
  1050410751,
  1016987135,
  1000406271,
  966982911,
  950402047,
  917043711,
  883620095,
  866973439,
  833615359,
  800191487,
  766833151,
  733409279,
  716828159,
  683404287,
  649980415,
  633399039,
  599975167,
  566551039,
  549904383,
  516545791,
  499899135,
  483252223,
  466605311,
  449958655,
  433311743,
  416664831,
  416795391,
  400148479,
  400213247,
  400343807,
  400474111,
  417381887,
  417446655,
  434354431,
  451196671,
  468038911,
  501723647,
  518565887,
  552185087,
  585869823,
  619489023,
  669885439,
  703504639,
  753901055,
  804297471,
  854693887,
  905155839,
  955552255,
  1005882879,
  1073056511,
  1123452927,
  1190626303,
  1257799935,
  1308196095,
  1375304191,
  1442477823,
  1509651199,
  1576759295,
  1643932927,
  1711040767,
  1778214399,
  1845322495,
  1912430591,
  1962827007,
  2029935103,
  2097043199,
  2164151295,
  2231259391,
  2281590271,
  2348698623,
  2399029503,
  2466137855,
  2516468991,
  2566800127,
  2617065727,
  2667396863,
  2717662719,
  2767993855,
  2801482495,
  2851813887,
  2902079487,
  2935568383,
  2985834239,
  3019388415,
  3069654527,
  3119854847,
  3153343743,
  3203609855,
  3237098495,
  3287364607,
  3320787967,
  3371054079,
  3404542975,
  3454743807,
  3488232703,
  3521656063,
  3571922431,
  3605345791,
  3638769151,
  3672258303,
  3722458879,
  3755882239,
  3789305855,
  3822729215,
  3856152831,
  3889641727,
  3906287871,
  3939711487,
  3973134847,
  3989780991,
  4023204351,
  4039850751,
  4073208575,
  4089854719,
  4106500863,
  4139924223,
  4156570111,
  4173216255,
  4189862399,
  4189731071,
  4206311423,
  4222957567,
  4222826239,
  4239406591,
  4239275263,
  4255855615,
  4255724287,
  4255527423,
  4255330559,
  4271976447,
  4271779583,
  4271582719,
  4271385855,
  4254411775,
  4254214655,
  4254017791,
  4253820927,
  4236846847,
  4236649727,
  4219675647,
  4219478783,
  4202504447,
  4202307583,
  4185333503,
  4168359167,
  4151385087,
  4151188223,
  4134213887,
  4117239807,
  4100265727,
  4083357183,
  4066383103,
  4049409023,
  4015657471,
  3998748927,
  3981774847,
  3964800767,
  3931115007,
  3914141183,
  3897232639,
  3863546879,
  3846572799,
  3812887295,
  3795978751,
  3762292991,
  3728607487,
  3711698943,
  3678013439,
  3644327679,
  3610642175,
  3593733631,
  3560048127,
  3526362623,
  3492742399,
  3459056895,
  3408593919,
  3374908415,
  3341288447,
  3307602687,
  3273917183,
  3223519999,
  3189834495,
  3139371519,
  3105751551,
  3055288831,
  3021668863,
  2971206143,
  2920808959,
  2887123455,
  2836726271,
  2786329087,
  2735866367,
  2685469183,
  2635071999,
  2584609279,
  2534212095,
  2483814911,
  2433417727,
  2383020543,
  2332623359,
  2265448959,
  2215051775,
  2164654847,
  2097480447,
  2047083263
];
var Accent3 = [2143911935, 3199128831, 4257253119];
var Accent4 = [...Accent3, 4294941183];
var Accent5 = [...Accent4, 946647295];
var Accent6 = [...Accent5, 4026695679];
var Accent7 = [...Accent6, 3210418175];
var Accent8 = [...Accent7, 1717987071];
var Dark2_3 = [463370239, 3646882559, 1970320383];
var Dark2_4 = [...Dark2_3, 3878259455];
var Dark2_5 = [...Dark2_4, 1722162943];
var Dark2_6 = [...Dark2_5, 3869967103];
var Dark2_7 = [...Dark2_6, 2792758783];
var Dark2_8 = [...Dark2_7, 1717987071];
var Paired3 = [2798576639, 528004351, 3000994559];
var Paired4 = [...Paired3, 866135295];
var Paired5 = [...Paired4, 4221213183];
var Paired6 = [...Paired5, 3810139391];
var Paired7 = [...Paired6, 4257181695];
var Paired8 = [...Paired7, 4286513407];
var Paired9 = [...Paired8, 3400718079];
var Paired10 = [...Paired9, 1782422271];
var Paired11 = [...Paired10, 4294941183];
var Paired12 = [...Paired11, 2975410431];
var Pastel1_3 = [4222922495, 3016614911, 3438003711];
var Pastel1_4 = [...Pastel1_3, 3737904383];
var Pastel1_5 = [...Pastel1_4, 4275676927];
var Pastel1_6 = [...Pastel1_5, 4294954239];
var Pastel1_7 = [...Pastel1_6, 3856186879];
var Pastel1_8 = [...Pastel1_7, 4258983167];
var Pastel1_9 = [...Pastel1_8, 4076008191];
var Pastel2_3 = [3017985535, 4258114815, 3419793663];
var Pastel2_4 = [...Pastel2_3, 4106937599];
var Pastel2_5 = [...Pastel2_4, 3874867711];
var Pastel2_6 = [...Pastel2_5, 4294094591];
var Pastel2_7 = [...Pastel2_6, 4058172671];
var Pastel2_8 = [...Pastel2_7, 3435973887];
var Set1_3 = [3826916607, 931051775, 1303333631];
var Set1_4 = [...Set1_3, 2555290623];
var Set1_5 = [...Set1_4, 4286513407];
var Set1_6 = [...Set1_5, 4294915071];
var Set1_7 = [...Set1_6, 2790664447];
var Set1_8 = [...Set1_7, 4152475647];
var Set1_9 = [...Set1_8, 2576980479];
var Set2_3 = [1724032511, 4237124351, 2376125439];
var Set2_4 = [...Set2_3, 3884631039];
var Set2_5 = [...Set2_4, 2799195391];
var Set2_6 = [...Set2_5, 4292423679];
var Set2_7 = [...Set2_6, 3854865663];
var Set2_8 = [...Set2_7, 3014898687];
var Set3_3 = [2379466751, 4294947839, 3199916799];
var Set3_4 = [...Set3_3, 4219499263];
var Set3_5 = [...Set3_4, 2159137791];
var Set3_6 = [...Set3_5, 4256457471];
var Set3_7 = [...Set3_6, 3017697791];
var Set3_8 = [...Set3_7, 4241352191];
var Set3_9 = [...Set3_8, 3654932991];
var Set3_10 = [...Set3_9, 3162553855];
var Set3_11 = [...Set3_10, 3438003711];
var Set3_12 = [...Set3_11, 4293750783];
var Category10_3 = [527938815, 4286516991, 748694783];
var Category10_4 = [...Category10_3, 3592890623];
var Category10_5 = [...Category10_4, 2489826815];
var Category10_6 = [...Category10_5, 2354465791];
var Category10_7 = [...Category10_6, 3816276735];
var Category10_8 = [...Category10_7, 2139062271];
var Category10_9 = [...Category10_8, 3166511871];
var Category10_10 = [...Category10_9, 398381055];
var Category20_3 = [527938815, 2932336895, 4286516991];
var Category20_4 = [...Category20_3, 4290476287];
var Category20_5 = [...Category20_4, 748694783];
var Category20_6 = [...Category20_5, 2564786943];
var Category20_7 = [...Category20_6, 3592890623];
var Category20_8 = [...Category20_7, 4288190207];
var Category20_9 = [...Category20_8, 2489826815];
var Category20_10 = [...Category20_9, 3316700671];
var Category20_11 = [...Category20_10, 2354465791];
var Category20_12 = [...Category20_11, 3298596095];
var Category20_13 = [...Category20_12, 3816276735];
var Category20_14 = [...Category20_13, 4155953919];
var Category20_15 = [...Category20_14, 2139062271];
var Category20_16 = [...Category20_15, 3351758847];
var Category20_17 = [...Category20_16, 3166511871];
var Category20_18 = [...Category20_17, 3688599039];
var Category20_19 = [...Category20_18, 398381055];
var Category20_20 = [...Category20_19, 2665145855];
var Category20b_3 = [960199167, 1381278719, 1802424319];
var Category20b_4 = [...Category20b_3, 2627657471];
var Category20b_5 = [...Category20b_4, 1668889087];
var Category20b_6 = [...Category20b_5, 2359448319];
var Category20b_7 = [...Category20b_6, 3050269695];
var Category20b_8 = [...Category20b_7, 3470499071];
var Category20b_9 = [...Category20b_8, 2355966463];
var Category20b_10 = [...Category20b_9, 3181263359];
var Category20b_11 = [...Category20b_10, 3887747839];
var Category20b_12 = [...Category20b_11, 3888878847];
var Category20b_13 = [...Category20b_12, 2218539519];
var Category20b_14 = [...Category20b_13, 2907261695];
var Category20b_15 = [...Category20b_14, 3596708863];
var Category20b_16 = [...Category20b_15, 3885407487];
var Category20b_17 = [...Category20b_16, 2067887103];
var Category20b_18 = [...Category20b_17, 2773587199];
var Category20b_19 = [...Category20b_18, 3463298559];
var Category20b_20 = [...Category20b_19, 3734951679];
var Category20c_3 = [830651903, 1806620415, 2664096255];
var Category20c_4 = [...Category20c_3, 3336302591];
var Category20c_5 = [...Category20c_4, 3864333823];
var Category20c_6 = [...Category20c_5, 4253891839];
var Category20c_7 = [...Category20c_6, 4256066559];
var Category20c_8 = [...Category20c_7, 4258308863];
var Category20c_9 = [...Category20c_8, 832787711];
var Category20c_10 = [...Category20c_9, 1959032575];
var Category20c_11 = [...Category20c_10, 2715393023];
var Category20c_12 = [...Category20c_11, 3353985279];
var Category20c_13 = [...Category20c_12, 1969992191];
var Category20c_14 = [...Category20c_13, 2660944127];
var Category20c_15 = [...Category20c_14, 3166559487];
var Category20c_16 = [...Category20c_15, 3671780351];
var Category20c_17 = [...Category20c_16, 1667458047];
var Category20c_18 = [...Category20c_17, 2526451455];
var Category20c_19 = [...Category20c_18, 3183328767];
var Category20c_20 = [...Category20c_19, 3654932991];
var Colorblind3 = [7516927, 3869180159, 4041491199];
var Colorblind4 = [...Colorblind3, 10384383];
var Colorblind5 = [...Colorblind4, 1454696959];
var Colorblind6 = [...Colorblind5, 3579707647];
var Colorblind7 = [...Colorblind6, 3430524927];
var Colorblind8 = [...Colorblind7, 255];
var Bright3 = [1148693247, 3999692799, 579351551];
var Bright4 = [...Bright3, 3434824959];
var Bright5 = [...Bright4, 1724706559];
var Bright6 = [...Bright5, 2855499775];
var Bright7 = [...Bright6, 3149642751];
var HighContrast3 = [4491519, 3718919167, 3142936319];
var Vibrant3 = [4000789503, 7846911, 867954431];
var Vibrant4 = [...Vibrant3, 3996350463];
var Vibrant5 = [...Vibrant4, 3425899007];
var Vibrant6 = [...Vibrant5, 10062079];
var Vibrant7 = [...Vibrant6, 3149642751];
var Muted3 = [3429267455, 857901311, 3721164799];
var Muted4 = [...Muted3, 293024767];
var Muted5 = [...Muted4, 2295131903];
var Muted6 = [...Muted5, 2283951615];
var Muted7 = [...Muted6, 1152031231];
var Muted8 = [...Muted7, 2576954367];
var Muted9 = [...Muted8, 2856622591];
var MediumContrast3 = [1721355519, 4491519, 4006373119];
var MediumContrast4 = [...MediumContrast3, 2571392511];
var MediumContrast5 = [...MediumContrast4, 2574713087];
var MediumContrast6 = [...MediumContrast5, 4003048191];
var PaleTextBackground = [3150769919, 3438215167, 3437079295, 4008623103, 4291611903, 3722305023];
var DarkText = [572675583, 576017919, 576004863, 1717974015, 1714631679, 1431655935];
var Light3 = [2007686655, 4001916671, 4007495935];
var Light4 = [...Light3, 4289379327];
var Light5 = [...Light4, 2581463039];
var Light6 = [...Light5, 1153145343];
var Light7 = [...Light6, 3150722047];
var Light8 = [...Light7, 2863268095];
var Light9 = [...Light8, 3722305023];
var Sunset3 = [910924543, 3941387519, 2768250623];
var Sunset4 = [910924543, 2782062079, 4257247999, 2768250623];
var Sunset5 = [910924543, 2209929215, 3941387519, 4187511039, 2768250623];
var Sunset6 = [910924543, 1856425471, 3269783551, 4275735551, 4135472127, 2768250623];
var Sunset7 = [910924543, 1637336575, 2782062079, 3941387519, 4257247999, 3983032831, 2768250623];
var Sunset8 = [910924543, 1502462207, 2462375679, 3454461439, 4175404543, 4239090431, 3881318911, 2768250623];
var Sunset9 = [910924543, 1401208063, 2209929215, 2279468031, 3941387519, 4258300415, 4187511039, 3813487871, 2768250623];
var Sunset10 = [910924543, 1316993535, 2007945727, 2782062079, 3555188735, 4125272063, 4257247999, 4152971775, 3745788159, 2768250623];
var Sunset11 = [910924543, 1249622015, 1856425471, 2563432959, 3269783551, 3941387519, 4275735551, 4256392959, 4135472127, 3711774207, 2768250623];
var BuRd3 = [560377087, 4160223231, 2987928575];
var BuRd4 = [560377087, 3151686399, 4207522047, 2987928575];
var BuRd5 = [560377087, 2462441215, 4160223231, 4104487679, 2987928575];
var BuRd6 = [560377087, 1924256767, 3639144959, 4225814783, 3901320447, 2987928575];
var BuRd7 = [560377087, 1571015679, 3151686399, 4160223231, 4207522047, 3765919487, 2987928575];
var BuRd8 = [560377087, 1318766335, 2748244991, 3790402559, 4209499135, 4139030015, 3664336127, 2987928575];
var BuRd9 = [560377087, 1133757439, 2462441215, 3521507583, 4160223231, 4259039231, 4104487679, 3596635647, 2987928575];
var TolPRGn3 = [1982497791, 4160223231, 460863487];
var TolPRGn4 = [1982497791, 3670335487, 3404120575, 460863487];
var TolPRGn5 = [1982497791, 3265646591, 4160223231, 2899549951, 460863487];
var TolPRGn6 = [1982497791, 2978988287, 3940281343, 3740392191, 2344912383, 460863487];
var TolPRGn7 = [1982497791, 2793519103, 3670335487, 4160223231, 3404120575, 1975154175, 460863487];
var TolPRGn8 = [1982497791, 2658644223, 3434272511, 3991138047, 3857965823, 3101404671, 1706256895, 460863487];
var TolPRGn9 = [1982497791, 2574298111, 3265646591, 3889490175, 4160223231, 3656438783, 2899549951, 1521377791, 460863487];
var TolYlOrBr3 = [4294960639, 4221184511, 1713702655];
var TolYlOrBr4 = [4294960639, 4274939391, 3781431039, 1713702655];
var TolYlOrBr5 = [4294960639, 4276326911, 4221184511, 3427533567, 1713702655];
var TolYlOrBr6 = [4294960639, 4276855551, 4256909311, 4017625343, 3074556671, 1713702655];
var TolYlOrBr7 = [4294960639, 4277186047, 4274939391, 4221184511, 3781431039, 2856059903, 1713702655];
var TolYlOrBr8 = [4294960639, 4277450239, 4275732223, 4239539967, 4068613631, 3579185151, 2687960063, 1713702655];
var TolYlOrBr9 = [4294960639, 4294425855, 4276326911, 4274278399, 4221184511, 3966768383, 3427533567, 2570323199, 1713702655];
var Iridescent3 = [4277922303, 4244100607, 4126392831];
var Iridescent4 = [...Iridescent3, 3941643775];
var Iridescent5 = [...Iridescent4, 3723280383];
var Iridescent6 = [...Iridescent5, 3504851711];
var Iridescent7 = [...Iridescent6, 3269710591];
var Iridescent8 = [...Iridescent7, 3051215103];
var Iridescent9 = [...Iridescent8, 2832784639];
var Iridescent10 = [...Iridescent9, 2614288895];
var Iridescent11 = [...Iridescent10, 2378949887];
var Iridescent12 = [...Iridescent11, 2177165311];
var Iridescent13 = [...Iridescent12, 2075977727];
var Iridescent14 = [...Iridescent13, 2125653247];
var Iridescent15 = [...Iridescent14, 2292571647];
var Iridescent16 = [...Iridescent15, 2476266239];
var Iridescent17 = [...Iridescent16, 2609562879];
var Iridescent18 = [...Iridescent17, 2642260735];
var Iridescent19 = [...Iridescent18, 2591071999];
var Iridescent20 = [...Iridescent19, 2422442239];
var Iridescent21 = [...Iridescent20, 2153214207];
var Iridescent22 = [...Iridescent21, 1749637119];
var Iridescent23 = [...Iridescent22, 1177893631];
var TolRainbow3 = [426094847, 4159723263, 3691318527];
var TolRainbow4 = [426094847, 1320314367, 4159723263, 3691318527];
var TolRainbow5 = [426094847, 2075123455, 1320314367, 4159723263, 3691318527];
var TolRainbow6 = [426094847, 2075123455, 1320314367, 3403721727, 4159723263, 3691318527];
var TolRainbow7 = [2284745471, 426094847, 2075123455, 1320314367, 3403721727, 4159723263, 3691318527];
var TolRainbow8 = [2284745471, 426094847, 2075123455, 1320314367, 3403721727, 4159723263, 4001375999, 3691318527];
var TolRainbow9 = [2284745471, 426094847, 2075123455, 1320314367, 3403721727, 4159723263, 4001375999, 3691318527, 1914244863];
var TolRainbow10 = [2284745471, 426094847, 2075123455, 1320314367, 3403721727, 4159723263, 4104599295, 3898612991, 3691318527, 1914244863];
var TolRainbow11 = [2284745471, 426094847, 1384761343, 2075123455, 1320314367, 3403721727, 4159723263, 4104599295, 3898612991, 3691318527, 1914244863];
var TolRainbow12 = [3518748671, 2859441919, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 3403721727, 4159723263, 4104599295, 3898612991, 3691318527];
var TolRainbow13 = [3518748671, 2859441919, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4104599295, 3898612991, 3691318527];
var TolRainbow14 = [3518748671, 2859441919, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527];
var TolRainbow15 = [3518748671, 2859441919, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 1914244863];
var TolRainbow16 = [3518748671, 3129849087, 2859441919, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 1914244863];
var TolRainbow17 = [3518748671, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 1914244863];
var TolRainbow18 = [3518748671, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 2769751807, 1914244863];
var TolRainbow19 = [3654083583, 3400322047, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1384761343, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 2769751807, 1914244863];
var TolRainbow20 = [3654083583, 3400322047, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1132314623, 1637208063, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4139860479, 4052954623, 3898612991, 3691318527, 2769751807, 1914244863];
var TolRainbow21 = [3654083583, 3400322047, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1132314623, 1637208063, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4157294079, 4104599295, 4001375999, 3864336639, 3691318527, 2769751807, 1914244863];
var TolRainbow22 = [3654083583, 3400322047, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1132314623, 1637208063, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4157294079, 4104599295, 4001375999, 3864336639, 3691318527, 2769751807, 1914244863, 1108675327];
var TolRainbow23 = [3907845119, 3654083583, 3400322047, 3129849087, 2859441919, 2572126463, 2284745471, 426094847, 1132314623, 1637208063, 2075123455, 1320314367, 2429126655, 3403721727, 4159723263, 4157294079, 4104599295, 4001375999, 3864336639, 3691318527, 2769751807, 1914244863, 1108675327];
var YlGn = { YlGn3, YlGn4, YlGn5, YlGn6, YlGn7, YlGn8, YlGn9 };
var YlGnBu = { YlGnBu3, YlGnBu4, YlGnBu5, YlGnBu6, YlGnBu7, YlGnBu8, YlGnBu9 };
var GnBu = { GnBu3, GnBu4, GnBu5, GnBu6, GnBu7, GnBu8, GnBu9 };
var BuGn = { BuGn3, BuGn4, BuGn5, BuGn6, BuGn7, BuGn8, BuGn9 };
var PuBuGn = { PuBuGn3, PuBuGn4, PuBuGn5, PuBuGn6, PuBuGn7, PuBuGn8, PuBuGn9 };
var PuBu = { PuBu3, PuBu4, PuBu5, PuBu6, PuBu7, PuBu8, PuBu9 };
var BuPu = { BuPu3, BuPu4, BuPu5, BuPu6, BuPu7, BuPu8, BuPu9 };
var RdPu = { RdPu3, RdPu4, RdPu5, RdPu6, RdPu7, RdPu8, RdPu9 };
var PuRd = { PuRd3, PuRd4, PuRd5, PuRd6, PuRd7, PuRd8, PuRd9 };
var OrRd = { OrRd3, OrRd4, OrRd5, OrRd6, OrRd7, OrRd8, OrRd9 };
var YlOrRd = { YlOrRd3, YlOrRd4, YlOrRd5, YlOrRd6, YlOrRd7, YlOrRd8, YlOrRd9 };
var YlOrBr = { YlOrBr3, YlOrBr4, YlOrBr5, YlOrBr6, YlOrBr7, YlOrBr8, YlOrBr9 };
var Purples = { Purples3, Purples4, Purples5, Purples6, Purples7, Purples8, Purples9 };
var Blues = { Blues3, Blues4, Blues5, Blues6, Blues7, Blues8, Blues9 };
var Greens = { Greens3, Greens4, Greens5, Greens6, Greens7, Greens8, Greens9 };
var Oranges = { Oranges3, Oranges4, Oranges5, Oranges6, Oranges7, Oranges8, Oranges9 };
var Reds = { Reds3, Reds4, Reds5, Reds6, Reds7, Reds8, Reds9 };
var Greys = { Greys3, Greys4, Greys5, Greys6, Greys7, Greys8, Greys9: Greys92, Greys10, Greys11, Greys256 };
var PuOr = { PuOr3, PuOr4, PuOr5, PuOr6, PuOr7, PuOr8, PuOr9, PuOr10, PuOr11 };
var BrBG = { BrBG3, BrBG4, BrBG5, BrBG6, BrBG7, BrBG8, BrBG9, BrBG10, BrBG11 };
var PRGn = { PRGn3, PRGn4, PRGn5, PRGn6, PRGn7, PRGn8, PRGn9, PRGn10, PRGn11 };
var PiYG = { PiYG3, PiYG4, PiYG5, PiYG6, PiYG7, PiYG8, PiYG9, PiYG10, PiYG11 };
var RdBu = { RdBu3, RdBu4, RdBu5, RdBu6, RdBu7, RdBu8, RdBu9, RdBu10, RdBu11 };
var RdGy = { RdGy3, RdGy4, RdGy5, RdGy6, RdGy7, RdGy8, RdGy9, RdGy10, RdGy11 };
var RdYlBu = { RdYlBu3, RdYlBu4, RdYlBu5, RdYlBu6, RdYlBu7, RdYlBu8, RdYlBu9, RdYlBu10, RdYlBu11 };
var Spectral = { Spectral3, Spectral4, Spectral5, Spectral6, Spectral7, Spectral8, Spectral9, Spectral10, Spectral11 };
var RdYlGn = { RdYlGn3, RdYlGn4, RdYlGn5, RdYlGn6, RdYlGn7, RdYlGn8, RdYlGn9, RdYlGn10, RdYlGn11 };
var Bokeh = { Bokeh3, Bokeh4, Bokeh5, Bokeh6, Bokeh7, Bokeh8 };
var Inferno = { Inferno3, Inferno4, Inferno5, Inferno6, Inferno7, Inferno8, Inferno9, Inferno10, Inferno11, Inferno256 };
var Magma = { Magma3, Magma4, Magma5, Magma6, Magma7, Magma8, Magma9, Magma10, Magma11, Magma256 };
var Plasma = { Plasma3, Plasma4, Plasma5, Plasma6, Plasma7, Plasma8, Plasma9, Plasma10, Plasma11, Plasma256 };
var Viridis = { Viridis3, Viridis4, Viridis5, Viridis6, Viridis7, Viridis8, Viridis9, Viridis10, Viridis11, Viridis256 };
var Cividis = { Cividis3, Cividis4, Cividis5, Cividis6, Cividis7, Cividis8, Cividis9, Cividis10, Cividis11, Cividis256 };
var Turbo = { Turbo3, Turbo4, Turbo5, Turbo6, Turbo7, Turbo8, Turbo9, Turbo10, Turbo11, Turbo256 };
var Accent = { Accent3, Accent4, Accent5, Accent6, Accent7, Accent8 };
var Dark2 = { Dark2_3, Dark2_4, Dark2_5, Dark2_6, Dark2_7, Dark2_8 };
var Paired = { Paired3, Paired4, Paired5, Paired6, Paired7, Paired8, Paired9, Paired10, Paired11, Paired12 };
var Pastel1 = { Pastel1_3, Pastel1_4, Pastel1_5, Pastel1_6, Pastel1_7, Pastel1_8, Pastel1_9 };
var Pastel2 = { Pastel2_3, Pastel2_4, Pastel2_5, Pastel2_6, Pastel2_7, Pastel2_8 };
var Set1 = { Set1_3, Set1_4, Set1_5, Set1_6, Set1_7, Set1_8, Set1_9 };
var Set2 = { Set2_3, Set2_4, Set2_5, Set2_6, Set2_7, Set2_8 };
var Set3 = { Set3_3, Set3_4, Set3_5, Set3_6, Set3_7, Set3_8, Set3_9, Set3_10, Set3_11, Set3_12 };
var Category10 = { Category10_3, Category10_4, Category10_5, Category10_6, Category10_7, Category10_8, Category10_9, Category10_10 };
var Category20 = { Category20_3, Category20_4, Category20_5, Category20_6, Category20_7, Category20_8, Category20_9, Category20_10, Category20_11, Category20_12, Category20_13, Category20_14, Category20_15, Category20_16, Category20_17, Category20_18, Category20_19, Category20_20 };
var Category20b = { Category20b_3, Category20b_4, Category20b_5, Category20b_6, Category20b_7, Category20b_8, Category20b_9, Category20b_10, Category20b_11, Category20b_12, Category20b_13, Category20b_14, Category20b_15, Category20b_16, Category20b_17, Category20b_18, Category20b_19, Category20b_20 };
var Category20c = { Category20c_3, Category20c_4, Category20c_5, Category20c_6, Category20c_7, Category20c_8, Category20c_9, Category20c_10, Category20c_11, Category20c_12, Category20c_13, Category20c_14, Category20c_15, Category20c_16, Category20c_17, Category20c_18, Category20c_19, Category20c_20 };
var Colorblind = { Colorblind3, Colorblind4, Colorblind5, Colorblind6, Colorblind7, Colorblind8 };
var Bright = { Bright3, Bright4, Bright5, Bright6, Bright7 };
var HighContrast = { HighContrast3 };
var Vibrant = { Vibrant3, Vibrant4, Vibrant5, Vibrant6, Vibrant7 };
var Muted = { Muted3, Muted4, Muted5, Muted6, Muted7, Muted8 };
var MediumContrast = { MediumContrast3, MediumContrast4, MediumContrast5, MediumContrast6 };
var Light = { Light3, Light4, Light5, Light6, Light7, Light8, Light9 };
var Sunset = { Sunset3, Sunset4, Sunset5, Sunset6, Sunset7, Sunset8, Sunset9, Sunset10, Sunset11 };
var BuRd = { BuRd3, BuRd4, BuRd5, BuRd6, BuRd7, BuRd8, BuRd9 };
var TolPRGn = { TolPRGn3, TolPRGn4, TolPRGn5, TolPRGn6, TolPRGn7, TolPRGn8, TolPRGn9 };
var TolYlOrBr = { TolYlOrBr3, TolYlOrBr4, TolYlOrBr5, TolYlOrBr6, TolYlOrBr7, TolYlOrBr8, TolYlOrBr9 };
var Iridescent = {
  Iridescent3,
  Iridescent4,
  Iridescent5,
  Iridescent6,
  Iridescent7,
  Iridescent8,
  Iridescent9,
  Iridescent10,
  Iridescent11,
  Iridescent12,
  Iridescent13,
  Iridescent14,
  Iridescent15,
  Iridescent16,
  Iridescent17,
  Iridescent18,
  Iridescent19,
  Iridescent20,
  Iridescent21,
  Iridescent22,
  Iridescent23
};
var TolRainbow = {
  TolRainbow3,
  TolRainbow4,
  TolRainbow5,
  TolRainbow6,
  TolRainbow7,
  TolRainbow8,
  TolRainbow9,
  TolRainbow10,
  TolRainbow11,
  TolRainbow12,
  TolRainbow13,
  TolRainbow14,
  TolRainbow15,
  TolRainbow16,
  TolRainbow17,
  TolRainbow18,
  TolRainbow19,
  TolRainbow20,
  TolRainbow21,
  TolRainbow22,
  TolRainbow23
};
var brewer = {
  YlGn,
  YlGnBu,
  GnBu,
  BuGn,
  PuBuGn,
  PuBu,
  BuPu,
  RdPu,
  PuRd,
  OrRd,
  YlOrRd,
  YlOrBr,
  Purples,
  Blues,
  Greens,
  Oranges,
  Reds,
  Greys,
  PuOr,
  BrBG,
  PRGn,
  PiYG,
  RdBu,
  RdGy,
  RdYlBu,
  Spectral,
  RdYlGn,
  Accent,
  Dark2,
  Paired,
  Pastel1,
  Pastel2,
  Set1,
  Set2,
  Set3
};
var d3 = {
  Category10,
  Category20,
  Category20b,
  Category20c
};
var bokeh = {
  Bokeh
};
var mpl = {
  Magma,
  Inferno,
  Plasma,
  Viridis,
  Cividis,
  Turbo
};
var tol = {
  Bright,
  HighContrast,
  Vibrant,
  Muted,
  MediumContrast,
  Light,
  Sunset,
  BuRd,
  TolPRGn,
  TolYlOrBr,
  Iridescent,
  TolRainbow
};
var colorblind = {
  Colorblind
};
function interp_palette(palette, n2) {
  const npalette = palette.length;
  if (npalette < 1) {
    throw new Error("palette must contain at least one color");
  }
  if (n2 < 0) {
    throw new Error("requested palette length cannot be negative");
  }
  const r = new Uint8Array(n2);
  const g = new Uint8Array(n2);
  const b2 = new Uint8Array(n2);
  const a2 = new Uint8Array(n2);
  for (let i2 = 0; i2 < npalette; i2++) {
    [r[i2], g[i2], b2[i2], a2[i2]] = color2rgba(palette[i2]);
  }
  const integers = range(0, npalette);
  const fractions = linspace(0, npalette - 1, n2);
  const r_interp = interpolate(fractions, integers, r);
  const g_interp = interpolate(fractions, integers, g);
  const b_interp = interpolate(fractions, integers, b2);
  const a_interp = interpolate(fractions, integers, a2);
  const ret = new Array(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    ret[i2] = [byte(r_interp[i2]), byte(g_interp[i2]), byte(b_interp[i2]), byte(a_interp[i2])];
  }
  return ret;
}
function linear_palette(palette, n2) {
  if (n2 <= palette.length) {
    return linspace(0, palette.length - 1, n2).map((i2) => palette[i2 | 0]);
  } else {
    throw new Error("too many color entries requested");
  }
}
function varying_alpha_palette(color, n2 = null, start_alpha = 0, end_alpha = 255) {
  if (start_alpha < 0 || start_alpha > 255) {
    throw new Error("start_alpha must be in the range 0 to 255");
  }
  if (end_alpha < 0 || end_alpha > 255) {
    throw new Error("end_alpha must be in the range 0 to 255");
  }
  const rgba = color2rgba(color);
  if (rgba[3] < 255) {
    const factor = rgba[3] / 255;
    start_alpha *= factor;
    end_alpha *= factor;
  }
  const npalette = n2 != null && n2 > 0 ? n2 : Math.round(Math.abs(end_alpha - start_alpha)) + 1;
  const diff_alpha = (end_alpha - start_alpha) / 255;
  start_alpha /= 255;
  const palette = new Array(npalette);
  for (let i2 = 0; i2 < npalette; i2++) {
    palette[i2] = color2hex(rgba, start_alpha + diff_alpha * i2 / (npalette - 1));
  }
  return palette;
}
function magma(n2) {
  return linear_palette(Magma256, n2);
}
function inferno(n2) {
  return linear_palette(Inferno256, n2);
}
function plasma(n2) {
  return linear_palette(Plasma256, n2);
}
function viridis(n2) {
  return linear_palette(Viridis256, n2);
}
function cividis(n2) {
  return linear_palette(Cividis256, n2);
}
function turbo(n2) {
  return linear_palette(Turbo256, n2);
}
function grey2(n2) {
  return linear_palette(Greys256, n2);
}

// node_modules/@bokeh/bokehjs/build/js/lib/api/charts.js
function resolve_palette(palette = "Spectral11") {
  return isArray(palette) ? palette : palettes_exports[palette];
}
function pie(data3, opts = {}) {
  const labels = [];
  const values2 = [];
  for (let i2 = 0; i2 < Math.min(data3.labels.length, data3.values.length); i2++) {
    if (data3.values[i2] > 0) {
      labels.push(data3.labels[i2]);
      values2.push(data3.values[i2]);
    }
  }
  const start_angle = opts.start_angle != null ? opts.start_angle : 0;
  const end_angle = opts.end_angle != null ? opts.end_angle : start_angle + 2 * Math.PI;
  const angle_span = Math.abs(end_angle - start_angle);
  const to_radians = (x2) => angle_span * x2;
  const total_value = sum(values2);
  const normalized_values = values2.map((v) => v / total_value);
  const cumulative_values = cumsum(normalized_values);
  const end_angles = cumulative_values.map((v) => start_angle + to_radians(v));
  const start_angles = [start_angle].concat(end_angles.slice(0, -1));
  const half_angles = zip(start_angles, end_angles).map(([start2, end]) => (start2 + end) / 2);
  let cx;
  let cy;
  if (opts.center == null) {
    cx = 0;
    cy = 0;
  } else if (isArray(opts.center)) {
    cx = opts.center[0];
    cy = opts.center[1];
  } else {
    cx = opts.center.x;
    cy = opts.center.y;
  }
  const inner_radius = opts.inner_radius != null ? opts.inner_radius : 0;
  const outer_radius = opts.outer_radius != null ? opts.outer_radius : 1;
  const palette = resolve_palette(opts.palette);
  const colors = [];
  for (let i2 = 0; i2 < normalized_values.length; i2++) {
    colors.push(palette[i2 % palette.length]);
  }
  const text_colors = colors.map((c) => is_dark(color2rgba(c)) ? "white" : "black");
  function to_cartesian(r, alpha) {
    return [r * Math.cos(alpha), r * Math.sin(alpha)];
  }
  const half_radius = (inner_radius + outer_radius) / 2;
  let [text_cx, text_cy] = unzip(half_angles.map((half_angle) => to_cartesian(half_radius, half_angle)));
  text_cx = text_cx.map((x2) => x2 + cx);
  text_cy = text_cy.map((y2) => y2 + cy);
  const text_angles = half_angles.map((a2) => {
    if (a2 >= Math.PI / 2 && a2 <= 3 * Math.PI / 2) {
      return a2 + Math.PI;
    } else {
      return a2;
    }
  });
  const source2 = new ColumnDataSource({
    data: {
      labels,
      values: values2,
      percentages: normalized_values.map((v) => sprintf("%.2f%%", v * 100)),
      start_angles,
      end_angles,
      text_angles,
      colors,
      text_colors,
      text_cx,
      text_cy
    }
  });
  const g1 = new AnnularWedge({
    x: cx,
    y: cy,
    inner_radius,
    outer_radius,
    start_angle: { field: "start_angles" },
    end_angle: { field: "end_angles" },
    line_color: null,
    line_width: 1,
    fill_color: { field: "colors" }
  });
  const h12 = new AnnularWedge({
    x: cx,
    y: cy,
    inner_radius,
    outer_radius,
    start_angle: { field: "start_angles" },
    end_angle: { field: "end_angles" },
    line_color: null,
    line_width: 1,
    fill_color: { field: "colors" },
    fill_alpha: 0.8
  });
  const r1 = new GlyphRenderer({
    data_source: source2,
    glyph: g1,
    hover_glyph: h12
  });
  const g2 = new Text4({
    x: { field: "text_cx" },
    y: { field: "text_cy" },
    text: { field: opts.slice_labels ?? "labels" },
    angle: { field: "text_angles" },
    text_align: "center",
    text_baseline: "middle",
    text_color: { field: "text_colors" },
    text_font_size: "12px"
  });
  const r2 = new GlyphRenderer({
    data_source: source2,
    glyph: g2
  });
  const xdr = new DataRange1d({ renderers: [r1], range_padding: 0.2 });
  const ydr = new DataRange1d({ renderers: [r1], range_padding: 0.2 });
  const plot = new Plot({ x_range: xdr, y_range: ydr });
  plot.add_renderers(r1, r2);
  const tooltip = "<div>@labels</div><div><b>@values</b> (@percentages)</div>";
  const hover = new HoverTool({ renderers: [r1], tooltips: tooltip });
  plot.add_tools(hover);
  return plot;
}
function bar(data3, opts = {}) {
  const column_names = data3[0];
  const row_data = data3.slice(1);
  const col_data = transpose(row_data);
  const labels = col_data[0].map((v) => v.toString());
  const columns2 = col_data.slice(1);
  let yaxis = new CategoricalAxis();
  let ydr = new FactorRange({ factors: labels });
  let yscale = new CategoricalScale();
  let xformatter;
  if (opts.axis_number_format != null) {
    xformatter = new NumeralTickFormatter({ format: opts.axis_number_format });
  } else {
    xformatter = new BasicTickFormatter();
  }
  let xaxis = new LinearAxis({ formatter: xformatter });
  let xdr = new DataRange1d({ start: 0 });
  let xscale = new LinearScale();
  const palette = resolve_palette(opts.palette);
  const stacked = opts.stacked != null ? opts.stacked : false;
  const orientation = opts.orientation != null ? opts.orientation : "horizontal";
  const renderers = [];
  if (stacked) {
    const left2 = [];
    const right3 = [];
    for (let i2 = 0; i2 < columns2.length; i2++) {
      const bottom = [];
      const top = [];
      for (let j = 0; j < labels.length; j++) {
        const label3 = labels[j];
        if (i2 == 0) {
          left2.push(0);
          right3.push(columns2[i2][j]);
        } else {
          left2[j] += columns2[i2 - 1][j];
          right3[j] += columns2[i2][j];
        }
        bottom.push([label3, -0.5]);
        top.push([label3, 0.5]);
      }
      const source2 = new ColumnDataSource({
        data: {
          left: copy(left2),
          right: copy(right3),
          top,
          bottom,
          labels,
          values: columns2[i2],
          columns: columns2[i2].map((_2) => column_names[i2 + 1])
        }
      });
      const g1 = new Quad({
        left: { field: "left" },
        bottom: { field: "bottom" },
        right: { field: "right" },
        top: { field: "top" },
        line_color: null,
        fill_color: palette[i2 % palette.length]
      });
      const r1 = new GlyphRenderer({ data_source: source2, glyph: g1 });
      renderers.push(r1);
    }
  } else {
    const dy = 1 / columns2.length;
    for (let i2 = 0; i2 < columns2.length; i2++) {
      const left2 = [];
      const right3 = [];
      const bottom = [];
      const top = [];
      for (let j = 0; j < labels.length; j++) {
        const label3 = labels[j];
        left2.push(0);
        right3.push(columns2[i2][j]);
        bottom.push([label3, i2 * dy - 0.5]);
        top.push([label3, (i2 + 1) * dy - 0.5]);
      }
      const source2 = new ColumnDataSource({
        data: {
          left: left2,
          right: right3,
          top,
          bottom,
          labels,
          values: columns2[i2],
          columns: columns2[i2].map((_2) => column_names[i2 + 1])
        }
      });
      const g1 = new Quad({
        left: { field: "left" },
        bottom: { field: "bottom" },
        right: { field: "right" },
        top: { field: "top" },
        line_color: null,
        fill_color: palette[i2 % palette.length]
      });
      const r1 = new GlyphRenderer({ data_source: source2, glyph: g1 });
      renderers.push(r1);
    }
  }
  if (orientation == "vertical") {
    [xdr, ydr] = [ydr, xdr];
    [xaxis, yaxis] = [yaxis, xaxis];
    [xscale, yscale] = [yscale, xscale];
    for (const r of renderers) {
      const data4 = dict(r.data_source.data);
      const left2 = data4.get("left");
      const right3 = data4.get("right");
      const top = data4.get("top");
      const bottom = data4.get("bottom");
      data4.set("left", bottom);
      data4.set("bottom", left2);
      data4.set("right", top);
      data4.set("top", right3);
    }
  }
  const plot = new Plot({ x_range: xdr, y_range: ydr, x_scale: xscale, y_scale: yscale });
  plot.add_renderers(...renderers);
  plot.add_layout(yaxis, "left");
  plot.add_layout(xaxis, "below");
  const tooltip = "<div>@labels</div><div>@columns:&nbsp<b>@values</b></div>";
  let anchor2;
  let attachment;
  if (orientation == "horizontal") {
    anchor2 = "center_right";
    attachment = "horizontal";
  } else {
    anchor2 = "top_center";
    attachment = "vertical";
  }
  const hover = new HoverTool({
    renderers,
    tooltips: tooltip,
    point_policy: "snap_to_data",
    anchor: anchor2,
    attachment
  });
  plot.add_tools(hover);
  return plot;
}

// node_modules/@bokeh/bokehjs/build/js/lib/api/plotting.js
var plotting_exports = {};
__export(plotting_exports, {
  Figure: () => Figure2,
  color: () => color2css,
  figure: () => figure2,
  gridplot: () => gridplot,
  show: () => show2
});

// node_modules/@bokeh/bokehjs/build/js/lib/core/class.js
function extend2(ctor, ...mixins) {
  for (const mixin of mixins) {
    for (const name of Object.getOwnPropertyNames(mixin.prototype)) {
      if (name == "constructor") {
        continue;
      }
      Object.defineProperty(ctor.prototype, name, Object.getOwnPropertyDescriptor(mixin.prototype, name) ?? /* @__PURE__ */ Object.create(null));
    }
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/api/glyph_api.js
var GlyphAPI = class {
  annular_wedge(...args) {
    return this._glyph(AnnularWedge, "annular_wedge", ["x", "y", "inner_radius", "outer_radius", "start_angle", "end_angle"], args);
  }
  annulus(...args) {
    return this._glyph(Annulus, "annulus", ["x", "y", "inner_radius", "outer_radius"], args);
  }
  arc(...args) {
    return this._glyph(Arc, "arc", ["x", "y", "radius", "start_angle", "end_angle"], args);
  }
  bezier(...args) {
    return this._glyph(Bezier, "bezier", ["x0", "y0", "x1", "y1", "cx0", "cy0", "cx1", "cy1"], args);
  }
  block(...args) {
    return this._glyph(Block, "block", ["x", "y", "width", "height"], args);
  }
  circle(...args) {
    return this._glyph(Circle, "circle", ["x", "y", "radius"], args);
  }
  ellipse(...args) {
    return this._glyph(Ellipse, "ellipse", ["x", "y", "width", "height"], args);
  }
  harea(...args) {
    return this._glyph(HArea, "harea", ["x1", "x2", "y"], args);
  }
  harea_step(...args) {
    return this._glyph(HAreaStep, "harea_step", ["x1", "x2", "y", "step_mode"], args);
  }
  hbar(...args) {
    return this._glyph(HBar, "hbar", ["y", "height", "right", "left"], args);
  }
  hspan(...args) {
    return this._glyph(HSpan, "hspan", ["y"], args);
  }
  hstrip(...args) {
    return this._glyph(HStrip, "hstrip", ["y0", "y1"], args);
  }
  hex_tile(...args) {
    return this._glyph(HexTile, "hex_tile", ["q", "r"], args);
  }
  image(...args) {
    return this._glyph(Image4, "image", ["color_mapper", "image", "x", "y", "dw", "dh"], args);
  }
  image_stack(...args) {
    return this._glyph(ImageStack, "image_stack", ["color_mapper", "image", "x", "y", "dw", "dh"], args);
  }
  image_rgba(...args) {
    return this._glyph(ImageRGBA, "image_rgba", ["image", "x", "y", "dw", "dh"], args);
  }
  image_url(...args) {
    return this._glyph(ImageURL, "image_url", ["url", "x", "y", "w", "h"], args);
  }
  line(...args) {
    return this._glyph(Line3, "line", ["x", "y"], args);
  }
  mathml(...args) {
    return this._glyph(MathMLGlyph, "mathml", ["x", "y", "text"], args);
  }
  multi_line(...args) {
    return this._glyph(MultiLine, "multi_line", ["xs", "ys"], args);
  }
  multi_polygons(...args) {
    return this._glyph(MultiPolygons, "multi_polygons", ["xs", "ys"], args);
  }
  ngon(...args) {
    return this._glyph(Ngon, "ngon", ["x", "y", "radius"], args);
  }
  patch(...args) {
    return this._glyph(Patch, "patch", ["x", "y"], args);
  }
  patches(...args) {
    return this._glyph(Patches, "patches", ["xs", "ys"], args);
  }
  quad(...args) {
    return this._glyph(Quad, "quad", ["left", "right", "bottom", "top"], args);
  }
  quadratic(...args) {
    return this._glyph(Quadratic, "quadratic", ["x0", "y0", "x1", "y1", "cx", "cy"], args);
  }
  ray(...args) {
    return this._glyph(Ray, "ray", ["x", "y", "length"], args);
  }
  rect(...args) {
    return this._glyph(Rect, "rect", ["x", "y", "width", "height"], args);
  }
  segment(...args) {
    return this._glyph(Segment, "segment", ["x0", "y0", "x1", "y1"], args);
  }
  spline(...args) {
    return this._glyph(Spline, "spline", ["x", "y"], args);
  }
  step(...args) {
    return this._glyph(Step, "step", ["x", "y", "mode"], args);
  }
  tex(...args) {
    return this._glyph(TeXGlyph, "tex", ["x", "y", "text"], args);
  }
  text(...args) {
    return this._glyph(Text4, "text", ["x", "y", "text"], args);
  }
  varea(...args) {
    return this._glyph(VArea, "varea", ["x", "y1", "y2"], args);
  }
  varea_step(...args) {
    return this._glyph(VAreaStep, "varea_step", ["x", "y1", "y2", "step_mode"], args);
  }
  vbar(...args) {
    return this._glyph(VBar, "vbar", ["x", "width", "top", "bottom"], args);
  }
  vspan(...args) {
    return this._glyph(VSpan, "vspan", ["x"], args);
  }
  vstrip(...args) {
    return this._glyph(VStrip, "vstrip", ["x0", "x1"], args);
  }
  wedge(...args) {
    return this._glyph(Wedge, "wedge", ["x", "y", "radius", "start_angle", "end_angle"], args);
  }
  _scatter(args, marker) {
    return this._glyph(Scatter, marker ?? "scatter", ["x", "y"], args, marker != null ? { marker } : void 0);
  }
  scatter(...args) {
    return this._scatter(args);
  }
  /** @deprecated */
  asterisk(...args) {
    return this._scatter(args, "asterisk");
  }
  /** @deprecated */
  circle_cross(...args) {
    return this._scatter(args, "circle_cross");
  }
  /** @deprecated */
  circle_dot(...args) {
    return this._scatter(args, "circle_dot");
  }
  /** @deprecated */
  circle_x(...args) {
    return this._scatter(args, "circle_x");
  }
  /** @deprecated */
  circle_y(...args) {
    return this._scatter(args, "circle_y");
  }
  /** @deprecated */
  cross(...args) {
    return this._scatter(args, "cross");
  }
  /** @deprecated */
  dash(...args) {
    return this._scatter(args, "dash");
  }
  /** @deprecated */
  diamond(...args) {
    return this._scatter(args, "diamond");
  }
  /** @deprecated */
  diamond_cross(...args) {
    return this._scatter(args, "diamond_cross");
  }
  /** @deprecated */
  diamond_dot(...args) {
    return this._scatter(args, "diamond_dot");
  }
  /** @deprecated */
  dot(...args) {
    return this._scatter(args, "dot");
  }
  /** @deprecated */
  hex(...args) {
    return this._scatter(args, "hex");
  }
  /** @deprecated */
  hex_dot(...args) {
    return this._scatter(args, "hex_dot");
  }
  /** @deprecated */
  inverted_triangle(...args) {
    return this._scatter(args, "inverted_triangle");
  }
  /** @deprecated */
  plus(...args) {
    return this._scatter(args, "plus");
  }
  /** @deprecated */
  square(...args) {
    return this._scatter(args, "square");
  }
  /** @deprecated */
  square_cross(...args) {
    return this._scatter(args, "square_cross");
  }
  /** @deprecated */
  square_dot(...args) {
    return this._scatter(args, "square_dot");
  }
  /** @deprecated */
  square_pin(...args) {
    return this._scatter(args, "square_pin");
  }
  /** @deprecated */
  square_x(...args) {
    return this._scatter(args, "square_x");
  }
  /** @deprecated */
  star(...args) {
    return this._scatter(args, "star");
  }
  /** @deprecated */
  star_dot(...args) {
    return this._scatter(args, "star_dot");
  }
  /** @deprecated */
  triangle(...args) {
    return this._scatter(args, "triangle");
  }
  /** @deprecated */
  triangle_dot(...args) {
    return this._scatter(args, "triangle_dot");
  }
  /** @deprecated */
  triangle_pin(...args) {
    return this._scatter(args, "triangle_pin");
  }
  /** @deprecated */
  x(...args) {
    return this._scatter(args, "x");
  }
  /** @deprecated */
  y(...args) {
    return this._scatter(args, "y");
  }
};
__publicField(GlyphAPI, "__name__", "GlyphAPI");

// node_modules/@bokeh/bokehjs/build/js/lib/api/figure.js
var _default_tools = ["pan", "wheel_zoom", "box_zoom", "save", "reset", "help"];
var _default_color = "#1f77b4";
var _default_alpha = 1;
var ModelProxy = class {
  constructor(models) {
    __publicField(this, "models");
    this.models = models;
    const mapping = /* @__PURE__ */ new Map();
    for (const model2 of models) {
      for (const prop of model2) {
        const { attr: attr2 } = prop;
        if (!mapping.has(attr2)) {
          mapping.set(attr2, []);
        }
        mapping.get(attr2).push(prop);
      }
    }
    for (const [name, props] of mapping) {
      Object.defineProperty(this, name, {
        get() {
          throw new Error("only setting values is supported");
        },
        set(value2) {
          for (const prop of props) {
            prop.obj.setv({ [name]: value2 });
          }
          return this;
        }
      });
    }
  }
  each(fn) {
    let i2 = 0;
    for (const model2 of this.models) {
      fn(model2, i2++);
    }
  }
  *[Symbol.iterator]() {
    yield* this.models;
  }
};
__publicField(ModelProxy, "__name__", "ModelProxy");
var SubFigure = class extends GlyphAPI {
  constructor(coordinates, parent) {
    super();
    __publicField(this, "coordinates");
    __publicField(this, "parent");
    this.coordinates = coordinates;
    this.parent = parent;
  }
  _glyph(cls, method, positional, args, overrides) {
    const { coordinates } = this;
    return this.parent._glyph(cls, method, positional, args, { coordinates, ...overrides });
  }
};
__publicField(SubFigure, "__name__", "SubFigure");
var _Figure2 = class _Figure2 extends Figure {
  get xaxes() {
    return [...this.below, ...this.above].filter((r) => r instanceof Axis);
  }
  get yaxes() {
    return [...this.left, ...this.right].filter((r) => r instanceof Axis);
  }
  get axes() {
    return [...this.below, ...this.above, ...this.left, ...this.right].filter((r) => r instanceof Axis);
  }
  get xaxis() {
    return new ModelProxy(this.xaxes);
  }
  get yaxis() {
    return new ModelProxy(this.yaxes);
  }
  get axis() {
    return new ModelProxy(this.axes);
  }
  get xgrids() {
    return this.center.filter((r) => r instanceof Grid2).filter((grid) => grid.dimension == 0);
  }
  get ygrids() {
    return this.center.filter((r) => r instanceof Grid2).filter((grid) => grid.dimension == 1);
  }
  get grids() {
    return this.center.filter((r) => r instanceof Grid2);
  }
  get xgrid() {
    return new ModelProxy(this.xgrids);
  }
  get ygrid() {
    return new ModelProxy(this.ygrids);
  }
  get grid() {
    return new ModelProxy(this.grids);
  }
  get legend() {
    const legends = this.panels.filter((r) => r instanceof Legend);
    if (legends.length == 0) {
      const legend2 = new Legend();
      this.add_layout(legend2);
      return legend2;
    } else {
      const [legend2] = legends;
      return legend2;
    }
  }
  constructor(attrs = {}) {
    attrs = { ...attrs };
    const x_axis_type = attrs.x_axis_type === void 0 ? "auto" : attrs.x_axis_type;
    const y_axis_type = attrs.y_axis_type === void 0 ? "auto" : attrs.y_axis_type;
    delete attrs.x_axis_type;
    delete attrs.y_axis_type;
    const x_minor_ticks = attrs.x_minor_ticks ?? "auto";
    const y_minor_ticks = attrs.y_minor_ticks ?? "auto";
    delete attrs.x_minor_ticks;
    delete attrs.y_minor_ticks;
    const x_axis_location = attrs.x_axis_location === void 0 ? "below" : attrs.x_axis_location;
    const y_axis_location = attrs.y_axis_location === void 0 ? "left" : attrs.y_axis_location;
    delete attrs.x_axis_location;
    delete attrs.y_axis_location;
    const x_axis_label = attrs.x_axis_label ?? "";
    const y_axis_label = attrs.y_axis_label ?? "";
    delete attrs.x_axis_label;
    delete attrs.y_axis_label;
    const x_range = _Figure2._get_range(attrs.x_range);
    const y_range = _Figure2._get_range(attrs.y_range);
    delete attrs.x_range;
    delete attrs.y_range;
    const x_scale = attrs.x_scale ?? _Figure2._get_scale(x_range, x_axis_type);
    const y_scale = attrs.y_scale ?? _Figure2._get_scale(y_range, y_axis_type);
    delete attrs.x_scale;
    delete attrs.y_scale;
    const { active_drag, active_inspect, active_scroll, active_tap, active_multi } = attrs;
    delete attrs.active_drag;
    delete attrs.active_inspect;
    delete attrs.active_scroll;
    delete attrs.active_tap;
    delete attrs.active_multi;
    const tools2 = (() => {
      const { tools: tools3, toolbar } = attrs;
      if (tools3 != null) {
        if (toolbar != null) {
          throw new Error("'tools' and 'toolbar' can't be used together");
        } else {
          delete attrs.tools;
          if (isString(tools3)) {
            return tools3.split(",").map((s2) => s2.trim()).filter((s2) => s2.length > 0);
          } else {
            return tools3;
          }
        }
      } else {
        return toolbar != null ? null : _default_tools;
      }
    })();
    super({ ...attrs, x_range, y_range, x_scale, y_scale });
    this._process_axis_and_grid(x_axis_type, x_axis_location, x_minor_ticks, x_axis_label, x_range, 0);
    this._process_axis_and_grid(y_axis_type, y_axis_location, y_minor_ticks, y_axis_label, y_range, 1);
    const tool_map = /* @__PURE__ */ new Map();
    if (tools2 != null) {
      const resolved_tools = tools2.map((tool) => {
        if (tool instanceof Tool) {
          return tool;
        } else {
          const resolved_tool = Tool.from_string(tool);
          tool_map.set(tool, resolved_tool);
          return resolved_tool;
        }
      });
      this.add_tools(...resolved_tools);
    }
    if (isString(active_drag) && active_drag != "auto") {
      const tool = tool_map.get(active_drag);
      if (tool instanceof GestureTool || tool instanceof ToolProxy) {
        this.toolbar.active_drag = tool;
      }
    } else if (active_drag !== void 0) {
      this.toolbar.active_drag = active_drag;
    }
    if (isString(active_inspect) && active_inspect != "auto") {
      const tool = tool_map.get(active_inspect);
      if (tool != null) {
        this.toolbar.active_inspect = tool;
      }
    } else if (active_inspect !== void 0) {
      this.toolbar.active_inspect = active_inspect;
    }
    if (isString(active_scroll) && active_scroll != "auto") {
      const tool = tool_map.get(active_scroll);
      if (tool instanceof GestureTool || tool instanceof ToolProxy) {
        this.toolbar.active_scroll = tool;
      }
    } else if (active_scroll !== void 0) {
      this.toolbar.active_scroll = active_scroll;
    }
    if (isString(active_tap) && active_tap != "auto") {
      const tool = tool_map.get(active_tap);
      if (tool instanceof GestureTool || tool instanceof ToolProxy) {
        this.toolbar.active_tap = tool;
      }
    } else if (active_tap !== void 0) {
      this.toolbar.active_tap = active_tap;
    }
    if (isString(active_multi) && active_multi != "auto") {
      const tool = tool_map.get(active_multi);
      if (tool instanceof GestureTool || tool instanceof ToolProxy) {
        this.toolbar.active_multi = tool;
      }
    } else if (active_multi !== void 0) {
      this.toolbar.active_multi = active_multi;
    }
  }
  get coordinates() {
    return null;
  }
  subplot(coordinates) {
    const mapping = new CoordinateMapping(coordinates);
    return new SubFigure(mapping, this);
  }
  _pop_visuals(cls, props, prefix = "", defaults3 = {}, override_defaults = {}) {
    const _split_feature_trait = function(ft) {
      const fta = ft.split("_", 2);
      return fta.length == 2 ? fta : fta.concat([""]);
    };
    const _is_visual = function(ft) {
      const [feature, trait] = _split_feature_trait(ft);
      return includes(["line", "fill", "hatch", "text", "global"], feature) && trait !== "";
    };
    defaults3 = { ...defaults3 };
    const trait_defaults = {};
    const props_proxy = dict(props);
    const prototype_props_proxy = dict(cls.prototype._props);
    const defaults_proxy = dict(defaults3);
    const trait_defaults_proxy = dict(trait_defaults);
    const override_defaults_proxy = dict(override_defaults);
    if (!defaults_proxy.has("text_color")) {
      defaults3.text_color = "black";
    }
    if (!defaults_proxy.has("hatch_color")) {
      defaults3.hatch_color = "black";
    }
    if (!trait_defaults_proxy.has("color")) {
      trait_defaults.color = _default_color;
    }
    if (!trait_defaults_proxy.has("alpha")) {
      trait_defaults.alpha = _default_alpha;
    }
    const result = {};
    const traits = /* @__PURE__ */ new Set();
    for (const pname of keys(cls.prototype._props)) {
      if (_is_visual(pname)) {
        const trait = _split_feature_trait(pname)[1];
        if (props_proxy.has(prefix + pname)) {
          result[pname] = props[prefix + pname];
          delete props[prefix + pname];
        } else if (!prototype_props_proxy.has(trait) && props_proxy.has(prefix + trait)) {
          result[pname] = props[prefix + trait];
        } else if (override_defaults_proxy.has(trait)) {
          result[pname] = override_defaults[trait];
        } else if (defaults_proxy.has(pname)) {
          result[pname] = defaults3[pname];
        } else if (trait_defaults_proxy.has(trait)) {
          result[pname] = trait_defaults[trait];
        }
        if (!prototype_props_proxy.has(trait)) {
          traits.add(trait);
        }
      }
    }
    for (const name of traits) {
      delete props[prefix + name];
    }
    return result;
  }
  _find_uniq_name(data3, name) {
    let i2 = 1;
    while (true) {
      const new_name = `${name}__${i2}`;
      if (data3.has(new_name)) {
        i2 += 1;
      } else {
        return new_name;
      }
    }
  }
  _fixup_values(cls, data3, attrs) {
    const unresolved_attrs = /* @__PURE__ */ new Set();
    const props = dict(cls.prototype._props);
    for (const [name, value2] of entries(attrs)) {
      const prop = props.get(name);
      if (prop != null) {
        if (prop.type.prototype instanceof VectorSpec) {
          if (value2 != null) {
            if (isArray(value2) || is_NDArray(value2)) {
              let field;
              if (data3.has(name)) {
                if (data3.get(name) !== value2) {
                  field = this._find_uniq_name(data3, name);
                  data3.set(field, value2);
                } else {
                  field = name;
                }
              } else {
                field = name;
                data3.set(field, value2);
              }
              attrs[name] = { field };
            } else if (isNumber(value2) || isString(value2)) {
              attrs[name] = { value: value2 };
            }
          }
          if (prop.type.prototype instanceof UnitsSpec) {
            const units_attr = `${name}_units`;
            const units = attrs[units_attr];
            if (units !== void 0) {
              attrs[name] = { ...attrs[name], units };
              unresolved_attrs.delete(units_attr);
              delete attrs[units_attr];
            }
          }
        }
      } else {
        unresolved_attrs.add(name);
      }
    }
    return unresolved_attrs;
  }
  _signature(method, positional) {
    return `the method signature is ${method}(${positional.join(", ")}, args?)`;
  }
  _glyph(cls, method, positional, args, overrides = {}) {
    let attrs;
    const n_args = args.length;
    const n_pos = positional.length;
    if (n_args == n_pos || n_args == n_pos + 1) {
      attrs = {};
      for (const [[param, arg], i2] of enumerate(zip(positional, args))) {
        if (isPlainObject(arg) && !isVectorized(arg)) {
          throw new Error(`invalid value for '${param}' parameter at position ${i2}; ${this._signature(method, positional)}`);
        } else {
          attrs[param] = arg;
        }
      }
      if (n_args == n_pos + 1) {
        const opts = args[n_args - 1];
        if (!isPlainObject(opts) || isVectorized(opts)) {
          throw new Error(`expected optional arguments; ${this._signature(method, positional)}`);
        } else {
          attrs = { ...attrs, ...args[args.length - 1] };
        }
      }
    } else if (n_args == 0) {
      attrs = {};
    } else if (n_args == 1) {
      attrs = { ...args[0] };
    } else {
      throw new Error(`wrong number of arguments; ${this._signature(method, positional)}`);
    }
    attrs = { ...attrs, ...overrides };
    const source2 = (() => {
      const { source: source3 } = attrs;
      if (source3 == null) {
        return new ColumnDataSource();
      } else if (source3 instanceof ColumnarDataSource) {
        return source3;
      } else {
        return new ColumnDataSource({ data: source3 });
      }
    })();
    const data3 = clone(source2.data);
    delete attrs.source;
    const { view } = attrs;
    delete attrs.view;
    const legend2 = attrs.legend;
    delete attrs.legend;
    const legend_label = attrs.legend_label;
    delete attrs.legend_label;
    const legend_field = attrs.legend_field;
    delete attrs.legend_field;
    const legend_group = attrs.legend_group;
    delete attrs.legend_group;
    if ([legend2, legend_label, legend_field, legend_group].filter((arg) => arg != null).length > 1) {
      throw new Error("only one of legend, legend_label, legend_field, legend_group can be specified");
    }
    const name = attrs.name;
    delete attrs.name;
    const level = attrs.level;
    delete attrs.level;
    const visible = attrs.visible;
    delete attrs.visible;
    const x_range_name = attrs.x_range_name;
    delete attrs.x_range_name;
    const y_range_name = attrs.y_range_name;
    delete attrs.y_range_name;
    const coordinates = attrs.coordinates;
    delete attrs.coordinates;
    const glyph_ca = this._pop_visuals(cls, attrs);
    const nglyph_ca = this._pop_visuals(cls, attrs, "nonselection_", glyph_ca, { alpha: 0.1 });
    const sglyph_ca = this._pop_visuals(cls, attrs, "selection_", glyph_ca);
    const hglyph_ca = this._pop_visuals(cls, attrs, "hover_", glyph_ca);
    const mglyph_ca = this._pop_visuals(cls, attrs, "muted_", glyph_ca, { alpha: 0.2 });
    const data_dict = dict(data3);
    this._fixup_values(cls, data_dict, glyph_ca);
    this._fixup_values(cls, data_dict, nglyph_ca);
    this._fixup_values(cls, data_dict, sglyph_ca);
    this._fixup_values(cls, data_dict, hglyph_ca);
    this._fixup_values(cls, data_dict, mglyph_ca);
    this._fixup_values(cls, data_dict, attrs);
    source2.data = data3;
    const _make_glyph = (cls2, attrs2, extra_attrs) => {
      return new cls2({ ...attrs2, ...extra_attrs });
    };
    const glyph = _make_glyph(cls, attrs, glyph_ca);
    const nglyph = !is_empty2(nglyph_ca) ? _make_glyph(cls, attrs, nglyph_ca) : "auto";
    const sglyph = !is_empty2(sglyph_ca) ? _make_glyph(cls, attrs, sglyph_ca) : "auto";
    const hglyph = !is_empty2(hglyph_ca) ? _make_glyph(cls, attrs, hglyph_ca) : void 0;
    const mglyph = !is_empty2(mglyph_ca) ? _make_glyph(cls, attrs, mglyph_ca) : "auto";
    const glyph_renderer = new GlyphRenderer({
      data_source: source2,
      view,
      glyph,
      nonselection_glyph: nglyph,
      selection_glyph: sglyph,
      hover_glyph: hglyph,
      muted_glyph: mglyph,
      name,
      level,
      visible,
      x_range_name,
      y_range_name,
      coordinates
    });
    if (legend_label != null) {
      this._handle_legend_label(legend_label, this.legend, glyph_renderer);
    }
    if (legend_field != null) {
      this._handle_legend_field(legend_field, this.legend, glyph_renderer);
    }
    if (legend_group != null) {
      this._handle_legend_group(legend_group, this.legend, glyph_renderer);
    }
    this.add_renderers(glyph_renderer);
    return glyph_renderer;
  }
  static _get_range(range2) {
    if (range2 == null) {
      return new DataRange1d();
    }
    if (range2 instanceof Range) {
      return range2;
    }
    if (isArray(range2)) {
      if (isArrayOf(range2, isString)) {
        const factors = range2;
        return new FactorRange({ factors });
      } else {
        const [start2, end] = range2;
        return new Range1d({ start: start2, end });
      }
    }
    throw new Error(`unable to determine proper range for: '${range2}'`);
  }
  static _get_scale(range_input, axis_type) {
    if (range_input instanceof DataRange1d || range_input instanceof Range1d) {
      switch (axis_type) {
        case null:
        case "auto":
        case "linear":
        case "datetime":
        case "mercator":
          return new LinearScale();
        case "log":
          return new LogScale();
      }
    }
    if (range_input instanceof FactorRange) {
      return new CategoricalScale();
    }
    throw new Error(`unable to determine proper scale for: '${range_input}'`);
  }
  _process_axis_and_grid(axis_type, axis_location, minor_ticks, axis_label, rng, dim) {
    const axis = this._get_axis(axis_type, rng, dim);
    if (axis != null) {
      if (axis instanceof LogAxis) {
        if (dim == 0) {
          this.x_scale = new LogScale();
        } else {
          this.y_scale = new LogScale();
        }
      }
      if (axis.ticker instanceof ContinuousTicker) {
        axis.ticker.num_minor_ticks = this._get_num_minor_ticks(axis, minor_ticks);
      }
      axis.axis_label = axis_label;
      if (axis_location != null) {
        this.add_layout(axis, axis_location);
      }
      const grid = new Grid2({ dimension: dim, ticker: axis.ticker });
      this.add_layout(grid);
    }
  }
  _get_axis(axis_type, range2, dim) {
    switch (axis_type) {
      case null:
        return null;
      case "linear":
        return new LinearAxis();
      case "log":
        return new LogAxis();
      case "datetime":
        return new DatetimeAxis();
      case "mercator": {
        const axis = new MercatorAxis();
        const dimension = dim == 0 ? "lon" : "lat";
        axis.ticker.dimension = dimension;
        axis.formatter.dimension = dimension;
        return axis;
      }
      case "auto":
        if (range2 instanceof FactorRange) {
          return new CategoricalAxis();
        } else {
          return new LinearAxis();
        }
      default:
        throw new Error("shouldn't have happened");
    }
  }
  _get_num_minor_ticks(axis, num_minor_ticks) {
    if (isNumber(num_minor_ticks)) {
      if (num_minor_ticks <= 1) {
        throw new Error("num_minor_ticks must be > 1");
      } else {
        return num_minor_ticks;
      }
    } else if (num_minor_ticks == null) {
      return 0;
    } else {
      return axis instanceof LogAxis ? 10 : 5;
    }
  }
  _update_legend(legend_item_label, glyph_renderer) {
    const { legend: legend2 } = this;
    let added = false;
    for (const item3 of legend2.items) {
      if (item3.label != null && is_equal(item3.label, legend_item_label)) {
        const label3 = item3.label;
        if ("value" in label3) {
          item3.renderers.push(glyph_renderer);
          added = true;
          break;
        }
        if ("field" in label3 && glyph_renderer.data_source == item3.renderers[0].data_source) {
          item3.renderers.push(glyph_renderer);
          added = true;
          break;
        }
      }
    }
    if (!added) {
      const new_item = new LegendItem({ label: legend_item_label, renderers: [glyph_renderer] });
      legend2.items.push(new_item);
    }
  }
  _handle_legend_label(value2, legend2, glyph_renderer) {
    const label3 = { value: value2 };
    const item3 = this._find_legend_item(label3, legend2);
    if (item3 != null) {
      item3.renderers.push(glyph_renderer);
    } else {
      const new_item = new LegendItem({ label: label3, renderers: [glyph_renderer] });
      legend2.items.push(new_item);
    }
  }
  _handle_legend_field(field, legend2, glyph_renderer) {
    const label3 = { field };
    const item3 = this._find_legend_item(label3, legend2);
    if (item3 != null) {
      item3.renderers.push(glyph_renderer);
    } else {
      const new_item = new LegendItem({ label: label3, renderers: [glyph_renderer] });
      legend2.items.push(new_item);
    }
  }
  _handle_legend_group(name, legend2, glyph_renderer) {
    const data3 = dict(glyph_renderer.data_source.data);
    if (!data3.has(name)) {
      throw new Error(`column to be grouped does not exist in glyph data source: ${name}`);
    }
    const column = data3.get(name) ?? [];
    const values2 = uniq(column).sort();
    for (const value2 of values2) {
      const label3 = { value: `${value2}` };
      const index2 = column.indexOf(value2);
      const new_item = new LegendItem({ label: label3, renderers: [glyph_renderer], index: index2 });
      legend2.items.push(new_item);
    }
  }
  _find_legend_item(label3, legend2) {
    const cmp = new Comparator();
    for (const item3 of legend2.items) {
      if (cmp.eq(item3.label, label3)) {
        return item3;
      }
    }
    return null;
  }
};
__publicField(_Figure2, "__name__", "Figure");
extend2(_Figure2, GlyphAPI);
var Figure2 = _Figure2;
function figure2(attributes) {
  return new Figure2(attributes);
}

// node_modules/@bokeh/bokehjs/build/js/lib/api/io.js
async function show2(obj, target) {
  const doc = (() => {
    if (obj instanceof Document) {
      return obj;
    } else {
      const doc2 = new Document();
      for (const item3 of isArray(obj) ? obj : [obj]) {
        doc2.add_root(item3);
      }
      return doc2;
    }
  })();
  const script2 = document.currentScript;
  await dom_ready();
  const element = (() => {
    if (target == null) {
      if (script2 != null && contains2(document.body, script2)) {
        const parent = script2.parentNode;
        if (parent instanceof HTMLElement || parent instanceof DocumentFragment) {
          return parent;
        }
      }
      return document.body;
    } else if (isString(target)) {
      const found = document.querySelector(target);
      if (found instanceof HTMLElement) {
        if (found.shadowRoot != null) {
          return found.shadowRoot;
        } else {
          return found;
        }
      } else {
        throw new Error(`'${target}' selector didn't match any elements`);
      }
    } else if (target instanceof HTMLElement) {
      return target;
    } else if (typeof $ !== "undefined" && target instanceof $) {
      return target[0];
    } else {
      throw new Error("target should be a HTMLElement, string selector, $ or null");
    }
  })();
  const view_manager = await add_document_standalone(doc, element);
  return new Promise((resolve, _reject) => {
    const views = [...view_manager];
    const result = isArray(obj) || obj instanceof Document ? views : views[0];
    if (doc.is_idle) {
      resolve(result);
    } else {
      doc.idle.connect(() => resolve(result));
    }
  });
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/matrix.js
var _Matrix = class _Matrix {
  constructor(nrows, ncols, init4) {
    __publicField(this, "nrows");
    __publicField(this, "ncols");
    __publicField(this, "_matrix");
    this.nrows = nrows;
    this.ncols = ncols;
    this._matrix = new Array(nrows);
    for (let y2 = 0; y2 < nrows; y2++) {
      this._matrix[y2] = new Array(ncols);
      for (let x2 = 0; x2 < ncols; x2++) {
        this._matrix[y2][x2] = init4(y2, x2);
      }
    }
  }
  at(row2, col2) {
    return this._matrix[row2][col2];
  }
  *[Symbol.iterator]() {
    for (let y2 = 0; y2 < this.nrows; y2++) {
      for (let x2 = 0; x2 < this.ncols; x2++) {
        const value2 = this._matrix[y2][x2];
        if (value2 !== void 0) {
          yield [value2, y2, x2];
        }
      }
    }
  }
  *values() {
    for (const [item3] of this) {
      yield item3;
    }
  }
  map(fn) {
    return new _Matrix(this.nrows, this.ncols, (row2, col2) => fn(this.at(row2, col2), row2, col2));
  }
  apply(obj) {
    const fn = _Matrix.from(obj);
    const { nrows, ncols } = this;
    if (nrows == fn.nrows && ncols == fn.ncols) {
      return new _Matrix(nrows, ncols, (row2, col2) => fn.at(row2, col2)(this.at(row2, col2), row2, col2));
    } else {
      throw new Error("dimensions don't match");
    }
  }
  to_sparse() {
    return [...this];
  }
  static from(obj, ncols) {
    if (obj instanceof _Matrix) {
      return obj;
    } else if (ncols != null) {
      const entries2 = obj;
      const nrows = Math.ceil(entries2.length / ncols);
      return new _Matrix(nrows, ncols, (row2, col2) => entries2[row2 * ncols + col2]);
    } else {
      const arrays = obj;
      const nrows = obj.length;
      const ncols2 = min(arrays.map((row2) => row2.length));
      return new _Matrix(nrows, ncols2, (row2, col2) => arrays[row2][col2]);
    }
  }
};
__publicField(_Matrix, "__name__", "Matrix");
var Matrix = _Matrix;

// node_modules/@bokeh/bokehjs/build/js/lib/api/gridplot.js
function group_tools(tools2, merge2, ignore = /* @__PURE__ */ new Set(["overlay", "renderers"])) {
  const by_type = /* @__PURE__ */ new Map();
  const computed = [];
  for (const tool of tools2) {
    if (tool instanceof ToolProxy) {
      computed.push(tool);
    } else {
      const attrs = tool.attributes;
      for (const attr2 of ignore) {
        if (attr2 in attrs) {
          delete attrs[attr2];
        }
      }
      const proto = tool.constructor.prototype;
      let values2 = by_type.get(proto);
      if (values2 == null) {
        by_type.set(proto, values2 = /* @__PURE__ */ new Set());
      }
      values2.add({ tool, attrs });
    }
  }
  for (const [cls, entries2] of by_type.entries()) {
    if (merge2 != null) {
      const merged = merge2(cls, [...entries2].map((entry2) => entry2.tool));
      if (merged != null) {
        computed.push(merged);
        continue;
      }
    }
    while (entries2.size != 0) {
      const [head3, ...tail] = entries2;
      entries2.delete(head3);
      const group = [head3.tool];
      for (const item3 of tail) {
        if (is_equal(item3.attrs, head3.attrs)) {
          group.push(item3.tool);
          entries2.delete(item3);
        }
      }
      if (group.length == 1) {
        computed.push(group[0]);
      } else {
        const merged = merge2 == null ? void 0 : merge2(cls, group);
        computed.push(merged ?? new ToolProxy({ tools: group }));
      }
    }
  }
  return computed;
}
function gridplot(children, options2 = {}) {
  const toolbar_location = options2.toolbar_location;
  const merge_tools = options2.merge_tools ?? true;
  const sizing_mode = options2.sizing_mode;
  const matrix = Matrix.from(children);
  const items = [];
  const toolbars2 = [];
  for (const [item3, row2, col2] of matrix) {
    if (item3 == null) {
      continue;
    }
    if (item3 instanceof Plot) {
      if (merge_tools) {
        toolbars2.push(item3.toolbar);
        item3.toolbar_location = null;
      }
    }
    if (options2.width != null) {
      item3.width = options2.width;
    }
    if (options2.height != null) {
      item3.height = options2.height;
    }
    items.push([item3, row2, col2]);
  }
  function merge2(_cls, group) {
    const tool = group[0];
    if (tool instanceof SaveTool) {
      return new SaveTool();
    } else if (tool instanceof CopyTool) {
      return new CopyTool();
    } else if (tool instanceof ExamineTool) {
      return new ExamineTool();
    } else if (tool instanceof FullscreenTool) {
      return new FullscreenTool();
    } else {
      return null;
    }
  }
  const tools2 = (() => {
    const tools3 = [];
    for (const toolbar2 of toolbars2) {
      tools3.push(...toolbar2.tools);
    }
    if (merge_tools) {
      return group_tools(tools3, merge2);
    } else {
      return tools3;
    }
  })();
  const logos2 = toolbars2.map((toolbar2) => toolbar2.logo);
  const autohides = toolbars2.map((toolbar2) => toolbar2.autohide);
  const active_drags = toolbars2.map((toolbar2) => toolbar2.active_drag);
  const active_inspects = toolbars2.map((toolbar2) => toolbar2.active_inspect);
  const active_scrolls = toolbars2.map((toolbar2) => toolbar2.active_scroll);
  const active_taps = toolbars2.map((toolbar2) => toolbar2.active_tap);
  const active_multis = toolbars2.map((toolbar2) => toolbar2.active_multi);
  function assert_unique(values2, name) {
    const n2 = new Set(values2).size;
    if (n2 == 0) {
      return void 0;
    } else if (n2 > 1) {
      console.warn(`found multiple competing values for 'toolbar.${name}' property; using the latest value`);
    }
    return last(values2);
  }
  const logo2 = assert_unique(logos2, "logo");
  const autohide = assert_unique(autohides, "autohide");
  const active_drag = assert_unique(active_drags, "active_drag");
  const active_inspect = assert_unique(active_inspects, "active_inspect");
  const active_scroll = assert_unique(active_scrolls, "active_scroll");
  const active_tap = assert_unique(active_taps, "active_tap");
  const active_multi = assert_unique(active_multis, "active_multi");
  const toolbar = new Toolbar({
    tools: tools2,
    logo: logo2,
    autohide,
    active_drag,
    active_inspect,
    active_scroll,
    active_tap,
    active_multi
    // TODO ...toolbar_options,
  });
  const gp = new GridPlot({
    children: items,
    toolbar,
    toolbar_location,
    sizing_mode
  });
  return gp;
}

// node_modules/@bokeh/bokehjs/build/js/lib/api/themes.js
var themes_exports = {};
__export(themes_exports, {
  caliber: () => caliber,
  constrast: () => constrast,
  dark_minimal: () => dark_minimal,
  light_minimal: () => light_minimal,
  night_sky: () => night_sky
});
var ThemedAttrs = class {
  constructor(type, attrs) {
    __publicField(this, "type");
    __publicField(this, "attrs");
    __publicField(this, "defaults");
    this.type = type;
    this.attrs = attrs;
    this.defaults = new Map(entries(attrs));
  }
};
__publicField(ThemedAttrs, "__name__", "ThemedAttrs");
function themed(type, attrs) {
  return new ThemedAttrs(type, attrs);
}
var Theme = class {
  constructor(attrs) {
    __publicField(this, "attrs");
    this.attrs = attrs;
  }
  get(obj, attr2) {
    const model2 = obj instanceof HasProps ? obj.constructor : obj;
    for (const { type, defaults: defaults3 } of this.attrs) {
      if (model2 == type || model2.prototype instanceof type) {
        return defaults3.get(attr2);
      }
    }
    return void 0;
  }
};
__publicField(Theme, "__name__", "Theme");
var dark_minimal = new Theme([
  themed(Plot, {
    background_fill_color: "#20262b",
    border_fill_color: "#15191c",
    outline_line_color: "#e0e0e0",
    outline_line_alpha: 0.25
  }),
  themed(Grid2, {
    grid_line_color: "#e0e0e0",
    grid_line_alpha: 0.25
  }),
  themed(Axis, {
    major_tick_line_alpha: 0,
    major_tick_line_color: "#e0e0e0",
    minor_tick_line_alpha: 0,
    minor_tick_line_color: "#e0e0e0",
    axis_line_alpha: 0,
    axis_line_color: "#e0e0e0",
    major_label_text_color: "#e0e0e0",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    axis_label_standoff: 10,
    axis_label_text_color: "#e0e0e0",
    axis_label_text_font: "Helvetica",
    axis_label_text_font_size: "1.25em",
    axis_label_text_font_style: "normal"
  }),
  themed(Legend, {
    spacing: 8,
    glyph_width: 15,
    label_standoff: 8,
    label_text_color: "#e0e0e0",
    label_text_font: "Helvetica",
    label_text_font_size: "1.025em",
    border_line_alpha: 0,
    background_fill_alpha: 0.25,
    background_fill_color: "#20262b"
  }),
  themed(BaseColorBar, {
    title_text_color: "#e0e0e0",
    title_text_font: "Helvetica",
    title_text_font_size: "1.025em",
    title_text_font_style: "normal",
    major_label_text_color: "#e0e0e0",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    background_fill_color: "#15191c",
    major_tick_line_alpha: 0,
    bar_line_alpha: 0
  }),
  themed(Title, {
    text_color: "#e0e0e0",
    text_font: "Helvetica",
    text_font_size: "1.15em"
  })
]);
var light_minimal = new Theme([
  themed(Axis, {
    major_tick_line_alpha: 0,
    major_tick_line_color: "#5b5b5b",
    minor_tick_line_alpha: 0,
    minor_tick_line_color: "#5b5b5b",
    axis_line_alpha: 0,
    axis_line_color: "#5b5b5b",
    major_label_text_color: "#5b5b5b",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    axis_label_standoff: 10,
    axis_label_text_color: "#5b5b5b",
    axis_label_text_font: "Helvetica",
    axis_label_text_font_size: "1.25em",
    axis_label_text_font_style: "normal"
  }),
  themed(Legend, {
    spacing: 8,
    glyph_width: 15,
    label_standoff: 8,
    label_text_color: "#5b5b5b",
    label_text_font: "Helvetica",
    label_text_font_size: "1.025em",
    border_line_alpha: 0,
    background_fill_alpha: 0.25
  }),
  themed(BaseColorBar, {
    title_text_color: "#5b5b5b",
    title_text_font: "Helvetica",
    title_text_font_size: "1.025em",
    title_text_font_style: "normal",
    major_label_text_color: "#5b5b5b",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    major_tick_line_alpha: 0,
    bar_line_alpha: 0
  }),
  themed(Title, {
    text_color: "#5b5b5b",
    text_font: "Helvetica",
    text_font_size: "1.15em"
  })
]);
var caliber = new Theme([
  themed(Axis, {
    major_tick_in: 0,
    major_tick_out: 3,
    major_tick_line_alpha: 0.25,
    major_tick_line_color: "#5b5b5b",
    minor_tick_line_alpha: 0.25,
    minor_tick_line_color: "#5b5b5b",
    axis_line_alpha: 1,
    axis_line_color: "#5b5b5b",
    major_label_text_color: "#5b5b5b",
    major_label_text_font: "Calibri Light",
    major_label_text_font_size: "0.95em",
    major_label_text_font_style: "bold",
    axis_label_standoff: 10,
    axis_label_text_color: "#5b5b5b",
    axis_label_text_font: "Calibri Light",
    axis_label_text_font_size: "1.15em",
    axis_label_text_font_style: "bold"
  }),
  themed(Legend, {
    spacing: 8,
    glyph_width: 15,
    label_standoff: 8,
    label_text_color: "#5b5b5b",
    label_text_font: "Calibri Light",
    label_text_font_size: "0.95em",
    label_text_font_style: "bold",
    border_line_alpha: 0,
    background_fill_alpha: 0.25
  }),
  themed(BaseColorBar, {
    title_text_color: "#5b5b5b",
    title_text_font: "Calibri Light",
    title_text_font_size: "1.15em",
    title_text_font_style: "bold",
    major_label_text_color: "#5b5b5b",
    major_label_text_font: "Calibri Light",
    major_label_text_font_size: "0.95em",
    major_label_text_font_style: "bold",
    major_tick_line_alpha: 0,
    bar_line_alpha: 0
  }),
  themed(Title, {
    text_color: "#5b5b5b",
    text_font: "Calibri Light",
    text_font_size: "1.25em",
    text_font_style: "bold"
  })
]);
var constrast = new Theme([
  themed(Plot, {
    background_fill_color: "#000000",
    border_fill_color: "#ffffff",
    outline_line_color: "#000000",
    outline_line_alpha: 0.25
  }),
  themed(Grid2, {
    grid_line_color: "#e0e0e0",
    grid_line_alpha: 0.25
  }),
  themed(Axis, {
    major_tick_line_alpha: 0,
    major_tick_line_color: "#000000",
    minor_tick_line_alpha: 0,
    minor_tick_line_color: "#000000",
    axis_line_alpha: 0,
    axis_line_color: "#000000",
    major_label_text_color: "#000000",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    axis_label_standoff: 10,
    axis_label_text_color: "#000000",
    axis_label_text_font: "Helvetica",
    axis_label_text_font_size: "1.25em",
    axis_label_text_font_style: "normal"
  }),
  themed(Legend, {
    spacing: 8,
    glyph_width: 15,
    label_standoff: 8,
    label_text_color: "#ffffff",
    label_text_font: "Helvetica",
    label_text_font_size: "1.025em",
    border_line_alpha: 0,
    background_fill_alpha: 0.25,
    background_fill_color: "#000000"
  }),
  themed(BaseColorBar, {
    title_text_color: "#e0e0e0",
    title_text_font: "Helvetica",
    title_text_font_size: "1.025em",
    title_text_font_style: "normal",
    major_label_text_color: "#e0e0e0",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    background_fill_color: "#15191c",
    major_tick_line_alpha: 0,
    bar_line_alpha: 0
  }),
  themed(Title, {
    text_color: "#000000",
    text_font: "Helvetica",
    text_font_size: "1.15em"
  })
]);
var night_sky = new Theme([
  themed(Plot, {
    background_fill_color: "#2C001e",
    border_fill_color: "#15191c",
    outline_line_color: "#e0e0e0",
    outline_line_alpha: 0.25
  }),
  themed(Grid2, {
    grid_line_color: "#e0e0e0",
    grid_line_alpha: 0.25
  }),
  themed(Axis, {
    major_tick_line_alpha: 0,
    major_tick_line_color: "#e0e0e0",
    minor_tick_line_alpha: 0,
    minor_tick_line_color: "#e0e0e0",
    axis_line_alpha: 0,
    axis_line_color: "#e0e0e0",
    major_label_text_color: "#e0e0e0",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    axis_label_standoff: 10,
    axis_label_text_color: "#e0e0e0",
    axis_label_text_font: "Helvetica",
    axis_label_text_font_size: "1.25em",
    axis_label_text_font_style: "normal"
  }),
  themed(Legend, {
    spacing: 8,
    glyph_width: 15,
    label_standoff: 8,
    label_text_color: "#e0e0e0",
    label_text_font: "Helvetica",
    label_text_font_size: "1.025em",
    border_line_alpha: 0,
    background_fill_alpha: 0.25,
    background_fill_color: "#2C001e"
  }),
  themed(BaseColorBar, {
    title_text_color: "#e0e0e0",
    title_text_font: "Helvetica",
    title_text_font_size: "1.025em",
    title_text_font_style: "normal",
    major_label_text_color: "#e0e0e0",
    major_label_text_font: "Helvetica",
    major_label_text_font_size: "1.025em",
    background_fill_color: "#15191c",
    major_tick_line_alpha: 0,
    bar_line_alpha: 0
  }),
  themed(Title, {
    text_color: "#e0e0e0",
    text_font: "Helvetica",
    text_font_size: "1.15em"
  })
]);

// node_modules/@bokeh/bokehjs/build/js/lib/api/parser.js
var TAB_CODE = 9;
var LF_CODE = 10;
var CR_CODE = 13;
var SPACE_CODE = 32;
var PERIOD_CODE = 46;
var COMMA_CODE = 44;
var SQUOTE_CODE = 39;
var DQUOTE_CODE = 34;
var OPAREN_CODE = 40;
var CPAREN_CODE = 41;
var OBRACK_CODE = 91;
var CBRACK_CODE = 93;
var SEMCOL_CODE = 59;
var COMPOUND = Symbol("Compound");
var LITERAL = Symbol("Literal");
var IDENT = Symbol("Identifier");
var MEMBER = Symbol("MemberExpression");
var INDEX = Symbol("IndexExpression");
var CALL = Symbol("CallExpression");
var UNARY = Symbol("UnaryExpression");
var BINARY = Symbol("BinaryExpression");
var SEQUENCE = Symbol("SequenceExpression");
var ARRAY = Symbol("ArrayExpression");
var FAILURE = Symbol("Failure");
var unary_ops = dict({
  "-": 1,
  "!": 1,
  "~": 1,
  "+": 1
});
var binary_ops = dict({
  "||": 1,
  "&&": 2,
  "|": 3,
  "^": 4,
  "&": 5,
  "==": 6,
  "!=": 6,
  "<": 7,
  ">": 7,
  "<=": 7,
  ">=": 7,
  "<<": 8,
  ">>": 8,
  "+": 9,
  "-": 9,
  "*": 10,
  "/": 10,
  "%": 10,
  "**": 11
});
var additional_identifier_chars = /* @__PURE__ */ new Set(["$", "_"]);
var literals = dict({
  true: true,
  false: false,
  null: null
});
function max_key_len(obj) {
  return Math.max(0, ...[...obj.keys()].map((k) => k.length));
}
var max_unop_len = max_key_len(unary_ops);
var max_binop_len = max_key_len(binary_ops);
function binary_precedence(op_val) {
  return binary_ops.get(op_val) ?? 0;
}
function is_decimal_digit(ch) {
  return ch >= 48 && ch <= 57;
}
function is_identifier_start(ch) {
  return ch >= 65 && ch <= 90 || // A...Z
  ch >= 97 && ch <= 122 || // a...z
  ch >= 128 && !binary_ops.has(String.fromCharCode(ch)) || // any non-ASCII that is not an operator
  additional_identifier_chars.has(String.fromCharCode(ch));
}
function is_identifier_part(ch) {
  return is_identifier_start(ch) || is_decimal_digit(ch);
}
var ParseError = class extends Error {
};
__publicField(ParseError, "__name__", "ParseError");
var Parser2 = class {
  constructor(expr2) {
    __publicField(this, "expr");
    // `index` stores the character number we are currently at
    // All of the gobbles below will modify `index` as we move along
    __publicField(this, "index", 0);
    this.expr = expr2;
  }
  get char() {
    return this.expr.charAt(this.index);
  }
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * throw error at index of the expression
   */
  error(message) {
    throw new ParseError(`${message} at character ${this.index}`);
  }
  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch = this.code;
    while (ch == SPACE_CODE || ch == TAB_CODE || ch == LF_CODE || ch == CR_CODE) {
      ch = this.expr.charCodeAt(++this.index);
    }
  }
  /**
   * Top-level method to parse all expressions and returns compound or single node
   */
  parse() {
    try {
      const nodes = this.gobbleExpressions(void 0);
      const node = nodes.length == 1 ? nodes[0] : { type: COMPOUND, body: nodes };
      return node;
    } catch (error) {
      if (error instanceof ParseError) {
        return { type: FAILURE, message: error.message };
      } else {
        throw error;
      }
    }
  }
  /**
   * top-level parser (but can be reused within as well)
   */
  gobbleExpressions(until) {
    const nodes = [];
    while (this.index < this.expr.length) {
      const ch_i = this.code;
      if (ch_i == SEMCOL_CODE || ch_i == COMMA_CODE) {
        this.index++;
      } else {
        const node = this.gobbleExpression();
        if (node != false) {
          nodes.push(node);
        } else if (this.index < this.expr.length) {
          if (ch_i == until) {
            break;
          }
          this.error(`Unexpected '${this.char}'`);
        }
      }
    }
    return nodes;
  }
  /**
   * The main parsing function.
   */
  gobbleExpression() {
    const node = this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return node;
  }
  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substring(this.index, this.index + max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      if (binary_ops.has(to_check) && (!is_identifier_start(this.code) || this.index + to_check.length < this.expr.length && !is_identifier_part(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substring(0, --tc_len);
    }
    return false;
  }
  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   */
  gobbleBinaryExpression() {
    const left2 = this.gobbleToken();
    if (left2 == false) {
      return left2;
    }
    let biop = this.gobbleBinaryOp();
    if (biop == false) {
      return left2;
    }
    let biop_info = { value: biop, prec: binary_precedence(biop) };
    const right3 = this.gobbleToken();
    if (right3 == false) {
      this.error(`Expected expression after ${biop}`);
    }
    const stack = [left2, biop_info, right3];
    let cur_biop;
    while ((biop = this.gobbleBinaryOp()) != false) {
      const prec = binary_precedence(biop);
      if (prec == 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = { value: biop, prec };
      cur_biop = biop;
      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
        const right4 = stack.pop();
        const biop2 = stack.pop().value;
        const left3 = stack.pop();
        const node3 = {
          type: BINARY,
          operator: biop2,
          left: left3,
          right: right4
        };
        stack.push(node3);
      }
      const node2 = this.gobbleToken();
      if (node2 == false) {
        this.error(`Expected expression after ${cur_biop}`);
      }
      stack.push(biop_info, node2);
    }
    let i2 = stack.length - 1;
    let node = stack[i2];
    while (i2 > 1) {
      node = {
        type: BINARY,
        operator: stack[i2 - 1].value,
        left: stack[i2 - 2],
        right: node
      };
      i2 -= 2;
    }
    return node;
  }
  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   */
  gobbleToken() {
    this.gobbleSpaces();
    const ch = this.code;
    if (is_decimal_digit(ch) || ch == PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    }
    let node = false;
    if (ch == SQUOTE_CODE || ch == DQUOTE_CODE) {
      node = this.gobbleStringLiteral();
    } else if (ch == OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      let to_check = this.expr.substring(this.index, this.index + max_unop_len);
      let tc_len = to_check.length;
      while (tc_len > 0) {
        if (unary_ops.has(to_check) && (!is_identifier_start(this.code) || this.index + to_check.length < this.expr.length && !is_identifier_part(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (argument == false) {
            this.error("missing unaryOp argument");
          }
          return {
            type: UNARY,
            operator: to_check,
            argument,
            prefix: true
          };
        }
        to_check = to_check.substring(0, --tc_len);
      }
      if (is_identifier_start(ch)) {
        node = this.gobbleIdentifier();
        const value2 = literals.get(node.name);
        if (value2 !== void 0) {
          node = {
            type: LITERAL,
            value: value2
          };
        }
      } else if (ch == OPAREN_CODE) {
        node = this.gobbleGroup();
      }
    }
    if (node == false) {
      return false;
    }
    node = this.gobbleTokenProperty(node);
    return node;
  }
  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch = this.code;
    while (ch == PERIOD_CODE || ch == OBRACK_CODE || ch == OPAREN_CODE) {
      this.index++;
      if (ch == PERIOD_CODE) {
        this.gobbleSpaces();
        node = {
          type: MEMBER,
          object: node,
          member: this.gobbleIdentifier()
        };
      } else if (ch == OBRACK_CODE) {
        const expr2 = this.gobbleExpression();
        if (expr2 == false) {
          this.error("Expected an expression");
        }
        node = {
          type: INDEX,
          object: node,
          index: expr2
        };
        this.gobbleSpaces();
        ch = this.code;
        if (ch !== CBRACK_CODE) {
          this.error("Unclosed [");
        }
        this.index++;
      } else {
        node = {
          type: CALL,
          args: this.gobbleArguments(CPAREN_CODE),
          callee: node
        };
      }
      this.gobbleSpaces();
      ch = this.code;
    }
    return node;
  }
  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   */
  gobbleNumericLiteral() {
    let number2 = "";
    while (is_decimal_digit(this.code)) {
      number2 += this.expr.charAt(this.index++);
    }
    if (this.code == PERIOD_CODE) {
      number2 += this.expr.charAt(this.index++);
      while (is_decimal_digit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
    }
    let ch = this.char;
    if (ch == "e" || ch == "E") {
      number2 += this.expr.charAt(this.index++);
      ch = this.char;
      if (ch == "+" || ch == "-") {
        number2 += this.expr.charAt(this.index++);
      }
      while (is_decimal_digit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
      if (!is_decimal_digit(this.expr.charCodeAt(this.index - 1))) {
        this.error(`Expected exponent (${number2 + this.char})`);
      }
    }
    const code2 = this.code;
    if (is_identifier_start(code2)) {
      this.error(`Variable names cannot start with a number (${number2 + this.char})`);
    } else if (code2 == PERIOD_CODE || number2.length == 1 && number2.charCodeAt(0) == PERIOD_CODE) {
      this.error("Unexpected ','");
    }
    return {
      type: LITERAL,
      value: parseFloat(number2)
    };
  }
  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   */
  gobbleStringLiteral() {
    const quote = this.expr.charAt(this.index++);
    let str = "";
    let closed = false;
    while (this.index < this.expr.length) {
      let ch = this.expr.charAt(this.index++);
      if (ch == quote) {
        closed = true;
        break;
      } else if (ch == "\\") {
        ch = this.expr.charAt(this.index++);
        switch (ch) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            str += ch;
        }
      } else {
        str += ch;
      }
    }
    if (!closed) {
      this.error(`Unclosed quote after "${str}"`);
    }
    return {
      type: LITERAL,
      value: str
    };
  }
  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   */
  gobbleIdentifier() {
    let ch = this.code;
    const start2 = this.index;
    if (is_identifier_start(ch)) {
      this.index++;
    } else {
      this.error(`Unexpected '${this.char}'`);
    }
    while (this.index < this.expr.length) {
      ch = this.code;
      if (is_identifier_part(ch)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: IDENT,
      name: this.expr.slice(start2, this.index)
    };
  }
  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      const ch_i = this.code;
      if (ch_i == termination) {
        closed = true;
        this.index++;
        if (termination == CPAREN_CODE && separator_count != 0 && separator_count >= args.length) {
          this.error(`Unexpected token '${String.fromCharCode(termination)}'`);
        }
        break;
      } else if (ch_i == COMMA_CODE) {
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          if (termination == CPAREN_CODE) {
            this.error("Unexpected token ','");
          } else if (termination == CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              this.error("Expected an expression");
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        this.error("Expected comma");
      } else {
        const node = this.gobbleExpression();
        if (node == false || node.type == COMPOUND) {
          this.error("Expected comma");
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.error(`Expected ${String.fromCharCode(termination)}`);
    }
    return args;
  }
  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   */
  gobbleGroup() {
    this.index++;
    const nodes = this.gobbleExpressions(CPAREN_CODE);
    if (this.code == CPAREN_CODE) {
      this.index++;
      if (nodes.length == 1) {
        return nodes[0];
      } else if (nodes.length == 0) {
        return false;
      } else {
        return {
          type: SEQUENCE,
          expressions: nodes
        };
      }
    } else {
      this.error("Unclosed (");
    }
  }
  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   */
  gobbleArray() {
    this.index++;
    return {
      type: ARRAY,
      elements: this.gobbleArguments(CBRACK_CODE)
    };
  }
};
__publicField(Parser2, "__name__", "Parser");

// node_modules/@bokeh/bokehjs/build/js/lib/api/expr.js
function evaluate(ast, refs) {
  const np_proxy = dict(np);
  function resolve(ast2) {
    switch (ast2.type) {
      case LITERAL:
        return ast2.value;
      case IDENT:
        if (ast2.name.startsWith("$")) {
          const i2 = Number(ast2.name.slice(1));
          if (isFinite(i2) && 0 <= i2 && i2 < refs.length) {
            return refs[i2];
          } else {
            throw new Error(`invalid reference: ${ast2.name}`);
          }
        }
        switch (ast2.name) {
          case "np":
            return np;
          default:
            throw new Error(`unknown identifier: ${ast2.name}`);
        }
      case MEMBER:
        const obj = resolve(ast2.object);
        if (obj === np) {
          const { name } = ast2.member;
          const member = np_proxy.get(name);
          if (member !== void 0) {
            return member;
          } else {
            throw new Error(`'np.${name}' doesn't exist`);
          }
        } else {
          throw new Error("not an accessible expression");
        }
      case INDEX:
        throw new Error("not an indexable expression");
      case CALL:
        const callee = resolve(ast2.callee);
        if (isFunction(callee)) {
          return callee.apply(void 0, ast2.args.map((arg) => resolve(arg)));
        } else {
          throw new Error("not a callable expression");
        }
      case UNARY: {
        const op2 = (() => {
          switch (ast2.operator) {
            case "+":
              return np.pos;
            case "-":
              return np.neg;
            default:
              throw new Error(`unsupported operator: ${ast2.operator}`);
          }
        })();
        const x3 = resolve(ast2.argument);
        if (is_Numerical(x3)) {
          return op2(x3);
        } else {
          throw new Error("a number or an array was expected");
        }
      }
      case BINARY:
        const op = (() => {
          switch (ast2.operator) {
            case "+":
              return np.add;
            case "-":
              return np.sub;
            case "*":
              return np.mul;
            case "/":
              return np.div;
            case "**":
              return np.pow;
            case "<=":
              return np.le;
            case ">=":
              return np.ge;
            case "<":
              return np.lt;
            case ">":
              return np.gt;
            default:
              throw new Error(`unsupported operator: ${ast2.operator}`);
          }
        })();
        const x2 = resolve(ast2.left);
        const y2 = resolve(ast2.right);
        if (is_Numerical(x2) && is_Numerical(y2)) {
          return op(x2, y2);
        } else {
          throw new Error("a number or an array was expected");
        }
      case COMPOUND:
      case SEQUENCE:
      case ARRAY:
      default:
        throw new Error("unsupported");
    }
  }
  return resolve(ast);
}
function f(strings, ...subs) {
  const [head3, ...tail] = strings;
  const input12 = head3 + tail.map((s2, i2) => `($${i2})${s2}`).join("");
  const parser = new Parser2(input12);
  const ast = parser.parse();
  if (ast.type != FAILURE) {
    return evaluate(ast, subs);
  } else {
    throw new Error(ast.message);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/index.js
var widgets_exports = {};
__export(widgets_exports, {
  AbstractButton: () => AbstractButton,
  AutocompleteInput: () => AutocompleteInput,
  Button: () => Button,
  CategoricalSlider: () => CategoricalSlider,
  Checkbox: () => Checkbox,
  CheckboxButtonGroup: () => CheckboxButtonGroup,
  CheckboxGroup: () => CheckboxGroup,
  ColorPicker: () => ColorPicker,
  DatePicker: () => DatePicker,
  DateRangePicker: () => DateRangePicker,
  DateRangeSlider: () => DateRangeSlider,
  DateSlider: () => DateSlider,
  DatetimePicker: () => DatetimePicker,
  DatetimeRangePicker: () => DatetimeRangePicker,
  DatetimeRangeSlider: () => DatetimeRangeSlider,
  Div: () => Div2,
  Dropdown: () => Dropdown,
  FileInput: () => FileInput,
  HelpButton: () => HelpButton,
  InputWidget: () => InputWidget,
  Markup: () => Markup,
  MultiChoice: () => MultiChoice,
  MultiSelect: () => MultiSelect,
  MultipleDatePicker: () => MultipleDatePicker,
  MultipleDatetimePicker: () => MultipleDatetimePicker,
  NumericInput: () => NumericInput,
  PaletteSelect: () => PaletteSelect,
  Paragraph: () => Paragraph,
  PasswordInput: () => PasswordInput,
  PreText: () => PreText,
  RadioButtonGroup: () => RadioButtonGroup,
  RadioGroup: () => RadioGroup,
  RangeSlider: () => RangeSlider,
  Select: () => Select,
  Slider: () => Slider,
  Spinner: () => Spinner,
  Switch: () => Switch,
  TextAreaInput: () => TextAreaInput,
  TextInput: () => TextInput,
  TimePicker: () => TimePicker,
  Toggle: () => Toggle,
  Widget: () => Widget
});

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/widget.js
var WidgetView = class extends LayoutDOMView {
  get child_models() {
    return [];
  }
  get provider() {
    return default_provider;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    if (this.provider.status == "not_started") {
      await this.provider.fetch();
    }
  }
  _after_layout() {
    super._after_layout();
    if (this.provider.status == "loading") {
      this._has_finished = false;
    }
  }
  process_tex(text2) {
    if (this.provider.MathJax == null) {
      return text2;
    }
    const tex_parts = this.provider.MathJax.find_tex(text2);
    const processed_text = [];
    let last_index = 0;
    for (const part of tex_parts) {
      processed_text.push(text2.slice(last_index, part.start.n));
      processed_text.push(this.provider.MathJax.tex2svg(part.math, { display: part.display }).outerHTML);
      last_index = part.end.n;
    }
    if (last_index < text2.length) {
      processed_text.push(text2.slice(last_index));
    }
    return processed_text.join("");
  }
  contains_tex_string(text2) {
    if (this.provider.MathJax == null) {
      return false;
    }
    return this.provider.MathJax.find_tex(text2).length > 0;
  }
};
__publicField(WidgetView, "__name__", "WidgetView");
var _Widget = class _Widget extends LayoutDOM {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Widget, "__name__", "Widget");
_Widget.override({
  margin: 5
});
var Widget = _Widget;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/control.js
var ControlView = class extends WidgetView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.disabled, (disabled5) => {
      for (const el of this.controls()) {
        toggle_attribute(el, "disabled", disabled5);
      }
    });
  }
};
__publicField(ControlView, "__name__", "ControlView");
var Control = class extends Widget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(Control, "__name__", "Control");

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/abstract_button.js
import buttons_css, * as buttons from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var AbstractButtonView = class extends ControlView {
  constructor() {
    super(...arguments);
    __publicField(this, "label_view");
    __publicField(this, "icon_view");
    __publicField(this, "button_el");
    __publicField(this, "group_el");
  }
  *controls() {
    yield this.button_el;
  }
  *children() {
    yield* super.children();
    if (this.label_view != null) {
      yield this.label_view;
    }
    if (this.icon_view != null) {
      yield this.icon_view;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._rebuild_label();
    await this._rebuild_icon();
  }
  async _rebuild_label() {
    var _a34;
    (_a34 = this.label_view) == null ? void 0 : _a34.remove();
    const label3 = (() => {
      const { label: label4 } = this.model;
      return isString(label4) ? new Text3({ content: label4 }) : label4;
    })();
    this.label_view = await this.owner.build_view(label3, this);
  }
  async _rebuild_icon() {
    var _a34;
    (_a34 = this.icon_view) == null ? void 0 : _a34.remove();
    const { icon: icon3 } = this.model;
    if (icon3 != null) {
      this.icon_view = await build_view(icon3, { parent: this });
    }
  }
  connect_signals() {
    super.connect_signals();
    const { label: label3, icon: icon3, button_type, disabled: disabled5 } = this.model.properties;
    this.on_transitive_change(label3, async () => {
      await this._rebuild_label();
      this.render();
    });
    this.on_transitive_change(icon3, async () => {
      await this._rebuild_icon();
      this.render();
    });
    this.on_change([button_type, disabled5], () => {
      this.render();
    });
  }
  remove() {
    var _a34, _b4;
    (_a34 = this.label_view) == null ? void 0 : _a34.remove();
    (_b4 = this.icon_view) == null ? void 0 : _b4.remove();
    super.remove();
  }
  stylesheets() {
    return [...super.stylesheets(), buttons_css];
  }
  _render_button(...children) {
    return button({
      type: "button",
      disabled: this.model.disabled,
      class: [buttons.btn, buttons[`btn_${this.model.button_type}`]]
    }, ...children);
  }
  render() {
    var _a34, _b4;
    super.render();
    (_a34 = this.label_view) == null ? void 0 : _a34.render();
    this.button_el = this._render_button((_b4 = this.label_view) == null ? void 0 : _b4.el);
    this.button_el.addEventListener("click", () => this.click());
    if (this.icon_view != null) {
      const separator = this.model.label != "" ? nbsp() : text("");
      prepend2(this.button_el, this.icon_view.el, separator);
      this.icon_view.render();
    }
    this.group_el = div({ class: buttons.btn_group }, this.button_el);
    this.shadow_el.append(this.group_el);
  }
  click() {
  }
};
__publicField(AbstractButtonView, "__name__", "AbstractButtonView");
var _AbstractButton = class _AbstractButton extends Control {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_AbstractButton, "__name__", "AbstractButton");
_AbstractButton.define(({ Str: Str2, Ref: Ref2, Or: Or2, Nullable: Nullable2 }) => ({
  label: [Or2(Ref2(DOMNode), Str2), "Button"],
  icon: [Nullable2(Ref2(Icon)), null],
  button_type: [ButtonType, "default"]
}));
var AbstractButton = _AbstractButton;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/input_widget.js
import inputs_css, * as inputs from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
import icons_css10 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ClearInput_1;
var _a33;
var ClearInput = (_a33 = class extends ModelEvent {
  constructor(model2) {
    super();
    __publicField(this, "model");
    this.model = model2;
    this.origin = model2;
  }
  static from_values(values2) {
    const { model: model2 } = values2;
    return new ClearInput_1(model2);
  }
}, ClearInput_1 = _a33, __publicField(_a33, "__name__", "ClearInput"), _a33);
ClearInput = ClearInput_1 = __decorate2([
  server_event("clear_input")
], ClearInput);
var InputWidgetView = class extends ControlView {
  constructor() {
    super(...arguments);
    __publicField(this, "title");
    __publicField(this, "description", null);
    __publicField(this, "input_el");
    __publicField(this, "title_el");
    __publicField(this, "desc_el", null);
    __publicField(this, "group_el");
  }
  *controls() {
    yield this.input_el;
  }
  *children() {
    yield* super.children();
    const { title: title3, description: description2 } = this;
    if (title3 instanceof View) {
      yield title3;
    }
    if (description2 instanceof View) {
      yield description2;
    }
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    await this._build_title();
    await this._build_description();
  }
  remove() {
    const { title: title3, description: description2 } = this;
    if (title3 instanceof View) {
      title3.remove();
    }
    if (description2 instanceof View) {
      description2.remove();
    }
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    const { title: title3, description: description2 } = this.model.properties;
    this.on_change(title3, async () => {
      await this._build_title();
      this.render();
    });
    this.on_change(description2, async () => {
      await this._build_description();
      this.render();
    });
  }
  stylesheets() {
    return [...super.stylesheets(), inputs_css, icons_css10];
  }
  render() {
    super.render();
    this.desc_el = this._build_description_el();
    this.title_el = this._build_title_el();
    const input_or_container_el = this._render_input();
    this.input_el.id = "input";
    this.group_el = div({ class: inputs.input_group }, this.title_el, input_or_container_el);
    this.shadow_el.append(this.group_el);
  }
  _build_description_el() {
    const { description: description2 } = this;
    if (description2 == null) {
      return null;
    } else {
      const icon_el = div({ class: inputs.icon });
      const desc_el = div({ class: inputs.description }, icon_el);
      if (isString(description2)) {
        desc_el.title = description2;
      } else {
        if (description2.model.target == "auto") {
          description2.target = desc_el;
        }
        let persistent = false;
        const toggle = (visible) => {
          description2.model.setv({
            visible,
            closable: persistent
          });
          icon_el.classList.toggle(inputs.opaque, visible && persistent);
        };
        this.on_change(description2.model.properties.visible, () => {
          const { visible } = description2.model;
          if (!visible) {
            persistent = false;
          }
          toggle(visible);
        });
        desc_el.addEventListener("mouseenter", () => {
          toggle(true);
        });
        desc_el.addEventListener("mouseleave", () => {
          if (!persistent) {
            toggle(false);
          }
        });
        document.addEventListener("mousedown", (event2) => {
          const path = event2.composedPath();
          if (path.includes(description2.el)) {
            return;
          } else if (path.includes(desc_el)) {
            persistent = !persistent;
            toggle(persistent);
          } else {
            persistent = false;
            toggle(false);
          }
        });
        window.addEventListener("blur", () => {
          persistent = false;
          toggle(false);
        });
      }
      return desc_el;
    }
  }
  async _build_title() {
    const { title: title3 } = this.model;
    if (title3 instanceof HTML) {
      this.title = await build_view(title3, { parent: this });
    } else {
      this.title = title3;
    }
  }
  async _build_description() {
    const { description: description2 } = this.model;
    if (description2 instanceof Tooltip) {
      this.description = await build_view(description2, { parent: this });
    } else {
      this.description = description2;
    }
  }
  _build_title_el() {
    const { title: title3 } = this;
    const content2 = (() => {
      if (title3 instanceof HTMLView) {
        title3.render();
        return title3.el;
      } else {
        return title3;
      }
    })();
    const display2 = title3 == "" ? "none" : "";
    return label({ for: "input", style: { display: display2 } }, content2, this.desc_el);
  }
  change_input() {
  }
};
__publicField(InputWidgetView, "__name__", "InputWidgetView");
var _InputWidget = class _InputWidget extends Control {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_InputWidget, "__name__", "InputWidget");
_InputWidget.define(({ Str: Str2, Nullable: Nullable2, Or: Or2, Ref: Ref2 }) => ({
  title: [Or2(Str2, Ref2(HTML)), ""],
  description: [Nullable2(Or2(Str2, Ref2(Tooltip))), null]
}));
var InputWidget = _InputWidget;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/text_like_input.js
var TextLikeInputView = class extends InputWidgetView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.value.change, () => this.input_el.value = this.model.value);
    this.connect(this.model.properties.value_input.change, () => this.input_el.value = this.model.value_input);
    this.connect(this.model.properties.disabled.change, () => this.input_el.disabled = this.model.disabled);
    this.connect(this.model.properties.placeholder.change, () => this.input_el.placeholder = this.model.placeholder);
    this.connect(this.model.properties.max_length.change, () => {
      const { max_length } = this.model;
      if (max_length != null) {
        this.input_el.maxLength = max_length;
      } else {
        this.input_el.removeAttribute("maxLength");
      }
    });
  }
  render() {
    super.render();
    const { input_el } = this;
    input_el.value = this.model.value;
    input_el.disabled = this.model.disabled;
    input_el.placeholder = this.model.placeholder;
    if (this.model.max_length != null) {
      input_el.maxLength = this.model.max_length;
    }
    input_el.addEventListener("change", () => this.change_input());
    input_el.addEventListener("input", () => this.change_input_value());
  }
  change_input() {
    this.model.value = this.input_el.value;
    super.change_input();
  }
  change_input_value() {
    this.model.value_input = this.input_el.value;
    super.change_input();
  }
};
__publicField(TextLikeInputView, "__name__", "TextLikeInputView");
var _TextLikeInput = class _TextLikeInput extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TextLikeInput, "__name__", "TextLikeInput");
_TextLikeInput.define(({ Int: Int2, Str: Str2, Nullable: Nullable2 }) => ({
  value: [Str2, ""],
  value_input: [Str2, ""],
  placeholder: [Str2, ""],
  max_length: [Nullable2(Int2), null]
}));
var TextLikeInput = _TextLikeInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/text_input.js
import * as inputs2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var TextInputView = class extends TextLikeInputView {
  connect_signals() {
    super.connect_signals();
    const { prefix, suffix } = this.model.properties;
    this.on_change([prefix, suffix], () => this.render());
  }
  _render_input() {
    this.input_el = input({ type: "text", class: inputs2.input });
    const { prefix, suffix } = this.model;
    const prefix_el = prefix != null ? div({ class: "bk-input-prefix" }, prefix) : null;
    const suffix_el = suffix != null ? div({ class: "bk-input-suffix" }, suffix) : null;
    const container_el = div({ class: "bk-input-container" }, prefix_el, this.input_el, suffix_el);
    return container_el;
  }
  render() {
    super.render();
    this.input_el.addEventListener("keyup", (event2) => this._keyup(event2));
  }
  _keyup(event2) {
    if (event2.key == "Enter" && !event2.shiftKey && !event2.ctrlKey && !event2.altKey) {
      this.model.trigger_event(new ValueSubmit(this.input_el.value));
    }
  }
};
__publicField(TextInputView, "__name__", "TextInputView");
var _TextInput = class _TextInput extends TextLikeInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TextInput, "__name__", "TextInput");
_TextInput.prototype.default_view = TextInputView;
_TextInput.define(({ Str: Str2, Nullable: Nullable2 }) => ({
  prefix: [Nullable2(Str2), null],
  suffix: [Nullable2(Str2), null]
}));
var TextInput = _TextInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/autocomplete_input.js
import dropdown_css, * as dropdown from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/dropdown.css.js";
var SearchStrategy = Enum("starts_with", "includes");
var AutocompleteInputView = class extends TextInputView {
  constructor() {
    super(...arguments);
    __publicField(this, "_open", false);
    __publicField(this, "_last_value", "");
    __publicField(this, "_hover_index", 0);
    __publicField(this, "menu");
  }
  stylesheets() {
    return [...super.stylesheets(), dropdown_css];
  }
  render() {
    super.render();
    this.input_el.addEventListener("focusin", () => this._toggle_menu());
    this.menu = div({ class: [dropdown.menu, dropdown.below] });
    this.menu.addEventListener("click", (event2) => this._menu_click(event2));
    this.menu.addEventListener("mouseover", (event2) => this._menu_hover(event2));
    this.shadow_el.appendChild(this.menu);
    undisplay(this.menu);
  }
  change_input() {
    if (this._open && this.menu.children.length > 0) {
      this.model.value = this.menu.children[this._hover_index].textContent;
      this.input_el.focus();
      this._hide_menu();
    } else if (!this.model.restrict) {
      super.change_input();
    }
  }
  _update_completions(completions) {
    var _a34;
    empty2(this.menu);
    const { max_completions } = this.model;
    const selected_completions = max_completions != null ? take(completions, max_completions) : completions;
    for (const text2 of selected_completions) {
      const item3 = div(text2);
      this.menu.append(item3);
    }
    (_a34 = this.menu.firstElementChild) == null ? void 0 : _a34.classList.add(dropdown.active);
  }
  compute_completions(value2) {
    const norm_function = (() => {
      const { case_sensitive } = this.model;
      return case_sensitive ? (t) => t : (t) => t.toLowerCase();
    })();
    const search_function = (() => {
      switch (this.model.search_strategy) {
        case "starts_with":
          return (t, v) => t.startsWith(v);
        case "includes":
          return (t, v) => t.includes(v);
      }
    })();
    const normalized_value = norm_function(value2);
    const completions = [];
    for (const text2 of this.model.completions) {
      const normalized_text = norm_function(text2);
      if (search_function(normalized_text, normalized_value)) {
        completions.push(text2);
      }
    }
    return completions;
  }
  _toggle_menu() {
    const { value: value2 } = this.input_el;
    if (value2.length < this.model.min_characters) {
      this._hide_menu();
      return;
    }
    const completions = this.compute_completions(value2);
    this._update_completions(completions);
    if (completions.length == 0) {
      this._hide_menu();
    } else {
      this._show_menu();
    }
  }
  _show_menu() {
    if (!this._open) {
      this._open = true;
      this._hover_index = 0;
      this._last_value = this.model.value;
      display(this.menu);
      const listener = (event2) => {
        if (!event2.composedPath().includes(this.el)) {
          document.removeEventListener("click", listener);
          this._hide_menu();
        }
      };
      document.addEventListener("click", listener);
    }
  }
  _hide_menu() {
    if (this._open) {
      this._open = false;
      undisplay(this.menu);
    }
  }
  _menu_click(event2) {
    if (event2.target != event2.currentTarget && event2.target instanceof Element) {
      this.model.value = event2.target.textContent;
      this.input_el.focus();
      this._hide_menu();
    }
  }
  _menu_hover(event2) {
    if (event2.target != event2.currentTarget && event2.target instanceof Element) {
      for (let i2 = 0; i2 < this.menu.children.length; i2++) {
        if (this.menu.children[i2].textContent == event2.target.textContent) {
          this._bump_hover(i2);
          break;
        }
      }
    }
  }
  _bump_hover(new_index) {
    const n_children = this.menu.children.length;
    if (this._open && n_children > 0) {
      this.menu.children[this._hover_index].classList.remove(dropdown.active);
      this._hover_index = clamp(new_index, 0, n_children - 1);
      this.menu.children[this._hover_index].classList.add(dropdown.active);
    }
  }
  _keyup(event2) {
    super._keyup(event2);
    switch (event2.key) {
      case "Enter": {
        this.change_input();
        break;
      }
      case "Escape": {
        this._hide_menu();
        break;
      }
      case "ArrowUp": {
        this._bump_hover(this._hover_index - 1);
        break;
      }
      case "ArrowDown": {
        this._bump_hover(this._hover_index + 1);
        break;
      }
      default:
        this._toggle_menu();
    }
  }
};
__publicField(AutocompleteInputView, "__name__", "AutocompleteInputView");
var _AutocompleteInput = class _AutocompleteInput extends TextInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_AutocompleteInput, "__name__", "AutocompleteInput");
_AutocompleteInput.prototype.default_view = AutocompleteInputView;
_AutocompleteInput.define(({ Bool: Bool2, Int: Int2, Str: Str2, List: List2, NonNegative: NonNegative2, Positive, Nullable: Nullable2 }) => ({
  completions: [List2(Str2), []],
  min_characters: [NonNegative2(Int2), 2],
  max_completions: [Nullable2(Positive(Int2)), null],
  case_sensitive: [Bool2, true],
  restrict: [Bool2, true],
  search_strategy: [SearchStrategy, "starts_with"]
}));
var AutocompleteInput = _AutocompleteInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/button.js
var ButtonView = class extends AbstractButtonView {
  click() {
    this.model.trigger_event(new ButtonClick());
    super.click();
  }
};
__publicField(ButtonView, "__name__", "ButtonView");
var _Button = class _Button extends AbstractButton {
  constructor(attrs) {
    super(attrs);
  }
  on_click(callback) {
    this.on_event(ButtonClick, callback);
  }
};
__publicField(_Button, "__name__", "Button");
_Button.prototype.default_view = ButtonView;
_Button.override({
  label: "Button"
});
var Button = _Button;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/oriented_control.js
var OrientedControlView = class extends ControlView {
};
__publicField(OrientedControlView, "__name__", "OrientedControlView");
var _OrientedControl = class _OrientedControl extends Control {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_OrientedControl, "__name__", "OrientedControl");
_OrientedControl.define(() => ({
  orientation: [Orientation, "horizontal"]
}));
var OrientedControl = _OrientedControl;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/toggle_button_group.js
import buttons_css2, * as buttons2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var ToggleButtonGroupView = class extends OrientedControlView {
  constructor() {
    super(...arguments);
    __publicField(this, "_buttons");
  }
  *controls() {
    yield* this._buttons;
  }
  connect_signals() {
    super.connect_signals();
    const p2 = this.model.properties;
    this.on_change(p2.button_type, () => this.render());
    this.on_change(p2.labels, () => this.render());
    this.on_change(p2.active, () => this._update_active());
  }
  stylesheets() {
    return [...super.stylesheets(), buttons_css2];
  }
  render() {
    super.render();
    this._buttons = this.model.labels.map((label3, i2) => {
      const button_el = button({
        class: [buttons2.btn, buttons2[`btn_${this.model.button_type}`]],
        disabled: this.model.disabled
      }, label3);
      button_el.addEventListener("click", () => {
        this.change_active(i2);
        this.model.trigger_event(new ButtonClick());
      });
      return button_el;
    });
    this._update_active();
    const orient = this.model.orientation == "horizontal" ? buttons2.horizontal : buttons2.vertical;
    const group = div({ class: [buttons2.btn_group, orient] }, this._buttons);
    this.shadow_el.appendChild(group);
  }
};
__publicField(ToggleButtonGroupView, "__name__", "ToggleButtonGroupView");
var _ToggleButtonGroup = class _ToggleButtonGroup extends OrientedControl {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToggleButtonGroup, "__name__", "ToggleButtonGroup");
_ToggleButtonGroup.define(({ Str: Str2, List: List2 }) => ({
  labels: [List2(Str2), []],
  button_type: [ButtonType, "default"]
}));
var ToggleButtonGroup = _ToggleButtonGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/checkbox_button_group.js
import * as buttons3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var CheckboxButtonGroupView = class extends ToggleButtonGroupView {
  get active() {
    return new Set(this.model.active);
  }
  change_active(i2) {
    const { active: active8 } = this;
    active8.has(i2) ? active8.delete(i2) : active8.add(i2);
    this.model.active = [...active8].sort();
  }
  _update_active() {
    const { active: active8 } = this;
    this._buttons.forEach((button_el, i2) => {
      button_el.classList.toggle(buttons3.active, active8.has(i2));
    });
  }
};
__publicField(CheckboxButtonGroupView, "__name__", "CheckboxButtonGroupView");
var _CheckboxButtonGroup = class _CheckboxButtonGroup extends ToggleButtonGroup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CheckboxButtonGroup, "__name__", "CheckboxButtonGroup");
_CheckboxButtonGroup.prototype.default_view = CheckboxButtonGroupView;
_CheckboxButtonGroup.define(({ Int: Int2, List: List2 }) => ({
  active: [List2(Int2), []]
}));
var CheckboxButtonGroup = _CheckboxButtonGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/toggle_input_group.js
import inputs_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
import checkbox_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/checkbox.css.js";
var ToggleInputGroupView = class extends ControlView {
  constructor() {
    super(...arguments);
    __publicField(this, "_inputs");
  }
  *controls() {
    yield* this._inputs;
  }
  connect_signals() {
    super.connect_signals();
    const { labels, inline: inline3 } = this.model.properties;
    this.on_change([labels, inline3], () => this.render());
  }
  stylesheets() {
    return [...super.stylesheets(), inputs_css2, checkbox_css];
  }
};
__publicField(ToggleInputGroupView, "__name__", "ToggleInputGroupView");
var _ToggleInputGroup = class _ToggleInputGroup extends Control {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToggleInputGroup, "__name__", "ToggleInputGroup");
_ToggleInputGroup.define(({ Bool: Bool2, Str: Str2, List: List2 }) => ({
  labels: [List2(Str2), []],
  inline: [Bool2, false]
}));
var ToggleInputGroup = _ToggleInputGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/checkbox_group.js
import * as inputs3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var CheckboxGroupView = class extends ToggleInputGroupView {
  get active() {
    return new Set(this.model.active);
  }
  connect_signals() {
    super.connect_signals();
    const { active: active8 } = this.model.properties;
    this.on_change(active8, () => {
      const { active: active9 } = this;
      for (const [input_el, i2] of enumerate(this._inputs)) {
        input_el.checked = active9.has(i2);
      }
    });
  }
  render() {
    super.render();
    const group = div({ class: [inputs3.input_group, this.model.inline ? inputs3.inline : null] });
    this.shadow_el.appendChild(group);
    const { active: active8, labels } = this.model;
    this._inputs = [];
    for (let i2 = 0; i2 < labels.length; i2++) {
      const checkbox = input({ type: "checkbox", value: `${i2}` });
      checkbox.addEventListener("change", () => this.change_active(i2));
      this._inputs.push(checkbox);
      if (this.model.disabled) {
        checkbox.disabled = true;
      }
      if (includes(active8, i2)) {
        checkbox.checked = true;
      }
      const label_el = label(checkbox, span(labels[i2]));
      group.appendChild(label_el);
    }
  }
  change_active(i2) {
    const { active: active8 } = this;
    active8.has(i2) ? active8.delete(i2) : active8.add(i2);
    this.model.active = [...active8].sort();
  }
};
__publicField(CheckboxGroupView, "__name__", "CheckboxGroupView");
var _CheckboxGroup = class _CheckboxGroup extends ToggleInputGroup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CheckboxGroup, "__name__", "CheckboxGroup");
_CheckboxGroup.prototype.default_view = CheckboxGroupView;
_CheckboxGroup.define(({ Int: Int2, List: List2 }) => ({
  active: [List2(Int2), []]
}));
var CheckboxGroup = _CheckboxGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/toggle_input.js
var ToggleInputView = class extends WidgetView {
  connect_signals() {
    super.connect_signals();
    const { active: active8, disabled: disabled5 } = this.model.properties;
    this.on_change(active8, () => this._update_active());
    this.on_change(disabled5, () => this._update_disabled());
  }
  _toggle_active() {
    if (!this.model.disabled) {
      this.model.active = !this.model.active;
    }
  }
};
__publicField(ToggleInputView, "__name__", "ToggleInputView");
var _ToggleInput = class _ToggleInput extends Widget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ToggleInput, "__name__", "ToggleInput");
_ToggleInput.define(({ Bool: Bool2 }) => ({
  active: [Bool2, false]
}));
var ToggleInput = _ToggleInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/checkbox.js
import checkbox_css2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/checkbox.css.js";
var CheckboxView = class extends ToggleInputView {
  constructor() {
    super(...arguments);
    __publicField(this, "checkbox_el");
    __publicField(this, "label_el");
  }
  stylesheets() {
    return [...super.stylesheets(), checkbox_css2];
  }
  connect_signals() {
    super.connect_signals();
    const { label: label3 } = this.model.properties;
    this.on_change(label3, () => this._update_label());
  }
  render() {
    super.render();
    this.checkbox_el = input({ type: "checkbox" });
    this.label_el = span(this.model.label);
    this.checkbox_el.addEventListener("change", () => this._toggle_active());
    this._update_active();
    this._update_disabled();
    this.shadow_el.append(this.checkbox_el, this.label_el);
  }
  _update_active() {
    this.checkbox_el.checked = this.model.active;
  }
  _update_disabled() {
    this.checkbox_el.toggleAttribute("disabled", this.model.disabled);
  }
  _update_label() {
    this.label_el.textContent = this.model.label;
  }
};
__publicField(CheckboxView, "__name__", "CheckboxView");
var _Checkbox = class _Checkbox extends ToggleInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Checkbox, "__name__", "Checkbox");
_Checkbox.prototype.default_view = CheckboxView;
_Checkbox.define(({ Str: Str2 }) => ({
  label: [Str2, ""]
}));
var Checkbox = _Checkbox;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/color_picker.js
import * as inputs4 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var ColorPickerView = class extends InputWidgetView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.name.change, () => this.input_el.name = this.model.name ?? "");
    this.connect(this.model.properties.color.change, () => this.input_el.value = color2hexrgb(this.model.color));
    this.connect(this.model.properties.disabled.change, () => this.input_el.disabled = this.model.disabled);
  }
  _render_input() {
    return this.input_el = input({
      type: "color",
      class: inputs4.input,
      name: this.model.name,
      value: color2hexrgb(this.model.color),
      disabled: this.model.disabled
    });
  }
  render() {
    super.render();
    this.input_el.addEventListener("change", () => this.change_input());
  }
  change_input() {
    this.model.color = this.input_el.value;
    super.change_input();
  }
};
__publicField(ColorPickerView, "__name__", "ColorPickerView");
var _ColorPicker = class _ColorPicker extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_ColorPicker, "__name__", "ColorPicker");
_ColorPicker.prototype.default_view = ColorPickerView;
_ColorPicker.define(({ Color: Color2 }) => ({
  color: [Color2, "#000000"]
}));
var ColorPicker = _ColorPicker;

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults2 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth2) {
    var s2 = nth2 % 100;
    if (s2 > 3 && s2 < 21)
      return "th";
    switch (s2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number2, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number2).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content2) {
  var e = window.document.createElement(tag);
  className = className || "";
  content2 = content2 || "";
  e.className = className;
  if (content2 !== void 0)
    e.textContent = content2;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event2) {
  try {
    if (typeof event2.composedPath === "function") {
      var path = event2.composedPath();
      return path[0];
    }
    return event2.target;
  } catch (error) {
    return event2.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_2, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_2, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_2, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options2) {
    return locale.weekdays.shorthand[formats.w(date, locale, options2)];
  },
  F: function(date, locale, options2) {
    return monthToStr(formats.n(date, locale, options2) - 1, false, locale);
  },
  G: function(date, locale, options2) {
    return pad(formats.h(date, locale, options2));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _2, options2) {
    return options2.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a34) {
  var _b4 = _a34.config, config = _b4 === void 0 ? defaults2 : _b4, _c = _a34.l10n, l10n = _c === void 0 ? english : _c, _d = _a34.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i2, arr) {
      return formats[c] && arr[i2 - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a34) {
  var _b4 = _a34.config, config = _b4 === void 0 ? defaults2 : _b4, _c = _a34.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format7 = givenFormat || (config || defaults2).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format7);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i2 = 0, matchIndex = 0, regexStr = ""; i2 < format7.length; i2++) {
          var token2 = format7[i2];
          var isBackSlash = token2 === "\\";
          var escaped = format7[i2 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token2] && !escaped) {
            regexStr += tokenRegex[token2];
            var match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token2 !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token2],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a35) {
          var fn = _a35.fn, val = _a35.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source3) {
      if (source3) {
        Object.keys(source3).forEach(function(key) {
          return target[key] = source3[key];
        });
      }
    };
    for (var _a34 = 0, args_1 = args; _a34 < args_1.length; _a34++) {
      var source2 = args_1[_a34];
      _loop_1(source2);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
      r[k] = a2[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults2), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear2;
  self2.close = close4;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy2;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open2;
  self2.redraw = redraw;
  self2.set = set;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init4() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a34;
    return ((_a34 = self2.calendarContainer) === null || _a34 === void 0 ? void 0 : _a34.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults3 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event2) {
    var eventTarget = getEventTarget(event2);
    var year = parseInt(eventTarget.value) + (event2.delta || 0);
    if (year / 1e3 > 1 || event2.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event2, handler, options2) {
    if (event2 instanceof Array)
      return event2.forEach(function(ev) {
        return bind(element2, ev, handler, options2);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event2, handler, options2);
      });
    element2.addEventListener(event2, handler, options2);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event2, handler, options2);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", function(e) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e) {
        return getEventTarget(e).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e) {
          updateTime(e);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input12 = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event2 = createEvent("increment");
    event2.delta = delta;
    input12 && input12.dispatchEvent(event2);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a34 = buildWeeks(), weekWrapper = _a34.weekWrapper, weekNumbers = _a34.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i2) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i2;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i2 % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i2 = startIndex; i2 != endIndex; i2 += delta) {
        var c = month.children[i2];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
        var c = month.children[i2];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset3) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset3 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset3);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i2 = 0; i2 < self2.config.showMonths; i2++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i2);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i2 = 0; i2 < 12; i2++) {
      if (!shouldBuildMonth(i2))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i2).getMonth().toString();
      month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i2) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container2 = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container2.appendChild(monthNavFragment);
    return {
      container: container2,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults3 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i2 = self2.config.showMonths; i2--; ) {
      var container2 = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container2);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i2 = self2.config.showMonths; i2--; ) {
      self2.weekdayContainer.children[i2].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value2, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value2 : value2 - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear2(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a34 = getDefaultHours(self2.config), hours = _a34.hours, minutes = _a34.minutes, seconds = _a34.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close4() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy2() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i2 = self2._handlers.length; i2--; ) {
      self2._handlers[i2].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_2) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a34;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array2 = (_a34 = self2.config.enable) !== null && _a34 !== void 0 ? _a34 : self2.config.disable;
    for (var i2 = 0, d = void 0; i2 < array2.length; i2++) {
      d = array2[i2];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x2) {
              return x2;
            });
            var i2 = elems.indexOf(eventTarget);
            if (i2 !== -1) {
              var target = elems[i2 + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange))
          minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange))
          maxRange = t;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open2(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults2.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults2.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i2 = 0; i2 < boolOpts.length; i2++)
      self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i2 = 0; i2 < self2.config.plugins.length; i2++) {
      var pluginConf = self2.config.plugins[i2](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left2 = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left2 -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left2 -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self2.calendarContainer, "arrowRight", isRight);
    var right3 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right3 + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left2 + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right3 + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self2.calendarContainer, "rightMost", false);
      toggleClass(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      var sheet = document.styleSheets[i2];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style2 = document.createElement("style");
    document.head.appendChild(style2);
    return style2.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0)
      return;
    var target = t;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a2, b2) {
          return a2.getTime() - b2.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set(option2, value2) {
    if (option2 !== null && typeof option2 === "object") {
      Object.assign(self2.config, option2);
      for (var key in option2) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x2) {
            return x2();
          });
      }
    } else {
      self2.config[option2] = value2;
      if (CALLBACKS[option2] !== void 0)
        CALLBACKS[option2].forEach(function(x2) {
          return x2();
        });
      else if (HOOKS.indexOf(option2) > -1)
        self2.config[option2] = arrayify(value2);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format7) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self2.parseDate(d, format7);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format7)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format7)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format7);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format7);
          });
          break;
        default:
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a2, b2) {
        return a2.getTime() - b2.getTime();
      });
  }
  function setDate(date, triggerChange2, format7) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format7 === void 0) {
      format7 = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date, format7);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x2) {
      return x2;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a34) {
    }
    bind(self2.mobileInput, "change", function(e) {
      self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e);
  }
  function triggerEvent(event2, data3) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event2];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i2 = 0; hooks[i2] && i2 < hooks.length; i2++)
        hooks[i2](self2.selectedDates, self2.input.value, self2, data3);
    }
    if (event2 === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i2 = 0; i2 < self2.selectedDates.length; i2++) {
      var selectedDate = self2.selectedDates[i2];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i2;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i2) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i2);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i2].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format7 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format7);
    }).filter(function(d, i2, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i2;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input12 = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min10 = parseFloat(input12.getAttribute("min")), max18 = parseFloat(input12.getAttribute("max")), step = parseFloat(input12.getAttribute("step")), curValue = parseInt(input12.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input12.value !== "undefined" && input12.value.length === 2) {
      var isHourElem = input12 === self2.hourElement, isMinuteElem = input12 === self2.minuteElement;
      if (newValue < min10) {
        newValue = max18 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max18) {
        newValue = input12 === self2.hourElement ? newValue - max18 - int(!self2.amPM) : min10;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input12.value = pad(newValue);
    }
  }
  init4();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x2) {
    return x2 instanceof HTMLElement;
  });
  var instances = [];
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/picker_base.js
import flatpickr_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/flatpickr.css.js";
import * as inputs5 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var PickerBaseView = class extends InputWidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "_picker");
  }
  get picker() {
    assert(this._picker != null);
    return this._picker;
  }
  *controls() {
    yield this.picker.altInput ?? this.input_el;
  }
  remove() {
    var _a34;
    (_a34 = this._picker) == null ? void 0 : _a34.destroy();
    super.remove();
  }
  stylesheets() {
    return [...super.stylesheets(), flatpickr_css];
  }
  connect_signals() {
    super.connect_signals();
    const { inline: inline3 } = this.model.properties;
    this.connect(inline3.change, () => this.picker.set("inline", this.model.inline));
  }
  get flatpickr_options() {
    return {
      appendTo: this.group_el,
      inline: this.model.inline,
      position: this._position.bind(this),
      onChange: (selected) => {
        this._on_change(selected);
        this.change_input();
      }
    };
  }
  _render_input() {
    return this.input_el = input({ type: "text", class: inputs5.input, disabled: this.model.disabled });
  }
  render() {
    var _a34;
    super.render();
    (_a34 = this._picker) == null ? void 0 : _a34.destroy();
    const options2 = this.flatpickr_options;
    this._picker = esm_default(this.input_el, options2);
  }
  // https://github.com/flatpickr/flatpickr/pull/2362
  _position(self2, custom_el) {
    const positionElement = custom_el ?? self2._positionElement;
    const calendarHeight = [...self2.calendarContainer.children].reduce((acc, child) => acc + bounding_box(child).height, 0);
    const calendarWidth = self2.calendarContainer.offsetWidth;
    const configPos = this.model.position.split(" ");
    const configPosVertical = configPos[0];
    const configPosHorizontal = configPos.length > 1 ? configPos[1] : null;
    const inputBounds = {
      top: positionElement.offsetTop,
      bottom: positionElement.offsetTop + positionElement.offsetHeight,
      left: positionElement.offsetLeft,
      right: positionElement.offsetLeft + positionElement.offsetWidth,
      width: positionElement.offsetWidth
    };
    const distanceFromBottom = window.innerHeight - inputBounds.bottom;
    const showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    const top = self2.config.appendTo != null ? inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2) : window.scrollY + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    self2.calendarContainer.classList.toggle("arrowTop", !showOnTop);
    self2.calendarContainer.classList.toggle("arrowBottom", showOnTop);
    if (self2.config.inline) {
      return;
    }
    let left2 = window.scrollX + inputBounds.left;
    let isCenter = false;
    let isRight = false;
    if (configPosHorizontal === "center") {
      left2 -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left2 -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    self2.calendarContainer.classList.toggle("arrowLeft", !isCenter && !isRight);
    self2.calendarContainer.classList.toggle("arrowCenter", isCenter);
    self2.calendarContainer.classList.toggle("arrowRight", isRight);
    const right3 = window.document.body.offsetWidth - (window.scrollX + inputBounds.right);
    const rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
    const centerMost = right3 + calendarWidth > window.document.body.offsetWidth;
    self2.calendarContainer.classList.toggle("rightMost", rightMost);
    if (self2.config.static) {
      return;
    }
    self2.calendarContainer.style.top = `${top}px`;
    if (!rightMost) {
      self2.calendarContainer.style.left = `${left2}px`;
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = `${right3}px`;
    } else {
      const css = this.shadow_el.styleSheets[0];
      const bodyWidth = window.document.body.offsetWidth;
      const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      const centerBefore = ".flatpickr-calendar.centerMost:before";
      const centerAfter = ".flatpickr-calendar.centerMost:after";
      const centerIndex = css.cssRules.length;
      const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
      self2.calendarContainer.classList.toggle("rightMost", false);
      self2.calendarContainer.classList.toggle("centerMost", true);
      css.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
      self2.calendarContainer.style.left = `${centerLeft}px`;
      self2.calendarContainer.style.right = "auto";
    }
  }
};
__publicField(PickerBaseView, "__name__", "PickerBaseView");
var _PickerBase = class _PickerBase extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PickerBase, "__name__", "PickerBase");
_PickerBase.define(({ Bool: Bool2 }) => {
  return {
    position: [CalendarPosition, "auto"],
    inline: [Bool2, false]
  };
});
var PickerBase = _PickerBase;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/base_date_picker.js
var DateLike = Or(Ref(Date), Str, Float);
var DateLikeList = List(Or(DateLike, Tuple(DateLike, DateLike), Struct({ from: DateLike, to: DateLike })));
var BaseDatePickerView = class extends PickerBaseView {
  _format_date(date) {
    const { picker } = this;
    return picker.formatDate(date, picker.config.dateFormat);
  }
  connect_signals() {
    super.connect_signals();
    const { value: value2, min_date, max_date, disabled_dates, enabled_dates, date_format } = this.model.properties;
    this.connect(value2.change, () => {
      const { value: value3 } = this.model;
      if (value3 != null) {
        this.picker.setDate(value3);
      } else {
        this.picker.clear();
      }
    });
    this.connect(min_date.change, () => this.picker.set("minDate", this.model.min_date));
    this.connect(max_date.change, () => this.picker.set("maxDate", this.model.max_date));
    this.connect(disabled_dates.change, () => {
      const { disabled_dates: disabled_dates2 } = this.model;
      this.picker.set("disable", disabled_dates2 != null ? this._convert_date_list(disabled_dates2) : []);
    });
    this.connect(enabled_dates.change, () => {
      const { enabled_dates: enabled_dates2 } = this.model;
      if (enabled_dates2 != null) {
        this.picker.set("enable", this._convert_date_list(enabled_dates2));
      } else {
        this.picker.config._enable = void 0;
        this.picker.redraw();
        this.picker.updateValue(true);
      }
    });
    this.connect(date_format.change, () => this.picker.set("altFormat", this.model.date_format));
  }
  get flatpickr_options() {
    const { value: value2, min_date, max_date, disabled_dates, enabled_dates, date_format } = this.model;
    const options2 = super.flatpickr_options;
    options2.altInput = true;
    options2.altFormat = date_format;
    options2.dateFormat = "Y-m-d";
    if (value2 != null) {
      options2.defaultDate = value2;
    }
    if (min_date != null) {
      options2.minDate = min_date;
    }
    if (max_date != null) {
      options2.maxDate = max_date;
    }
    if (disabled_dates != null) {
      options2.disable = this._convert_date_list(disabled_dates);
    }
    if (enabled_dates != null) {
      options2.enable = this._convert_date_list(enabled_dates);
    }
    return options2;
  }
  _convert_date_list(value2) {
    const result = [];
    for (const item3 of value2) {
      if (isArray(item3)) {
        const [from, to] = item3;
        result.push({ from, to });
      } else {
        result.push(item3);
      }
    }
    return result;
  }
};
__publicField(BaseDatePickerView, "__name__", "BaseDatePickerView");
var _BaseDatePicker = class _BaseDatePicker extends PickerBase {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BaseDatePicker, "__name__", "BaseDatePicker");
_BaseDatePicker.define(({ Nullable: Nullable2 }) => ({
  min_date: [Nullable2(DateLike), null],
  max_date: [Nullable2(DateLike), null],
  disabled_dates: [Nullable2(DateLikeList), null],
  enabled_dates: [Nullable2(DateLikeList), null],
  date_format: [Str, "Y-m-d"]
}));
var BaseDatePicker = _BaseDatePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/date_picker.js
var DatePickerView = class extends BaseDatePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "single"
    };
  }
  _on_change(selected) {
    assert(selected.length <= 1);
    this.model.value = (() => {
      if (selected.length == 0) {
        return null;
      } else {
        const [datetime] = selected;
        const date = this._format_date(datetime);
        return date;
      }
    })();
  }
};
__publicField(DatePickerView, "__name__", "DatePickerView");
var _DatePicker = class _DatePicker extends BaseDatePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatePicker, "__name__", "DatePicker");
_DatePicker.prototype.default_view = DatePickerView;
_DatePicker.define(({ Nullable: Nullable2 }) => ({
  value: [Nullable2(DateLike), null]
}));
var DatePicker = _DatePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/date_range_picker.js
var DateRangePickerView = class extends BaseDatePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "range"
    };
  }
  _on_change(selected) {
    switch (selected.length) {
      case 0:
        this.model.value = null;
        break;
      case 1: {
        break;
      }
      case 2: {
        const [from, to] = selected;
        const from_date = this._format_date(from);
        const to_date = this._format_date(to);
        this.model.value = [from_date, to_date];
        break;
      }
      default: {
        assert(false, "invalid length");
      }
    }
  }
};
__publicField(DateRangePickerView, "__name__", "DateRangePickerView");
var _DateRangePicker = class _DateRangePicker extends BaseDatePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DateRangePicker, "__name__", "DateRangePicker");
_DateRangePicker.prototype.default_view = DateRangePickerView;
_DateRangePicker.define(({ Tuple: Tuple2, Nullable: Nullable2 }) => ({
  value: [Nullable2(Tuple2(DateLike, DateLike)), null]
}));
var DateRangePicker = _DateRangePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/base_datetime_picker.js
var BaseDatetimePickerView = class extends BaseDatePickerView {
  connect_signals() {
    super.connect_signals();
    const { value: value2, hour_increment, minute_increment, second_increment, seconds, clock } = this.model.properties;
    this.connect(value2.change, () => {
      const { value: value3 } = this.model;
      if (value3 != null) {
        this.picker.setDate(value3);
      } else {
        this.picker.clear();
      }
    });
    this.connect(hour_increment.change, () => this.picker.set("hourIncrement", this.model.hour_increment));
    this.connect(minute_increment.change, () => this.picker.set("minuteIncrement", this.model.minute_increment));
    this.connect(second_increment.change, () => this._update_second_increment());
    this.connect(seconds.change, () => this.picker.set("enableSeconds", this.model.seconds));
    this.connect(clock.change, () => this.picker.set("time_24hr", this.model.clock == "24h"));
  }
  get flatpickr_options() {
    const { hour_increment, minute_increment, seconds, clock } = this.model;
    const options2 = super.flatpickr_options;
    options2.enableTime = true;
    options2.dateFormat = "Y-m-dTH:i:S";
    options2.hourIncrement = hour_increment;
    options2.minuteIncrement = minute_increment;
    options2.enableSeconds = seconds;
    options2.time_24hr = clock == "24h";
    return options2;
  }
  render() {
    super.render();
    this._update_second_increment();
  }
  _update_second_increment() {
    var _a34;
    const { second_increment } = this.model;
    (_a34 = this.picker.secondElement) == null ? void 0 : _a34.setAttribute("step", second_increment.toString());
  }
};
__publicField(BaseDatetimePickerView, "__name__", "BaseDatetimePickerView");
var _BaseDatetimePicker = class _BaseDatetimePicker extends BaseDatePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BaseDatetimePicker, "__name__", "BaseDatetimePicker");
_BaseDatetimePicker.define(({ Bool: Bool2, Positive, Int: Int2 }) => ({
  hour_increment: [Positive(Int2), 1],
  minute_increment: [Positive(Int2), 1],
  second_increment: [Positive(Int2), 1],
  seconds: [Bool2, false],
  clock: [Clock, "24h"]
}));
_BaseDatetimePicker.override({
  date_format: "Y-m-d H:i"
});
var BaseDatetimePicker = _BaseDatetimePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/datetime_picker.js
var DatetimePickerView = class extends BaseDatetimePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "single"
    };
  }
  _on_change(selected) {
    assert(selected.length <= 1);
    this.model.value = (() => {
      if (selected.length == 0) {
        return null;
      } else {
        const [datetime] = selected;
        return this._format_date(datetime);
      }
    })();
  }
};
__publicField(DatetimePickerView, "__name__", "DatetimePickerView");
var _DatetimePicker = class _DatetimePicker extends BaseDatetimePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatetimePicker, "__name__", "DatetimePicker");
_DatetimePicker.prototype.default_view = DatetimePickerView;
_DatetimePicker.define(({ Nullable: Nullable2 }) => ({
  value: [Nullable2(DateLike), null]
}));
var DatetimePicker = _DatetimePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/datetime_range_picker.js
var DatetimeRangePickerView = class extends BaseDatetimePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "range"
    };
  }
  _on_change(selected) {
    switch (selected.length) {
      case 0:
        this.model.value = null;
        break;
      case 1: {
        break;
      }
      case 2: {
        const [from, to] = selected;
        const from_date = this._format_date(from);
        const to_date = this._format_date(to);
        this.model.value = [from_date, to_date];
        break;
      }
      default: {
        assert(false, "invalid length");
      }
    }
  }
};
__publicField(DatetimeRangePickerView, "__name__", "DatetimeRangePickerView");
var _DatetimeRangePicker = class _DatetimeRangePicker extends BaseDatetimePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatetimeRangePicker, "__name__", "DatetimeRangePicker");
_DatetimeRangePicker.prototype.default_view = DatetimeRangePickerView;
_DatetimeRangePicker.define(({ Nullable: Nullable2, Tuple: Tuple2 }) => ({
  value: [Nullable2(Tuple2(DateLike, DateLike)), null]
}));
var DatetimeRangePicker = _DatetimeRangePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/markup.js
import clearfix_css, { clearfix } from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/clearfix.css.js";
var MarkupView = class extends WidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "markup_el");
    __publicField(this, "_auto_width", "fit-content");
    __publicField(this, "_auto_height", "auto");
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    if (this.provider.status == "not_started" || this.provider.status == "loading") {
      this.provider.ready.connect(() => {
        if (this.contains_tex_string(this.model.text)) {
          this.rerender();
        }
      });
    }
  }
  has_math_disabled() {
    return this.model.disable_math || !this.contains_tex_string(this.model.text);
  }
  rerender() {
    this.render();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => {
      this.rerender();
    });
  }
  stylesheets() {
    return [...super.stylesheets(), clearfix_css, "p { margin: 0; }"];
  }
  render() {
    super.render();
    this.markup_el = div({ class: clearfix, style: { display: "inline-block" } });
    this.shadow_el.appendChild(this.markup_el);
    if (this.provider.status == "failed" || this.provider.status == "loaded") {
      this._has_finished = true;
    }
  }
};
__publicField(MarkupView, "__name__", "MarkupView");
var _Markup = class _Markup extends Widget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Markup, "__name__", "Markup");
_Markup.define(({ Bool: Bool2, Str: Str2 }) => ({
  text: [Str2, ""],
  disable_math: [Bool2, false]
}));
var Markup = _Markup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/div.js
var DivView2 = class extends MarkupView {
  render() {
    super.render();
    if (this.model.render_as_text) {
      this.markup_el.textContent = this.model.text;
    } else {
      this.markup_el.innerHTML = this.has_math_disabled() ? this.model.text : this.process_tex(this.model.text);
    }
  }
};
__publicField(DivView2, "__name__", "DivView");
var _Div2 = class _Div2 extends Markup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Div2, "__name__", "Div");
_Div2.prototype.default_view = DivView2;
_Div2.define(({ Bool: Bool2 }) => ({
  render_as_text: [Bool2, false]
}));
var Div2 = _Div2;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/dropdown.js
import * as buttons4 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
import dropdown_css2, * as dropdown2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/dropdown.css.js";
import carets_css, * as carets from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/caret.css.js";
var DropdownView = class extends AbstractButtonView {
  constructor() {
    super(...arguments);
    __publicField(this, "_open", false);
    __publicField(this, "menu_el");
  }
  stylesheets() {
    return [...super.stylesheets(), dropdown_css2, carets_css];
  }
  connect_signals() {
    super.connect_signals();
    const { menu: menu5 } = this.model.properties;
    this.on_change(menu5, () => this.rebuild_menu());
  }
  render() {
    super.render();
    const caret2 = div({ class: [carets.caret, carets.down] });
    if (!this.model.is_split) {
      this.button_el.append(caret2);
    } else {
      const toggle = this._render_button(caret2);
      toggle.classList.add(buttons4.dropdown_toggle);
      toggle.addEventListener("click", () => this._toggle_menu());
      this.group_el.append(toggle);
    }
    this.menu_el = div({ class: [dropdown2.menu, dropdown2.below] });
    this.shadow_el.append(this.menu_el);
    this.rebuild_menu();
    undisplay(this.menu_el);
  }
  _show_menu() {
    if (!this._open) {
      this._open = true;
      display(this.menu_el);
      const listener = (event2) => {
        if (!event2.composedPath().includes(this.el)) {
          document.removeEventListener("click", listener);
          this._hide_menu();
        }
      };
      document.addEventListener("click", listener);
    }
  }
  _hide_menu() {
    if (this._open) {
      this._open = false;
      undisplay(this.menu_el);
    }
  }
  _toggle_menu() {
    if (this._open) {
      this._hide_menu();
    } else {
      this._show_menu();
    }
  }
  click() {
    if (!this.model.is_split) {
      this._toggle_menu();
    } else {
      this._hide_menu();
      this.model.trigger_event(new ButtonClick());
      super.click();
    }
  }
  _item_click(i2) {
    this._hide_menu();
    const item3 = this.model.menu[i2];
    if (item3 != null) {
      const value_or_callback = isString(item3) ? item3 : item3[1];
      if (isString(value_or_callback)) {
        this.model.trigger_event(new MenuItemClick(value_or_callback));
      } else {
        void execute(value_or_callback, this.model, { index: i2 });
      }
    }
  }
  rebuild_menu() {
    empty2(this.menu_el);
    const items = this.model.menu.map((item3, i2) => {
      if (item3 == null) {
        return div({ class: dropdown2.divider });
      } else {
        const label3 = isString(item3) ? item3 : item3[0];
        const el = div(label3);
        el.addEventListener("click", () => this._item_click(i2));
        return el;
      }
    });
    this.menu_el.append(...items);
  }
};
__publicField(DropdownView, "__name__", "DropdownView");
var _Dropdown = class _Dropdown extends AbstractButton {
  constructor(attrs) {
    super(attrs);
  }
  get is_split() {
    return this.split;
  }
};
__publicField(_Dropdown, "__name__", "Dropdown");
_Dropdown.prototype.default_view = DropdownView;
_Dropdown.define(({ Null: Null2, Bool: Bool2, Str: Str2, List: List2, Tuple: Tuple2, Or: Or2 }) => ({
  split: [Bool2, false],
  menu: [List2(Or2(Str2, Tuple2(Str2, Or2(
    Str2
    /*TODO*/
  )), Null2)), []]
}));
_Dropdown.override({
  label: "Dropdown"
});
var Dropdown = _Dropdown;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/file_input.js
import * as inputs6 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
import buttons_css3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var FileInputView = class extends InputWidgetView {
  connect_signals() {
    super.connect_signals();
    this.model.on_event(ClearInput, () => {
      this.model.setv({
        value: "",
        // p.unset,
        mime_type: "",
        // p.unset,
        filename: ""
        // p.unset,
      });
      this.input_el.value = "";
    });
  }
  stylesheets() {
    return [...super.stylesheets(), buttons_css3];
  }
  _render_input() {
    const { multiple, disabled: disabled5, directory } = this.model;
    const accept = (() => {
      const { accept: accept2 } = this.model;
      return isString(accept2) ? accept2 : accept2.join(",");
    })();
    return this.input_el = input({ type: "file", class: inputs6.input, multiple, accept, disabled: disabled5, webkitdirectory: directory });
  }
  render() {
    super.render();
    this.input_el.addEventListener("change", async () => {
      const { files } = this.input_el;
      if (files != null) {
        await this.load_files(files);
      }
    });
  }
  async load_files(files) {
    const values2 = [];
    const filenames = [];
    const mime_types = [];
    const { directory, multiple } = this.model;
    const accept = (() => {
      const { accept: accept2 } = this.model;
      return isString(accept2) ? accept2 : accept2.join(",");
    })();
    for (const file of files) {
      const data_url = await this._read_file(file);
      const [, mime_type2 = "", , value3 = ""] = data_url.split(/[:;,]/, 4);
      if (directory) {
        const ext = file.name.split(".").pop();
        if (accept.length > 0 && isString(ext) ? accept.includes(`.${ext}`) : true) {
          filenames.push(file.webkitRelativePath);
          values2.push(value3);
          mime_types.push(mime_type2);
        }
      } else {
        filenames.push(file.name);
        values2.push(value3);
        mime_types.push(mime_type2);
      }
    }
    const [value2, filename, mime_type] = (() => {
      if (directory || multiple) {
        return [values2, filenames, mime_types];
      } else if (files.length != 0) {
        return [values2[0], filenames[0], mime_types[0]];
      } else {
        return ["", "", ""];
      }
    })();
    this.model.setv({ value: value2, filename, mime_type });
  }
  _read_file(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const { result } = reader;
        if (result != null) {
          resolve(result);
        } else {
          reject(reader.error ?? new Error(`unable to read '${file.name}'`));
        }
      };
      reader.readAsDataURL(file);
    });
  }
};
__publicField(FileInputView, "__name__", "FileInputView");
var _FileInput = class _FileInput extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_FileInput, "__name__", "FileInput");
_FileInput.prototype.default_view = FileInputView;
_FileInput.define(({ Bool: Bool2, Str: Str2, List: List2, Or: Or2 }) => ({
  value: [Or2(Str2, List2(Str2)), unset, { readonly: true }],
  mime_type: [Or2(Str2, List2(Str2)), unset, { readonly: true }],
  filename: [Or2(Str2, List2(Str2)), unset, { readonly: true }],
  accept: [Or2(Str2, List2(Str2)), ""],
  multiple: [Bool2, false],
  directory: [Bool2, false]
}));
var FileInput = _FileInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/help_button.js
var HelpButtonView = class extends AbstractButtonView {
  constructor() {
    super(...arguments);
    __publicField(this, "tooltip");
  }
  *children() {
    yield* super.children();
    yield this.tooltip;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    const { tooltip } = this.model;
    this.tooltip = await build_view(tooltip, { parent: this });
  }
  remove() {
    this.tooltip.remove();
    super.remove();
  }
  render() {
    super.render();
    let persistent = false;
    const toggle = (visible) => {
      this.tooltip.model.setv({
        visible,
        closable: persistent
      });
    };
    this.on_change(this.tooltip.model.properties.visible, () => {
      const { visible } = this.tooltip.model;
      if (!visible) {
        persistent = false;
      }
      toggle(visible);
    });
    this.el.addEventListener("mouseenter", () => {
      toggle(true);
    });
    this.el.addEventListener("mouseleave", () => {
      if (!persistent) {
        toggle(false);
      }
    });
    document.addEventListener("mousedown", (event2) => {
      const path = event2.composedPath();
      if (path.includes(this.tooltip.el)) {
        return;
      } else if (path.includes(this.el)) {
        persistent = !persistent;
        toggle(persistent);
      } else {
        persistent = false;
        toggle(false);
      }
    });
    window.addEventListener("blur", () => {
      persistent = false;
      toggle(false);
    });
  }
};
__publicField(HelpButtonView, "__name__", "HelpButtonView");
var _HelpButton = class _HelpButton extends AbstractButton {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_HelpButton, "__name__", "HelpButton");
_HelpButton.prototype.default_view = HelpButtonView;
_HelpButton.define(({ Ref: Ref2 }) => ({
  tooltip: [Ref2(Tooltip)]
}));
_HelpButton.override({
  label: "",
  icon: () => new BuiltinIcon({ icon_name: "help", size: 18 }),
  button_type: "default"
});
var HelpButton = _HelpButton;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/multi_choice.js
var import_choices = __toESM(require_choices());
import * as inputs7 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
import choices_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/choices.css.js";
function retarget(event2) {
  Object.defineProperty(event2, "target", {
    get: () => event2.composedPath()[0] ?? null,
    configurable: true
  });
  return event2;
}
var OurChoices = class extends import_choices.default {
  _onFocus(event2) {
    super._onFocus(retarget(event2));
  }
  _onBlur(event2) {
    super._onBlur(retarget(event2));
  }
  _onKeyUp(event2) {
    super._onKeyUp(retarget(event2));
  }
  _onKeyDown(event2) {
    super._onKeyDown(retarget(event2));
  }
  _onClick(event2) {
    super._onClick(retarget(event2));
  }
  _onTouchEnd(event2) {
    super._onTouchEnd(retarget(event2));
  }
  _onMouseDown(event2) {
    super._onMouseDown(retarget(event2));
  }
  _onMouseOver(event2) {
    super._onMouseOver(retarget(event2));
  }
};
__publicField(OurChoices, "__name__", "OurChoices");
var MultiChoiceView = class extends InputWidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "choice_el");
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.disabled.change, () => this.set_disabled());
    const { value: value2, max_items, option_limit, search_option_limit, delete_button, placeholder, options: options2, name, title: title3 } = this.model.properties;
    this.on_change([max_items, option_limit, search_option_limit, delete_button, placeholder, options2, name, title3], () => this.render());
    this.on_change(value2, () => {
      if (!is_equal(this.model.value, this._current_values)) {
        this.render();
      }
    });
  }
  stylesheets() {
    return [...super.stylesheets(), choices_css];
  }
  _render_input() {
    return this.input_el = select({
      multiple: true,
      class: inputs7.input,
      name: this.model.name,
      disabled: this.model.disabled
    });
  }
  render() {
    super.render();
    const selected = new Set(this.model.value);
    const choices = this.model.options.map((opt) => {
      let value2, label3;
      if (isString(opt)) {
        value2 = label3 = opt;
      } else {
        [value2, label3] = opt;
      }
      return { value: value2, label: label3, selected: selected.has(value2) };
    });
    const fill = this.model.solid ? "solid" : "light";
    const item3 = `choices__item ${fill}`;
    const button2 = `choices__button ${fill}`;
    const options2 = {
      choices,
      itemSelectText: "",
      duplicateItemsAllowed: false,
      shouldSort: false,
      removeItemButton: this.model.delete_button,
      classNames: { item: item3, button: button2 },
      // XXX: missing typings
      placeholderValue: this.model.placeholder,
      maxItemCount: this.model.max_items ?? -1,
      renderChoiceLimit: this.model.option_limit ?? -1,
      searchResultLimit: this.model.search_option_limit ?? 4
    };
    this.choice_el = new OurChoices(this.input_el, options2);
    this.input_el.addEventListener("change", () => this.change_input());
  }
  set_disabled() {
    if (this.model.disabled) {
      this.choice_el.disable();
    } else {
      this.choice_el.enable();
    }
  }
  get _current_values() {
    const values2 = this.choice_el.getValue();
    return values2.map((item3) => item3.value);
  }
  change_input() {
    this.model.value = this._current_values;
    super.change_input();
  }
};
__publicField(MultiChoiceView, "__name__", "MultiChoiceView");
var _MultiChoice = class _MultiChoice extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultiChoice, "__name__", "MultiChoice");
_MultiChoice.prototype.default_view = MultiChoiceView;
_MultiChoice.define(({ Bool: Bool2, Int: Int2, Str: Str2, List: List2, Tuple: Tuple2, Or: Or2, Nullable: Nullable2 }) => ({
  value: [List2(Str2), []],
  options: [List2(Or2(Str2, Tuple2(Str2, Str2))), []],
  max_items: [Nullable2(Int2), null],
  delete_button: [Bool2, true],
  placeholder: [Nullable2(Str2), null],
  option_limit: [Nullable2(Int2), null],
  search_option_limit: [Nullable2(Int2), null],
  solid: [Bool2, true]
}));
var MultiChoice = _MultiChoice;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/multiselect.js
import * as inputs8 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var MultiSelectView = class extends InputWidgetView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.value.change, () => this.render_selection());
    this.connect(this.model.properties.options.change, () => this.render());
    this.connect(this.model.properties.name.change, () => this.render());
    this.connect(this.model.properties.title.change, () => this.render());
    this.connect(this.model.properties.size.change, () => this.render());
    this.connect(this.model.properties.disabled.change, () => this.render());
  }
  _render_input() {
    const options2 = this.model.options.map((opt) => {
      let value2, _label;
      if (isString(opt)) {
        value2 = _label = opt;
      } else {
        [value2, _label] = opt;
      }
      return option({ value: value2 }, _label);
    });
    this.input_el = select({
      multiple: true,
      class: inputs8.input,
      name: this.model.name,
      disabled: this.model.disabled
    }, options2);
    this.input_el.addEventListener("change", () => this.change_input());
    return this.input_el;
  }
  render() {
    super.render();
    this.render_selection();
  }
  render_selection() {
    const selected = new Set(this.model.value);
    for (const el of this.shadow_el.querySelectorAll("option")) {
      el.selected = selected.has(el.value);
    }
    this.input_el.size = this.model.size;
  }
  change_input() {
    const is_focused = this.shadow_el.querySelector("select:focus") != null;
    const values2 = [];
    for (const el of this.shadow_el.querySelectorAll("option")) {
      if (el.selected) {
        values2.push(el.value);
      }
    }
    this.model.value = values2;
    super.change_input();
    if (is_focused) {
      this.input_el.focus();
    }
  }
};
__publicField(MultiSelectView, "__name__", "MultiSelectView");
var _MultiSelect = class _MultiSelect extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultiSelect, "__name__", "MultiSelect");
_MultiSelect.prototype.default_view = MultiSelectView;
_MultiSelect.define(({ Int: Int2, Str: Str2, List: List2, Tuple: Tuple2, Or: Or2 }) => ({
  value: [List2(Str2), []],
  options: [List2(Or2(Str2, Tuple2(Str2, Str2))), []],
  size: [Int2, 4]
  // 4 is the HTML default
}));
var MultiSelect = _MultiSelect;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/multiple_date_picker.js
var MultipleDatePickerView = class extends BaseDatePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "multiple",
      conjunction: this.model.separator
    };
  }
  _on_change(selected) {
    this.model.value = selected.map((datetime) => this._format_date(datetime));
  }
};
__publicField(MultipleDatePickerView, "__name__", "MultipleDatePickerView");
var _MultipleDatePicker = class _MultipleDatePicker extends BaseDatePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultipleDatePicker, "__name__", "MultipleDatePicker");
_MultipleDatePicker.prototype.default_view = MultipleDatePickerView;
_MultipleDatePicker.define(({ Str: Str2, List: List2 }) => ({
  value: [List2(DateLike), []],
  separator: [Str2, ", "]
}));
var MultipleDatePicker = _MultipleDatePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/multiple_datetime_picker.js
var MultipleDatetimePickerView = class extends BaseDatetimePickerView {
  get flatpickr_options() {
    return {
      ...super.flatpickr_options,
      mode: "multiple",
      conjunction: this.model.separator
    };
  }
  _on_change(selected) {
    this.model.value = selected.map((datetime) => this._format_date(datetime));
  }
};
__publicField(MultipleDatetimePickerView, "__name__", "MultipleDatetimePickerView");
var _MultipleDatetimePicker = class _MultipleDatetimePicker extends BaseDatetimePicker {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_MultipleDatetimePicker, "__name__", "MultipleDatetimePicker");
_MultipleDatetimePicker.prototype.default_view = MultipleDatetimePickerView;
_MultipleDatetimePicker.define(({ Str: Str2, List: List2 }) => ({
  value: [List2(DateLike), []],
  separator: [Str2, ", "]
}));
var MultipleDatetimePicker = _MultipleDatetimePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/numeric_input.js
var numbro = __toESM(require_numbro());
import * as inputs9 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var int_regex = /^[-+]?\d*$/;
var float_regex = /^[-+]?\d*\.?\d*(?:(?:\d|\d.)[eE][-+]?)*\d*$/;
var NumericInputView = class extends InputWidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "old_value");
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.name.change, () => this.input_el.name = this.model.name ?? "");
    this.connect(this.model.properties.value.change, () => {
      this.input_el.value = this.format_value;
      this.old_value = this.input_el.value;
    });
    this.connect(this.model.properties.low.change, () => {
      const { value: value2, low, high } = this.model;
      if (low != null && high != null) {
        assert(low <= high, "Invalid bounds, low must be inferior to high");
      }
      if (value2 != null && low != null && value2 < low) {
        this.model.value = low;
      }
    });
    this.connect(this.model.properties.high.change, () => {
      const { value: value2, low, high } = this.model;
      if (low != null && high != null) {
        assert(high >= low, "Invalid bounds, high must be superior to low");
      }
      if (value2 != null && high != null && value2 > high) {
        this.model.value = high;
      }
    });
    this.connect(this.model.properties.high.change, () => this.input_el.placeholder = this.model.placeholder);
    this.connect(this.model.properties.disabled.change, () => this.input_el.disabled = this.model.disabled);
    this.connect(this.model.properties.placeholder.change, () => this.input_el.placeholder = this.model.placeholder);
  }
  get format_value() {
    return this.model.value != null ? this.model.pretty(this.model.value) : "";
  }
  _set_input_filter(inputFilter) {
    this.input_el.addEventListener("input", () => {
      const { selectionStart, selectionEnd } = this.input_el;
      if (!inputFilter(this.input_el.value)) {
        const difflen = this.old_value.length - this.input_el.value.length;
        this.input_el.value = this.old_value;
        if (selectionStart != null && selectionEnd != null) {
          this.input_el.setSelectionRange(selectionStart - 1, selectionEnd + difflen);
        }
      } else {
        this.old_value = this.input_el.value;
      }
    });
  }
  _render_input() {
    return this.input_el = input({
      type: "text",
      class: inputs9.input,
      name: this.model.name,
      value: this.format_value,
      disabled: this.model.disabled,
      placeholder: this.model.placeholder
    });
  }
  render() {
    super.render();
    this.old_value = this.format_value;
    this.set_input_filter();
    this.input_el.addEventListener("change", () => this.change_input());
    this.input_el.addEventListener("focusout", () => this.input_el.value = this.format_value);
  }
  set_input_filter() {
    const regex2 = this.model.mode == "int" ? int_regex : float_regex;
    this._set_input_filter((value2) => regex2.test(value2));
  }
  bound_value(value2) {
    let output2 = value2;
    const { low, high } = this.model;
    output2 = low != null ? Math.max(low, output2) : output2;
    output2 = high != null ? Math.min(high, output2) : output2;
    return output2;
  }
  get value() {
    let value2 = this.input_el.value != "" ? Number(this.input_el.value) : null;
    if (value2 != null) {
      value2 = this.bound_value(value2);
    }
    return value2;
  }
  change_input() {
    if (this.value == null) {
      this.model.value = null;
    } else if (!Number.isNaN(this.value)) {
      this.model.value = this.value;
    }
  }
};
__publicField(NumericInputView, "__name__", "NumericInputView");
var _NumericInput = class _NumericInput extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return numbro.format(value2, format7);
    } else {
      return format7.doFormat([value2], { loc: 0 })[0];
    }
  }
  pretty(value2) {
    if (this.format != null) {
      return this._formatter(value2, this.format);
    } else {
      return `${value2}`;
    }
  }
};
__publicField(_NumericInput, "__name__", "NumericInput");
_NumericInput.prototype.default_view = NumericInputView;
_NumericInput.define(({ Float: Float2, Str: Str2, Enum: Enum2, Ref: Ref2, Or: Or2, Nullable: Nullable2 }) => ({
  value: [Nullable2(Float2), null],
  placeholder: [Str2, ""],
  mode: [Enum2("int", "float"), "int"],
  format: [Nullable2(Or2(Str2, Ref2(TickFormatter))), null],
  low: [Nullable2(Float2), null],
  high: [Nullable2(Float2), null]
}));
var NumericInput = _NumericInput;

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/panes.js
import panes_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/panes.css.js";
import base_css3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/base.css.js";
var DropPane = class {
  constructor(contents, options2) {
    __publicField(this, "contents");
    __publicField(this, "el", div());
    __publicField(this, "shadow_el");
    __publicField(this, "_open", false);
    __publicField(this, "target");
    __publicField(this, "orientation");
    __publicField(this, "reversed");
    __publicField(this, "prevent_hide");
    __publicField(this, "extra_stylesheets");
    __publicField(this, "class_list");
    __publicField(this, "_on_mousedown", (event2) => {
      if (event2.composedPath().includes(this.el)) {
        return;
      }
      const { prevent_hide } = this;
      if (prevent_hide instanceof HTMLElement) {
        if (event2.composedPath().includes(prevent_hide)) {
          return;
        }
      } else if (prevent_hide != null) {
        if (prevent_hide(event2)) {
          return;
        }
      }
      this.hide();
    });
    __publicField(this, "_on_keydown", (event2) => {
      switch (event2.key) {
        case "Escape": {
          this.hide();
          break;
        }
        default:
      }
    });
    __publicField(this, "_on_blur", () => {
      this.hide();
    });
    this.contents = contents;
    this.target = options2.target;
    this.prevent_hide = options2.prevent_hide;
    this.extra_stylesheets = options2.extra_stylesheets ?? [];
    this.shadow_el = this.el.attachShadow({ mode: "open" });
    this.class_list = new ClassList(this.el.classList);
  }
  get is_open() {
    return this._open;
  }
  remove() {
    this._unlisten();
    this.el.remove();
  }
  _listen() {
    document.addEventListener("mousedown", this._on_mousedown);
    document.addEventListener("keydown", this._on_keydown);
    window.addEventListener("blur", this._on_blur);
  }
  _unlisten() {
    document.removeEventListener("mousedown", this._on_mousedown);
    document.removeEventListener("keydown", this._on_keydown);
    window.removeEventListener("blur", this._on_blur);
  }
  stylesheets() {
    return [
      base_css3,
      /*...super.stylesheets(), */
      panes_css,
      ...this.extra_stylesheets
    ];
  }
  empty() {
    empty2(this.shadow_el);
    this.class_list.clear();
  }
  render() {
    this.empty();
    for (const style2 of this.stylesheets()) {
      const stylesheet2 = isString(style2) ? new InlineStyleSheet(style2) : style2;
      stylesheet2.install(this.shadow_el);
    }
    this.shadow_el.append(...this.contents);
  }
  show() {
    if (!this._open) {
      this.render();
      const actual_target = this.target.shadowRoot ?? this.target;
      actual_target.appendChild(this.el);
      this._listen();
      this._open = true;
    }
  }
  hide() {
    if (this._open) {
      this._open = false;
      this._unlisten();
      this.el.remove();
    }
  }
  toggle() {
    this._open ? this.hide() : this.show();
  }
};
__publicField(DropPane, "__name__", "DropPane");

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/palette_select.js
import * as inputs_css3 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
import * as palette_select_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/palette_select.css.js";
import * as item_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/palette_select_item.css.js";
import * as pane_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/palette_select_pane.css.js";
import * as icons_css11 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var Item = Tuple(Str, Arrayable(Color));
var PaletteSelectView = class extends InputWidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "_value_el");
    __publicField(this, "_pane");
    __publicField(this, "_style", new InlineStyleSheet());
    __publicField(this, "_style_menu", new InlineStyleSheet());
  }
  stylesheets() {
    return [...super.stylesheets(), palette_select_css.default, item_css.default, icons_css11.default, this._style];
  }
  connect_signals() {
    super.connect_signals();
    const { value: value2, items, ncols, swatch_width, swatch_height } = this.model.properties;
    this.on_change([items, swatch_width, swatch_height], () => this.render());
    this.on_change(value2, () => this._update_value());
    this.on_change(ncols, () => this._update_ncols());
  }
  _update_value() {
    empty2(this._value_el);
    const content2 = this._render_value();
    if (content2 != null) {
      this._value_el.append(content2);
    }
  }
  _update_ncols() {
    const { ncols } = this.model;
    this._pane.el.style.setProperty("--number-of-columns", `${ncols}`);
  }
  _render_item(item3) {
    const [name] = item3;
    const i2 = this.model.items.indexOf(item3);
    assert(i2 != -1);
    const swatch2 = div({ class: item_css.swatch, id: `item_${i2}` });
    return div({ class: item_css.entry }, swatch2, div(name));
  }
  _render_value() {
    const { value: value2, items } = this.model;
    const entry2 = items.find(([name]) => name == value2);
    if (entry2 != null) {
      return this._render_item(entry2);
    } else {
      return null;
    }
  }
  _render_input() {
    this._value_el = div({ class: [palette_select_css.value, item_css.entry] }, this._render_value());
    const chevron_el = div({ class: [palette_select_css.chevron, icons_css11.tool_icon_chevron_down] });
    const input_el = div({ class: [inputs_css3.input, palette_select_css.value_input] }, this._value_el, chevron_el);
    if (this.model.disabled) {
      input_el.classList.add(inputs_css3.disabled);
    } else {
      input_el.tabIndex = 0;
    }
    this.input_el = input_el;
    return this.input_el;
  }
  render() {
    super.render();
    const { swatch_width, swatch_height } = this.model;
    this._style.replace(`
      .${item_css.swatch} {
        width: ${swatch_width}px;
        height: ${swatch_height == "auto" ? "auto" : px(swatch_height)};
      }
    `);
    for (const [item3, i2] of enumerate(this.model.items)) {
      const [, colors] = item3;
      const n2 = colors.length;
      const stops = linspace(0, 100, n2 + 1);
      const color_map = [];
      for (const [color, i3] of enumerate(colors)) {
        const [from, to] = [stops[i3], stops[i3 + 1]];
        color_map.push(`${color2css(color)} ${from}% ${to}%`);
      }
      const gradient = color_map.join(", ");
      this._style.append(`
        #item_${i2} {
          background: linear-gradient(to right, ${gradient});
        }
      `);
    }
    this._style_menu.replace(this._style.css);
    const item_els = [];
    for (const [item3, i2] of enumerate(this.model.items)) {
      const entry_el = this._render_item(item3);
      const item_el = div({ class: item_css.item, tabIndex: 0 }, entry_el);
      item_el.addEventListener("pointerup", () => {
        this.select(item3);
      });
      item_el.addEventListener("keyup", (event2) => {
        switch (event2.key) {
          case "Enter": {
            this.select(item3);
            break;
          }
          case "Escape": {
            this.hide();
            break;
          }
          default:
        }
      });
      const move_focus = (offset3) => {
        const { items } = this.model;
        const j = cycle(i2 + offset3, 0, items.length - 1);
        item_els[j].focus();
      };
      item_el.addEventListener("keydown", (event2) => {
        const offset3 = (() => {
          switch (event2.key) {
            case "ArrowUp":
              return -this.model.ncols;
            case "ArrowDown":
              return +this.model.ncols;
            case "ArrowLeft":
              return -1;
            case "ArrowRight":
              return 1;
            default:
              return null;
          }
        })();
        if (offset3 != null) {
          event2.preventDefault();
          move_focus(offset3);
        }
      });
      item_els.push(item_el);
    }
    this._pane = new DropPane(item_els, {
      target: this.group_el,
      prevent_hide: this.input_el,
      extra_stylesheets: [item_css.default, pane_css.default, this._style_menu]
    });
    this._update_ncols();
    this.input_el.addEventListener("pointerup", () => {
      this.toggle();
    });
    this.input_el.addEventListener("keyup", (event2) => {
      switch (event2.key) {
        case "Enter": {
          this.toggle();
          break;
        }
        case "Escape": {
          this.hide();
          break;
        }
        default:
      }
    });
    const move_selection = (offset3) => {
      const { items, value: value2 } = this.model;
      const i2 = items.findIndex(([name]) => value2 == name);
      if (i2 != -1) {
        const j = cycle(i2 + offset3, 0, items.length - 1);
        this.select(items[j]);
      }
    };
    this.input_el.addEventListener("keydown", (event2) => {
      const offset3 = (() => {
        switch (event2.key) {
          case "ArrowUp":
            return -1;
          case "ArrowDown":
            return 1;
          default:
            return null;
        }
      })();
      if (offset3 != null) {
        event2.preventDefault();
        move_selection(offset3);
      }
    });
  }
  select(item3) {
    this.hide();
    const [name] = item3;
    this.model.value = name;
    super.change_input();
    this.input_el.focus();
  }
  toggle() {
    if (!this.model.disabled) {
      this._pane.toggle();
    }
  }
  hide() {
    this._pane.hide();
  }
};
__publicField(PaletteSelectView, "__name__", "PaletteSelectView");
var _PaletteSelect = class _PaletteSelect extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PaletteSelect, "__name__", "PaletteSelect");
_PaletteSelect.prototype.default_view = PaletteSelectView;
_PaletteSelect.define(({ Int: Int2, Str: Str2, List: List2, NonNegative: NonNegative2, Positive, Or: Or2, Auto: Auto2 }) => ({
  value: [Str2],
  items: [List2(Item)],
  ncols: [Positive(Int2), 1],
  swatch_width: [NonNegative2(Int2), 100],
  swatch_height: [Or2(Auto2, NonNegative2(Int2)), "auto"]
}));
var PaletteSelect = _PaletteSelect;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/paragraph.js
var ParagraphView = class extends MarkupView {
  render() {
    super.render();
    const content2 = p({ style: { margin: "0px" } });
    if (this.has_math_disabled()) {
      content2.textContent = this.model.text;
    } else {
      content2.innerHTML = this.process_tex(this.model.text);
    }
    this.markup_el.appendChild(content2);
  }
};
__publicField(ParagraphView, "__name__", "ParagraphView");
var _Paragraph = class _Paragraph extends Markup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Paragraph, "__name__", "Paragraph");
_Paragraph.prototype.default_view = ParagraphView;
var Paragraph = _Paragraph;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/password_input.js
import password_input_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/password_input.css.js";
import icons_css12 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/icons.css.js";
var PasswordInputView = class extends TextInputView {
  constructor() {
    super(...arguments);
    __publicField(this, "toggle_el");
  }
  stylesheets() {
    return [...super.stylesheets(), password_input_css, icons_css12];
  }
  render() {
    super.render();
    this.input_el.type = "password";
    this.toggle_el = div({ class: "bk-toggle" });
    this.toggle_el.addEventListener("click", () => {
      const { input_el, toggle_el } = this;
      const is_visible = input_el.type == "text";
      toggle_el.classList.toggle("bk-visible", !is_visible);
      input_el.type = is_visible ? "password" : "text";
    });
    this.shadow_el.append(this.toggle_el);
  }
};
__publicField(PasswordInputView, "__name__", "PasswordInputView");
var _PasswordInput = class _PasswordInput extends TextInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PasswordInput, "__name__", "PasswordInput");
_PasswordInput.prototype.default_view = PasswordInputView;
var PasswordInput = _PasswordInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/pretext.js
var PreTextView = class extends MarkupView {
  render() {
    super.render();
    const content2 = pre({ style: { overflow: "auto" } }, this.model.text);
    this.markup_el.appendChild(content2);
  }
};
__publicField(PreTextView, "__name__", "PreTextView");
var _PreText = class _PreText extends Markup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_PreText, "__name__", "PreText");
_PreText.prototype.default_view = PreTextView;
var PreText = _PreText;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/radio_button_group.js
import * as buttons5 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var RadioButtonGroupView = class extends ToggleButtonGroupView {
  change_active(i2) {
    if (this.model.active !== i2) {
      this.model.active = i2;
    }
  }
  _update_active() {
    const { active: active8 } = this.model;
    this._buttons.forEach((button_el, i2) => {
      button_el.classList.toggle(buttons5.active, active8 === i2);
    });
  }
};
__publicField(RadioButtonGroupView, "__name__", "RadioButtonGroupView");
var _RadioButtonGroup = class _RadioButtonGroup extends ToggleButtonGroup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RadioButtonGroup, "__name__", "RadioButtonGroup");
_RadioButtonGroup.prototype.default_view = RadioButtonGroupView;
_RadioButtonGroup.define(({ Int: Int2, Nullable: Nullable2 }) => ({
  active: [Nullable2(Int2), null]
}));
var RadioButtonGroup = _RadioButtonGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/radio_group.js
import * as inputs10 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var RadioGroupView = class extends ToggleInputGroupView {
  connect_signals() {
    super.connect_signals();
    const { active: active8 } = this.model.properties;
    this.on_change(active8, () => {
      const { active: active9 } = this.model;
      for (const [input_el, i2] of enumerate(this._inputs)) {
        input_el.checked = active9 == i2;
      }
    });
  }
  render() {
    super.render();
    const group = div({ class: [inputs10.input_group, this.model.inline ? inputs10.inline : null] });
    this.shadow_el.appendChild(group);
    const name = unique_id();
    const { active: active8, labels } = this.model;
    this._inputs = [];
    for (let i2 = 0; i2 < labels.length; i2++) {
      const radio = input({ type: "radio", name, value: `${i2}` });
      radio.addEventListener("change", () => this.change_active(i2));
      this._inputs.push(radio);
      if (this.model.disabled) {
        radio.disabled = true;
      }
      if (i2 == active8) {
        radio.checked = true;
      }
      const label_el = label(radio, span(labels[i2]));
      group.appendChild(label_el);
    }
  }
  change_active(i2) {
    this.model.active = i2;
  }
};
__publicField(RadioGroupView, "__name__", "RadioGroupView");
var _RadioGroup = class _RadioGroup extends ToggleInputGroup {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RadioGroup, "__name__", "RadioGroup");
_RadioGroup.prototype.default_view = RadioGroupView;
_RadioGroup.define(({ Int: Int2, Nullable: Nullable2 }) => ({
  active: [Nullable2(Int2), null]
}));
var RadioGroup = _RadioGroup;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/select.js
import * as inputs11 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var Value = Unknown;
var Label2 = Str;
var Options = List(Or(Label2, Tuple(Value, Label2)));
var OptionsGroups = Dict(Options);
var NotSelected = "";
var SelectView = class extends InputWidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "_known_values", /* @__PURE__ */ new Map());
  }
  connect_signals() {
    super.connect_signals();
    const { value: value2, options: options2 } = this.model.properties;
    this.on_change(value2, () => {
      this._update_value();
    });
    this.on_change(options2, () => {
      empty2(this.input_el);
      this.input_el.append(...this.options_el());
      this._update_value();
    });
  }
  options_el() {
    const { _known_values } = this;
    _known_values.clear();
    function build_options(values2) {
      return values2.map((el) => {
        let value2, label3;
        if (isString(el)) {
          value2 = label3 = el;
        } else {
          [value2, label3] = el;
        }
        _known_values.set(value2, label3);
        return option({ value: label3 }, label3);
      });
    }
    const { options: options2 } = this.model;
    if (isArray(options2)) {
      return build_options(options2);
    } else {
      return entries(options2).map(([label3, values2]) => optgroup({ label: label3 }, build_options(values2)));
    }
  }
  _render_input() {
    this.input_el = select({
      class: inputs11.input,
      name: this.model.name,
      disabled: this.model.disabled
    }, this.options_el());
    this.input_el.addEventListener("change", () => this.change_input());
    return this.input_el;
  }
  render() {
    super.render();
    this._update_value();
  }
  change_input() {
    const selected_label = this.input_el.value;
    const found = [...this._known_values].find(([_2, label3]) => selected_label == label3);
    const value2 = (() => {
      if (found == null) {
        return NotSelected;
      } else {
        const [value3, _2] = found;
        return value3;
      }
    })();
    this.model.value = value2;
    super.change_input();
  }
  _update_value() {
    const { value: value2 } = this.model;
    const label3 = this._known_values.get(value2);
    if (label3 !== void 0) {
      this.input_el.value = label3;
    } else {
      this.input_el.removeAttribute("value");
      this.input_el.selectedIndex = -1;
    }
  }
};
__publicField(SelectView, "__name__", "SelectView");
var _Select = class _Select extends InputWidget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Select, "__name__", "Select");
_Select.prototype.default_view = SelectView;
_Select.define(() => {
  return {
    value: [Value, NotSelected],
    options: [Or(Options, OptionsGroups), []]
  };
});
var Select = _Select;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/spinner.js
var { min: min8, max: max16 } = Math;
function debounce2(func, wait, immediate = false) {
  let timeoutId;
  return function(...args) {
    const context = this;
    const doLater = function() {
      timeoutId = void 0;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const shouldCallNow = immediate && timeoutId === void 0;
    if (timeoutId !== void 0) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(doLater, wait);
    if (shouldCallNow) {
      func.apply(context, args);
    }
  };
}
var SpinnerView = class extends NumericInputView {
  constructor() {
    super(...arguments);
    __publicField(this, "wrapper_el");
    __publicField(this, "btn_up_el");
    __publicField(this, "btn_down_el");
    __publicField(this, "_handles");
    __publicField(this, "_counter");
    __publicField(this, "_interval");
  }
  *buttons() {
    yield this.btn_up_el;
    yield this.btn_down_el;
  }
  initialize() {
    super.initialize();
    this._handles = { interval: void 0, timeout: void 0 };
    this._interval = 200;
  }
  connect_signals() {
    super.connect_signals();
    const p2 = this.model.properties;
    this.on_change(p2.disabled, () => {
      for (const btn3 of this.buttons()) {
        toggle_attribute(btn3, "disabled", this.model.disabled);
      }
    });
  }
  _render_input() {
    super._render_input();
    this.btn_up_el = button({ class: "bk-spin-btn bk-spin-btn-up" });
    this.btn_down_el = button({ class: "bk-spin-btn bk-spin-btn-down" });
    const { input_el, btn_up_el, btn_down_el } = this;
    this.wrapper_el = div({ class: "bk-spin-wrapper" }, input_el, btn_up_el, btn_down_el);
    return this.wrapper_el;
  }
  render() {
    super.render();
    for (const btn3 of this.buttons()) {
      toggle_attribute(btn3, "disabled", this.model.disabled);
      btn3.addEventListener("mousedown", (evt) => this._btn_mouse_down(evt));
      btn3.addEventListener("mouseup", () => this._btn_mouse_up());
      btn3.addEventListener("mouseleave", () => this._btn_mouse_leave());
    }
    this.input_el.addEventListener("keydown", (evt) => {
      this._input_key_down(evt);
    });
    this.input_el.addEventListener("keyup", () => {
      this.model.value_throttled = this.model.value;
    });
    this.input_el.addEventListener("wheel", (evt) => {
      this._input_mouse_wheel(evt);
    });
    this.input_el.addEventListener("wheel", debounce2(() => {
      this.model.value_throttled = this.model.value;
    }, this.model.wheel_wait, false));
  }
  remove() {
    this._stop_incrementation();
    super.remove();
  }
  _start_incrementation(sign) {
    clearInterval(this._handles.interval);
    this._counter = 0;
    const { step } = this.model;
    const increment_with_increasing_rate = (step2) => {
      this._counter += 1;
      if (this._counter % 5 == 0) {
        const quotient = Math.floor(this._counter / 5);
        if (quotient < 10) {
          clearInterval(this._handles.interval);
          this._handles.interval = setInterval(() => increment_with_increasing_rate(step2), this._interval / (quotient + 1));
        } else if (quotient >= 10 && quotient <= 13) {
          clearInterval(this._handles.interval);
          this._handles.interval = setInterval(() => increment_with_increasing_rate(step2 * 2), this._interval / 10);
        }
      }
      this.increment(step2);
    };
    this._handles.interval = setInterval(() => increment_with_increasing_rate(sign * step), this._interval);
  }
  _stop_incrementation() {
    clearTimeout(this._handles.timeout);
    this._handles.timeout = void 0;
    clearInterval(this._handles.interval);
    this._handles.interval = void 0;
    this.model.value_throttled = this.model.value;
  }
  _btn_mouse_down(event2) {
    event2.preventDefault();
    const sign = event2.currentTarget === this.btn_up_el ? 1 : -1;
    this.increment(sign * this.model.step);
    this.input_el.focus();
    this._handles.timeout = setTimeout(() => this._start_incrementation(sign), this._interval);
  }
  _btn_mouse_up() {
    this._stop_incrementation();
  }
  _btn_mouse_leave() {
    this._stop_incrementation();
  }
  _input_mouse_wheel(event2) {
    if (this.shadow_el.activeElement === this.input_el) {
      event2.preventDefault();
      const sign = event2.deltaY > 0 ? -1 : 1;
      this.increment(sign * this.model.step);
    }
  }
  _input_key_down(event2) {
    const step = (() => {
      const { step: step2, page_step_multiplier } = this.model;
      switch (event2.key) {
        case "ArrowUp":
          return step2;
        case "ArrowDown":
          return -step2;
        case "PageUp":
          return page_step_multiplier * step2;
        case "PageDown":
          return -page_step_multiplier * step2;
        default:
          return null;
      }
    })();
    if (step != null) {
      event2.preventDefault();
      this.increment(step);
    }
  }
  increment(step) {
    const { low, high } = this.model;
    if (this.model.value == null) {
      if (step > 0) {
        this.model.value = low != null ? low : high != null ? min8(0, high) : 0;
      } else if (step < 0) {
        this.model.value = high != null ? high : low != null ? max16(low, 0) : 0;
      }
    } else {
      this.model.value = this.bound_value(this.model.value + step);
    }
  }
  change_input() {
    super.change_input();
    this.model.value_throttled = this.model.value;
  }
  bound_value(value2) {
    const { low, high } = this.model;
    if (low != null && value2 < low) {
      return this.model.value ?? 0;
    }
    if (high != null && value2 > high) {
      return this.model.value ?? 0;
    }
    return value2;
  }
};
__publicField(SpinnerView, "__name__", "SpinnerView");
var _Spinner = class _Spinner extends NumericInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Spinner, "__name__", "Spinner");
_Spinner.prototype.default_view = SpinnerView;
_Spinner.define(({ Float: Float2, Nullable: Nullable2 }) => ({
  value_throttled: [Nullable2(Float2), unset, { readonly: true }],
  step: [Float2, 1],
  page_step_multiplier: [Float2, 10],
  wheel_wait: [Float2, 100]
}));
_Spinner.override({
  mode: "float"
});
var Spinner = _Spinner;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/switch.js
import switch_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/switch.css.js";
var SwitchView = class extends ToggleInputView {
  constructor() {
    super(...arguments);
    __publicField(this, "knob_el");
    __publicField(this, "bar_el");
  }
  stylesheets() {
    return [...super.stylesheets(), switch_css];
  }
  connect_signals() {
    super.connect_signals();
    this.el.addEventListener("keydown", (event2) => {
      switch (event2.key) {
        case "Enter":
        case " ": {
          event2.preventDefault();
          this._toggle_active();
          break;
        }
      }
    });
    this.el.addEventListener("click", () => this._toggle_active());
  }
  render() {
    super.render();
    this.bar_el = div({ class: "bar" });
    this.knob_el = div({ class: "knob", tabIndex: 0 });
    const body_el = div({ class: "body" }, this.bar_el, this.knob_el);
    this._update_active();
    this._update_disabled();
    this.shadow_el.appendChild(body_el);
  }
  _update_active() {
    this.el.classList.toggle("active", this.model.active);
  }
  _update_disabled() {
    this.el.classList.toggle("disabled", this.model.disabled);
  }
};
__publicField(SwitchView, "__name__", "SwitchView");
var _Switch = class _Switch extends ToggleInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Switch, "__name__", "Switch");
_Switch.prototype.default_view = SwitchView;
_Switch.override({
  width: 32
});
var Switch = _Switch;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/textarea_input.js
import * as inputs12 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var TextAreaInputView = class extends TextLikeInputView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.rows.change, () => this.input_el.rows = this.model.rows);
    this.connect(this.model.properties.cols.change, () => this.input_el.cols = this.model.cols);
  }
  _render_input() {
    return this.input_el = textarea({ class: inputs12.input });
  }
  render() {
    super.render();
    this.input_el.cols = this.model.cols;
    this.input_el.rows = this.model.rows;
  }
};
__publicField(TextAreaInputView, "__name__", "TextAreaInputView");
var _TextAreaInput = class _TextAreaInput extends TextLikeInput {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TextAreaInput, "__name__", "TextAreaInput");
_TextAreaInput.prototype.default_view = TextAreaInputView;
_TextAreaInput.define(({ Int: Int2 }) => ({
  cols: [Int2, 20],
  rows: [Int2, 2]
}));
_TextAreaInput.override({
  max_length: 500
});
var TextAreaInput = _TextAreaInput;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/time_picker.js
var TimeLike = Or(Str, Float);
var TimePickerView = class extends PickerBaseView {
  _format_time(date) {
    const { picker } = this;
    return picker.formatDate(date, picker.config.dateFormat);
  }
  connect_signals() {
    super.connect_signals();
    const { value: value2, min_time, max_time, time_format, hour_increment, minute_increment, second_increment, seconds, clock } = this.model.properties;
    this.connect(value2.change, () => {
      const { value: value3 } = this.model;
      if (value3 != null) {
        this.picker.setDate(value3);
      } else {
        this.picker.clear();
      }
    });
    this.connect(min_time.change, () => this.picker.set("minTime", this.model.min_time));
    this.connect(max_time.change, () => this.picker.set("maxTime", this.model.max_time));
    this.connect(time_format.change, () => this.picker.set("altFormat", this.model.time_format));
    this.connect(hour_increment.change, () => this.picker.set("hourIncrement", this.model.hour_increment));
    this.connect(minute_increment.change, () => this.picker.set("minuteIncrement", this.model.minute_increment));
    this.connect(second_increment.change, () => this._update_second_increment());
    this.connect(seconds.change, () => this.picker.set("enableSeconds", this.model.seconds));
    this.connect(clock.change, () => this.picker.set("time_24hr", this.model.clock == "24h"));
  }
  get flatpickr_options() {
    const { value: value2, min_time, max_time, time_format, hour_increment, minute_increment, seconds, clock } = this.model;
    const options2 = super.flatpickr_options;
    options2.enableTime = true;
    options2.noCalendar = true;
    options2.altInput = true;
    options2.altFormat = time_format;
    options2.dateFormat = "H:i:S";
    options2.hourIncrement = hour_increment;
    options2.minuteIncrement = minute_increment;
    options2.enableSeconds = seconds;
    options2.time_24hr = clock == "24h";
    if (value2 != null) {
      options2.defaultDate = value2;
    }
    if (min_time != null) {
      options2.minTime = min_time;
    }
    if (max_time != null) {
      options2.maxTime = max_time;
    }
    return options2;
  }
  render() {
    super.render();
    this._update_second_increment();
  }
  _update_second_increment() {
    var _a34;
    const { second_increment } = this.model;
    (_a34 = this.picker.secondElement) == null ? void 0 : _a34.setAttribute("step", second_increment.toString());
  }
  _on_change(selected) {
    assert(selected.length <= 1);
    this.model.value = (() => {
      if (selected.length == 0) {
        return null;
      } else {
        const [datetime] = selected;
        return this._format_time(datetime);
      }
    })();
  }
};
__publicField(TimePickerView, "__name__", "TimePickerView");
var _TimePicker = class _TimePicker extends PickerBase {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TimePicker, "__name__", "TimePicker");
_TimePicker.prototype.default_view = TimePickerView;
_TimePicker.define(({ Bool: Bool2, Str: Str2, Nullable: Nullable2, Positive, Int: Int2 }) => ({
  value: [Nullable2(TimeLike), null],
  min_time: [Nullable2(TimeLike), null],
  max_time: [Nullable2(TimeLike), null],
  time_format: [Str2, "H:i"],
  hour_increment: [Positive(Int2), 1],
  minute_increment: [Positive(Int2), 1],
  second_increment: [Positive(Int2), 1],
  seconds: [Bool2, false],
  clock: [Clock, "24h"]
}));
var TimePicker = _TimePicker;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/toggle.js
import * as buttons6 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/buttons.css.js";
var ToggleView = class extends AbstractButtonView {
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.properties.active.change, () => this._update_active());
  }
  render() {
    super.render();
    this._update_active();
  }
  click() {
    this.model.active = !this.model.active;
    this.model.trigger_event(new ButtonClick());
    super.click();
  }
  _update_active() {
    this.button_el.classList.toggle(buttons6.active, this.model.active);
  }
};
__publicField(ToggleView, "__name__", "ToggleView");
var _Toggle = class _Toggle extends AbstractButton {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Toggle, "__name__", "Toggle");
_Toggle.prototype.default_view = ToggleView;
_Toggle.define(({ Bool: Bool2 }) => ({
  active: [Bool2, false]
}));
_Toggle.override({
  label: "Toggle"
});
var Toggle = _Toggle;

// node_modules/nouislider/dist/nouislider.mjs
var PipsMode;
(function(PipsMode2) {
  PipsMode2["Range"] = "range";
  PipsMode2["Steps"] = "steps";
  PipsMode2["Positions"] = "positions";
  PipsMode2["Count"] = "count";
  PipsMode2["Values"] = "values";
})(PipsMode || (PipsMode = {}));
var PipsType;
(function(PipsType2) {
  PipsType2[PipsType2["None"] = -1] = "None";
  PipsType2[PipsType2["NoValue"] = 0] = "NoValue";
  PipsType2[PipsType2["LargeValue"] = 1] = "LargeValue";
  PipsType2[PipsType2["SmallValue"] = 2] = "SmallValue";
})(PipsType || (PipsType = {}));
function isValidFormatter(entry2) {
  return isValidPartialFormatter(entry2) && typeof entry2.from === "function";
}
function isValidPartialFormatter(entry2) {
  return typeof entry2 === "object" && typeof entry2.to === "function";
}
function removeElement(el) {
  el.parentElement.removeChild(el);
}
function isSet(value2) {
  return value2 !== null && value2 !== void 0;
}
function preventDefault(e) {
  e.preventDefault();
}
function unique(array2) {
  return array2.filter(function(a2) {
    return !this[a2] ? this[a2] = true : false;
  }, {});
}
function closest(value2, to) {
  return Math.round(value2 / to) * to;
}
function offset2(elem, orientation) {
  var rect = elem.getBoundingClientRect();
  var doc = elem.ownerDocument;
  var docElem = doc.documentElement;
  var pageOffset = getPageOffset(doc);
  if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
    pageOffset.x = 0;
  }
  return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
}
function isNumeric(a2) {
  return typeof a2 === "number" && !isNaN(a2) && isFinite(a2);
}
function addClassFor(element, className, duration2) {
  if (duration2 > 0) {
    addClass(element, className);
    setTimeout(function() {
      removeClass(element, className);
    }, duration2);
  }
}
function limit(a2) {
  return Math.max(Math.min(a2, 100), 0);
}
function asArray(a2) {
  return Array.isArray(a2) ? a2 : [a2];
}
function countDecimals(numStr) {
  numStr = String(numStr);
  var pieces = numStr.split(".");
  return pieces.length > 1 ? pieces[1].length : 0;
}
function addClass(el, className) {
  if (el.classList && !/\s/.test(className)) {
    el.classList.add(className);
  } else {
    el.className += " " + className;
  }
}
function removeClass(el, className) {
  if (el.classList && !/\s/.test(className)) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
  }
}
function hasClass(el, className) {
  return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
}
function getPageOffset(doc) {
  var supportPageOffset = window.pageXOffset !== void 0;
  var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
  var x2 = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
  var y2 = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function getActions() {
  return window.navigator.pointerEnabled ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup"
  } : window.navigator.msPointerEnabled ? {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  } : {
    start: "mousedown touchstart",
    move: "mousemove touchmove",
    end: "mouseup touchend"
  };
}
function getSupportsPassive() {
  var supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
  return supportsPassive;
}
function getSupportsTouchActionNone() {
  return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
}
function subRangeRatio(pa, pb) {
  return 100 / (pb - pa);
}
function fromPercentage(range2, value2, startRange) {
  return value2 * 100 / (range2[startRange + 1] - range2[startRange]);
}
function toPercentage(range2, value2) {
  return fromPercentage(range2, range2[0] < 0 ? value2 + Math.abs(range2[0]) : value2 - range2[0], 0);
}
function isPercentage(range2, value2) {
  return value2 * (range2[1] - range2[0]) / 100 + range2[0];
}
function getJ(value2, arr) {
  var j = 1;
  while (value2 >= arr[j]) {
    j += 1;
  }
  return j;
}
function toStepping(xVal, xPct, value2) {
  if (value2 >= xVal.slice(-1)[0]) {
    return 100;
  }
  var j = getJ(value2, xVal);
  var va = xVal[j - 1];
  var vb = xVal[j];
  var pa = xPct[j - 1];
  var pb = xPct[j];
  return pa + toPercentage([va, vb], value2) / subRangeRatio(pa, pb);
}
function fromStepping(xVal, xPct, value2) {
  if (value2 >= 100) {
    return xVal.slice(-1)[0];
  }
  var j = getJ(value2, xPct);
  var va = xVal[j - 1];
  var vb = xVal[j];
  var pa = xPct[j - 1];
  var pb = xPct[j];
  return isPercentage([va, vb], (value2 - pa) * subRangeRatio(pa, pb));
}
function getStep(xPct, xSteps, snap, value2) {
  if (value2 === 100) {
    return value2;
  }
  var j = getJ(value2, xPct);
  var a2 = xPct[j - 1];
  var b2 = xPct[j];
  if (snap) {
    if (value2 - a2 > (b2 - a2) / 2) {
      return b2;
    }
    return a2;
  }
  if (!xSteps[j - 1]) {
    return value2;
  }
  return xPct[j - 1] + closest(value2 - xPct[j - 1], xSteps[j - 1]);
}
var Spectrum = (
  /** @class */
  function() {
    function Spectrum2(entry2, snap, singleStep) {
      this.xPct = [];
      this.xVal = [];
      this.xSteps = [];
      this.xNumSteps = [];
      this.xHighestCompleteStep = [];
      this.xSteps = [singleStep || false];
      this.xNumSteps = [false];
      this.snap = snap;
      var index2;
      var ordered = [];
      Object.keys(entry2).forEach(function(index3) {
        ordered.push([asArray(entry2[index3]), index3]);
      });
      ordered.sort(function(a2, b2) {
        return a2[0][0] - b2[0][0];
      });
      for (index2 = 0; index2 < ordered.length; index2++) {
        this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
      }
      this.xNumSteps = this.xSteps.slice(0);
      for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
        this.handleStepPoint(index2, this.xNumSteps[index2]);
      }
    }
    Spectrum2.prototype.getDistance = function(value2) {
      var distances = [];
      for (var index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
        distances[index2] = fromPercentage(this.xVal, value2, index2);
      }
      return distances;
    };
    Spectrum2.prototype.getAbsoluteDistance = function(value2, distances, direction) {
      var xPct_index = 0;
      if (value2 < this.xPct[this.xPct.length - 1]) {
        while (value2 > this.xPct[xPct_index + 1]) {
          xPct_index++;
        }
      } else if (value2 === this.xPct[this.xPct.length - 1]) {
        xPct_index = this.xPct.length - 2;
      }
      if (!direction && value2 === this.xPct[xPct_index + 1]) {
        xPct_index++;
      }
      if (distances === null) {
        distances = [];
      }
      var start_factor;
      var rest_factor = 1;
      var rest_rel_distance = distances[xPct_index];
      var range_pct = 0;
      var rel_range_distance = 0;
      var abs_distance_counter = 0;
      var range_counter = 0;
      if (direction) {
        start_factor = (value2 - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
      } else {
        start_factor = (this.xPct[xPct_index + 1] - value2) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
      }
      while (rest_rel_distance > 0) {
        range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
        if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
          rel_range_distance = range_pct * start_factor;
          rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
          start_factor = 1;
        } else {
          rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
          rest_factor = 0;
        }
        if (direction) {
          abs_distance_counter = abs_distance_counter - rel_range_distance;
          if (this.xPct.length + range_counter >= 1) {
            range_counter--;
          }
        } else {
          abs_distance_counter = abs_distance_counter + rel_range_distance;
          if (this.xPct.length - range_counter >= 1) {
            range_counter++;
          }
        }
        rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
      }
      return value2 + abs_distance_counter;
    };
    Spectrum2.prototype.toStepping = function(value2) {
      value2 = toStepping(this.xVal, this.xPct, value2);
      return value2;
    };
    Spectrum2.prototype.fromStepping = function(value2) {
      return fromStepping(this.xVal, this.xPct, value2);
    };
    Spectrum2.prototype.getStep = function(value2) {
      value2 = getStep(this.xPct, this.xSteps, this.snap, value2);
      return value2;
    };
    Spectrum2.prototype.getDefaultStep = function(value2, isDown, size2) {
      var j = getJ(value2, this.xPct);
      if (value2 === 100 || isDown && value2 === this.xPct[j - 1]) {
        j = Math.max(j - 1, 1);
      }
      return (this.xVal[j] - this.xVal[j - 1]) / size2;
    };
    Spectrum2.prototype.getNearbySteps = function(value2) {
      var j = getJ(value2, this.xPct);
      return {
        stepBefore: {
          startValue: this.xVal[j - 2],
          step: this.xNumSteps[j - 2],
          highestStep: this.xHighestCompleteStep[j - 2]
        },
        thisStep: {
          startValue: this.xVal[j - 1],
          step: this.xNumSteps[j - 1],
          highestStep: this.xHighestCompleteStep[j - 1]
        },
        stepAfter: {
          startValue: this.xVal[j],
          step: this.xNumSteps[j],
          highestStep: this.xHighestCompleteStep[j]
        }
      };
    };
    Spectrum2.prototype.countStepDecimals = function() {
      var stepDecimals = this.xNumSteps.map(countDecimals);
      return Math.max.apply(null, stepDecimals);
    };
    Spectrum2.prototype.hasNoSize = function() {
      return this.xVal[0] === this.xVal[this.xVal.length - 1];
    };
    Spectrum2.prototype.convert = function(value2) {
      return this.getStep(this.toStepping(value2));
    };
    Spectrum2.prototype.handleEntryPoint = function(index2, value2) {
      var percentage;
      if (index2 === "min") {
        percentage = 0;
      } else if (index2 === "max") {
        percentage = 100;
      } else {
        percentage = parseFloat(index2);
      }
      if (!isNumeric(percentage) || !isNumeric(value2[0])) {
        throw new Error("noUiSlider: 'range' value isn't numeric.");
      }
      this.xPct.push(percentage);
      this.xVal.push(value2[0]);
      var value1 = Number(value2[1]);
      if (!percentage) {
        if (!isNaN(value1)) {
          this.xSteps[0] = value1;
        }
      } else {
        this.xSteps.push(isNaN(value1) ? false : value1);
      }
      this.xHighestCompleteStep.push(0);
    };
    Spectrum2.prototype.handleStepPoint = function(i2, n2) {
      if (!n2) {
        return;
      }
      if (this.xVal[i2] === this.xVal[i2 + 1]) {
        this.xSteps[i2] = this.xHighestCompleteStep[i2] = this.xVal[i2];
        return;
      }
      this.xSteps[i2] = fromPercentage([this.xVal[i2], this.xVal[i2 + 1]], n2, 0) / subRangeRatio(this.xPct[i2], this.xPct[i2 + 1]);
      var totalSteps = (this.xVal[i2 + 1] - this.xVal[i2]) / this.xNumSteps[i2];
      var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
      var step = this.xVal[i2] + this.xNumSteps[i2] * highestStep;
      this.xHighestCompleteStep[i2] = step;
    };
    return Spectrum2;
  }()
);
var defaultFormatter2 = {
  to: function(value2) {
    return value2 === void 0 ? "" : value2.toFixed(2);
  },
  from: Number
};
var cssClasses = {
  target: "target",
  base: "base",
  origin: "origin",
  handle: "handle",
  handleLower: "handle-lower",
  handleUpper: "handle-upper",
  touchArea: "touch-area",
  horizontal: "horizontal",
  vertical: "vertical",
  background: "background",
  connect: "connect",
  connects: "connects",
  ltr: "ltr",
  rtl: "rtl",
  textDirectionLtr: "txt-dir-ltr",
  textDirectionRtl: "txt-dir-rtl",
  draggable: "draggable",
  drag: "state-drag",
  tap: "state-tap",
  active: "active",
  tooltip: "tooltip",
  pips: "pips",
  pipsHorizontal: "pips-horizontal",
  pipsVertical: "pips-vertical",
  marker: "marker",
  markerHorizontal: "marker-horizontal",
  markerVertical: "marker-vertical",
  markerNormal: "marker-normal",
  markerLarge: "marker-large",
  markerSub: "marker-sub",
  value: "value",
  valueHorizontal: "value-horizontal",
  valueVertical: "value-vertical",
  valueNormal: "value-normal",
  valueLarge: "value-large",
  valueSub: "value-sub"
};
var INTERNAL_EVENT_NS = {
  tooltips: ".__tooltips",
  aria: ".__aria"
};
function testStep(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'step' is not numeric.");
  }
  parsed.singleStep = entry2;
}
function testKeyboardPageMultiplier(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
  }
  parsed.keyboardPageMultiplier = entry2;
}
function testKeyboardMultiplier(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
  }
  parsed.keyboardMultiplier = entry2;
}
function testKeyboardDefaultStep(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
  }
  parsed.keyboardDefaultStep = entry2;
}
function testRange(parsed, entry2) {
  if (typeof entry2 !== "object" || Array.isArray(entry2)) {
    throw new Error("noUiSlider: 'range' is not an object.");
  }
  if (entry2.min === void 0 || entry2.max === void 0) {
    throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
  }
  parsed.spectrum = new Spectrum(entry2, parsed.snap || false, parsed.singleStep);
}
function testStart(parsed, entry2) {
  entry2 = asArray(entry2);
  if (!Array.isArray(entry2) || !entry2.length) {
    throw new Error("noUiSlider: 'start' option is incorrect.");
  }
  parsed.handles = entry2.length;
  parsed.start = entry2;
}
function testSnap(parsed, entry2) {
  if (typeof entry2 !== "boolean") {
    throw new Error("noUiSlider: 'snap' option must be a boolean.");
  }
  parsed.snap = entry2;
}
function testAnimate(parsed, entry2) {
  if (typeof entry2 !== "boolean") {
    throw new Error("noUiSlider: 'animate' option must be a boolean.");
  }
  parsed.animate = entry2;
}
function testAnimationDuration(parsed, entry2) {
  if (typeof entry2 !== "number") {
    throw new Error("noUiSlider: 'animationDuration' option must be a number.");
  }
  parsed.animationDuration = entry2;
}
function testConnect(parsed, entry2) {
  var connect = [false];
  var i2;
  if (entry2 === "lower") {
    entry2 = [true, false];
  } else if (entry2 === "upper") {
    entry2 = [false, true];
  }
  if (entry2 === true || entry2 === false) {
    for (i2 = 1; i2 < parsed.handles; i2++) {
      connect.push(entry2);
    }
    connect.push(false);
  } else if (!Array.isArray(entry2) || !entry2.length || entry2.length !== parsed.handles + 1) {
    throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
  } else {
    connect = entry2;
  }
  parsed.connect = connect;
}
function testOrientation(parsed, entry2) {
  switch (entry2) {
    case "horizontal":
      parsed.ort = 0;
      break;
    case "vertical":
      parsed.ort = 1;
      break;
    default:
      throw new Error("noUiSlider: 'orientation' option is invalid.");
  }
}
function testMargin(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'margin' option must be numeric.");
  }
  if (entry2 === 0) {
    return;
  }
  parsed.margin = parsed.spectrum.getDistance(entry2);
}
function testLimit(parsed, entry2) {
  if (!isNumeric(entry2)) {
    throw new Error("noUiSlider: 'limit' option must be numeric.");
  }
  parsed.limit = parsed.spectrum.getDistance(entry2);
  if (!parsed.limit || parsed.handles < 2) {
    throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
  }
}
function testPadding(parsed, entry2) {
  var index2;
  if (!isNumeric(entry2) && !Array.isArray(entry2)) {
    throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
  }
  if (Array.isArray(entry2) && !(entry2.length === 2 || isNumeric(entry2[0]) || isNumeric(entry2[1]))) {
    throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
  }
  if (entry2 === 0) {
    return;
  }
  if (!Array.isArray(entry2)) {
    entry2 = [entry2, entry2];
  }
  parsed.padding = [parsed.spectrum.getDistance(entry2[0]), parsed.spectrum.getDistance(entry2[1])];
  for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
    if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
      throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
    }
  }
  var totalPadding = entry2[0] + entry2[1];
  var firstValue = parsed.spectrum.xVal[0];
  var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
  if (totalPadding / (lastValue - firstValue) > 1) {
    throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
  }
}
function testDirection(parsed, entry2) {
  switch (entry2) {
    case "ltr":
      parsed.dir = 0;
      break;
    case "rtl":
      parsed.dir = 1;
      break;
    default:
      throw new Error("noUiSlider: 'direction' option was not recognized.");
  }
}
function testBehaviour(parsed, entry2) {
  if (typeof entry2 !== "string") {
    throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
  }
  var tap = entry2.indexOf("tap") >= 0;
  var drag = entry2.indexOf("drag") >= 0;
  var fixed = entry2.indexOf("fixed") >= 0;
  var snap = entry2.indexOf("snap") >= 0;
  var hover = entry2.indexOf("hover") >= 0;
  var unconstrained = entry2.indexOf("unconstrained") >= 0;
  var invertConnects = entry2.indexOf("invert-connects") >= 0;
  var dragAll = entry2.indexOf("drag-all") >= 0;
  var smoothSteps = entry2.indexOf("smooth-steps") >= 0;
  if (fixed) {
    if (parsed.handles !== 2) {
      throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
    }
    testMargin(parsed, parsed.start[1] - parsed.start[0]);
  }
  if (invertConnects && parsed.handles !== 2) {
    throw new Error("noUiSlider: 'invert-connects' behaviour must be used with 2 handles");
  }
  if (unconstrained && (parsed.margin || parsed.limit)) {
    throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
  }
  parsed.events = {
    tap: tap || snap,
    drag,
    dragAll,
    smoothSteps,
    fixed,
    snap,
    hover,
    unconstrained,
    invertConnects
  };
}
function testTooltips(parsed, entry2) {
  if (entry2 === false) {
    return;
  }
  if (entry2 === true || isValidPartialFormatter(entry2)) {
    parsed.tooltips = [];
    for (var i2 = 0; i2 < parsed.handles; i2++) {
      parsed.tooltips.push(entry2);
    }
  } else {
    entry2 = asArray(entry2);
    if (entry2.length !== parsed.handles) {
      throw new Error("noUiSlider: must pass a formatter for all handles.");
    }
    entry2.forEach(function(formatter) {
      if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
        throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
      }
    });
    parsed.tooltips = entry2;
  }
}
function testHandleAttributes(parsed, entry2) {
  if (entry2.length !== parsed.handles) {
    throw new Error("noUiSlider: must pass a attributes for all handles.");
  }
  parsed.handleAttributes = entry2;
}
function testAriaFormat(parsed, entry2) {
  if (!isValidPartialFormatter(entry2)) {
    throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
  }
  parsed.ariaFormat = entry2;
}
function testFormat(parsed, entry2) {
  if (!isValidFormatter(entry2)) {
    throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
  }
  parsed.format = entry2;
}
function testKeyboardSupport(parsed, entry2) {
  if (typeof entry2 !== "boolean") {
    throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
  }
  parsed.keyboardSupport = entry2;
}
function testDocumentElement(parsed, entry2) {
  parsed.documentElement = entry2;
}
function testCssPrefix(parsed, entry2) {
  if (typeof entry2 !== "string" && entry2 !== false) {
    throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
  }
  parsed.cssPrefix = entry2;
}
function testCssClasses(parsed, entry2) {
  if (typeof entry2 !== "object") {
    throw new Error("noUiSlider: 'cssClasses' must be an object.");
  }
  if (typeof parsed.cssPrefix === "string") {
    parsed.cssClasses = {};
    Object.keys(entry2).forEach(function(key) {
      parsed.cssClasses[key] = parsed.cssPrefix + entry2[key];
    });
  } else {
    parsed.cssClasses = entry2;
  }
}
function testOptions(options2) {
  var parsed = {
    margin: null,
    limit: null,
    padding: null,
    animate: true,
    animationDuration: 300,
    ariaFormat: defaultFormatter2,
    format: defaultFormatter2
  };
  var tests = {
    step: { r: false, t: testStep },
    keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
    keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
    keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
    start: { r: true, t: testStart },
    connect: { r: true, t: testConnect },
    direction: { r: true, t: testDirection },
    snap: { r: false, t: testSnap },
    animate: { r: false, t: testAnimate },
    animationDuration: { r: false, t: testAnimationDuration },
    range: { r: true, t: testRange },
    orientation: { r: false, t: testOrientation },
    margin: { r: false, t: testMargin },
    limit: { r: false, t: testLimit },
    padding: { r: false, t: testPadding },
    behaviour: { r: true, t: testBehaviour },
    ariaFormat: { r: false, t: testAriaFormat },
    format: { r: false, t: testFormat },
    tooltips: { r: false, t: testTooltips },
    keyboardSupport: { r: true, t: testKeyboardSupport },
    documentElement: { r: false, t: testDocumentElement },
    cssPrefix: { r: true, t: testCssPrefix },
    cssClasses: { r: true, t: testCssClasses },
    handleAttributes: { r: false, t: testHandleAttributes }
  };
  var defaults3 = {
    connect: false,
    direction: "ltr",
    behaviour: "tap",
    orientation: "horizontal",
    keyboardSupport: true,
    cssPrefix: "noUi-",
    cssClasses,
    keyboardPageMultiplier: 5,
    keyboardMultiplier: 1,
    keyboardDefaultStep: 10
  };
  if (options2.format && !options2.ariaFormat) {
    options2.ariaFormat = options2.format;
  }
  Object.keys(tests).forEach(function(name) {
    if (!isSet(options2[name]) && defaults3[name] === void 0) {
      if (tests[name].r) {
        throw new Error("noUiSlider: '" + name + "' is required.");
      }
      return;
    }
    tests[name].t(parsed, !isSet(options2[name]) ? defaults3[name] : options2[name]);
  });
  parsed.pips = options2.pips;
  var d = document.createElement("div");
  var msPrefix = d.style.msTransform !== void 0;
  var noPrefix = d.style.transform !== void 0;
  parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
  var styles3 = [
    ["left", "top"],
    ["right", "bottom"]
  ];
  parsed.style = styles3[parsed.dir][parsed.ort];
  return parsed;
}
function scope(target, options2, originalOptions) {
  var actions = getActions();
  var supportsTouchActionNone = getSupportsTouchActionNone();
  var supportsPassive = supportsTouchActionNone && getSupportsPassive();
  var scope_Target = target;
  var scope_Base;
  var scope_ConnectBase;
  var scope_Handles;
  var scope_Connects;
  var scope_Pips;
  var scope_Tooltips;
  var scope_Spectrum = options2.spectrum;
  var scope_Values = [];
  var scope_Locations = [];
  var scope_HandleNumbers = [];
  var scope_ActiveHandlesCount = 0;
  var scope_Events = {};
  var scope_ConnectsInverted = false;
  var scope_Document = target.ownerDocument;
  var scope_DocumentElement = options2.documentElement || scope_Document.documentElement;
  var scope_Body = scope_Document.body;
  var scope_DirOffset = scope_Document.dir === "rtl" || options2.ort === 1 ? 0 : 100;
  function addNodeTo(addTarget, className) {
    var div2 = scope_Document.createElement("div");
    if (className) {
      addClass(div2, className);
    }
    addTarget.appendChild(div2);
    return div2;
  }
  function addOrigin(base2, handleNumber) {
    var origin = addNodeTo(base2, options2.cssClasses.origin);
    var handle2 = addNodeTo(origin, options2.cssClasses.handle);
    addNodeTo(handle2, options2.cssClasses.touchArea);
    handle2.setAttribute("data-handle", String(handleNumber));
    if (options2.keyboardSupport) {
      handle2.setAttribute("tabindex", "0");
      handle2.addEventListener("keydown", function(event2) {
        return eventKeydown(event2, handleNumber);
      });
    }
    if (options2.handleAttributes !== void 0) {
      var attributes_1 = options2.handleAttributes[handleNumber];
      Object.keys(attributes_1).forEach(function(attribute) {
        handle2.setAttribute(attribute, attributes_1[attribute]);
      });
    }
    handle2.setAttribute("role", "slider");
    handle2.setAttribute("aria-orientation", options2.ort ? "vertical" : "horizontal");
    if (handleNumber === 0) {
      addClass(handle2, options2.cssClasses.handleLower);
    } else if (handleNumber === options2.handles - 1) {
      addClass(handle2, options2.cssClasses.handleUpper);
    }
    origin.handle = handle2;
    return origin;
  }
  function addConnect(base2, add2) {
    if (!add2) {
      return false;
    }
    return addNodeTo(base2, options2.cssClasses.connect);
  }
  function addElements(connectOptions, base2) {
    scope_ConnectBase = addNodeTo(base2, options2.cssClasses.connects);
    scope_Handles = [];
    scope_Connects = [];
    scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[0]));
    for (var i2 = 0; i2 < options2.handles; i2++) {
      scope_Handles.push(addOrigin(base2, i2));
      scope_HandleNumbers[i2] = i2;
      scope_Connects.push(addConnect(scope_ConnectBase, connectOptions[i2 + 1]));
    }
  }
  function addSlider(addTarget) {
    addClass(addTarget, options2.cssClasses.target);
    if (options2.dir === 0) {
      addClass(addTarget, options2.cssClasses.ltr);
    } else {
      addClass(addTarget, options2.cssClasses.rtl);
    }
    if (options2.ort === 0) {
      addClass(addTarget, options2.cssClasses.horizontal);
    } else {
      addClass(addTarget, options2.cssClasses.vertical);
    }
    var textDirection = getComputedStyle(addTarget).direction;
    if (textDirection === "rtl") {
      addClass(addTarget, options2.cssClasses.textDirectionRtl);
    } else {
      addClass(addTarget, options2.cssClasses.textDirectionLtr);
    }
    return addNodeTo(addTarget, options2.cssClasses.base);
  }
  function addTooltip(handle2, handleNumber) {
    if (!options2.tooltips || !options2.tooltips[handleNumber]) {
      return false;
    }
    return addNodeTo(handle2.firstChild, options2.cssClasses.tooltip);
  }
  function isSliderDisabled() {
    return scope_Target.hasAttribute("disabled");
  }
  function isHandleDisabled(handleNumber) {
    var handleOrigin = scope_Handles[handleNumber];
    return handleOrigin.hasAttribute("disabled");
  }
  function disable(handleNumber) {
    if (handleNumber !== null && handleNumber !== void 0) {
      scope_Handles[handleNumber].setAttribute("disabled", "");
      scope_Handles[handleNumber].handle.removeAttribute("tabindex");
    } else {
      scope_Target.setAttribute("disabled", "");
      scope_Handles.forEach(function(handle2) {
        handle2.handle.removeAttribute("tabindex");
      });
    }
  }
  function enable(handleNumber) {
    if (handleNumber !== null && handleNumber !== void 0) {
      scope_Handles[handleNumber].removeAttribute("disabled");
      scope_Handles[handleNumber].handle.setAttribute("tabindex", "0");
    } else {
      scope_Target.removeAttribute("disabled");
      scope_Handles.forEach(function(handle2) {
        handle2.removeAttribute("disabled");
        handle2.handle.setAttribute("tabindex", "0");
      });
    }
  }
  function removeTooltips() {
    if (scope_Tooltips) {
      removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
      scope_Tooltips.forEach(function(tooltip) {
        if (tooltip) {
          removeElement(tooltip);
        }
      });
      scope_Tooltips = null;
    }
  }
  function tooltips2() {
    removeTooltips();
    scope_Tooltips = scope_Handles.map(addTooltip);
    bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values2, handleNumber, unencoded) {
      if (!scope_Tooltips || !options2.tooltips) {
        return;
      }
      if (scope_Tooltips[handleNumber] === false) {
        return;
      }
      var formattedValue = values2[handleNumber];
      if (options2.tooltips[handleNumber] !== true) {
        formattedValue = options2.tooltips[handleNumber].to(unencoded[handleNumber]);
      }
      scope_Tooltips[handleNumber].innerHTML = formattedValue;
    });
  }
  function aria() {
    removeEvent("update" + INTERNAL_EVENT_NS.aria);
    bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values2, handleNumber, unencoded, tap, positions) {
      scope_HandleNumbers.forEach(function(index2) {
        var handle2 = scope_Handles[index2];
        var min10 = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
        var max18 = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
        var now = positions[index2];
        var text2 = String(options2.ariaFormat.to(unencoded[index2]));
        min10 = scope_Spectrum.fromStepping(min10).toFixed(1);
        max18 = scope_Spectrum.fromStepping(max18).toFixed(1);
        now = scope_Spectrum.fromStepping(now).toFixed(1);
        handle2.children[0].setAttribute("aria-valuemin", min10);
        handle2.children[0].setAttribute("aria-valuemax", max18);
        handle2.children[0].setAttribute("aria-valuenow", now);
        handle2.children[0].setAttribute("aria-valuetext", text2);
      });
    });
  }
  function getGroup(pips2) {
    if (pips2.mode === PipsMode.Range || pips2.mode === PipsMode.Steps) {
      return scope_Spectrum.xVal;
    }
    if (pips2.mode === PipsMode.Count) {
      if (pips2.values < 2) {
        throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
      }
      var interval = pips2.values - 1;
      var spread = 100 / interval;
      var values2 = [];
      while (interval--) {
        values2[interval] = interval * spread;
      }
      values2.push(100);
      return mapToRange(values2, pips2.stepped);
    }
    if (pips2.mode === PipsMode.Positions) {
      return mapToRange(pips2.values, pips2.stepped);
    }
    if (pips2.mode === PipsMode.Values) {
      if (pips2.stepped) {
        return pips2.values.map(function(value2) {
          return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value2)));
        });
      }
      return pips2.values;
    }
    return [];
  }
  function mapToRange(values2, stepped) {
    return values2.map(function(value2) {
      return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value2) : value2);
    });
  }
  function generateSpread(pips2) {
    function safeIncrement(value2, increment) {
      return Number((value2 + increment).toFixed(7));
    }
    var group = getGroup(pips2);
    var indexes = {};
    var firstInRange = scope_Spectrum.xVal[0];
    var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
    var ignoreFirst = false;
    var ignoreLast = false;
    var prevPct = 0;
    group = unique(group.slice().sort(function(a2, b2) {
      return a2 - b2;
    }));
    if (group[0] !== firstInRange) {
      group.unshift(firstInRange);
      ignoreFirst = true;
    }
    if (group[group.length - 1] !== lastInRange) {
      group.push(lastInRange);
      ignoreLast = true;
    }
    group.forEach(function(current, index2) {
      var step;
      var i2;
      var q2;
      var low = current;
      var high = group[index2 + 1];
      var newPct;
      var pctDifference;
      var pctPos;
      var type;
      var steps;
      var realSteps;
      var stepSize;
      var isSteps = pips2.mode === PipsMode.Steps;
      if (isSteps) {
        step = scope_Spectrum.xNumSteps[index2];
      }
      if (!step) {
        step = high - low;
      }
      if (high === void 0) {
        high = low;
      }
      step = Math.max(step, 1e-7);
      for (i2 = low; i2 <= high; i2 = safeIncrement(i2, step)) {
        newPct = scope_Spectrum.toStepping(i2);
        pctDifference = newPct - prevPct;
        steps = pctDifference / (pips2.density || 1);
        realSteps = Math.round(steps);
        stepSize = pctDifference / realSteps;
        for (q2 = 1; q2 <= realSteps; q2 += 1) {
          pctPos = prevPct + q2 * stepSize;
          indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
        }
        type = group.indexOf(i2) > -1 ? PipsType.LargeValue : isSteps ? PipsType.SmallValue : PipsType.NoValue;
        if (!index2 && ignoreFirst && i2 !== high) {
          type = 0;
        }
        if (!(i2 === high && ignoreLast)) {
          indexes[newPct.toFixed(5)] = [i2, type];
        }
        prevPct = newPct;
      }
    });
    return indexes;
  }
  function addMarking(spread, filterFunc, formatter) {
    var _a34, _b4;
    var element = scope_Document.createElement("div");
    var valueSizeClasses = (_a34 = {}, _a34[PipsType.None] = "", _a34[PipsType.NoValue] = options2.cssClasses.valueNormal, _a34[PipsType.LargeValue] = options2.cssClasses.valueLarge, _a34[PipsType.SmallValue] = options2.cssClasses.valueSub, _a34);
    var markerSizeClasses = (_b4 = {}, _b4[PipsType.None] = "", _b4[PipsType.NoValue] = options2.cssClasses.markerNormal, _b4[PipsType.LargeValue] = options2.cssClasses.markerLarge, _b4[PipsType.SmallValue] = options2.cssClasses.markerSub, _b4);
    var valueOrientationClasses = [options2.cssClasses.valueHorizontal, options2.cssClasses.valueVertical];
    var markerOrientationClasses = [options2.cssClasses.markerHorizontal, options2.cssClasses.markerVertical];
    addClass(element, options2.cssClasses.pips);
    addClass(element, options2.ort === 0 ? options2.cssClasses.pipsHorizontal : options2.cssClasses.pipsVertical);
    function getClasses(type, source2) {
      var a2 = source2 === options2.cssClasses.value;
      var orientationClasses = a2 ? valueOrientationClasses : markerOrientationClasses;
      var sizeClasses = a2 ? valueSizeClasses : markerSizeClasses;
      return source2 + " " + orientationClasses[options2.ort] + " " + sizeClasses[type];
    }
    function addSpread(offset3, value2, type) {
      type = filterFunc ? filterFunc(value2, type) : type;
      if (type === PipsType.None) {
        return;
      }
      var node = addNodeTo(element, false);
      node.className = getClasses(type, options2.cssClasses.marker);
      node.style[options2.style] = offset3 + "%";
      if (type > PipsType.NoValue) {
        node = addNodeTo(element, false);
        node.className = getClasses(type, options2.cssClasses.value);
        node.setAttribute("data-value", String(value2));
        node.style[options2.style] = offset3 + "%";
        node.innerHTML = String(formatter.to(value2));
      }
    }
    Object.keys(spread).forEach(function(offset3) {
      addSpread(offset3, spread[offset3][0], spread[offset3][1]);
    });
    return element;
  }
  function removePips() {
    if (scope_Pips) {
      removeElement(scope_Pips);
      scope_Pips = null;
    }
  }
  function pips(pips2) {
    removePips();
    var spread = generateSpread(pips2);
    var filter2 = pips2.filter;
    var format7 = pips2.format || {
      to: function(value2) {
        return String(Math.round(value2));
      }
    };
    scope_Pips = scope_Target.appendChild(addMarking(spread, filter2, format7));
    return scope_Pips;
  }
  function baseSize() {
    var rect = scope_Base.getBoundingClientRect();
    var alt = "offset" + ["Width", "Height"][options2.ort];
    return options2.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
  }
  function attachEvent(events3, element, callback, data3) {
    var method = function(event2) {
      var e = fixEvent(event2, data3.pageOffset, data3.target || element);
      if (!e) {
        return false;
      }
      if (isSliderDisabled() && !data3.doNotReject) {
        return false;
      }
      if (hasClass(scope_Target, options2.cssClasses.tap) && !data3.doNotReject) {
        return false;
      }
      if (events3 === actions.start && e.buttons !== void 0 && e.buttons > 1) {
        return false;
      }
      if (data3.hover && e.buttons) {
        return false;
      }
      if (!supportsPassive) {
        e.preventDefault();
      }
      e.calcPoint = e.points[options2.ort];
      callback(e, data3);
      return;
    };
    var methods = [];
    events3.split(" ").forEach(function(eventName) {
      element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
      methods.push([eventName, method]);
    });
    return methods;
  }
  function fixEvent(e, pageOffset, eventTarget) {
    var touch = e.type.indexOf("touch") === 0;
    var mouse = e.type.indexOf("mouse") === 0;
    var pointer = e.type.indexOf("pointer") === 0;
    var x2 = 0;
    var y2 = 0;
    if (e.type.indexOf("MSPointer") === 0) {
      pointer = true;
    }
    if (e.type === "mousedown" && !e.buttons && !e.touches) {
      return false;
    }
    if (touch) {
      var isTouchOnTarget = function(checkTouch) {
        var target2 = checkTouch.target;
        return target2 === eventTarget || eventTarget.contains(target2) || e.composed && e.composedPath().shift() === eventTarget;
      };
      if (e.type === "touchstart") {
        var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
        if (targetTouches.length > 1) {
          return false;
        }
        x2 = targetTouches[0].pageX;
        y2 = targetTouches[0].pageY;
      } else {
        var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
        if (!targetTouch) {
          return false;
        }
        x2 = targetTouch.pageX;
        y2 = targetTouch.pageY;
      }
    }
    pageOffset = pageOffset || getPageOffset(scope_Document);
    if (mouse || pointer) {
      x2 = e.clientX + pageOffset.x;
      y2 = e.clientY + pageOffset.y;
    }
    e.pageOffset = pageOffset;
    e.points = [x2, y2];
    e.cursor = mouse || pointer;
    return e;
  }
  function calcPointToPercentage(calcPoint) {
    var location = calcPoint - offset2(scope_Base, options2.ort);
    var proposal = location * 100 / baseSize();
    proposal = limit(proposal);
    return options2.dir ? 100 - proposal : proposal;
  }
  function getClosestHandle(clickedPosition) {
    var smallestDifference = 100;
    var handleNumber = false;
    scope_Handles.forEach(function(handle2, index2) {
      if (isHandleDisabled(index2)) {
        return;
      }
      var handlePosition = scope_Locations[index2];
      var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
      var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
      var isCloser = differenceWithThisHandle < smallestDifference;
      var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
      if (isCloser || isCloserAfter || clickAtEdge) {
        handleNumber = index2;
        smallestDifference = differenceWithThisHandle;
      }
    });
    return handleNumber;
  }
  function documentLeave(event2, data3) {
    if (event2.type === "mouseout" && event2.target.nodeName === "HTML" && event2.relatedTarget === null) {
      eventEnd(event2, data3);
    }
  }
  function eventMove(event2, data3) {
    if (navigator.appVersion.indexOf("MSIE 9") === -1 && event2.buttons === 0 && data3.buttonsProperty !== 0) {
      return eventEnd(event2, data3);
    }
    var movement = (options2.dir ? -1 : 1) * (event2.calcPoint - data3.startCalcPoint);
    var proposal = movement * 100 / data3.baseSize;
    moveHandles(movement > 0, proposal, data3.locations, data3.handleNumbers, data3.connect);
  }
  function eventEnd(event2, data3) {
    if (data3.handle) {
      removeClass(data3.handle, options2.cssClasses.active);
      scope_ActiveHandlesCount -= 1;
    }
    data3.listeners.forEach(function(c) {
      scope_DocumentElement.removeEventListener(c[0], c[1]);
    });
    if (scope_ActiveHandlesCount === 0) {
      removeClass(scope_Target, options2.cssClasses.drag);
      setZindex();
      if (event2.cursor) {
        scope_Body.style.cursor = "";
        scope_Body.removeEventListener("selectstart", preventDefault);
      }
    }
    if (options2.events.smoothSteps) {
      data3.handleNumbers.forEach(function(handleNumber) {
        setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
      });
      data3.handleNumbers.forEach(function(handleNumber) {
        fireEvent("update", handleNumber);
      });
    }
    data3.handleNumbers.forEach(function(handleNumber) {
      fireEvent("change", handleNumber);
      fireEvent("set", handleNumber);
      fireEvent("end", handleNumber);
    });
  }
  function eventStart(event2, data3) {
    if (data3.handleNumbers.some(isHandleDisabled)) {
      return;
    }
    var handle2;
    if (data3.handleNumbers.length === 1) {
      var handleOrigin = scope_Handles[data3.handleNumbers[0]];
      handle2 = handleOrigin.children[0];
      scope_ActiveHandlesCount += 1;
      addClass(handle2, options2.cssClasses.active);
    }
    event2.stopPropagation();
    var listeners = [];
    var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
      // The event target has changed so we need to propagate the original one so that we keep
      // relying on it to extract target touches.
      target: event2.target,
      handle: handle2,
      connect: data3.connect,
      listeners,
      startCalcPoint: event2.calcPoint,
      baseSize: baseSize(),
      pageOffset: event2.pageOffset,
      handleNumbers: data3.handleNumbers,
      buttonsProperty: event2.buttons,
      locations: scope_Locations.slice()
    });
    var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
      target: event2.target,
      handle: handle2,
      listeners,
      doNotReject: true,
      handleNumbers: data3.handleNumbers
    });
    var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
      target: event2.target,
      handle: handle2,
      listeners,
      doNotReject: true,
      handleNumbers: data3.handleNumbers
    });
    listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
    if (event2.cursor) {
      scope_Body.style.cursor = getComputedStyle(event2.target).cursor;
      if (scope_Handles.length > 1) {
        addClass(scope_Target, options2.cssClasses.drag);
      }
      scope_Body.addEventListener("selectstart", preventDefault, false);
    }
    data3.handleNumbers.forEach(function(handleNumber) {
      fireEvent("start", handleNumber);
    });
  }
  function eventTap(event2) {
    event2.stopPropagation();
    var proposal = calcPointToPercentage(event2.calcPoint);
    var handleNumber = getClosestHandle(proposal);
    if (handleNumber === false) {
      return;
    }
    if (!options2.events.snap) {
      addClassFor(scope_Target, options2.cssClasses.tap, options2.animationDuration);
    }
    setHandle(handleNumber, proposal, true, true);
    setZindex();
    fireEvent("slide", handleNumber, true);
    fireEvent("update", handleNumber, true);
    if (!options2.events.snap) {
      fireEvent("change", handleNumber, true);
      fireEvent("set", handleNumber, true);
    } else {
      eventStart(event2, { handleNumbers: [handleNumber] });
    }
  }
  function eventHover(event2) {
    var proposal = calcPointToPercentage(event2.calcPoint);
    var to = scope_Spectrum.getStep(proposal);
    var value2 = scope_Spectrum.fromStepping(to);
    Object.keys(scope_Events).forEach(function(targetEvent) {
      if ("hover" === targetEvent.split(".")[0]) {
        scope_Events[targetEvent].forEach(function(callback) {
          callback.call(scope_Self, value2);
        });
      }
    });
  }
  function eventKeydown(event2, handleNumber) {
    if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
      return false;
    }
    var horizontalKeys = ["Left", "Right"];
    var verticalKeys = ["Down", "Up"];
    var largeStepKeys = ["PageDown", "PageUp"];
    var edgeKeys = ["Home", "End"];
    if (options2.dir && !options2.ort) {
      horizontalKeys.reverse();
    } else if (options2.ort && !options2.dir) {
      verticalKeys.reverse();
      largeStepKeys.reverse();
    }
    var key = event2.key.replace("Arrow", "");
    var isLargeDown = key === largeStepKeys[0];
    var isLargeUp = key === largeStepKeys[1];
    var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
    var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
    var isMin = key === edgeKeys[0];
    var isMax = key === edgeKeys[1];
    if (!isDown && !isUp && !isMin && !isMax) {
      return true;
    }
    event2.preventDefault();
    var to;
    if (isUp || isDown) {
      var direction = isDown ? 0 : 1;
      var steps = getNextStepsForHandle(handleNumber);
      var step = steps[direction];
      if (step === null) {
        return false;
      }
      if (step === false) {
        step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options2.keyboardDefaultStep);
      }
      if (isLargeUp || isLargeDown) {
        step *= options2.keyboardPageMultiplier;
      } else {
        step *= options2.keyboardMultiplier;
      }
      step = Math.max(step, 1e-7);
      step = (isDown ? -1 : 1) * step;
      to = scope_Values[handleNumber] + step;
    } else if (isMax) {
      to = options2.spectrum.xVal[options2.spectrum.xVal.length - 1];
    } else {
      to = options2.spectrum.xVal[0];
    }
    setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
    fireEvent("slide", handleNumber);
    fireEvent("update", handleNumber);
    fireEvent("change", handleNumber);
    fireEvent("set", handleNumber);
    return false;
  }
  function bindSliderEvents(behaviour) {
    if (!behaviour.fixed) {
      scope_Handles.forEach(function(handle2, index2) {
        attachEvent(actions.start, handle2.children[0], eventStart, {
          handleNumbers: [index2]
        });
      });
    }
    if (behaviour.tap) {
      attachEvent(actions.start, scope_Base, eventTap, {});
    }
    if (behaviour.hover) {
      attachEvent(actions.move, scope_Base, eventHover, {
        hover: true
      });
    }
    if (behaviour.drag) {
      scope_Connects.forEach(function(connect, index2) {
        if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
          return;
        }
        var handleBefore = scope_Handles[index2 - 1];
        var handleAfter = scope_Handles[index2];
        var eventHolders = [connect];
        var handlesToDrag = [handleBefore, handleAfter];
        var handleNumbersToDrag = [index2 - 1, index2];
        addClass(connect, options2.cssClasses.draggable);
        if (behaviour.fixed) {
          eventHolders.push(handleBefore.children[0]);
          eventHolders.push(handleAfter.children[0]);
        }
        if (behaviour.dragAll) {
          handlesToDrag = scope_Handles;
          handleNumbersToDrag = scope_HandleNumbers;
        }
        eventHolders.forEach(function(eventHolder) {
          attachEvent(actions.start, eventHolder, eventStart, {
            handles: handlesToDrag,
            handleNumbers: handleNumbersToDrag,
            connect
          });
        });
      });
    }
  }
  function bindEvent(namespacedEvent, callback) {
    scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
    scope_Events[namespacedEvent].push(callback);
    if (namespacedEvent.split(".")[0] === "update") {
      scope_Handles.forEach(function(a2, index2) {
        fireEvent("update", index2);
      });
    }
  }
  function isInternalNamespace(namespace) {
    return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
  }
  function removeEvent(namespacedEvent) {
    var event2 = namespacedEvent && namespacedEvent.split(".")[0];
    var namespace = event2 ? namespacedEvent.substring(event2.length) : namespacedEvent;
    Object.keys(scope_Events).forEach(function(bind) {
      var tEvent = bind.split(".")[0];
      var tNamespace = bind.substring(tEvent.length);
      if ((!event2 || event2 === tEvent) && (!namespace || namespace === tNamespace)) {
        if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
          delete scope_Events[bind];
        }
      }
    });
  }
  function fireEvent(eventName, handleNumber, tap) {
    Object.keys(scope_Events).forEach(function(targetEvent) {
      var eventType = targetEvent.split(".")[0];
      if (eventName === eventType) {
        scope_Events[targetEvent].forEach(function(callback) {
          callback.call(
            // Use the slider public API as the scope ('this')
            scope_Self,
            // Return values as array, so arg_1[arg_2] is always valid.
            scope_Values.map(options2.format.to),
            // Handle index, 0 or 1
            handleNumber,
            // Un-formatted slider values
            scope_Values.slice(),
            // Event is fired by tap, true or false
            tap || false,
            // Left offset of the handle, in relation to the slider
            scope_Locations.slice(),
            // add the slider public API to an accessible parameter when this is unavailable
            scope_Self
          );
        });
      }
    });
  }
  function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
    var distance;
    if (scope_Handles.length > 1 && !options2.events.unconstrained) {
      if (lookBackward && handleNumber > 0) {
        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options2.margin, false);
        to = Math.max(to, distance);
      }
      if (lookForward && handleNumber < scope_Handles.length - 1) {
        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options2.margin, true);
        to = Math.min(to, distance);
      }
    }
    if (scope_Handles.length > 1 && options2.limit) {
      if (lookBackward && handleNumber > 0) {
        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options2.limit, false);
        to = Math.min(to, distance);
      }
      if (lookForward && handleNumber < scope_Handles.length - 1) {
        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options2.limit, true);
        to = Math.max(to, distance);
      }
    }
    if (options2.padding) {
      if (handleNumber === 0) {
        distance = scope_Spectrum.getAbsoluteDistance(0, options2.padding[0], false);
        to = Math.max(to, distance);
      }
      if (handleNumber === scope_Handles.length - 1) {
        distance = scope_Spectrum.getAbsoluteDistance(100, options2.padding[1], true);
        to = Math.min(to, distance);
      }
    }
    if (!smoothSteps) {
      to = scope_Spectrum.getStep(to);
    }
    to = limit(to);
    if (to === reference[handleNumber] && !getValue) {
      return false;
    }
    return to;
  }
  function inRuleOrder(v, a2) {
    var o = options2.ort;
    return (o ? a2 : v) + ", " + (o ? v : a2);
  }
  function moveHandles(upward, proposal, locations, handleNumbers, connect) {
    var proposals = locations.slice();
    var firstHandle = handleNumbers[0];
    var smoothSteps = options2.events.smoothSteps;
    var b2 = [!upward, upward];
    var f2 = [upward, !upward];
    handleNumbers = handleNumbers.slice();
    if (upward) {
      handleNumbers.reverse();
    }
    if (handleNumbers.length > 1) {
      handleNumbers.forEach(function(handleNumber, o) {
        var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b2[o], f2[o], false, smoothSteps);
        if (to === false) {
          proposal = 0;
        } else {
          proposal = to - proposals[handleNumber];
          proposals[handleNumber] = to;
        }
      });
    } else {
      b2 = f2 = [true];
    }
    var state = false;
    handleNumbers.forEach(function(handleNumber, o) {
      state = setHandle(handleNumber, locations[handleNumber] + proposal, b2[o], f2[o], false, smoothSteps) || state;
    });
    if (state) {
      handleNumbers.forEach(function(handleNumber) {
        fireEvent("update", handleNumber);
        fireEvent("slide", handleNumber);
      });
      if (connect != void 0) {
        fireEvent("drag", firstHandle);
      }
    }
  }
  function transformDirection(a2, b2) {
    return options2.dir ? 100 - a2 - b2 : a2;
  }
  function updateHandlePosition(handleNumber, to) {
    scope_Locations[handleNumber] = to;
    scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
    var translation = transformDirection(to, 0) - scope_DirOffset;
    var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
    scope_Handles[handleNumber].style[options2.transformRule] = translateRule;
    if (options2.events.invertConnects && scope_Locations.length > 1) {
      var handlesAreInOrder = scope_Locations.every(function(position2, index2, locations) {
        return index2 === 0 || position2 >= locations[index2 - 1];
      });
      if (scope_ConnectsInverted !== !handlesAreInOrder) {
        invertConnects();
        return;
      }
    }
    updateConnect(handleNumber);
    updateConnect(handleNumber + 1);
    if (scope_ConnectsInverted) {
      updateConnect(handleNumber - 1);
      updateConnect(handleNumber + 2);
    }
  }
  function setZindex() {
    scope_HandleNumbers.forEach(function(handleNumber) {
      var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
      var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
      scope_Handles[handleNumber].style.zIndex = String(zIndex);
    });
  }
  function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
    if (!exactInput) {
      to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
    }
    if (to === false) {
      return false;
    }
    updateHandlePosition(handleNumber, to);
    return true;
  }
  function updateConnect(index2) {
    if (!scope_Connects[index2]) {
      return;
    }
    var locations = scope_Locations.slice();
    if (scope_ConnectsInverted) {
      locations.sort(function(a2, b2) {
        return a2 - b2;
      });
    }
    var l = 0;
    var h7 = 100;
    if (index2 !== 0) {
      l = locations[index2 - 1];
    }
    if (index2 !== scope_Connects.length - 1) {
      h7 = locations[index2];
    }
    var connectWidth = h7 - l;
    var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
    var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
    scope_Connects[index2].style[options2.transformRule] = translateRule + " " + scaleRule;
  }
  function resolveToValue(to, handleNumber) {
    if (to === null || to === false || to === void 0) {
      return scope_Locations[handleNumber];
    }
    if (typeof to === "number") {
      to = String(to);
    }
    to = options2.format.from(to);
    if (to !== false) {
      to = scope_Spectrum.toStepping(to);
    }
    if (to === false || isNaN(to)) {
      return scope_Locations[handleNumber];
    }
    return to;
  }
  function valueSet(input12, fireSetEvent, exactInput) {
    var values2 = asArray(input12);
    var isInit = scope_Locations[0] === void 0;
    fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
    if (options2.animate && !isInit) {
      addClassFor(scope_Target, options2.cssClasses.tap, options2.animationDuration);
    }
    scope_HandleNumbers.forEach(function(handleNumber) {
      setHandle(handleNumber, resolveToValue(values2[handleNumber], handleNumber), true, false, exactInput);
    });
    var i2 = scope_HandleNumbers.length === 1 ? 0 : 1;
    if (isInit && scope_Spectrum.hasNoSize()) {
      exactInput = true;
      scope_Locations[0] = 0;
      if (scope_HandleNumbers.length > 1) {
        var space_1 = 100 / (scope_HandleNumbers.length - 1);
        scope_HandleNumbers.forEach(function(handleNumber) {
          scope_Locations[handleNumber] = handleNumber * space_1;
        });
      }
    }
    for (; i2 < scope_HandleNumbers.length; ++i2) {
      scope_HandleNumbers.forEach(function(handleNumber) {
        setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
      });
    }
    setZindex();
    scope_HandleNumbers.forEach(function(handleNumber) {
      fireEvent("update", handleNumber);
      if (values2[handleNumber] !== null && fireSetEvent) {
        fireEvent("set", handleNumber);
      }
    });
  }
  function valueReset(fireSetEvent) {
    valueSet(options2.start, fireSetEvent);
  }
  function valueSetHandle(handleNumber, value2, fireSetEvent, exactInput) {
    handleNumber = Number(handleNumber);
    if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
      throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
    }
    setHandle(handleNumber, resolveToValue(value2, handleNumber), true, true, exactInput);
    fireEvent("update", handleNumber);
    if (fireSetEvent) {
      fireEvent("set", handleNumber);
    }
  }
  function valueGet(unencoded) {
    if (unencoded === void 0) {
      unencoded = false;
    }
    if (unencoded) {
      return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
    }
    var values2 = scope_Values.map(options2.format.to);
    if (values2.length === 1) {
      return values2[0];
    }
    return values2;
  }
  function destroy2() {
    removeEvent(INTERNAL_EVENT_NS.aria);
    removeEvent(INTERNAL_EVENT_NS.tooltips);
    Object.keys(options2.cssClasses).forEach(function(key) {
      removeClass(scope_Target, options2.cssClasses[key]);
    });
    while (scope_Target.firstChild) {
      scope_Target.removeChild(scope_Target.firstChild);
    }
    delete scope_Target.noUiSlider;
  }
  function getNextStepsForHandle(handleNumber) {
    var location = scope_Locations[handleNumber];
    var nearbySteps = scope_Spectrum.getNearbySteps(location);
    var value2 = scope_Values[handleNumber];
    var increment = nearbySteps.thisStep.step;
    var decrement = null;
    if (options2.snap) {
      return [
        value2 - nearbySteps.stepBefore.startValue || null,
        nearbySteps.stepAfter.startValue - value2 || null
      ];
    }
    if (increment !== false) {
      if (value2 + increment > nearbySteps.stepAfter.startValue) {
        increment = nearbySteps.stepAfter.startValue - value2;
      }
    }
    if (value2 > nearbySteps.thisStep.startValue) {
      decrement = nearbySteps.thisStep.step;
    } else if (nearbySteps.stepBefore.step === false) {
      decrement = false;
    } else {
      decrement = value2 - nearbySteps.stepBefore.highestStep;
    }
    if (location === 100) {
      increment = null;
    } else if (location === 0) {
      decrement = null;
    }
    var stepDecimals = scope_Spectrum.countStepDecimals();
    if (increment !== null && increment !== false) {
      increment = Number(increment.toFixed(stepDecimals));
    }
    if (decrement !== null && decrement !== false) {
      decrement = Number(decrement.toFixed(stepDecimals));
    }
    return [decrement, increment];
  }
  function getNextSteps() {
    return scope_HandleNumbers.map(getNextStepsForHandle);
  }
  function updateOptions(optionsToUpdate, fireSetEvent) {
    var v = valueGet();
    var updateAble = [
      "margin",
      "limit",
      "padding",
      "range",
      "animate",
      "snap",
      "step",
      "format",
      "pips",
      "tooltips",
      "connect"
    ];
    updateAble.forEach(function(name) {
      if (optionsToUpdate[name] !== void 0) {
        originalOptions[name] = optionsToUpdate[name];
      }
    });
    var newOptions = testOptions(originalOptions);
    updateAble.forEach(function(name) {
      if (optionsToUpdate[name] !== void 0) {
        options2[name] = newOptions[name];
      }
    });
    scope_Spectrum = newOptions.spectrum;
    options2.margin = newOptions.margin;
    options2.limit = newOptions.limit;
    options2.padding = newOptions.padding;
    if (options2.pips) {
      pips(options2.pips);
    } else {
      removePips();
    }
    if (options2.tooltips) {
      tooltips2();
    } else {
      removeTooltips();
    }
    scope_Locations = [];
    valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
    if (optionsToUpdate.connect) {
      updateConnectOption();
    }
  }
  function updateConnectOption() {
    while (scope_ConnectBase.firstChild) {
      scope_ConnectBase.removeChild(scope_ConnectBase.firstChild);
    }
    for (var i2 = 0; i2 <= options2.handles; i2++) {
      scope_Connects[i2] = addConnect(scope_ConnectBase, options2.connect[i2]);
      updateConnect(i2);
    }
    bindSliderEvents({ drag: options2.events.drag, fixed: true });
  }
  function invertConnects() {
    scope_ConnectsInverted = !scope_ConnectsInverted;
    testConnect(
      options2,
      // inverse the connect boolean array
      options2.connect.map(function(b2) {
        return !b2;
      })
    );
    updateConnectOption();
  }
  function setupSlider() {
    scope_Base = addSlider(scope_Target);
    addElements(options2.connect, scope_Base);
    bindSliderEvents(options2.events);
    valueSet(options2.start);
    if (options2.pips) {
      pips(options2.pips);
    }
    if (options2.tooltips) {
      tooltips2();
    }
    aria();
  }
  setupSlider();
  var scope_Self = {
    destroy: destroy2,
    steps: getNextSteps,
    on: bindEvent,
    off: removeEvent,
    get: valueGet,
    set: valueSet,
    setHandle: valueSetHandle,
    reset: valueReset,
    disable,
    enable,
    // Exposed for unit testing, don't use this in your application.
    __moveHandles: function(upward, proposal, handleNumbers) {
      moveHandles(upward, proposal, scope_Locations, handleNumbers);
    },
    options: originalOptions,
    updateOptions,
    target: scope_Target,
    removePips,
    removeTooltips,
    getPositions: function() {
      return scope_Locations.slice();
    },
    getTooltips: function() {
      return scope_Tooltips;
    },
    getOrigins: function() {
      return scope_Handles;
    },
    pips
    // Issue #594
  };
  return scope_Self;
}
function initialize(target, originalOptions) {
  if (!target || !target.nodeName) {
    throw new Error("noUiSlider: create requires a single element, got: " + target);
  }
  if (target.noUiSlider) {
    throw new Error("noUiSlider: Slider was already initialized.");
  }
  var options2 = testOptions(originalOptions);
  var api = scope(target, options2, originalOptions);
  target.noUiSlider = api;
  return api;
}
var nouislider_default = {
  // Exposed for unit testing, don't use this in your application.
  __spectrum: Spectrum,
  // A reference to the default classes, allows global changes.
  // Use the cssClasses option for changes to one slider.
  cssClasses,
  create: initialize
};

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/abstract_slider.js
import sliders_css, * as sliders from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/sliders.css.js";
import nouislider_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/nouislider.css.js";
import * as inputs13 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/inputs.css.js";
var AbstractSliderView = class extends OrientedControlView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour");
    __publicField(this, "connected", false);
    __publicField(this, "group_el");
    __publicField(this, "slider_el");
    __publicField(this, "title_el");
    __publicField(this, "_auto_width", "auto");
    __publicField(this, "_auto_height", "auto");
    __publicField(this, "_noUiSlider");
  }
  *controls() {
    yield this.slider_el;
  }
  get _steps() {
    return this._noUiSlider.steps;
  }
  _update_slider() {
    this._noUiSlider.updateOptions(this._calc_to(), true);
  }
  connect_signals() {
    super.connect_signals();
    const { direction, orientation, tooltips: tooltips2 } = this.model.properties;
    this.on_change([direction, orientation, tooltips2], () => this.render());
    const { bar_color } = this.model.properties;
    this.on_change(bar_color, () => {
      this._set_bar_color();
    });
    const { value: value2, title: title3, show_value } = this.model.properties;
    this.on_change([value2, title3, show_value], () => this._update_title());
    this.on_change(value2, () => this._update_slider());
  }
  stylesheets() {
    return [...super.stylesheets(), nouislider_css, sliders_css];
  }
  _update_title() {
    empty2(this.title_el);
    const hide_header = this.model.title == null || this.model.title.length == 0 && !this.model.show_value;
    this.title_el.style.display = hide_header ? "none" : "";
    if (!hide_header) {
      const { title: title3 } = this.model;
      if (title3 != null && title3.length > 0) {
        if (this.contains_tex_string(title3)) {
          this.title_el.innerHTML = `${this.process_tex(title3)}: `;
        } else {
          this.title_el.textContent = `${title3}: `;
        }
      }
      if (this.model.show_value) {
        const { start: start2 } = this._calc_to();
        const pretty3 = start2.map((v) => this.pretty(v)).join(" .. ");
        this.title_el.appendChild(span({ class: sliders.slider_value }, pretty3));
      }
    }
  }
  _set_bar_color() {
    if (this.connected !== false && !this.model.disabled && this.slider_el != null) {
      const connect_el = this.slider_el.querySelector(".noUi-connect");
      connect_el.style.backgroundColor = color2css(this.model.bar_color);
    }
  }
  render() {
    super.render();
    let tooltips2;
    if (this.model.tooltips) {
      const formatter = {
        to: (value2) => this.pretty(value2)
      };
      const { start: start2 } = this._calc_to();
      tooltips2 = repeat(formatter, start2.length);
    } else {
      tooltips2 = null;
    }
    if (this.slider_el == null) {
      this.slider_el = div();
      this._noUiSlider = nouislider_default.create(this.slider_el, {
        ...this._calc_to(),
        behaviour: this.behaviour,
        connect: this.connected,
        tooltips: tooltips2 ?? false,
        orientation: this.model.orientation,
        direction: this.model.direction
      });
      this._noUiSlider.on("slide", (_2, __, values2) => this._slide(values2));
      this._noUiSlider.on("change", (_2, __, values2) => this._change(values2));
      const toggle_tooltip = (i2, show3) => {
        if (tooltips2 == null || this.slider_el == null) {
          return;
        }
        const handle2 = this.slider_el.querySelectorAll(".noUi-handle")[i2];
        const tooltip = handle2.querySelector(".noUi-tooltip");
        tooltip.style.display = show3 ? "block" : "";
      };
      this._noUiSlider.on("start", () => this._toggle_user_select(false));
      this._noUiSlider.on("end", () => this._toggle_user_select(true));
      this._noUiSlider.on("start", (_2, i2) => toggle_tooltip(i2, true));
      this._noUiSlider.on("end", (_2, i2) => toggle_tooltip(i2, false));
    } else {
      this._update_slider();
    }
    this._set_bar_color();
    if (this.model.disabled) {
      this.slider_el.setAttribute("disabled", "true");
    } else {
      this.slider_el.removeAttribute("disabled");
    }
    this.title_el = div({ class: sliders.slider_title });
    this._update_title();
    this.group_el = div({ class: inputs13.input_group }, this.title_el, this.slider_el);
    this.shadow_el.appendChild(this.group_el);
    this._has_finished = true;
  }
  _toggle_user_select(enable) {
    const { style: style2 } = document.body;
    const value2 = enable ? "" : "none";
    style2.userSelect = value2;
    style2.webkitUserSelect = value2;
  }
  _slide(values2) {
    this.model.value = this._calc_from(values2);
  }
  _change(values2) {
    const value2 = this._calc_from(values2);
    this.model.setv({ value: value2, value_throttled: value2 });
  }
};
__publicField(AbstractSliderView, "__name__", "AbstractSliderView");
var _AbstractSlider = class _AbstractSlider extends OrientedControl {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_AbstractSlider, "__name__", "AbstractSlider");
_AbstractSlider.define(({ Unknown: Unknown2, Bool: Bool2, Str: Str2, Color: Color2, Enum: Enum2, Nullable: Nullable2 }) => {
  return {
    title: [Nullable2(Str2), ""],
    show_value: [Bool2, true],
    value: [Unknown2],
    value_throttled: [Unknown2, unset, { readonly: true }],
    direction: [Enum2("ltr", "rtl"), "ltr"],
    tooltips: [Bool2, true],
    bar_color: [Color2, "#e6e6e6"]
  };
});
_AbstractSlider.override({
  width: 300
  // sliders don't have any intrinsic width
});
var AbstractSlider = _AbstractSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/categorical_slider.js
var CategoricalSliderView = class extends AbstractSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "tap");
  }
  connect_signals() {
    super.connect_signals();
    const { categories } = this.model.properties;
    this.on_change([categories], () => this._update_slider());
  }
  _calc_to() {
    const { categories } = this.model;
    return {
      range: {
        min: 0,
        max: categories.length - 1
      },
      start: [this.model.value],
      step: 1,
      format: {
        to: (value2) => categories[value2],
        from: (value2) => categories.indexOf(value2)
      }
    };
  }
  _calc_from([value2]) {
    const { categories } = this.model;
    return categories[value2 | 0];
  }
  pretty(value2) {
    return isNumber(value2) ? this.model.categories[value2] : value2;
  }
};
__publicField(CategoricalSliderView, "__name__", "CategoricalSliderView");
var _CategoricalSlider = class _CategoricalSlider extends AbstractSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_CategoricalSlider, "__name__", "CategoricalSlider");
_CategoricalSlider.prototype.default_view = CategoricalSliderView;
_CategoricalSlider.define(({ List: List2, Str: Str2 }) => ({
  categories: [List2(Str2)]
}));
var CategoricalSlider = _CategoricalSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/date_range_slider.js
var import_timezone3 = __toESM(require_timezone());

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/base_numerical_slider.js
var BaseNumericalSliderView = class extends AbstractSliderView {
  connect_signals() {
    super.connect_signals();
    const { start: start2, end, step } = this.model.properties;
    this.on_change([start2, end, step], () => this._update_slider());
  }
  pretty(value2) {
    return this._formatter(value2, this.model.format);
  }
};
__publicField(BaseNumericalSliderView, "__name__", "BaseNumericalSliderView");
var _BaseNumericalSlider = class _BaseNumericalSlider extends AbstractSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_BaseNumericalSlider, "__name__", "BaseNumericalSlider");
_BaseNumericalSlider.define(({ Float: Float2, Str: Str2, Or: Or2, Ref: Ref2 }) => {
  return {
    start: [Float2],
    end: [Float2],
    step: [Float2, 1],
    format: [Or2(Str2, Ref2(TickFormatter))]
  };
});
var BaseNumericalSlider = _BaseNumericalSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/numerical_range_slider.js
var NumericalRangeSliderView = class extends BaseNumericalSliderView {
  _calc_to() {
    return {
      range: {
        min: this.model.start,
        max: this.model.end
      },
      start: this.model.value,
      step: this.model.step
    };
  }
  _calc_from(values2) {
    return values2;
  }
};
__publicField(NumericalRangeSliderView, "__name__", "NumericalRangeSliderView");
var NumericalRangeSlider = class extends BaseNumericalSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(NumericalRangeSlider, "__name__", "NumericalRangeSlider");

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/date_range_slider.js
var DateRangeSliderView = class extends NumericalRangeSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "drag");
    __publicField(this, "connected", [false, true, false]);
  }
  _calc_to() {
    const spec = super._calc_to();
    spec.step *= 864e5;
    return spec;
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return (0, import_timezone3.default)(value2, format7);
    } else {
      return format7.compute(value2);
    }
  }
};
__publicField(DateRangeSliderView, "__name__", "DateRangeSliderView");
var _DateRangeSlider = class _DateRangeSlider extends NumericalRangeSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DateRangeSlider, "__name__", "DateRangeSlider");
_DateRangeSlider.prototype.default_view = DateRangeSliderView;
_DateRangeSlider.override({
  format: "%d %b %Y"
});
var DateRangeSlider = _DateRangeSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/date_slider.js
var import_timezone4 = __toESM(require_timezone());

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/numerical_slider.js
var NumericalSliderView = class extends BaseNumericalSliderView {
  _calc_to() {
    const { start: start2, end, value: value2, step } = this.model;
    return {
      range: {
        min: start2,
        max: end
      },
      start: [value2],
      step
    };
  }
  _calc_from([value2]) {
    if (Number.isInteger(this.model.start) && Number.isInteger(this.model.end) && Number.isInteger(this.model.step)) {
      return Math.round(value2);
    } else {
      return value2;
    }
  }
};
__publicField(NumericalSliderView, "__name__", "NumericalSliderView");
var NumericalSlider = class extends BaseNumericalSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(NumericalSlider, "__name__", "NumericalSlider");

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/date_slider.js
var DateSliderView = class extends NumericalSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "tap");
    __publicField(this, "connected", [true, false]);
  }
  _calc_to() {
    const spec = super._calc_to();
    spec.step *= 864e5;
    return spec;
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return (0, import_timezone4.default)(value2, format7);
    } else {
      return format7.compute(value2);
    }
  }
};
__publicField(DateSliderView, "__name__", "DateSliderView");
var _DateSlider = class _DateSlider extends NumericalSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DateSlider, "__name__", "DateSlider");
_DateSlider.prototype.default_view = DateSliderView;
_DateSlider.override({
  format: "%d %b %Y"
});
var DateSlider = _DateSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/datetime_range_slider.js
var import_timezone5 = __toESM(require_timezone());
var DatetimeRangeSliderView = class extends NumericalRangeSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "drag");
    __publicField(this, "connected", [false, true, false]);
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return (0, import_timezone5.default)(value2, format7);
    } else {
      return format7.compute(value2);
    }
  }
};
__publicField(DatetimeRangeSliderView, "__name__", "DatetimeRangeSliderView");
var _DatetimeRangeSlider = class _DatetimeRangeSlider extends NumericalRangeSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DatetimeRangeSlider, "__name__", "DatetimeRangeSlider");
_DatetimeRangeSlider.prototype.default_view = DatetimeRangeSliderView;
_DatetimeRangeSlider.override({
  format: "%d %b %Y %H:%M:%S",
  step: 36e5
  // 1 hour
});
var DatetimeRangeSlider = _DatetimeRangeSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/range_slider.js
var numbro2 = __toESM(require_numbro());
var RangeSliderView = class extends NumericalRangeSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "drag");
    __publicField(this, "connected", [false, true, false]);
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return numbro2.format(value2, format7);
    } else {
      return format7.compute(value2);
    }
  }
};
__publicField(RangeSliderView, "__name__", "RangeSliderView");
var _RangeSlider = class _RangeSlider extends NumericalRangeSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RangeSlider, "__name__", "RangeSlider");
_RangeSlider.prototype.default_view = RangeSliderView;
_RangeSlider.override({
  format: "0[.]00"
});
var RangeSlider = _RangeSlider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/sliders/slider.js
var numbro3 = __toESM(require_numbro());
var SliderView = class extends NumericalSliderView {
  constructor() {
    super(...arguments);
    __publicField(this, "behaviour", "tap");
    __publicField(this, "connected", [true, false]);
  }
  _formatter(value2, format7) {
    if (isString(format7)) {
      return numbro3.format(value2, format7);
    } else {
      return format7.compute(value2);
    }
  }
};
__publicField(SliderView, "__name__", "SliderView");
var _Slider = class _Slider extends NumericalSlider {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_Slider, "__name__", "Slider");
_Slider.prototype.default_view = SliderView;
_Slider.override({
  format: "0[.]00"
});
var Slider = _Slider;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/main.js
register_models(widgets_exports);

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/index.js
var tables_exports = {};
__export(tables_exports, {
  AvgAggregator: () => AvgAggregator,
  BooleanFormatter: () => BooleanFormatter,
  CellEditor: () => CellEditor,
  CellEditorView: () => CellEditorView,
  CellFormatter: () => CellFormatter,
  CheckboxEditor: () => CheckboxEditor,
  CheckboxEditorView: () => CheckboxEditorView,
  DataCube: () => DataCube,
  DataTable: () => DataTable,
  DateEditor: () => DateEditor,
  DateEditorView: () => DateEditorView,
  DateFormatter: () => DateFormatter,
  GroupingInfo: () => GroupingInfo,
  HTMLTemplateFormatter: () => HTMLTemplateFormatter,
  IntEditor: () => IntEditor,
  IntEditorView: () => IntEditorView,
  MaxAggregator: () => MaxAggregator,
  MinAggregator: () => MinAggregator,
  NumberEditor: () => NumberEditor,
  NumberEditorView: () => NumberEditorView,
  NumberFormatter: () => NumberFormatter,
  PercentEditor: () => PercentEditor,
  PercentEditorView: () => PercentEditorView,
  ScientificFormatter: () => ScientificFormatter,
  SelectEditor: () => SelectEditor,
  SelectEditorView: () => SelectEditorView,
  StringEditor: () => StringEditor,
  StringEditorView: () => StringEditorView,
  StringFormatter: () => StringFormatter,
  SumAggregator: () => SumAggregator,
  TableColumn: () => TableColumn,
  TableWidget: () => TableWidget,
  TextEditor: () => TextEditor,
  TextEditorView: () => TextEditorView,
  TimeEditor: () => TimeEditor,
  TimeEditorView: () => TimeEditorView
});

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/definitions.js
var DTINDEX_NAME = "__bkdt_internal_index__";

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/cell_editors.js
import * as tables from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/tables.css.js";
var CellEditorView = class extends DOMComponentView {
  constructor(options2) {
    const { model: model2, parent } = options2.column;
    super({ model: model2, parent, ...options2 });
    __publicField(this, "defaultValue");
    __publicField(this, "inputEl");
    __publicField(this, "args");
    this.args = options2;
    this.initialize();
    this.render();
  }
  get emptyValue() {
    return null;
  }
  initialize() {
    super.initialize();
    this.inputEl = this._createInput();
    this.defaultValue = null;
  }
  async lazy_initialize() {
    throw new Error("unsupported");
  }
  css_classes() {
    return super.css_classes().concat(tables.cell_editor);
  }
  render() {
    this.args.container.append(this.el);
    this.shadow_el.appendChild(this.inputEl);
    this.renderEditor();
    this.disableNavigation();
  }
  renderEditor() {
  }
  disableNavigation() {
    this.inputEl.addEventListener("keydown", (event2) => {
      switch (event2.key) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown":
        case "PageUp":
        case "PageDown": {
          event2.stopImmediatePropagation();
          break;
        }
      }
    });
  }
  destroy() {
    this.remove();
  }
  focus() {
    this.inputEl.focus();
  }
  show() {
  }
  hide() {
  }
  position() {
  }
  getValue() {
    return this.inputEl.value;
  }
  setValue(val) {
    this.inputEl.value = val;
  }
  serializeValue() {
    return this.getValue();
  }
  isValueChanged() {
    return !(this.getValue() == "" && this.defaultValue == null) && this.getValue() !== this.defaultValue;
  }
  applyValue(item3, state) {
    const grid_data = this.args.grid.getData();
    const offset3 = grid_data.index.indexOf(item3[DTINDEX_NAME]);
    grid_data.setField(offset3, this.args.column.field, state);
  }
  loadValue(item3) {
    const value2 = item3[this.args.column.field];
    this.defaultValue = value2 != null ? value2 : this.emptyValue;
    this.setValue(this.defaultValue);
  }
  validateValue(value2) {
    if (this.args.column.validator) {
      const result = this.args.column.validator(value2);
      if (!result.valid) {
        return result;
      }
    }
    return { valid: true, msg: null };
  }
  validate() {
    return this.validateValue(this.getValue());
  }
};
__publicField(CellEditorView, "__name__", "CellEditorView");
var CellEditor = class extends Model {
};
__publicField(CellEditor, "__name__", "CellEditor");
var StringEditorView = class extends CellEditorView {
  get emptyValue() {
    return "";
  }
  _createInput() {
    return input({ type: "text" });
  }
  renderEditor() {
    this.inputEl.focus();
    this.inputEl.select();
  }
  loadValue(item3) {
    super.loadValue(item3);
    this.inputEl.defaultValue = this.defaultValue;
    this.inputEl.select();
  }
};
__publicField(StringEditorView, "__name__", "StringEditorView");
var _StringEditor = class _StringEditor extends CellEditor {
};
__publicField(_StringEditor, "__name__", "StringEditor");
_StringEditor.prototype.default_view = StringEditorView;
_StringEditor.define(({ Str: Str2, List: List2 }) => ({
  completions: [List2(Str2), []]
}));
var StringEditor = _StringEditor;
var TextEditorView = class extends CellEditorView {
  _createInput() {
    return textarea();
  }
  renderEditor() {
    this.inputEl.focus();
    this.inputEl.select();
  }
};
__publicField(TextEditorView, "__name__", "TextEditorView");
var _TextEditor = class _TextEditor extends CellEditor {
};
__publicField(_TextEditor, "__name__", "TextEditor");
_TextEditor.prototype.default_view = TextEditorView;
var TextEditor = _TextEditor;
var SelectEditorView = class extends CellEditorView {
  _createInput() {
    return select();
  }
  renderEditor() {
    for (const opt of this.model.options) {
      this.inputEl.appendChild(option({ value: opt }, opt));
    }
    this.focus();
  }
};
__publicField(SelectEditorView, "__name__", "SelectEditorView");
var _SelectEditor = class _SelectEditor extends CellEditor {
};
__publicField(_SelectEditor, "__name__", "SelectEditor");
_SelectEditor.prototype.default_view = SelectEditorView;
_SelectEditor.define(({ Str: Str2, List: List2 }) => ({
  options: [List2(Str2), []]
}));
var SelectEditor = _SelectEditor;
var PercentEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "text" });
  }
};
__publicField(PercentEditorView, "__name__", "PercentEditorView");
var _PercentEditor = class _PercentEditor extends CellEditor {
};
__publicField(_PercentEditor, "__name__", "PercentEditor");
_PercentEditor.prototype.default_view = PercentEditorView;
var PercentEditor = _PercentEditor;
var CheckboxEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "checkbox" });
  }
  renderEditor() {
    this.focus();
  }
  loadValue(item3) {
    this.defaultValue = !!item3[this.args.column.field];
    this.inputEl.checked = this.defaultValue;
  }
  serializeValue() {
    return this.inputEl.checked;
  }
};
__publicField(CheckboxEditorView, "__name__", "CheckboxEditorView");
var _CheckboxEditor = class _CheckboxEditor extends CellEditor {
};
__publicField(_CheckboxEditor, "__name__", "CheckboxEditor");
_CheckboxEditor.prototype.default_view = CheckboxEditorView;
var CheckboxEditor = _CheckboxEditor;
var IntEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "text" });
  }
  renderEditor() {
    this.inputEl.focus();
    this.inputEl.select();
  }
  remove() {
    super.remove();
  }
  serializeValue() {
    const value2 = parseInt(this.getValue(), 10);
    return isNaN(value2) ? 0 : value2;
  }
  loadValue(item3) {
    super.loadValue(item3);
    this.inputEl.defaultValue = this.defaultValue;
    this.inputEl.select();
  }
  validateValue(value2) {
    if (isString(value2)) {
      value2 = Number(value2);
    }
    if (isInteger(value2)) {
      return super.validateValue(value2);
    } else {
      return { valid: false, msg: "Please enter a valid integer" };
    }
  }
};
__publicField(IntEditorView, "__name__", "IntEditorView");
var _IntEditor = class _IntEditor extends CellEditor {
};
__publicField(_IntEditor, "__name__", "IntEditor");
_IntEditor.prototype.default_view = IntEditorView;
_IntEditor.define(({ Int: Int2 }) => ({
  step: [Int2, 1]
}));
var IntEditor = _IntEditor;
var NumberEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "text" });
  }
  renderEditor() {
    this.inputEl.focus();
    this.inputEl.select();
  }
  remove() {
    super.remove();
  }
  serializeValue() {
    const value2 = parseFloat(this.getValue());
    return isNaN(value2) ? 0 : value2;
  }
  loadValue(item3) {
    super.loadValue(item3);
    this.inputEl.defaultValue = this.defaultValue;
    this.inputEl.select();
  }
  validateValue(value2) {
    if (isNaN(value2)) {
      return { valid: false, msg: "Please enter a valid number" };
    } else {
      return super.validateValue(value2);
    }
  }
};
__publicField(NumberEditorView, "__name__", "NumberEditorView");
var _NumberEditor = class _NumberEditor extends CellEditor {
};
__publicField(_NumberEditor, "__name__", "NumberEditor");
_NumberEditor.prototype.default_view = NumberEditorView;
_NumberEditor.define(({ Float: Float2 }) => ({
  step: [Float2, 0.01]
}));
var NumberEditor = _NumberEditor;
var TimeEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "text" });
  }
};
__publicField(TimeEditorView, "__name__", "TimeEditorView");
var _TimeEditor = class _TimeEditor extends CellEditor {
};
__publicField(_TimeEditor, "__name__", "TimeEditor");
_TimeEditor.prototype.default_view = TimeEditorView;
var TimeEditor = _TimeEditor;
var DateEditorView = class extends CellEditorView {
  _createInput() {
    return input({ type: "text" });
  }
  get emptyValue() {
    return /* @__PURE__ */ new Date();
  }
  renderEditor() {
    this.inputEl.focus();
    this.inputEl.select();
  }
  destroy() {
    super.destroy();
  }
  show() {
    super.show();
  }
  hide() {
    super.hide();
  }
  position() {
    return super.position();
  }
  getValue() {
  }
  setValue(_val) {
  }
};
__publicField(DateEditorView, "__name__", "DateEditorView");
var _DateEditor = class _DateEditor extends CellEditor {
};
__publicField(_DateEditor, "__name__", "DateEditor");
_DateEditor.prototype.default_view = DateEditorView;
var DateEditor = _DateEditor;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/cell_formatters.js
var import_timezone6 = __toESM(require_timezone());
var Numbro3 = __toESM(require_numbro());
var import_underscore = __toESM(require_lib());
var CellFormatter = class extends Model {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(_row, _cell, value2, _columnDef, _dataContext) {
    if (value2 == null) {
      return "";
    } else {
      return `${value2}`.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
};
__publicField(CellFormatter, "__name__", "CellFormatter");
var _StringFormatter = class _StringFormatter extends CellFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(_row, _cell, value2, _columnDef, dataContext) {
    const { font_style, text_align, text_color, background_color } = this;
    if (Number.isNaN(value2)) {
      value2 = this.nan_format;
    } else if (value2 == null) {
      value2 = this.null_format;
    }
    const text2 = div(value2 == null ? "" : `${value2}`);
    let resolved_font_style;
    if (isValue(font_style)) {
      resolved_font_style = font_style.value;
    } else if (isField(font_style)) {
      resolved_font_style = dataContext[font_style.field];
    } else if (isExpr(font_style)) {
    } else {
      unreachable();
    }
    switch (resolved_font_style) {
      case "normal":
        break;
      case "italic":
        text2.style.fontStyle = "italic";
        break;
      case "bold":
        text2.style.fontWeight = "bold";
        break;
      case "bold italic":
        text2.style.fontStyle = "italic";
        text2.style.fontWeight = "bold";
        break;
    }
    if (isValue(text_align)) {
      text2.style.textAlign = text_align.value;
    } else if (isField(text_align)) {
      text2.style.textAlign = dataContext[text_align.field];
    } else if (isExpr(text_align)) {
    } else {
      unreachable();
    }
    if (isValue(text_color)) {
      if (text_color.value != null) {
        text2.style.color = color2css(text_color.value);
      }
    } else if (isField(text_color)) {
      if (text_color.transform != null && text_color.transform instanceof ColorMapper) {
        const rgba_array = text_color.transform.rgba_mapper.v_compute([dataContext[text_color.field]]);
        const [r, g, b2, a2] = rgba_array;
        text2.style.color = rgba2css([r, g, b2, a2]);
      } else {
        text2.style.color = color2css(dataContext[text_color.field]);
      }
    } else if (isExpr(text_color)) {
    } else {
      unreachable();
    }
    if (isValue(background_color)) {
      if (background_color.value != null) {
        text2.style.backgroundColor = color2css(background_color.value);
      }
    } else if (isField(background_color)) {
      if (background_color.transform != null && background_color.transform instanceof ColorMapper) {
        const rgba_array = background_color.transform.rgba_mapper.v_compute([dataContext[background_color.field]]);
        const [r, g, b2, a2] = rgba_array;
        text2.style.backgroundColor = rgba2css([r, g, b2, a2]);
      } else {
        text2.style.backgroundColor = color2css(dataContext[background_color.field]);
      }
    } else if (isExpr(background_color)) {
    } else {
      unreachable();
    }
    return text2.outerHTML;
  }
};
__publicField(_StringFormatter, "__name__", "StringFormatter");
_StringFormatter.define(({ Str: Str2 }) => ({
  font_style: [FontStyleSpec, { value: "normal" }],
  text_align: [TextAlignSpec, { value: "left" }],
  text_color: [ColorSpec, null],
  background_color: [ColorSpec, null],
  nan_format: [Str2, "NaN"],
  null_format: [Str2, "(null)"]
}));
var StringFormatter = _StringFormatter;
var _ScientificFormatter = class _ScientificFormatter extends StringFormatter {
  constructor(attrs) {
    super(attrs);
  }
  get scientific_limit_low() {
    return 10 ** this.power_limit_low;
  }
  get scientific_limit_high() {
    return 10 ** this.power_limit_high;
  }
  doFormat(row2, cell, value2, columnDef, dataContext) {
    const need_sci = Math.abs(value2) <= this.scientific_limit_low || Math.abs(value2) >= this.scientific_limit_high;
    let precision = this.precision;
    if (precision < 1) {
      precision = 1;
    }
    if (Number.isNaN(value2)) {
      value2 = this.nan_format;
    } else if (value2 == null) {
      value2 = this.null_format;
    } else if (value2 == 0) {
      value2 = to_fixed(value2, 1);
    } else if (need_sci) {
      value2 = value2.toExponential(precision);
    } else {
      value2 = to_fixed(value2, precision);
    }
    return super.doFormat(row2, cell, value2, columnDef, dataContext);
  }
};
__publicField(_ScientificFormatter, "__name__", "ScientificFormatter");
_ScientificFormatter.define(({ Float: Float2 }) => ({
  precision: [Float2, 10],
  power_limit_high: [Float2, 5],
  power_limit_low: [Float2, -3]
}));
_ScientificFormatter.override({
  nan_format: "-",
  null_format: "-"
});
var ScientificFormatter = _ScientificFormatter;
var _NumberFormatter = class _NumberFormatter extends StringFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(row2, cell, value2, columnDef, dataContext) {
    const { format: format7, language, nan_format, null_format } = this;
    const rounding = (() => {
      switch (this.rounding) {
        case "round":
        case "nearest":
          return Math.round;
        case "floor":
        case "rounddown":
          return Math.floor;
        case "ceil":
        case "roundup":
          return Math.ceil;
      }
    })();
    if (Number.isNaN(value2)) {
      value2 = nan_format;
    } else if (value2 == null) {
      value2 = null_format;
    } else {
      value2 = Numbro3.format(value2, format7, language, rounding);
    }
    return super.doFormat(row2, cell, value2, columnDef, dataContext);
  }
};
__publicField(_NumberFormatter, "__name__", "NumberFormatter");
_NumberFormatter.define(({ Str: Str2 }) => ({
  format: [Str2, "0,0"],
  language: [Str2, "en"],
  rounding: [RoundingFunction, "round"]
}));
_NumberFormatter.override({
  nan_format: "-",
  null_format: "-"
});
var NumberFormatter = _NumberFormatter;
var _BooleanFormatter = class _BooleanFormatter extends CellFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(_row, _cell, value2, _columnDef, _dataContext) {
    return !!value2 ? i({ class: this.icon }).outerHTML : "";
  }
};
__publicField(_BooleanFormatter, "__name__", "BooleanFormatter");
_BooleanFormatter.define(({ Str: Str2 }) => ({
  icon: [Str2, "check"]
}));
var BooleanFormatter = _BooleanFormatter;
var _DateFormatter = class _DateFormatter extends StringFormatter {
  constructor(attrs) {
    super(attrs);
  }
  getFormat() {
    switch (this.format) {
      case "ATOM":
      case "W3C":
      case "RFC-3339":
      case "ISO-8601":
        return "%Y-%m-%d";
      case "COOKIE":
        return "%a, %d %b %Y";
      case "RFC-850":
        return "%A, %d-%b-%y";
      case "RFC-1123":
      case "RFC-2822":
        return "%a, %e %b %Y";
      case "RSS":
      case "RFC-822":
      case "RFC-1036":
        return "%a, %e %b %y";
      case "TIMESTAMP":
        return void 0;
      default:
        return this.format;
    }
  }
  doFormat(row2, cell, value2, columnDef, dataContext) {
    function parse2(date2) {
      const has_tz = /Z$|[+-]\d\d((:?)\d\d)?$/.test(date2);
      const iso_date = has_tz ? date2 : `${date2}Z`;
      return new Date(iso_date).getTime();
    }
    const epoch = (() => {
      if (value2 == null || isNumber(value2)) {
        return value2;
      } else if (isString(value2)) {
        const epoch2 = Number(value2);
        return isNaN(epoch2) ? parse2(value2) : epoch2;
      } else if (value2 instanceof Date) {
        return value2.valueOf();
      } else {
        return Number(value2);
      }
    })();
    const NaT = -9223372036854776;
    const date = (() => {
      if (Number.isNaN(epoch) || epoch == NaT) {
        return this.nan_format;
      } else if (value2 == null) {
        return this.null_format;
      } else {
        return (0, import_timezone6.default)(epoch, this.getFormat());
      }
    })();
    return super.doFormat(row2, cell, date, columnDef, dataContext);
  }
};
__publicField(_DateFormatter, "__name__", "DateFormatter");
_DateFormatter.define(({ Str: Str2 }) => ({
  format: [Str2, "ISO-8601"]
}));
_DateFormatter.override({
  nan_format: "-",
  null_format: "-"
});
var DateFormatter = _DateFormatter;
var _HTMLTemplateFormatter = class _HTMLTemplateFormatter extends CellFormatter {
  constructor(attrs) {
    super(attrs);
  }
  doFormat(_row, _cell, value2, _columnDef, dataContext) {
    const { template: template2 } = this;
    if (value2 == null) {
      return "";
    } else {
      const compiled_template = import_underscore._.template(template2);
      const context = { ...dataContext, value: value2 };
      return compiled_template(context);
    }
  }
};
__publicField(_HTMLTemplateFormatter, "__name__", "HTMLTemplateFormatter");
_HTMLTemplateFormatter.define(({ Str: Str2 }) => ({
  template: [Str2, "<%= value %>"]
}));
var HTMLTemplateFormatter = _HTMLTemplateFormatter;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/data_table.js
var import_slick = __toESM(require_slick_rowselectionmodel());
var import_slick2 = __toESM(require_slick_checkboxselectcolumn());
var import_slick3 = __toESM(require_slick_cellexternalcopymanager());
var import_slickgrid = __toESM(require_slickgrid());

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/table_widget.js
var _TableWidget = class _TableWidget extends Widget {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_TableWidget, "__name__", "TableWidget");
_TableWidget.define(({ Ref: Ref2 }) => ({
  source: [Ref2(ColumnDataSource), () => new ColumnDataSource()],
  view: [Ref2(CDSView), () => new CDSView()]
}));
var TableWidget = _TableWidget;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/table_column.js
var _TableColumn = class _TableColumn extends Model {
  constructor(attrs) {
    super(attrs);
  }
  toColumn() {
    return {
      id: unique_id(),
      field: this.field,
      name: this.title ?? this.field,
      width: this.width,
      formatter: this.formatter.doFormat.bind(this.formatter),
      model: this.editor,
      editor: this.editor.default_view,
      sortable: this.sortable,
      defaultSortAsc: this.default_sort == "ascending",
      sorter: this.sorter
    };
  }
};
__publicField(_TableColumn, "__name__", "TableColumn");
_TableColumn.define(({ Bool: Bool2, Float: Float2, Str: Str2, Nullable: Nullable2, Ref: Ref2 }) => ({
  field: [Str2],
  title: [Nullable2(Str2), null],
  width: [Float2, 300],
  formatter: [Ref2(CellFormatter), () => new StringFormatter()],
  editor: [Ref2(CellEditor), () => new StringEditor()],
  sortable: [Bool2, true],
  default_sort: [Sort, "ascending"],
  visible: [Bool2, true],
  sorter: [Nullable2(Ref2(Comparison)), null]
}));
var TableColumn = _TableColumn;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/data_table.js
import tables_css, * as tables2 from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/tables.css.js";
import slickgrid_css from "/home/gabriele/Workspace/astro-galaxy-ui/vuejs-prototype/mmodagalaxy_backup/mmodagalaxy/node_modules/@bokeh/bokehjs/build/js/lib/styles/widgets/slickgrid.css.js";
var AutosizeModes = {
  fit_columns: "FCV",
  fit_viewport: "FVC",
  force_fit: "LFF",
  none: "NOA"
};
var _warned_not_reorderable = false;
var TableDataProvider = class {
  constructor(source2, view) {
    __publicField(this, "index");
    __publicField(this, "source");
    __publicField(this, "view");
    this.init(source2, view);
  }
  init(source2, view) {
    if (DTINDEX_NAME in source2.data) {
      throw new Error(`special name ${DTINDEX_NAME} cannot be used as a data table column`);
    }
    this.source = source2;
    this.view = view;
    this.index = [...this.view.indices];
  }
  getLength() {
    return this.index.length;
  }
  getItem(offset3) {
    const item3 = {};
    const data3 = dict(this.source.data);
    for (const [field, column] of data3) {
      const i2 = this.index[offset3];
      const value2 = is_NDArray(column) ? column.get(i2) : column[i2];
      item3[field] = value2;
    }
    item3[DTINDEX_NAME] = this.index[offset3];
    return item3;
  }
  getField(offset3, field) {
    if (field == DTINDEX_NAME) {
      return this.index[offset3];
    } else {
      const data3 = dict(this.source.data);
      const column = data3.get(field) ?? [];
      const i2 = this.index[offset3];
      return is_NDArray(column) ? column.get(i2) : column[i2];
    }
  }
  setField(offset3, field, value2) {
    const index2 = this.index[offset3];
    const patches = /* @__PURE__ */ new Map([
      [field, [[index2, value2]]]
    ]);
    this.source.patch(patches);
  }
  getRecords() {
    return range(0, this.getLength()).map((i2) => this.getItem(i2));
  }
  getItems() {
    return this.getRecords();
  }
  slice(start2, end, step = 1) {
    end = end ?? this.getLength();
    return range(start2, end, step).map((i2) => this.getItem(i2));
  }
  sort(columns2) {
    let cols = columns2.map((column) => [column.sortCol, column.sortAsc ? 1 : -1]);
    if (cols.length == 0) {
      cols = [[{ field: DTINDEX_NAME }, 1]];
    }
    const records = this.getRecords();
    const lookup = {};
    this.index.forEach((v, i2) => lookup[v] = i2);
    this.index.sort((i0, i1) => {
      for (const [col2, sign] of cols) {
        const field = col2.field;
        const v0 = records[lookup[i0]][field];
        const v1 = records[lookup[i1]][field];
        if (col2.sorter != null) {
          return sign * col2.sorter.compute(v0, v1);
        }
        if (v0 === v1) {
          continue;
        }
        if (isNumber(v0) && isNumber(v1)) {
          return sign * (v0 - v1 || +isNaN(v0) - +isNaN(v1));
        } else {
          const result = `${v0}`.localeCompare(`${v1}`);
          if (result == 0) {
            continue;
          } else {
            return sign * result;
          }
        }
      }
      return 0;
    });
  }
};
__publicField(TableDataProvider, "__name__", "TableDataProvider");
var DataTableView = class extends WidgetView {
  constructor() {
    super(...arguments);
    __publicField(this, "cds_view");
    __publicField(this, "data");
    __publicField(this, "grid");
    __publicField(this, "_in_selection_update", false);
    __publicField(this, "_width", null);
    __publicField(this, "_filtered_selection", []);
    __publicField(this, "wrapper_el");
  }
  get data_source() {
    return this.model.properties.source;
  }
  *children() {
    yield* super.children();
    yield this.cds_view;
  }
  async lazy_initialize() {
    await super.lazy_initialize();
    this.cds_view = await build_view(this.model.view, { parent: this });
  }
  remove() {
    this.cds_view.remove();
    this.grid.destroy();
    super.remove();
  }
  connect_signals() {
    super.connect_signals();
    this.connect(this.model.change, () => {
      this.render();
      this.r_after_render();
    });
    for (const column of this.model.columns) {
      this.connect(column.change, () => {
        this.render();
        this.r_after_render();
      });
    }
    this.connect(this.model.view.change, () => this.updateGrid());
    this.connect(this.model.source.selected.change, () => this.updateSelection());
    this.connect(this.model.source.selected.properties.indices.change, () => this.updateSelection());
  }
  stylesheets() {
    return [...super.stylesheets(), slickgrid_css, tables_css];
  }
  _after_resize() {
    super._after_resize();
    this.grid.resizeCanvas();
    this.updateLayout(true, false);
  }
  _after_layout() {
    super._after_layout();
    this.grid.resizeCanvas();
    this.updateLayout(true, false);
  }
  box_sizing() {
    const sizing = super.box_sizing();
    if (this.model.autosize_mode === "fit_viewport" && this._width != null) {
      sizing.width = this._width;
    }
    return sizing;
  }
  updateLayout(initialized2, rerender) {
    const autosize = this.autosize;
    if (autosize === AutosizeModes.fit_columns || autosize === AutosizeModes.force_fit) {
      if (!initialized2) {
        this.grid.resizeCanvas();
      }
      this.grid.autosizeColumns();
    } else if (initialized2 && rerender && autosize === AutosizeModes.fit_viewport) {
      this.invalidate_layout();
    }
  }
  updateGrid() {
    this.data.init(this.model.source, this.model.view);
    if (this.model.sortable) {
      const columns2 = this.grid.getColumns();
      const sorters = this.grid.getSortColumns().map((x2) => ({
        sortCol: {
          field: columns2[this.grid.getColumnIndex(x2.columnId)].field
        },
        sortAsc: x2.sortAsc
      }));
      this.data.sort(sorters);
    }
    this._sync_selected_with_view();
    this.updateSelection();
    this.grid.invalidate();
    this.updateLayout(true, true);
  }
  updateSelection() {
    if (this.model.selectable === false || this._in_selection_update) {
      return;
    }
    const { indices } = this.model.source.selected;
    const permuted_indices = sort_by(map(indices, (x2) => this.data.index.indexOf(x2)), (x2) => x2);
    this._in_selection_update = true;
    try {
      this.grid.setSelectedRows([...permuted_indices]);
    } finally {
      this._in_selection_update = false;
    }
    const cur_grid_range = this.grid.getViewport();
    const scroll_index = this.model.get_scroll_index(cur_grid_range, permuted_indices);
    if (scroll_index != null) {
      this.grid.scrollRowToTop(scroll_index);
    }
  }
  newIndexColumn() {
    return {
      id: unique_id(),
      name: this.model.index_header,
      field: DTINDEX_NAME,
      width: this.model.index_width,
      behavior: "select",
      cannotTriggerInsert: true,
      resizable: false,
      selectable: false,
      sortable: true,
      cssClass: tables2.cell_index,
      headerCssClass: tables2.header_index
    };
  }
  get autosize() {
    let autosize;
    if (this.model.fit_columns === true) {
      autosize = AutosizeModes.force_fit;
    } else if (this.model.fit_columns === false) {
      autosize = AutosizeModes.none;
    } else {
      autosize = AutosizeModes[this.model.autosize_mode];
    }
    return autosize;
  }
  render() {
    super.render();
    this.wrapper_el = div({ class: tables2.data_table });
    this.shadow_el.appendChild(this.wrapper_el);
  }
  _render_table() {
    const columns2 = this.model.columns.filter((column) => column.visible).map((column) => {
      return { ...column.toColumn(), parent: this };
    });
    let checkbox_selector = null;
    if (this.model.selectable == "checkbox") {
      checkbox_selector = new import_slick2.CheckboxSelectColumn({ cssClass: tables2.cell_select });
      columns2.unshift(checkbox_selector.getColumnDefinition());
    }
    if (this.model.index_position != null) {
      const index_position = this.model.index_position;
      const index2 = this.newIndexColumn();
      if (index_position == -1) {
        columns2.push(index2);
      } else if (index_position < -1) {
        columns2.splice(index_position + 1, 0, index2);
      } else {
        columns2.splice(index_position, 0, index2);
      }
    }
    let { reorderable } = this.model;
    if (reorderable && !(typeof $ != "undefined" && typeof $.fn != "undefined" && "sortable" in $.fn)) {
      if (!_warned_not_reorderable) {
        logger.warn("jquery-ui is required to enable DataTable.reorderable");
        _warned_not_reorderable = true;
      }
      reorderable = false;
    }
    let frozen_row = -1;
    let frozen_bottom = false;
    const { frozen_rows, frozen_columns } = this.model;
    const frozen_column = frozen_columns == null ? -1 : frozen_columns - 1;
    if (frozen_rows != null) {
      frozen_bottom = frozen_rows < 0;
      frozen_row = Math.abs(frozen_rows);
    }
    const options2 = {
      enableCellNavigation: this.model.selectable !== false,
      enableColumnReorder: reorderable,
      autosizeColsMode: this.autosize,
      multiColumnSort: this.model.sortable,
      editable: this.model.editable,
      autoEdit: this.model.auto_edit,
      autoHeight: false,
      rowHeight: this.model.row_height,
      frozenColumn: frozen_column,
      frozenRow: frozen_row,
      frozenBottom: frozen_bottom,
      explicitInitialization: false
    };
    this.data = new TableDataProvider(this.model.source, this.model.view);
    this.grid = new import_slickgrid.Grid(this.wrapper_el, this.data, columns2, options2);
    if (this.autosize == AutosizeModes.fit_viewport) {
      this.grid.autosizeColumns();
      let width = 0;
      for (const column of columns2) {
        width += column.width ?? 0;
      }
      this._width = Math.ceil(width);
    }
    this.grid.onSort.subscribe((_event, args) => {
      if (!this.model.sortable) {
        return;
      }
      const to_sort = args.sortCols;
      if (to_sort == null) {
        return;
      }
      this.data.sort(to_sort);
      this.grid.invalidate();
      this.updateSelection();
      this.grid.render();
      if (!this.model.header_row) {
        this._hide_header();
      }
      this.model.update_sort_columns(to_sort);
    });
    if (this.model.selectable !== false) {
      this.grid.setSelectionModel(new import_slick.RowSelectionModel({ selectActiveRow: checkbox_selector == null }));
      if (checkbox_selector != null) {
        this.grid.registerPlugin(checkbox_selector);
      }
      const pluginOptions = {
        dataItemColumnValueExtractor(val, col2) {
          let value2 = val[col2.field];
          if (isString(value2)) {
            value2 = value2.replace(/\n/g, "\\n");
          }
          return value2;
        },
        includeHeaderWhenCopying: false
      };
      this.grid.registerPlugin(new import_slick3.CellExternalCopyManager(pluginOptions));
      this.grid.onSelectedRowsChanged.subscribe((_event, args) => {
        if (this._in_selection_update) {
          return;
        }
        this.model.source.selected.indices = args.rows.map((i2) => this.data.index[i2]);
      });
      this.updateSelection();
      if (!this.model.header_row) {
        this._hide_header();
      }
    }
  }
  _after_render() {
    const initialized2 = typeof this.grid !== "undefined";
    this._render_table();
    this.updateLayout(initialized2, false);
    super._after_render();
  }
  _hide_header() {
    for (const el of this.shadow_el.querySelectorAll(".slick-header-columns")) {
      el.style.height = "0px";
    }
    this.grid.resizeCanvas();
  }
  get_selected_rows() {
    return this.grid.getSelectedRows();
  }
  _sync_selected_with_view() {
    const index2 = this.data.view.indices;
    const { source: source2 } = this.data;
    const not_filtered = filter(source2.selected.indices, (i2) => index2.get(i2));
    const was_filtered = new Set(filter(this._filtered_selection, (i2) => index2.get(i2)));
    this._filtered_selection = [
      ...filter(this._filtered_selection, (i2) => !was_filtered.has(i2)),
      ...filter(source2.selected.indices, (i2) => !index2.get(i2))
    ];
    source2.selected.indices = [
      ...was_filtered,
      ...not_filtered
    ];
  }
};
__publicField(DataTableView, "__name__", "DataTableView");
var _DataTable = class _DataTable extends TableWidget {
  constructor(attrs) {
    super(attrs);
    __publicField(this, "_sort_columns", []);
  }
  get sort_columns() {
    return this._sort_columns;
  }
  update_sort_columns(sort_cols) {
    this._sort_columns = sort_cols.map(({ sortCol, sortAsc }) => ({ field: sortCol.field, sortAsc }));
  }
  get_scroll_index(grid_range, selected_indices) {
    if (!this.scroll_to_selection || selected_indices.length == 0) {
      return null;
    }
    if (!some(selected_indices, (i2) => grid_range.top <= i2 && i2 <= grid_range.bottom)) {
      return Math.max(0, Math.min(...selected_indices) - 1);
    }
    return null;
  }
};
__publicField(_DataTable, "__name__", "DataTable");
_DataTable.prototype.default_view = DataTableView;
_DataTable.define(({ List: List2, Bool: Bool2, Int: Int2, Ref: Ref2, Str: Str2, Enum: Enum2, Or: Or2, Nullable: Nullable2 }) => ({
  autosize_mode: [Enum2("fit_columns", "fit_viewport", "none", "force_fit"), "force_fit"],
  auto_edit: [Bool2, false],
  columns: [List2(Ref2(TableColumn)), []],
  fit_columns: [Nullable2(Bool2), null],
  frozen_columns: [Nullable2(Int2), null],
  frozen_rows: [Nullable2(Int2), null],
  sortable: [Bool2, true],
  reorderable: [Bool2, true],
  editable: [Bool2, false],
  selectable: [Or2(Bool2, Enum2("checkbox")), true],
  index_position: [Nullable2(Int2), 0],
  index_header: [Str2, "#"],
  index_width: [Int2, 40],
  scroll_to_selection: [Bool2, true],
  header_row: [Bool2, true],
  row_height: [Int2, 25]
}));
_DataTable.override({
  width: 600,
  height: 400
});
var DataTable = _DataTable;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/row_aggregators.js
var import_slickgrid3 = __toESM(require_slickgrid());
var { Avg, Min, Max, Sum } = import_slickgrid3.Data.Aggregators;
var _RowAggregator = class _RowAggregator extends Model {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_RowAggregator, "__name__", "RowAggregator");
_RowAggregator.define(({ Str: Str2 }) => ({
  field_: [Str2, ""]
}));
var RowAggregator = _RowAggregator;
var avg = new Avg();
var AvgAggregator = class extends RowAggregator {
  constructor() {
    super(...arguments);
    __publicField(this, "key", "avg");
    __publicField(this, "init", avg.init);
    __publicField(this, "accumulate", avg.accumulate);
    __publicField(this, "storeResult", avg.storeResult);
  }
};
__publicField(AvgAggregator, "__name__", "AvgAggregator");
var min9 = new Min();
var MinAggregator = class extends RowAggregator {
  constructor() {
    super(...arguments);
    __publicField(this, "key", "min");
    __publicField(this, "init", min9.init);
    __publicField(this, "accumulate", min9.accumulate);
    __publicField(this, "storeResult", min9.storeResult);
  }
};
__publicField(MinAggregator, "__name__", "MinAggregator");
var max17 = new Max();
var MaxAggregator = class extends RowAggregator {
  constructor() {
    super(...arguments);
    __publicField(this, "key", "max");
    __publicField(this, "init", max17.init);
    __publicField(this, "accumulate", max17.accumulate);
    __publicField(this, "storeResult", max17.storeResult);
  }
};
__publicField(MaxAggregator, "__name__", "MaxAggregator");
var sum2 = new Sum();
var SumAggregator = class extends RowAggregator {
  constructor() {
    super(...arguments);
    __publicField(this, "key", "sum");
    __publicField(this, "init", sum2.init);
    __publicField(this, "accumulate", sum2.accumulate);
    __publicField(this, "storeResult", sum2.storeResult);
  }
};
__publicField(SumAggregator, "__name__", "SumAggregator");

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/data_cube.js
var import_slickgrid4 = __toESM(require_slickgrid());
function groupCellFormatter(_row, _cell, _value, _columnDef, dataContext) {
  const { collapsed: collapsed2, level, title: title3 } = dataContext;
  const toggle = span({
    class: `slick-group-toggle ${collapsed2 ? "collapsed" : "expanded"}`,
    style: { "margin-left": `${level * 15}px` }
  });
  const titleElement = span({
    class: "slick-group-title"
  }, title3);
  return `${toggle.outerHTML}${titleElement.outerHTML}`;
}
function indentFormatter(formatter, indent) {
  return (row2, cell, value2, columnDef, dataContext) => {
    const spacer = span({
      class: "slick-group-toggle",
      style: { "margin-left": `${(indent ?? 0) * 15}px` }
    });
    const formatted = formatter != null ? formatter(row2, cell, value2, columnDef, dataContext) : `${value2}`;
    return `${spacer.outerHTML}${formatted.replace(/^<div/, "<span").replace(/div>$/, "span>")}`;
  };
}
function handleGridClick(event2, args) {
  const item3 = this.getDataItem(args.row);
  if (item3 instanceof import_slickgrid4.Group && event2.target.classList.contains("slick-group-toggle")) {
    if (item3.collapsed) {
      this.getData().expandGroup(item3.groupingKey);
    } else {
      this.getData().collapseGroup(item3.groupingKey);
    }
    event2.stopImmediatePropagation();
    event2.preventDefault();
    this.invalidate();
    this.render();
  }
}
var _GroupingInfo = class _GroupingInfo extends Model {
  constructor(attrs) {
    super(attrs);
  }
  get comparer() {
    return (a2, b2) => {
      return a2.value === b2.value ? 0 : a2.value > b2.value ? 1 : -1;
    };
  }
};
__publicField(_GroupingInfo, "__name__", "GroupingInfo");
_GroupingInfo.define(({ Bool: Bool2, Str: Str2, List: List2, Ref: Ref2 }) => ({
  getter: [Str2, ""],
  aggregators: [List2(Ref2(RowAggregator)), []],
  collapsed: [Bool2, false]
}));
var GroupingInfo = _GroupingInfo;
var DataCubeProvider = class extends TableDataProvider {
  constructor(source2, view, columns2, target) {
    super(source2, view);
    __publicField(this, "columns");
    __publicField(this, "groupingInfos");
    __publicField(this, "groupingDelimiter");
    __publicField(this, "toggledGroupsByLevel");
    __publicField(this, "rows");
    __publicField(this, "target");
    this.columns = columns2;
    this.groupingInfos = [];
    this.groupingDelimiter = ":|:";
    this.target = target;
  }
  setGrouping(groupingInfos) {
    this.groupingInfos = groupingInfos;
    this.toggledGroupsByLevel = groupingInfos.map(() => ({}));
    this.refresh();
  }
  extractGroups(rows, parent_group) {
    const groups = [];
    const groupsByValue = /* @__PURE__ */ new Map();
    const level = parent_group != null ? parent_group.level + 1 : 0;
    const { comparer, getter } = this.groupingInfos[level];
    for (const row2 of rows) {
      const column = dict(this.source.data).get(getter);
      assert(column != null);
      const value2 = column[row2];
      let group = groupsByValue.get(value2);
      if (group == null) {
        const groupingKey = parent_group != null ? `${parent_group.groupingKey}${this.groupingDelimiter}${value2}` : `${value2}`;
        group = Object.assign(new import_slickgrid4.Group(), { value: value2, level, groupingKey });
        groups.push(group);
        groupsByValue.set(value2, group);
      }
      group.rows.push(row2);
    }
    if (level < this.groupingInfos.length - 1) {
      for (const group of groups) {
        group.groups = this.extractGroups(group.rows, group);
      }
    }
    groups.sort(comparer);
    return groups;
  }
  calculateTotals(group, aggregators) {
    const totals = { avg: {}, max: {}, min: {}, sum: {} };
    const data3 = dict(this.source.data);
    const names4 = [...data3.keys()];
    const items = group.rows.map((i2) => {
      return names4.reduce((obj, name) => ({ ...obj, [name]: data3.get(name)[i2] }), {});
    });
    for (const aggregator of aggregators) {
      aggregator.init();
      for (const item3 of items) {
        aggregator.accumulate(item3);
      }
      aggregator.storeResult(totals);
    }
    return totals;
  }
  addTotals(groups, level = 0) {
    const { aggregators, collapsed: groupCollapsed } = this.groupingInfos[level];
    const toggledGroups = this.toggledGroupsByLevel[level];
    for (const group of groups) {
      if (!is_nullish(group.groups)) {
        this.addTotals(group.groups, level + 1);
      }
      if (aggregators.length != 0 && group.rows.length != 0) {
        group.totals = this.calculateTotals(group, aggregators);
      }
      group.collapsed = groupCollapsed !== toggledGroups[group.groupingKey];
      group.title = group.value ? `${group.value}` : "";
    }
  }
  flattenedGroupedRows(groups, level = 0) {
    const rows = [];
    for (const group of groups) {
      rows.push(group);
      if (!group.collapsed) {
        const subRows = !is_nullish(group.groups) ? this.flattenedGroupedRows(group.groups, level + 1) : group.rows;
        rows.push(...subRows);
      }
    }
    return rows;
  }
  refresh() {
    const groups = this.extractGroups(this.view.indices);
    const data3 = dict(this.source.data);
    const labels = data3.get(this.columns[0].field);
    assert(labels != null);
    if (groups.length != 0) {
      this.addTotals(groups);
      this.rows = this.flattenedGroupedRows(groups);
      this.target.data = {
        row_indices: this.rows.map((value2) => value2 instanceof import_slickgrid4.Group ? value2.rows : value2),
        labels: this.rows.map((value2) => value2 instanceof import_slickgrid4.Group ? value2.title : labels[value2])
      };
    }
  }
  getLength() {
    return this.rows.length;
  }
  getItem(i2) {
    const item3 = this.rows[i2];
    const data3 = dict(this.source.data);
    return item3 instanceof import_slickgrid4.Group ? item3 : [...data3.keys()].reduce((obj, name) => ({ ...obj, [name]: data3.get(name)[item3] }), { [DTINDEX_NAME]: item3 });
  }
  getItemMetadata(i2) {
    const my_item = this.rows[i2];
    const columns2 = this.columns.slice(1);
    const aggregators = my_item instanceof import_slickgrid4.Group ? this.groupingInfos[my_item.level].aggregators : [];
    function adapter(column) {
      const { field: my_field, formatter } = column;
      const aggregator = aggregators.find(({ field_ }) => field_ === my_field);
      if (aggregator != null) {
        const { key } = aggregator;
        return {
          formatter(row2, cell, _value, columnDef, dataContext) {
            return formatter != null ? formatter(row2, cell, dataContext.totals[key][my_field], columnDef, dataContext) : "";
          }
        };
      }
      return {};
    }
    return my_item instanceof import_slickgrid4.Group ? {
      selectable: false,
      focusable: false,
      cssClasses: "slick-group",
      columns: [{ formatter: groupCellFormatter }, ...columns2.map(adapter)]
    } : {};
  }
  collapseGroup(grouping_key) {
    const level = grouping_key.split(this.groupingDelimiter).length - 1;
    this.toggledGroupsByLevel[level][grouping_key] = !this.groupingInfos[level].collapsed;
    this.refresh();
  }
  expandGroup(grouping_key) {
    const level = grouping_key.split(this.groupingDelimiter).length - 1;
    this.toggledGroupsByLevel[level][grouping_key] = this.groupingInfos[level].collapsed;
    this.refresh();
  }
};
__publicField(DataCubeProvider, "__name__", "DataCubeProvider");
var DataCubeView = class extends DataTableView {
  _render_table() {
    const options2 = {
      enableCellNavigation: this.model.selectable !== false,
      enableColumnReorder: false,
      autosizeColsMode: this.autosize,
      multiColumnSort: false,
      editable: this.model.editable,
      autoEdit: this.model.auto_edit,
      rowHeight: this.model.row_height
    };
    const columns2 = this.model.columns.map((column) => column.toColumn());
    columns2[0].formatter = indentFormatter(columns2[0].formatter, this.model.grouping.length);
    delete columns2[0].editor;
    this.data = new DataCubeProvider(this.model.source, this.model.view, columns2, this.model.target);
    this.data.setGrouping(this.model.grouping);
    this.el.style.width = `${this.model.width}px`;
    this.grid = new import_slickgrid4.Grid(this.wrapper_el, this.data, columns2, options2);
    this.grid.onClick.subscribe(handleGridClick);
  }
};
__publicField(DataCubeView, "__name__", "DataCubeView");
var _DataCube = class _DataCube extends DataTable {
  constructor(attrs) {
    super(attrs);
  }
};
__publicField(_DataCube, "__name__", "DataCube");
_DataCube.prototype.default_view = DataCubeView;
_DataCube.define(({ List: List2, Ref: Ref2 }) => ({
  grouping: [List2(Ref2(GroupingInfo)), []],
  target: [Ref2(ColumnDataSource)]
}));
var DataCube = _DataCube;

// node_modules/@bokeh/bokehjs/build/js/lib/models/widgets/tables/main.js
register_models(tables_exports);
export {
  ActionItem,
  ActionTool,
  AdaptiveTicker,
  AjaxDataSource,
  AllIndices,
  AllLabels,
  Angular,
  Annotation,
  AnnularWedge,
  Annulus,
  Arc,
  AreaVisuals,
  Arrow,
  ArrowHead,
  Ascii,
  Axis,
  BBoxTileSource,
  Band,
  BaseColorBar,
  BasicTickFormatter,
  BasicTicker,
  Bezier,
  BinnedTicker,
  Block,
  BooleanFilter,
  BoxAnnotation,
  BoxEditTool,
  BoxInteractionHandles,
  BoxSelectTool,
  BoxZoomTool,
  BuiltinIcon,
  ByCSS,
  ByClass,
  ByID,
  ByXPath,
  CDSView,
  Canvas,
  CanvasTexture,
  CartesianFrame,
  CategoricalAxis,
  CategoricalColorMapper,
  CategoricalMarkerMapper,
  CategoricalPatternMapper,
  CategoricalScale,
  CategoricalTickFormatter,
  CategoricalTicker,
  charts_exports as Charts,
  CheckableItem,
  Circle,
  ClickButton,
  ClickPanTool,
  CloseDialog,
  ColorBar,
  ColorMapper,
  Column2 as Column,
  ColumnDataSource,
  ColumnarDataSource,
  Comparison,
  CompositeScale,
  CompositeTicker,
  ContinuousAxis,
  ContinuousColorMapper,
  ContinuousScale,
  ContinuousTicker,
  ContourColorBar,
  ContourRenderer,
  CoordinateMapping,
  CopyTool,
  CrosshairTool,
  CumSum,
  CustomAction,
  CustomJS,
  CustomJSCompare,
  CustomJSExpr,
  CustomJSFilter,
  CustomJSHover,
  CustomJSTickFormatter,
  CustomJSTicker,
  CustomJSTransform,
  CustomLabelingPolicy,
  DataRange,
  DataRange1d,
  DataSource,
  DatetimeAxis,
  DatetimeTickFormatter,
  DatetimeTicker,
  DaysTicker,
  Decoration,
  Dialog,
  DifferenceFilter,
  DividerItem,
  Document,
  Dodge,
  EdgeCoordinates,
  EdgesAndLinkedNodes,
  EdgesOnly,
  EditTool,
  Ellipse,
  EqHistColorMapper,
  ExamineTool,
  Examiner,
  Expression,
  FactorRange,
  Figure,
  Filter,
  FixedTicker,
  FlexBox,
  FreehandDrawTool,
  FullscreenTool,
  GMap,
  GMapOptions,
  GMapPlot,
  GeoJSONDataSource,
  GestureTool,
  Glyph,
  GlyphRenderer,
  GraphCoordinates,
  GraphHitTestPolicy,
  GraphLayout,
  GraphRenderer,
  Grid2 as Grid,
  GridBox,
  GridPlot,
  GroupBox,
  GroupByModels,
  GroupByName,
  GroupFilter,
  GuideRenderer,
  HArea,
  HAreaStep,
  HBar,
  HBox,
  HSpan,
  HStrip,
  HTMLLabel,
  HTMLLabelSet,
  HTMLTitle,
  HelpTool,
  HexTile,
  HoverTool,
  Image4 as Image,
  ImageRGBA,
  ImageStack,
  ImageURL,
  ImageURLTexture,
  ImperialLength,
  IndexFilter,
  Indexed,
  InspectTool,
  Interpolator,
  IntersectRenderers,
  IntersectionFilter,
  InversionFilter,
  Jitter,
  Label,
  LabelSet,
  LabelingPolicy,
  LassoSelectTool,
  LayoutDOM,
  LayoutProvider,
  Legend,
  LegendItem,
  linalg_exports as LinAlg,
  Line3 as Line,
  LineEditTool,
  LinearAxis,
  LinearColorMapper,
  LinearInterpolationScale,
  LinearInterpolator,
  LinearScale,
  LogAxis,
  LogColorMapper,
  LogScale,
  LogTickFormatter,
  LogTicker,
  MapOptions,
  Marking,
  MathML,
  MathMLGlyph,
  MathText,
  Maximum,
  Menu,
  MercatorAxis,
  MercatorTickFormatter,
  MercatorTicker,
  MercatorTileSource,
  Metric,
  MetricLength,
  Minimum,
  Models,
  MonthsTicker,
  MultiLine,
  MultiPolygons,
  NanCompare,
  Ngon,
  NoOverlap,
  Node2 as Node,
  NodeCoordinates,
  NodesAndAdjacentNodes,
  NodesAndLinkedEdges,
  NodesOnly,
  NormalHead,
  NumeralTickFormatter,
  OnOffButton,
  OpenDialog,
  OpenHead,
  OpenURL,
  palettes_exports as Palettes,
  PanTool,
  Pane,
  Panel,
  ParkMillerLCG,
  Patch,
  Patches,
  PlainText,
  Plot,
  plotting_exports as Plotting,
  PointDrawTool,
  PolarTransform,
  PolyAnnotation,
  PolyDrawTool,
  PolyEditTool,
  PolySelectTool,
  PolyTool,
  PrintfTickFormatter,
  QUADKEYTileSource,
  Quad,
  Quadratic,
  Range,
  Range1d,
  RangeTool,
  Ray,
  ReciprocalMetric,
  ReciprocalMetricLength,
  Rect,
  RedoTool,
  Renderer,
  RendererGroup,
  ResetTool,
  Row2 as Row,
  SVGIcon,
  SaveTool,
  ScalarExpression,
  Scale,
  ScaleBar,
  ScanningColorMapper,
  Scatter,
  ScrollBox,
  Segment,
  SelectTool,
  Selection,
  SelectionPolicy,
  ServerSentDataSource,
  SetValue,
  SingleIntervalTicker,
  Slope,
  Spacer,
  Span2 as Span,
  Spline,
  Stack2 as Stack,
  StackColorMapper,
  StaticLayoutProvider,
  Step,
  StepInterpolator,
  SymmetricDifferenceFilter,
  TMSTileSource,
  TabPanel,
  TablerIcon,
  tables_exports as Tables,
  Tabs,
  TapTool,
  TeX,
  TeXGlyph,
  TeeHead,
  Text4 as Text,
  TextAnnotation,
  Texture,
  themes_exports as Themes,
  TickFormatter,
  Ticker,
  TileRenderer,
  TileSource,
  Title,
  ToggleVisibility,
  Tool,
  ToolButton,
  ToolProxy,
  Toolbar,
  ToolbarPanel,
  Tooltip,
  Transform,
  UIElement,
  UndoTool,
  UnionFilter,
  UnionRenderers,
  VArea,
  VAreaStep,
  VBar,
  VBox,
  VSpan,
  VStrip,
  VeeHead,
  WMTSTileSource,
  WebDataSource,
  Wedge,
  WeightedStackColorMapper,
  WheelPanTool,
  WheelZoomTool,
  Whisker,
  widgets_exports as Widgets,
  XComponent,
  XY,
  YComponent,
  YearsTicker,
  ZoomInTool,
  ZoomOutTool,
  documents,
  embed_exports as embed,
  f,
  index,
  logger,
  protocol_exports as protocol,
  safely,
  set_log_level,
  settings,
  sprintf,
  version
};
/*! Bundled license information:

@bokeh/numbro/numbro.js:
  (*!
   * numbro.js
   * version : 1.6.2
   * author : Företagsplatsen AB
   * license : MIT
   * http://www.foretagsplatsen.se
   *)

choices.js/public/assets/scripts/choices.js:
  (*! choices.js v10.2.0 | © 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@bokeh/slickgrid/lib/jquery.event.drag-2.3.0.js:
  (*!
   * jquery.event.drag - v 2.3.0
   * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
   * Open Source MIT License - http://threedubmedia.com/code/license
   *)

@bokeh/slickgrid/lib/jquery.event.drop-2.3.0.js:
  (*!
   * jquery.event.drop - v 2.3.0
   * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
   * Open Source MIT License - http://threedubmedia.com/code/license
   *)

@bokeh/slickgrid/slick.grid.js:
  (**
   * @license
   * (c) 2009-2016 Michael Leibman
   * michael{dot}leibman{at}gmail{dot}com
   * http://github.com/mleibman/slickgrid
   *
   * Distributed under MIT license.
   * All rights reserved.
   *
   * SlickGrid v2.4
   *
   * NOTES:
   *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.
   *     This increases the speed dramatically, but can only be done safely because there are no event handlers
   *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()
   *     and do proper cleanup.
   *)

@bokeh/bokehjs/build/js/lib/core/util/wheel.js:
  (*!
   * jQuery Mousewheel 3.1.13
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *)
*/
//# sourceMappingURL=@bokeh_bokehjs.js.map
