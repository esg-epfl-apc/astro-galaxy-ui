{
  "version": 3,
  "sources": ["../../@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/multi_line.js"],
  "sourcesContent": ["import { BaseLineGL } from \"./base_line\";\nimport { Float32Buffer, Uint8Buffer } from \"./buffer\";\nexport class MultiLineGL extends BaseLineGL {\n    glyph;\n    static __name__ = \"MultiLineGL\";\n    constructor(regl_wrapper, glyph) {\n        super(regl_wrapper, glyph);\n        this.glyph = glyph;\n    }\n    draw(indices, main_glyph, transform) {\n        // Indices refer to whole lines not line segments\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        const main_gl_glyph = main_glyph.glglyph;\n        const data_changed_or_mapped = main_gl_glyph.data_changed || main_gl_glyph.data_mapped;\n        if (data_changed_or_mapped) {\n            main_gl_glyph._set_data(main_gl_glyph.data_changed);\n        }\n        if ((data_changed_or_mapped && main_gl_glyph._is_dashed) || this._is_dashed) {\n            // length_so_far is a data property as it depends on point positions in canvas coordinates\n            // but is only needed for dashed lines so it also depends on visual properties.\n            // Care needed if base glyph is solid but e.g. nonselection glyph is dashed.\n            main_gl_glyph._set_length();\n        }\n        if (data_changed_or_mapped) {\n            main_gl_glyph.data_changed = false;\n            main_gl_glyph.data_mapped = false;\n        }\n        const { data_size } = this.glyph; // Number of lines\n        let framebuffer = null;\n        let tex = null;\n        if (data_size > 1) {\n            [framebuffer, tex] = this.regl_wrapper.framebuffer_and_texture;\n        }\n        let point_offset = 0;\n        let prev_index = -1;\n        for (const index of indices) {\n            for (let i = prev_index + 1; i < index; i++) {\n                // Account for offsets of lines not displayed\n                const npoints = main_glyph.sxs.get(i).length;\n                point_offset += (npoints + 2) * 2;\n            }\n            const npoints = main_glyph.sxs.get(index).length;\n            const nsegments = npoints - 1; // Points array includes extra points at each end\n            // Not necessary if just a single line\n            if (framebuffer != null) {\n                this.regl_wrapper.clear_framebuffer(framebuffer);\n            }\n            this._draw_single(main_gl_glyph, transform, index, point_offset, nsegments, framebuffer);\n            if (framebuffer != null) {\n                // Accumulate framebuffer to WebGL canvas\n                const accumulate_props = {\n                    scissor: this.regl_wrapper.scissor,\n                    viewport: this.regl_wrapper.viewport,\n                    framebuffer_tex: tex,\n                };\n                this.regl_wrapper.accumulate()(accumulate_props);\n            }\n            point_offset += (npoints + 2) * 2;\n            prev_index = index;\n        }\n    }\n    _get_visuals() {\n        return this.glyph.visuals.line;\n    }\n    _set_data(data_changed) {\n        // If data_changed is false the underlying glyph data has not changed but has been mapped to\n        // different canvas coordinates e.g. via pan or zoom. If data_changed is true the data itself\n        // has changed, which also implies it has been mapped.\n        // Set data properties which are points and show flags for data\n        // (taking into account NaNs but not selected indices)\n        const line_count = this.glyph.data_size;\n        const total_point_count = this.glyph.sxs.data.length;\n        if (this._points == null) {\n            this._points = new Float32Buffer(this.regl_wrapper);\n        }\n        const points_array = this._points.get_sized_array((total_point_count + 2 * line_count) * 2);\n        let point_offset = 0;\n        for (let i = 0; i < line_count; i++) {\n            // Process a single line at a time.\n            const sx = this.glyph.sxs.get(i);\n            const sy = this.glyph.sys.get(i);\n            const npoints = sx.length;\n            const points = points_array.subarray(point_offset, point_offset + (npoints + 2) * 2);\n            this._set_points_single(points, sx, sy);\n            point_offset += (npoints + 2) * 2;\n        }\n        this._points.update();\n        if (data_changed) {\n            if (this._show == null) {\n                this._show = new Uint8Buffer(this.regl_wrapper);\n            }\n            const show_array = this._show.get_sized_array(total_point_count + line_count);\n            let point_offset = 0;\n            let show_offset = 0;\n            for (let i = 0; i < line_count; i++) {\n                // Process a single line at a time.\n                const sx = this.glyph.sxs.get(i);\n                const npoints = sx.length;\n                const points = points_array.subarray(point_offset, point_offset + (npoints + 2) * 2);\n                const show = show_array.subarray(show_offset, show_offset + npoints + 1);\n                this._set_show_single(show, points);\n                point_offset += (npoints + 2) * 2;\n                show_offset += npoints + 1;\n            }\n            this._show.update();\n        }\n    }\n    _set_length() {\n        const line_count = this.glyph.data_size;\n        const total_point_count = this.glyph.sxs.data.length;\n        const points_array = this._points.get_array();\n        const show_array = this._show.get_array();\n        if (this._length_so_far == null) {\n            this._length_so_far = new Float32Buffer(this.regl_wrapper);\n        }\n        const length_so_far = this._length_so_far.get_sized_array(total_point_count - line_count);\n        let point_offset = 0;\n        let show_offset = 0;\n        let length_offset = 0;\n        for (let i = 0; i < line_count; i++) {\n            const sx = this.glyph.sxs.get(i);\n            const npoints = sx.length;\n            const nsegments = npoints - 1;\n            const points = points_array.subarray(point_offset, point_offset + (npoints + 2) * 2);\n            const show = show_array.subarray(show_offset, show_offset + npoints + 1);\n            const length = length_so_far.subarray(length_offset, length_offset + nsegments);\n            this._set_length_single(length, points, show);\n            point_offset += (npoints + 2) * 2;\n            show_offset += npoints + 1;\n            length_offset += nsegments;\n        }\n        this._length_so_far.update();\n    }\n}\n//# sourceMappingURL=multi_line.js.map"],
  "mappings": "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",
  "names": ["npoints", "point_offset"]
}
