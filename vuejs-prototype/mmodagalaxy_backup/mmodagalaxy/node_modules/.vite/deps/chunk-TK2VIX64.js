import {
  BaseGLGlyph,
  Float32Buffer,
  NormalizedUint8Buffer,
  Uint8Buffer,
  marker_type_to_size_hint
} from "./chunk-FHOMUG4O.js";
import {
  __publicField
} from "./chunk-EWTE5DHJ.js";

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/base_marker.js
var BaseMarkerGL = class extends BaseGLGlyph {
  constructor() {
    super(...arguments);
    __publicField(this, "_antialias", 1.5);
    // data properties
    __publicField(this, "_centers", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_widths", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_heights", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_angles", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_auxs", new Float32Buffer(this.regl_wrapper));
    // used by RectGL
    __publicField(this, "_border_radius", [0, 0, 0, 0]);
    __publicField(this, "_border_radius_nonzero", false);
    // indices properties
    __publicField(this, "_show", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_show_all", false);
    // visual properties
    __publicField(this, "_linewidths", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_line_caps", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_line_joins", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_line_rgba", new NormalizedUint8Buffer(this.regl_wrapper, 4));
    __publicField(this, "_fill_rgba", new NormalizedUint8Buffer(this.regl_wrapper, 4));
    // Only needed if have hatch pattern, either all or none of the buffers are set.
    __publicField(this, "_have_hatch", false);
    __publicField(this, "_hatch_patterns", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_hatch_scales", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_hatch_weights", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_hatch_rgba", new NormalizedUint8Buffer(this.regl_wrapper, 4));
    __publicField(this, "_did_set_once", false);
  }
  marker_props(main_gl_glyph) {
    return {
      width: main_gl_glyph._widths,
      height: main_gl_glyph._heights,
      angle: main_gl_glyph._angles,
      aux: main_gl_glyph._auxs,
      border_radius: main_gl_glyph._border_radius
    };
  }
  get line_props() {
    return {
      linewidth: this._linewidths,
      line_color: this._line_rgba,
      line_cap: this._line_caps,
      line_join: this._line_joins
    };
  }
  get fill_props() {
    return {
      fill_color: this._fill_rgba
    };
  }
  get hatch_props() {
    return {
      hatch_pattern: this._hatch_patterns,
      hatch_scale: this._hatch_scales,
      hatch_weight: this._hatch_weights,
      hatch_color: this._hatch_rgba
    };
  }
  _draw_one_marker_type(marker_type, transform, main_gl_glyph) {
    const props_no_hatch = {
      scissor: this.regl_wrapper.scissor,
      viewport: this.regl_wrapper.viewport,
      canvas_size: [transform.width, transform.height],
      size_hint: marker_type_to_size_hint(marker_type),
      nmarkers: main_gl_glyph.nvertices,
      antialias: this._antialias / transform.pixel_ratio,
      show: this._show,
      center: main_gl_glyph._centers,
      ...this.marker_props(main_gl_glyph),
      ...this.line_props,
      ...this.fill_props
    };
    if (this._have_hatch) {
      const props_hatch = { ...props_no_hatch, ...this.hatch_props };
      const draw = this.regl_wrapper.marker_hatch(marker_type);
      draw(props_hatch);
    } else {
      const draw = this.regl_wrapper.marker_no_hatch(marker_type);
      draw(props_no_hatch);
    }
  }
  set_data() {
    if (!this._did_set_once) {
      this._did_set_once = true;
      this._set_once();
    }
    this._set_data();
  }
  _set_once() {
  }
  _set_visuals() {
    const { line, fill, hatch } = this._get_visuals();
    this._linewidths.set_from_prop(line.line_width);
    this._line_caps.set_from_line_cap(line.line_cap);
    this._line_joins.set_from_line_join(line.line_join);
    this._line_rgba.set_from_color(line.line_color, line.line_alpha);
    this._fill_rgba.set_from_color(fill.fill_color, fill.fill_alpha);
    this._have_hatch = hatch.doit;
    if (this._have_hatch) {
      this._hatch_patterns.set_from_hatch_pattern(hatch.hatch_pattern);
      this._hatch_scales.set_from_prop(hatch.hatch_scale);
      this._hatch_weights.set_from_prop(hatch.hatch_weight);
      this._hatch_rgba.set_from_color(hatch.hatch_color, hatch.hatch_alpha);
    }
  }
};
__publicField(BaseMarkerGL, "__name__", "BaseMarkerGL");
// Avoiding use of nan or inf to represent missing data in webgl as shaders may
// have reduced floating point precision. So here using a large-ish negative
// value instead.
__publicField(BaseMarkerGL, "missing_point", -1e4);

export {
  BaseMarkerGL
};
//# sourceMappingURL=chunk-TK2VIX64.js.map
