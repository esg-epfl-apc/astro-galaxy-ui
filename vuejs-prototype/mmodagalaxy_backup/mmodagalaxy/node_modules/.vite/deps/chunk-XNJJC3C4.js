import {
  BaseGLGlyph,
  Float32Buffer,
  NormalizedUint8Buffer,
  PlainObjectProxy,
  Uint8Buffer,
  assert,
  color2css,
  color2rgba,
  encode_rgba,
  entries,
  find,
  includes,
  isArray,
  isBoolean,
  isFunction,
  isInteger,
  isIterable,
  isNumber,
  isObject,
  isPlainObject,
  isPrimitive,
  isString,
  isSymbol,
  isTypedArray,
  is_Color,
  is_empty2 as is_empty,
  keys,
  logger,
  map,
  max,
  min,
  mul,
  range,
  remove_by,
  repeat,
  size,
  to_radians_coeff,
  typed_entries,
  typed_values,
  unreachable,
  values
} from "./chunk-FHOMUG4O.js";
import {
  __export,
  __publicField
} from "./chunk-EWTE5DHJ.js";

// node_modules/@bokeh/bokehjs/build/js/lib/core/settings.js
var Settings = class {
  constructor() {
    __publicField(this, "_dev", false);
    __publicField(this, "_wireframe", false);
    __publicField(this, "_force_webgl", false);
    __publicField(this, "_force_fields", false);
  }
  set dev(dev) {
    this._dev = dev;
  }
  get dev() {
    return this._dev;
  }
  set wireframe(wireframe) {
    this._wireframe = wireframe;
  }
  get wireframe() {
    return this._wireframe;
  }
  set force_webgl(force_webgl) {
    this._force_webgl = force_webgl;
  }
  get force_webgl() {
    return this._force_webgl;
  }
  set force_fields(force_fields) {
    this._force_fields = force_fields;
  }
  get force_fields() {
    return this._force_fields;
  }
};
__publicField(Settings, "__name__", "Settings");
var settings = new Settings();

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/visual.js
var global_css_prefix = "--bk-";
var VisualProperties = class {
  constructor(obj, prefix = "") {
    __publicField(this, "obj");
    __publicField(this, "prefix");
    __publicField(this, "_props");
    __publicField(this, "css_prefix");
    this.obj = obj;
    this.prefix = prefix;
    this.css_prefix = `${global_css_prefix}${prefix.replaceAll("_", "-")}`;
    const self = this;
    this._props = [];
    for (const attr of this.attrs) {
      const prop = obj.model.properties[prefix + attr];
      prop.change.connect(() => this.update());
      self[attr] = prop;
      this._props.push(prop);
    }
  }
  *[Symbol.iterator]() {
    yield* this._props;
  }
  update() {
  }
  _get_css_value(name) {
    const style = getComputedStyle(this.obj.el);
    return style.getPropertyValue(`${this.css_prefix}${name}`);
  }
};
__publicField(VisualProperties, "__name__", "VisualProperties");
var VisualUniforms = class {
  constructor(obj, prefix = "") {
    __publicField(this, "obj");
    __publicField(this, "prefix");
    this.obj = obj;
    this.prefix = prefix;
    for (const attr of this.attrs) {
      Object.defineProperty(this, attr, {
        get() {
          return obj[prefix + attr];
        }
      });
    }
  }
  *[Symbol.iterator]() {
    for (const attr of this.attrs) {
      yield this.obj.model.properties[this.prefix + attr];
    }
  }
  update() {
  }
};
__publicField(VisualUniforms, "__name__", "VisualUniforms");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/defer.js
var channel = new MessageChannel();
var tasks = /* @__PURE__ */ new Map();
channel.port1.onmessage = (event) => {
  const handle = event.data;
  const fn = tasks.get(handle);
  if (fn != null) {
    try {
      fn();
    } finally {
      tasks.delete(handle);
    }
  }
};
var counter = 1;
function defer() {
  return new Promise((resolve) => {
    const handle = counter++;
    tasks.set(handle, resolve);
    channel.port2.postMessage(handle);
  });
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/signaling.js
var Signal = class {
  constructor(sender, name) {
    __publicField(this, "sender");
    __publicField(this, "name");
    this.sender = sender;
    this.name = name;
  }
  connect(slot, context = null) {
    if (!receivers_for_sender.has(this.sender)) {
      receivers_for_sender.set(this.sender, []);
    }
    const receivers = receivers_for_sender.get(this.sender);
    if (find_connection(receivers, this, slot, context) != null) {
      return false;
    }
    const receiver = context ?? slot;
    if (!senders_for_receiver.has(receiver)) {
      senders_for_receiver.set(receiver, []);
    }
    const senders = senders_for_receiver.get(receiver);
    const connection = { signal: this, slot, context };
    receivers.push(connection);
    senders.push(connection);
    return true;
  }
  disconnect(slot, context = null) {
    const receivers = receivers_for_sender.get(this.sender);
    if (receivers == null || receivers.length === 0) {
      return false;
    }
    const connection = find_connection(receivers, this, slot, context);
    if (connection == null) {
      return false;
    }
    const receiver = context ?? slot;
    const senders = senders_for_receiver.get(receiver);
    connection.signal = null;
    schedule_cleanup(receivers);
    schedule_cleanup(senders);
    return true;
  }
  emit(args) {
    const receivers = receivers_for_sender.get(this.sender) ?? [];
    for (const { signal, slot, context } of receivers) {
      if (signal === this) {
        slot.call(context, args, this.sender);
      }
    }
  }
};
__publicField(Signal, "__name__", "Signal");
var Signal0 = class extends Signal {
  emit() {
    super.emit(void 0);
  }
};
__publicField(Signal0, "__name__", "Signal0");
(function(Signal2) {
  function disconnect_between(sender, receiver) {
    const receivers = receivers_for_sender.get(sender);
    if (receivers == null || receivers.length === 0) {
      return;
    }
    const senders = senders_for_receiver.get(receiver);
    if (senders == null || senders.length === 0) {
      return;
    }
    for (const connection of senders) {
      if (connection.signal == null) {
        return;
      }
      if (connection.signal.sender === sender) {
        connection.signal = null;
      }
    }
    schedule_cleanup(receivers);
    schedule_cleanup(senders);
  }
  Signal2.disconnect_between = disconnect_between;
  function disconnect_sender(sender) {
    const receivers = receivers_for_sender.get(sender);
    if (receivers == null || receivers.length === 0) {
      return;
    }
    for (const connection of receivers) {
      if (connection.signal == null) {
        return;
      }
      const receiver = connection.context ?? connection.slot;
      connection.signal = null;
      schedule_cleanup(senders_for_receiver.get(receiver));
    }
    schedule_cleanup(receivers);
  }
  Signal2.disconnect_sender = disconnect_sender;
  function disconnect_receiver(receiver, slot, except_senders) {
    const senders = senders_for_receiver.get(receiver);
    if (senders == null || senders.length === 0) {
      return;
    }
    for (const connection of senders) {
      if (connection.signal == null) {
        return;
      }
      if (slot != null && connection.slot != slot) {
        continue;
      }
      const sender = connection.signal.sender;
      if (except_senders != null && except_senders.has(sender)) {
        continue;
      }
      connection.signal = null;
      schedule_cleanup(receivers_for_sender.get(sender));
    }
    schedule_cleanup(senders);
  }
  Signal2.disconnect_receiver = disconnect_receiver;
  function disconnect_all(obj) {
    const receivers = receivers_for_sender.get(obj);
    if (receivers != null && receivers.length !== 0) {
      for (const connection of receivers) {
        connection.signal = null;
      }
      schedule_cleanup(receivers);
    }
    const senders = senders_for_receiver.get(obj);
    if (senders != null && senders.length !== 0) {
      for (const connection of senders) {
        connection.signal = null;
      }
      schedule_cleanup(senders);
    }
  }
  Signal2.disconnect_all = disconnect_all;
})(Signal || (Signal = {}));
function Signalable() {
  return class {
    connect(signal, slot) {
      return signal.connect(slot, this);
    }
    disconnect(signal, slot) {
      return signal.disconnect(slot, this);
    }
  };
}
var receivers_for_sender = /* @__PURE__ */ new WeakMap();
var senders_for_receiver = /* @__PURE__ */ new WeakMap();
function find_connection(conns, signal, slot, context) {
  return find(conns, (conn) => conn.signal === signal && conn.slot === slot && conn.context === context);
}
var dirty_set = /* @__PURE__ */ new Set();
function schedule_cleanup(connections) {
  if (dirty_set.size == 0) {
    void (async () => {
      await defer();
      cleanup_dirty_set();
    })();
  }
  dirty_set.add(connections);
}
function cleanup_dirty_set() {
  for (const connections of dirty_set) {
    remove_by(connections, (connection) => connection.signal == null);
  }
  dirty_set.clear();
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/kinds.js
var kinds_exports = {};
__export(kinds_exports, {
  Alpha: () => Alpha,
  And: () => And,
  Angle: () => Angle,
  Any: () => Any,
  AnyRef: () => AnyRef,
  Array: () => Array2,
  Arrayable: () => Arrayable,
  Auto: () => Auto,
  Bool: () => Bool,
  Boolean: () => Boolean,
  Bytes: () => Bytes,
  CSSLength: () => CSSLength,
  Color: () => Color,
  Dict: () => Dict,
  Enum: () => Enum,
  Float: () => Float,
  Font: () => Font,
  FontSize: () => FontSize,
  Func: () => Func,
  Function: () => Function2,
  Int: () => Int,
  Iterable: () => Iterable,
  Kind: () => Kind,
  Kinds: () => Kinds,
  List: () => List,
  Map: () => Map2,
  Mapping: () => Mapping,
  Node: () => Node2,
  NonEmptyList: () => NonEmptyList,
  NonNegative: () => NonNegative,
  Null: () => Null,
  Nullable: () => Nullable,
  Number: () => Number2,
  Opt: () => Opt,
  Or: () => Or,
  PartialStruct: () => PartialStruct,
  Percent: () => Percent,
  Positive: () => Positive,
  Ref: () => Ref,
  Regex: () => Regex,
  Set: () => Set2,
  Str: () => Str,
  String: () => String2,
  Struct: () => Struct,
  Tuple: () => Tuple,
  Unknown: () => Unknown
});

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/refs.js
function is_ref(obj) {
  return isPlainObject(obj) && "id" in obj && !("type" in obj);
}
var has_refs = Symbol("has_refs");
function _is_HasRefs(v) {
  return has_refs in v;
}
function is_HasRefs(v) {
  return isObject(v) && _is_HasRefs(v);
}
function may_have_refs(obj) {
  if (_is_HasRefs(obj)) {
    return obj[has_refs];
  }
  const type = obj.constructor;
  if (is_HasRefs(type)) {
    return type[has_refs];
  }
  return true;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/kinds.js
var ESMap = globalThis.Map;
var ESSet = globalThis.Set;
var DOMNode = globalThis.Node;
var Kind = class {
  constructor() {
    __publicField(this, "__type__");
  }
};
__publicField(Kind, "__name__", "Kind");
var Kinds;
(function(Kinds2) {
  class Primitive extends Kind {
    may_have_refs() {
      return false;
    }
  }
  __publicField(Primitive, "__name__", "Primitive");
  Kinds2.Primitive = Primitive;
  class Any2 extends Primitive {
    valid(value) {
      return value !== void 0;
    }
    toString() {
      return "Any";
    }
    may_have_refs() {
      return true;
    }
  }
  __publicField(Any2, "__name__", "Any");
  Kinds2.Any = Any2;
  class Unknown2 extends Primitive {
    valid(value) {
      return value !== void 0;
    }
    toString() {
      return "Unknown";
    }
    may_have_refs() {
      return true;
    }
  }
  __publicField(Unknown2, "__name__", "Unknown");
  Kinds2.Unknown = Unknown2;
  class Bool2 extends Primitive {
    valid(value) {
      return isBoolean(value);
    }
    toString() {
      return "Bool";
    }
  }
  __publicField(Bool2, "__name__", "Bool");
  Kinds2.Bool = Bool2;
  class Ref2 extends Kind {
    constructor(obj_type) {
      super();
      __publicField(this, "obj_type");
      this.obj_type = obj_type;
    }
    valid(value) {
      return value instanceof this.obj_type;
    }
    toString() {
      const tp = this.obj_type;
      const name = tp.__name__ ?? tp.toString();
      return `Ref(${name})`;
    }
    may_have_refs() {
      const { obj_type } = this;
      return has_refs in obj_type ? obj_type[has_refs] : true;
    }
  }
  __publicField(Ref2, "__name__", "Ref");
  Kinds2.Ref = Ref2;
  class AnyRef2 extends Kind {
    valid(value) {
      return isObject(value);
    }
    toString() {
      return "AnyRef";
    }
    may_have_refs() {
      return true;
    }
  }
  __publicField(AnyRef2, "__name__", "AnyRef");
  Kinds2.AnyRef = AnyRef2;
  class Float2 extends Primitive {
    valid(value) {
      return isNumber(value);
    }
    toString() {
      return "Float";
    }
  }
  __publicField(Float2, "__name__", "Float");
  Kinds2.Float = Float2;
  class Int2 extends Float2 {
    valid(value) {
      return super.valid(value) && isInteger(value);
    }
    toString() {
      return "Int";
    }
  }
  __publicField(Int2, "__name__", "Int");
  Kinds2.Int = Int2;
  class Percent2 extends Float2 {
    valid(value) {
      return super.valid(value) && 0 <= value && value <= 1;
    }
    toString() {
      return "Percent";
    }
  }
  __publicField(Percent2, "__name__", "Percent");
  Kinds2.Percent = Percent2;
  class Or2 extends Kind {
    constructor(types) {
      super();
      __publicField(this, "types");
      this.types = types;
      this.types = types;
    }
    valid(value) {
      return this.types.some((type) => type.valid(value));
    }
    toString() {
      return `Or(${this.types.map((type) => type.toString()).join(", ")})`;
    }
    may_have_refs() {
      return this.types.some((type) => type.may_have_refs());
    }
  }
  __publicField(Or2, "__name__", "Or");
  Kinds2.Or = Or2;
  class And2 extends Kind {
    constructor(type0, type1) {
      super();
      __publicField(this, "types");
      this.types = [type0, type1];
    }
    valid(value) {
      return this.types.some((type) => type.valid(value));
    }
    toString() {
      return `And(${this.types.map((type) => type.toString()).join(", ")})`;
    }
    may_have_refs() {
      return this.types.some((type) => type.may_have_refs());
    }
  }
  __publicField(And2, "__name__", "And");
  Kinds2.And = And2;
  class Tuple2 extends Kind {
    constructor(types) {
      super();
      __publicField(this, "types");
      this.types = types;
      this.types = types;
    }
    valid(value) {
      if (!isArray(value)) {
        return false;
      }
      for (let i = 0; i < this.types.length; i++) {
        const type = this.types[i];
        const item = value[i];
        if (!type.valid(item)) {
          return false;
        }
      }
      return true;
    }
    toString() {
      return `Tuple(${this.types.map((type) => type.toString()).join(", ")})`;
    }
    may_have_refs() {
      return this.types.some((type) => type.may_have_refs());
    }
  }
  __publicField(Tuple2, "__name__", "Tuple");
  Kinds2.Tuple = Tuple2;
  class Struct2 extends Kind {
    constructor(struct_type) {
      super();
      __publicField(this, "struct_type");
      this.struct_type = struct_type;
    }
    valid(value) {
      if (!isPlainObject(value)) {
        return false;
      }
      const struct_type_proxy = new PlainObjectProxy(this.struct_type);
      for (const key of keys(value)) {
        if (!struct_type_proxy.has(key)) {
          return false;
        }
      }
      for (const [key, item_type] of struct_type_proxy) {
        const item = value[key];
        if (!item_type.valid(item)) {
          return false;
        }
      }
      return true;
    }
    toString() {
      const items = typed_entries(this.struct_type).map(([key, kind]) => `${key.toString()}: ${kind}`).join(", ");
      return `Struct({${items}})`;
    }
    may_have_refs() {
      return typed_values(this.struct_type).some((kind) => kind.may_have_refs());
    }
  }
  __publicField(Struct2, "__name__", "Struct");
  Kinds2.Struct = Struct2;
  class PartialStruct2 extends Kind {
    constructor(struct_type) {
      super();
      __publicField(this, "struct_type");
      this.struct_type = struct_type;
    }
    valid(value) {
      if (!isPlainObject(value)) {
        return false;
      }
      const value_proxy = new PlainObjectProxy(value);
      const struct_type_proxy = new PlainObjectProxy(this.struct_type);
      for (const key of value_proxy.keys()) {
        if (!struct_type_proxy.has(key)) {
          return false;
        }
      }
      for (const [key, item_type] of struct_type_proxy) {
        const item = value_proxy.get(key);
        if (item === void 0) {
          continue;
        }
        if (!item_type.valid(item)) {
          return false;
        }
      }
      return true;
    }
    toString() {
      const items = typed_entries(this.struct_type).map(([key, kind]) => `${key.toString()}?: ${kind}`).join(", ");
      return `Struct({${items}})`;
    }
    may_have_refs() {
      return typed_values(this.struct_type).some((kind) => kind.may_have_refs());
    }
  }
  __publicField(PartialStruct2, "__name__", "PartialStruct");
  Kinds2.PartialStruct = PartialStruct2;
  class Iterable2 extends Kind {
    constructor(item_type) {
      super();
      __publicField(this, "item_type");
      this.item_type = item_type;
    }
    valid(value) {
      return isIterable(value);
    }
    toString() {
      return `Iterable(${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.item_type.may_have_refs();
    }
  }
  __publicField(Iterable2, "__name__", "Iterable");
  Kinds2.Iterable = Iterable2;
  class Arrayable2 extends Kind {
    constructor(item_type) {
      super();
      __publicField(this, "item_type");
      this.item_type = item_type;
    }
    valid(value) {
      return isArray(value) || isTypedArray(value);
    }
    toString() {
      return `Arrayable(${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.item_type.may_have_refs();
    }
  }
  __publicField(Arrayable2, "__name__", "Arrayable");
  Kinds2.Arrayable = Arrayable2;
  class List2 extends Kind {
    constructor(item_type) {
      super();
      __publicField(this, "item_type");
      this.item_type = item_type;
    }
    valid(value) {
      return isArray(value) && value.every((item) => this.item_type.valid(item));
    }
    toString() {
      return `List(${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.item_type.may_have_refs();
    }
  }
  __publicField(List2, "__name__", "List");
  Kinds2.List = List2;
  class NonEmptyList2 extends List2 {
    valid(value) {
      return super.valid(value) && value.length != 0;
    }
    toString() {
      return `NonEmptyList(${this.item_type.toString()})`;
    }
  }
  __publicField(NonEmptyList2, "__name__", "NonEmptyList");
  Kinds2.NonEmptyList = NonEmptyList2;
  class Null2 extends Primitive {
    valid(value) {
      return value === null;
    }
    toString() {
      return "Null";
    }
  }
  __publicField(Null2, "__name__", "Null");
  Kinds2.Null = Null2;
  class Nullable2 extends Kind {
    constructor(base_type) {
      super();
      __publicField(this, "base_type");
      this.base_type = base_type;
    }
    valid(value) {
      return value === null || this.base_type.valid(value);
    }
    toString() {
      return `Nullable(${this.base_type.toString()})`;
    }
    may_have_refs() {
      return this.base_type.may_have_refs();
    }
  }
  __publicField(Nullable2, "__name__", "Nullable");
  Kinds2.Nullable = Nullable2;
  class Opt2 extends Kind {
    constructor(base_type) {
      super();
      __publicField(this, "base_type");
      this.base_type = base_type;
    }
    valid(value) {
      return value === void 0 || this.base_type.valid(value);
    }
    toString() {
      return `Opt(${this.base_type.toString()})`;
    }
    may_have_refs() {
      return this.base_type.may_have_refs();
    }
  }
  __publicField(Opt2, "__name__", "Opt");
  Kinds2.Opt = Opt2;
  class Bytes2 extends Kind {
    valid(value) {
      return value instanceof ArrayBuffer;
    }
    toString() {
      return "Bytes";
    }
    may_have_refs() {
      return false;
    }
  }
  __publicField(Bytes2, "__name__", "Bytes");
  Kinds2.Bytes = Bytes2;
  class Str2 extends Primitive {
    valid(value) {
      return isString(value);
    }
    toString() {
      return "Str";
    }
  }
  __publicField(Str2, "__name__", "Str");
  Kinds2.Str = Str2;
  class Regex2 extends Str2 {
    constructor(regex) {
      super();
      __publicField(this, "regex");
      this.regex = regex;
    }
    valid(value) {
      return super.valid(value) && this.regex.test(value);
    }
    toString() {
      return `Regex(${this.regex.toString()})`;
    }
  }
  __publicField(Regex2, "__name__", "Regex");
  Kinds2.Regex = Regex2;
  class Enum2 extends Primitive {
    constructor(values2) {
      super();
      __publicField(this, "values");
      this.values = new ESSet(values2);
    }
    valid(value) {
      return this.values.has(value);
    }
    *[Symbol.iterator]() {
      yield* this.values;
    }
    toString() {
      return `Enum(${[...this.values].map((v) => v.toString()).join(", ")})`;
    }
  }
  __publicField(Enum2, "__name__", "Enum");
  Kinds2.Enum = Enum2;
  class Dict2 extends Kind {
    constructor(item_type) {
      super();
      __publicField(this, "item_type");
      this.item_type = item_type;
    }
    valid(value) {
      if (!(value instanceof ESMap || isPlainObject(value))) {
        return false;
      }
      for (const item of values(value)) {
        if (!this.item_type.valid(item)) {
          return false;
        }
      }
      return true;
    }
    toString() {
      return `Dict(${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.item_type.may_have_refs();
    }
  }
  __publicField(Dict2, "__name__", "Dict");
  Kinds2.Dict = Dict2;
  class Mapping2 extends Kind {
    constructor(key_type, item_type) {
      super();
      __publicField(this, "key_type");
      __publicField(this, "item_type");
      this.key_type = key_type;
      this.item_type = item_type;
    }
    coerce(value) {
      if (isPlainObject(value) && is_empty(value)) {
        return new ESMap();
      } else {
        return value;
      }
    }
    valid(value) {
      if (!(value instanceof ESMap)) {
        return false;
      }
      for (const [key, item] of value.entries()) {
        if (!(this.key_type.valid(key) && this.item_type.valid(item))) {
          return false;
        }
      }
      return true;
    }
    toString() {
      return `Mapping(${this.key_type.toString()}, ${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.key_type.may_have_refs() || this.item_type.may_have_refs();
    }
  }
  __publicField(Mapping2, "__name__", "Mapping");
  Kinds2.Mapping = Mapping2;
  class Set3 extends Kind {
    constructor(item_type) {
      super();
      __publicField(this, "item_type");
      this.item_type = item_type;
    }
    valid(value) {
      if (!(value instanceof ESSet)) {
        return false;
      }
      for (const item of value) {
        if (!this.item_type.valid(item)) {
          return false;
        }
      }
      return true;
    }
    toString() {
      return `Set(${this.item_type.toString()})`;
    }
    may_have_refs() {
      return this.item_type.may_have_refs();
    }
  }
  __publicField(Set3, "__name__", "Set");
  Kinds2.Set = Set3;
  class Color2 extends Kind {
    valid(value) {
      return is_Color(value);
    }
    toString() {
      return "Color";
    }
    may_have_refs() {
      return false;
    }
  }
  __publicField(Color2, "__name__", "Color");
  Kinds2.Color = Color2;
  class CSSLength2 extends Str2 {
    /*
    override valid(value: unknown): value is string {
      return super.valid(value) // TODO: && this._parse(value)
    }
    */
    toString() {
      return "CSSLength";
    }
  }
  __publicField(CSSLength2, "__name__", "CSSLength");
  Kinds2.CSSLength = CSSLength2;
  class Func2 extends Kind {
    valid(value) {
      return isFunction(value);
    }
    toString() {
      return "Func(...)";
    }
    may_have_refs() {
      return false;
    }
  }
  __publicField(Func2, "__name__", "Func");
  Kinds2.Func = Func2;
  class NonNegative2 extends Kind {
    constructor(base_type) {
      super();
      __publicField(this, "base_type");
      this.base_type = base_type;
    }
    valid(value) {
      return this.base_type.valid(value) && value >= 0;
    }
    toString() {
      return `NonNegative(${this.base_type.toString()})`;
    }
    may_have_refs() {
      return this.base_type.may_have_refs();
    }
  }
  __publicField(NonNegative2, "__name__", "NonNegative");
  Kinds2.NonNegative = NonNegative2;
  class Positive2 extends Kind {
    constructor(base_type) {
      super();
      __publicField(this, "base_type");
      this.base_type = base_type;
    }
    valid(value) {
      return this.base_type.valid(value) && value > 0;
    }
    toString() {
      return `Positive(${this.base_type.toString()})`;
    }
    may_have_refs() {
      return this.base_type.may_have_refs();
    }
  }
  __publicField(Positive2, "__name__", "Positive");
  Kinds2.Positive = Positive2;
  class Node3 extends Kind {
    valid(value) {
      return value instanceof DOMNode;
    }
    toString() {
      return "Node";
    }
    may_have_refs() {
      return false;
    }
  }
  __publicField(Node3, "__name__", "Node");
  Kinds2.Node = Node3;
})(Kinds || (Kinds = {}));
var Any = new Kinds.Any();
var Unknown = new Kinds.Unknown();
var Bool = new Kinds.Bool();
var Float = new Kinds.Float();
var Int = new Kinds.Int();
var Bytes = new Kinds.Bytes();
var Str = new Kinds.Str();
var Regex = (regex) => new Kinds.Regex(regex);
var Null = new Kinds.Null();
var Nullable = (base_type) => new Kinds.Nullable(base_type);
var Opt = (base_type) => new Kinds.Opt(base_type);
var Or = (...types) => new Kinds.Or(types);
var And = (type0, type1) => new Kinds.And(type0, type1);
var Tuple = (...types) => new Kinds.Tuple(types);
var Struct = (struct_type) => new Kinds.Struct(struct_type);
var PartialStruct = (struct_type) => new Kinds.PartialStruct(struct_type);
var Iterable = (item_type) => new Kinds.Iterable(item_type);
var Arrayable = (item_type) => new Kinds.Arrayable(item_type);
var List = (item_type) => new Kinds.List(item_type);
var NonEmptyList = (item_type) => new Kinds.NonEmptyList(item_type);
var Dict = (item_type) => new Kinds.Dict(item_type);
var Mapping = (key_type, item_type) => new Kinds.Mapping(key_type, item_type);
var Set2 = (item_type) => new Kinds.Set(item_type);
var Enum = (...values2) => new Kinds.Enum(values2);
var Ref = (obj_type) => new Kinds.Ref(obj_type);
var AnyRef = () => new Kinds.AnyRef();
var Func = () => new Kinds.Func();
var Node2 = new Kinds.Node();
var NonNegative = (base_type) => new Kinds.NonNegative(base_type);
var Positive = (base_type) => new Kinds.Positive(base_type);
var Percent = new Kinds.Percent();
var Alpha = Percent;
var Color = new Kinds.Color();
var Auto = Enum("auto");
var CSSLength = new Kinds.CSSLength();
var FontSize = Str;
var Font = Str;
var Angle = Float;
var Boolean = Bool;
var String2 = Str;
var Number2 = Float;
var Array2 = List;
var Map2 = Mapping;
var Function2 = Func;

// node_modules/@bokeh/bokehjs/build/js/lib/core/enums.js
var Align = Enum("start", "center", "end");
var HAlign = Enum("left", "center", "right");
var VAlign = Enum("top", "center", "bottom");
var Anchor = Enum("top_left", "top_center", "top_right", "center_left", "center_center", "center_right", "bottom_left", "bottom_center", "bottom_right", "top", "left", "center", "right", "bottom");
var AngleUnits = Enum("deg", "rad", "grad", "turn");
var AlternationPolicy = Enum("none", "even", "odd", "every");
var BoxOrigin = Enum("corner", "center");
var ButtonType = Enum("default", "primary", "success", "warning", "danger", "light");
var CalendarPosition = Enum("auto", "above", "below");
var Clock = Enum("12h", "24h");
var CoordinateUnits = Enum("canvas", "screen", "data");
var ContextWhich = Enum("start", "center", "end", "all");
var Dimension = Enum("width", "height");
var Dimensions = Enum("width", "height", "both");
var Direction = Enum("clock", "anticlock");
var Distribution = Enum("uniform", "normal");
var Face = Enum("front", "back");
var FlowMode = Enum("block", "inline");
var FontStyle = Enum("normal", "italic", "bold", "bold italic");
var HatchPatternType = Enum("blank", "dot", "ring", "horizontal_line", "vertical_line", "cross", "horizontal_dash", "vertical_dash", "spiral", "right_diagonal_line", "left_diagonal_line", "diagonal_cross", "right_diagonal_dash", "left_diagonal_dash", "horizontal_wave", "vertical_wave", "criss_cross", " ", ".", "o", "-", "|", "+", '"', ":", "@", "/", "\\", "x", ",", "`", "v", ">", "*");
var BuiltinFormatter = Enum("raw", "basic", "numeral", "printf", "datetime");
var HTTPMethod = Enum("POST", "GET");
var HexTileOrientation = Enum("pointytop", "flattop");
var HoverMode = Enum("mouse", "hline", "vline");
var ImageOrigin = Enum("bottom_left", "top_left", "bottom_right", "top_right");
var LatLon = Enum("lat", "lon");
var LegendClickPolicy = Enum("none", "hide", "mute");
var LegendLocation = Anchor;
var LineCap = Enum("butt", "round", "square");
var LineDash = Enum("solid", "dashed", "dotted", "dotdash", "dashdot");
var LineJoin = Enum("miter", "round", "bevel");
var LinePolicy = Enum("prev", "next", "nearest", "interp", "none");
var Location = Enum("above", "below", "left", "right");
var Logo = Enum("normal", "grey");
var MapType = Enum("satellite", "roadmap", "terrain", "hybrid");
var MarkerType = Enum("asterisk", "circle", "circle_cross", "circle_dot", "circle_x", "circle_y", "cross", "dash", "diamond", "diamond_cross", "diamond_dot", "dot", "hex", "hex_dot", "inverted_triangle", "plus", "square", "square_cross", "square_dot", "square_pin", "square_x", "star", "star_dot", "triangle", "triangle_dot", "triangle_pin", "x", "y");
var MutedPolicy = Enum("show", "ignore");
var Orientation = Enum("vertical", "horizontal");
var OutlineShapeName = Enum("none", "box", "rectangle", "square", "circle", "ellipse", "trapezoid", "parallelogram", "diamond", "triangle");
var OutputBackend = Enum("canvas", "svg", "webgl");
var PaddingUnits = Enum("percent", "absolute");
var PanDirection = Enum("left", "right", "up", "down", "west", "east", "north", "south");
var Place = Enum("above", "below", "left", "right", "center");
var PointPolicy = Enum("snap_to_data", "follow_mouse", "none");
var RadiusDimension = Enum("x", "y", "max", "min");
var RenderLevel = Enum("image", "underlay", "glyph", "guide", "annotation", "overlay");
var ResetPolicy = Enum("standard", "event_only");
var ResolutionType = Enum("microseconds", "milliseconds", "seconds", "minsec", "minutes", "hourmin", "hours", "days", "months", "years");
var RoundingFunction = Enum("round", "nearest", "floor", "rounddown", "ceil", "roundup");
var ScrollbarPolicy = Enum("auto", "visible", "hidden");
var RegionSelectionMode = Enum("replace", "append", "intersect", "subtract", "xor");
var SelectionMode = Enum(...RegionSelectionMode, "toggle");
var Side = Enum("above", "below", "left", "right");
var SizingMode = Enum("stretch_width", "stretch_height", "stretch_both", "scale_width", "scale_height", "scale_both", "fixed", "inherit");
var Sort = Enum("ascending", "descending");
var SpatialUnits = Enum("screen", "data");
var StartEnd = Enum("start", "end");
var StepMode = Enum("after", "before", "center");
var TapBehavior = Enum("select", "inspect");
var TapGesture = Enum("tap", "doubletap");
var TextAlign = Enum("left", "right", "center");
var TextBaseline = Enum("top", "middle", "bottom", "alphabetic", "hanging", "ideographic");
var TextureRepetition = Enum("repeat", "repeat_x", "repeat_y", "no_repeat");
var LabelOrientation = Enum("vertical", "horizontal", "parallel", "normal");
var TooltipAttachment = Enum("horizontal", "vertical", "left", "right", "above", "below");
var UpdateMode = Enum("replace", "append");
var VerticalAlign = Enum("top", "middle", "bottom");
var ToolIcon = Enum("append_mode", "arrow_down_to_bar", "arrow_up_from_bar", "auto_box_zoom", "bold", "box_edit", "box_select", "box_zoom", "caret_down", "caret_left", "caret_right", "caret_up", "check", "chevron_down", "chevron_left", "chevron_right", "chevron_up", "clear_selection", "copy", "crosshair", "delete", "freehand_draw", "fullscreen", "help", "hover", "intersect_mode", "invert_selection", "italic", "lasso_select", "line_edit", "maximize", "minimize", "pan", "pin", "point_draw", "pointer", "poly_draw", "poly_edit", "polygon_select", "range", "redo", "replace_mode", "reset", "save", "see_off", "see_on", "settings", "square", "square_check", "subtract_mode", "tap_select", "text_align_center", "text_align_left", "text_align_right", "undo", "unknown", "unpin", "wheel_pan", "wheel_zoom", "x_box_select", "x_box_zoom", "x_grip", "x_pan", "xor_mode", "y_box_select", "y_box_zoom", "y_grip", "y_pan", "zoom_in", "zoom_out");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/eq.js
var { hasOwnProperty } = Object.prototype;
var equals = Symbol("equals");
function is_Equatable(obj) {
  return isObject(obj) && equals in obj;
}
var wildcard = Symbol("wildcard");
var toString = Object.prototype.toString;
var EqNotImplemented = class extends Error {
};
__publicField(EqNotImplemented, "__name__", "EqNotImplemented");
var Comparator = class {
  constructor(options) {
    __publicField(this, "a_stack", []);
    __publicField(this, "b_stack", []);
    __publicField(this, "structural");
    this.structural = (options == null ? void 0 : options.structural) ?? false;
  }
  eq(a, b) {
    if (a === b || Object.is(a, b)) {
      return true;
    }
    if (a === wildcard || b === wildcard) {
      return true;
    }
    if (a == null || b == null) {
      return a === b;
    }
    const class_name = toString.call(a);
    if (class_name != toString.call(b)) {
      return false;
    }
    switch (class_name) {
      case "[object Number]":
        return this.numbers(a, b);
      case "[object Symbol]":
        return a === b;
      case "[object RegExp]":
      case "[object String]":
        return `${a}` == `${b}`;
      case "[object Date]":
      case "[object Boolean]":
        return +a === +b;
    }
    const { a_stack, b_stack } = this;
    let length = a_stack.length;
    while (length-- > 0) {
      if (a_stack[length] === a) {
        return b_stack[length] === b;
      }
    }
    a_stack.push(a);
    b_stack.push(b);
    const result = (() => {
      if (is_Equatable(a) && is_Equatable(b)) {
        return a[equals](b, this);
      }
      switch (class_name) {
        case "[object Array]":
        case "[object Uint8Array]":
        case "[object Int8Array]":
        case "[object Uint16Array]":
        case "[object Int16Array]":
        case "[object Uint32Array]":
        case "[object Int32Array]":
        case "[object Float32Array]":
        case "[object Float64Array]": {
          return this.arrays(a, b);
        }
        case "[object Map]":
          return this.maps(a, b);
        case "[object Set]":
          return this.sets(a, b);
        case "[object Object]": {
          if (a.constructor == b.constructor && (a.constructor == null || a.constructor === Object)) {
            return this.objects(a, b);
          }
        }
        case "[object Function]": {
          if (a.constructor == b.constructor && a.constructor === Function) {
            return this.eq(`${a}`, `${b}`);
          }
        }
      }
      if (typeof Node !== "undefined" && a instanceof Node) {
        return this.nodes(a, b);
      }
      throw new EqNotImplemented(`can't compare objects of type ${class_name}`);
    })();
    a_stack.pop();
    b_stack.pop();
    return result;
  }
  numbers(a, b) {
    return a === b || Object.is(a, b);
  }
  arrays(a, b) {
    const { length } = a;
    if (length != b.length) {
      return false;
    }
    for (let i = 0; i < length; i++) {
      if (!this.eq(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  iterables(a, b) {
    const ai = a[Symbol.iterator]();
    const bi = b[Symbol.iterator]();
    while (true) {
      const an = ai.next();
      const bn = bi.next();
      const an_done = an.done ?? false;
      const bn_done = bn.done ?? false;
      if (an_done && bn_done) {
        return true;
      }
      if (an_done || bn_done) {
        return false;
      }
      if (!this.eq(an.value, bn.value)) {
        return false;
      }
    }
  }
  maps(a, b) {
    if (a.size != b.size) {
      return false;
    }
    if (this.structural) {
      return this.iterables(a.entries(), b.entries());
    } else {
      for (const [key, val] of a) {
        if (!b.has(key) || !this.eq(val, b.get(key))) {
          return false;
        }
      }
      return true;
    }
  }
  sets(a, b) {
    if (a.size != b.size) {
      return false;
    }
    if (this.structural) {
      return this.iterables(a.entries(), b.entries());
    } else {
      for (const key of a) {
        if (!b.has(key)) {
          return false;
        }
      }
      return true;
    }
  }
  objects(a, b) {
    const keys2 = Object.keys(a);
    if (keys2.length != Object.keys(b).length) {
      return false;
    }
    for (const key of keys2) {
      if (!hasOwnProperty.call(b, key) || !this.eq(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  nodes(a, b) {
    if (a.nodeType != b.nodeType) {
      return false;
    }
    if (a.textContent != b.textContent) {
      return false;
    }
    if (!this.iterables(a.childNodes, b.childNodes)) {
      return false;
    }
    return true;
  }
};
__publicField(Comparator, "__name__", "Comparator");
var { abs } = Math;
var SimilarComparator = class extends Comparator {
  constructor(tolerance = 1e-4) {
    super();
    __publicField(this, "tolerance");
    this.tolerance = tolerance;
  }
  numbers(a, b) {
    return super.numbers(a, b) || abs(a - b) < this.tolerance;
  }
};
__publicField(SimilarComparator, "__name__", "SimilarComparator");
function is_equal(a, b) {
  const comparator = new Comparator();
  return comparator.eq(a, b);
}
function is_structurally_equal(a, b) {
  const comparator = new Comparator({ structural: true });
  return comparator.eq(a, b);
}
function is_similar(a, b, tolerance) {
  const comparator = new SimilarComparator(tolerance);
  return comparator.eq(a, b);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/bitset.js
var _a, _b;
var _BitSet = class _BitSet {
  constructor(size2, init = 0) {
    __publicField(this, "size");
    __publicField(this, _b, "BitSet");
    __publicField(this, "_array");
    __publicField(this, "_nwords");
    __publicField(this, "_count", null);
    this.size = size2;
    this._nwords = Math.ceil(size2 / _BitSet._word_length);
    if (init == 0 || init == 1) {
      this._array = new Uint32Array(this._nwords);
      if (init == 1) {
        this._array.fill(4294967295);
      }
    } else {
      assert(init.length == this._nwords, "Initializer size mismatch");
      this._array = init;
    }
  }
  clone() {
    return new _BitSet(this.size, new Uint32Array(this._array));
  }
  [(_b = Symbol.toStringTag, _a = has_refs, equals)](that, cmp) {
    if (!cmp.eq(this.size, that.size)) {
      return false;
    }
    const { _nwords } = this;
    const trailing = this.size % _BitSet._word_length;
    const n = trailing == 0 ? _nwords : _nwords - 1;
    for (let i = 0; i < n; i++) {
      if (this._array[i] != that._array[i]) {
        return false;
      }
    }
    if (trailing == 0) {
      return true;
    } else {
      const msb = 1 << trailing - 1;
      const mask = msb - 1 ^ msb;
      return (this._array[n] & mask) == (that._array[n] & mask);
    }
  }
  static all_set(size2) {
    return new _BitSet(size2, 1);
  }
  static all_unset(size2) {
    return new _BitSet(size2, 0);
  }
  static from_indices(size2, indices) {
    const bits = new _BitSet(size2);
    for (const i of indices) {
      bits.set(i);
    }
    return bits;
  }
  static from_booleans(size2, booleans) {
    const bits = new _BitSet(size2);
    let i = 0;
    for (const boolean of booleans) {
      if (i == size2) {
        break;
      }
      if (boolean) {
        bits.set(i);
      }
      i += 1;
    }
    return bits;
  }
  _check_bounds(k) {
    assert(0 <= k && k < this.size, `Out of bounds: 0 <= ${k} < ${this.size}`);
  }
  get(k) {
    this._check_bounds(k);
    const i = k >>> 5;
    const j = k & 31;
    return (this._array[i] >> j & 1) == 1;
  }
  set(k, v = true) {
    this._check_bounds(k);
    this._count = null;
    const i = k >>> 5;
    const j = k & 31;
    if (v) {
      this._array[i] |= 1 << j;
    } else {
      this._array[i] &= ~(1 << j);
    }
  }
  unset(k) {
    this.set(k, false);
  }
  *[Symbol.iterator]() {
    yield* this.ones();
  }
  get count() {
    let count = this._count;
    if (count == null) {
      this._count = count = this._get_count();
    }
    return count;
  }
  _get_count() {
    const { _array, _nwords, size: size2 } = this;
    let c = 0;
    for (let k = 0, i = 0; i < _nwords; i++) {
      const word = _array[i];
      if (word == 0) {
        k += _BitSet._word_length;
      } else {
        for (let j = 0; j < _BitSet._word_length && k < size2; j++, k++) {
          if ((word >>> j & 1) == 1) {
            c += 1;
          }
        }
      }
    }
    return c;
  }
  *ones() {
    const { _array, _nwords, size: size2 } = this;
    for (let k = 0, i = 0; i < _nwords; i++) {
      const word = _array[i];
      if (word == 0) {
        k += _BitSet._word_length;
        continue;
      }
      for (let j = 0; j < _BitSet._word_length && k < size2; j++, k++) {
        if ((word >>> j & 1) == 1) {
          yield k;
        }
      }
    }
  }
  *zeros() {
    const { _array, _nwords, size: size2 } = this;
    for (let k = 0, i = 0; i < _nwords; i++) {
      const word = _array[i];
      if (word == 4294967295) {
        k += _BitSet._word_length;
        continue;
      }
      for (let j = 0; j < _BitSet._word_length && k < size2; j++, k++) {
        if ((word >>> j & 1) == 0) {
          yield k;
        }
      }
    }
  }
  _check_size(other) {
    assert(this.size == other.size, `Size mismatch (${this.size} != ${other.size})`);
  }
  invert() {
    for (let i = 0; i < this._nwords; i++) {
      this._array[i] = ~this._array[i] >>> 0;
    }
  }
  add(other) {
    this._check_size(other);
    for (let i = 0; i < this._nwords; i++) {
      this._array[i] |= other._array[i];
    }
  }
  intersect(other) {
    this._check_size(other);
    for (let i = 0; i < this._nwords; i++) {
      this._array[i] &= other._array[i];
    }
  }
  subtract(other) {
    this._check_size(other);
    for (let i = 0; i < this._nwords; i++) {
      const a = this._array[i];
      const b = other._array[i];
      this._array[i] = (a ^ b) & a;
    }
  }
  symmetric_subtract(other) {
    this._check_size(other);
    for (let i = 0; i < this._nwords; i++) {
      this._array[i] ^= other._array[i];
    }
  }
  inversion() {
    const result = this.clone();
    result.invert();
    return result;
  }
  union(other) {
    const result = this.clone();
    result.add(other);
    return result;
  }
  intersection(other) {
    const result = this.clone();
    result.intersect(other);
    return result;
  }
  difference(other) {
    const result = this.clone();
    result.subtract(other);
    return result;
  }
  symmetric_difference(other) {
    const result = this.clone();
    result.symmetric_subtract(other);
    return result;
  }
  select(array) {
    assert(this.size <= array.length, "Size mismatch");
    const n = this.count;
    const result = new array.constructor(n);
    let i = 0;
    for (const j of this) {
      result[i++] = array[j];
    }
    return result;
  }
};
__publicField(_BitSet, "__name__", "BitSet");
__publicField(_BitSet, _a, false);
__publicField(_BitSet, "_word_length", 32);
var BitSet = _BitSet;

// node_modules/@bokeh/bokehjs/build/js/lib/core/types.js
var GeneratorFunction = Object.getPrototypeOf(function* () {
}).constructor;
var AsyncGeneratorFunction = Object.getPrototypeOf(async function* () {
}).constructor;
var ColorArray = Uint32Array;
var RGBAArray = Uint8ClampedArray;
function infer_type(a0, a1) {
  if (a0 instanceof Float64Array || a0 instanceof Array) {
    return Float64Array;
  }
  if (a1 instanceof Float64Array || a1 instanceof Array) {
    return Float64Array;
  }
  return Float32Array;
}
var ScreenArray = Float32Array;
function to_screen(array) {
  if (!(array instanceof Float32Array)) {
    return Float32Array.from(array);
  } else {
    return array;
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/platform.js
var is_mobile = (() => {
  return "ontouchstart" in globalThis || typeof navigator !== "undefined" && navigator.maxTouchPoints > 0;
})();
var is_little_endian = (() => {
  const buf = new ArrayBuffer(4);
  const buf8 = new Uint8Array(buf);
  const buf32 = new Uint32Array(buf);
  buf32[1] = 168496141;
  let little_endian = true;
  if (buf8[4] == 10 && buf8[5] == 11 && buf8[6] == 12 && buf8[7] == 13) {
    little_endian = false;
  }
  return little_endian;
})();
var BYTE_ORDER = is_little_endian ? "little" : "big";
function to_big_endian(values2) {
  if (is_little_endian) {
    const result = new Uint32Array(values2.length);
    const view = new DataView(result.buffer);
    let j = 0;
    for (const color of values2) {
      view.setUint32(j, color);
      j += 4;
    }
    return result;
  } else {
    return values2;
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/vectorization.js
function is_of_type(obj, field) {
  if (!isPlainObject(obj)) {
    return false;
  }
  if (!(field in obj)) {
    return false;
  }
  let n = size(obj) - 1;
  if ("transform" in obj) {
    n -= 1;
  }
  if ("units" in obj) {
    n -= 1;
  }
  return n == 0;
}
function isValue(obj) {
  return is_of_type(obj, "value");
}
function isField(obj) {
  return is_of_type(obj, "field");
}
function isExpr(obj) {
  return is_of_type(obj, "expr");
}
function isVectorized(obj) {
  return isValue(obj) || isField(obj) || isExpr(obj);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/cloneable.js
var clone = Symbol("clone");
function is_Cloneable(obj) {
  return isObject(obj) && clone in obj;
}
var CloningError = class extends Error {
};
__publicField(CloningError, "__name__", "CloningError");
var Cloner = class {
  constructor() {
  }
  clone(obj) {
    if (is_Cloneable(obj)) {
      return obj[clone](this);
    } else if (isPrimitive(obj)) {
      return obj;
    } else if (isArray(obj)) {
      const n = obj.length;
      const result = new Array(n);
      for (let i = 0; i < n; i++) {
        const value = obj[i];
        result[i] = this.clone(value);
      }
      return result;
    } else if (isPlainObject(obj)) {
      const result = {};
      for (const [key, value] of entries(obj)) {
        result[key] = this.clone(value);
      }
      return result;
    } else if (obj instanceof Map) {
      return new Map([...obj].map(([k, v]) => [this.clone(k), this.clone(v)]));
    } else if (obj instanceof Set) {
      return new Set([...obj].map((v) => this.clone(v)));
    } else {
      throw new CloningError(`${Object.prototype.toString.call(obj)} is not cloneable`);
    }
  }
};
__publicField(Cloner, "__name__", "Cloner");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/iterator.js
var iterator_exports = {};
__export(iterator_exports, {
  combinations: () => combinations,
  enumerate: () => enumerate,
  every: () => every,
  filter: () => filter,
  flat_map: () => flat_map,
  interleave: () => interleave,
  join: () => join,
  map: () => map2,
  max: () => max,
  min: () => min,
  range: () => range2,
  reverse: () => reverse,
  skip: () => skip,
  some: () => some,
  subsets: () => subsets,
  tail: () => tail,
  take: () => take,
  zip: () => zip
});
function* range2(start, stop, step = 1) {
  assert(step > 0);
  const { abs: abs2, ceil, max: max3 } = Math;
  if (stop == null) {
    stop = start;
    start = 0;
  }
  const delta = start <= stop ? step : -step;
  const length = max3(ceil(abs2(stop - start) / step), 0);
  for (let i = 0; i < length; i++, start += delta) {
    yield start;
  }
}
function* reverse(array) {
  const n = array.length;
  for (let i = 0; i < n; i++) {
    yield array[n - i - 1];
  }
}
function* enumerate(seq) {
  let i = 0;
  for (const item of seq) {
    yield [item, i++];
  }
}
function* take(seq, n) {
  assert(n >= 0);
  let i = 0;
  for (const item of seq) {
    if (i++ < n) {
      yield item;
    } else {
      break;
    }
  }
}
function* skip(seq, n) {
  assert(n >= 0);
  for (const value of seq) {
    if (n == 0) {
      yield value;
    } else {
      n -= 1;
    }
  }
}
function* tail(seq) {
  yield* skip(seq, 1);
}
function* join(seq, separator) {
  let first = true;
  for (const entry of seq) {
    if (first) {
      first = false;
    } else if (separator != null) {
      yield separator();
    }
    yield* entry;
  }
}
function* zip(iterable0, iterable1) {
  const it0 = iterable0[Symbol.iterator]();
  const it1 = iterable1[Symbol.iterator]();
  do {
    const r0 = it0.next();
    const r1 = it1.next();
    if (r0.done === true || r1.done === true) {
      break;
    } else {
      yield [r0.value, r1.value];
    }
  } while (true);
}
function* interleave(seq, separator) {
  let first = true;
  for (const entry of seq) {
    if (first) {
      first = false;
    } else {
      yield separator();
    }
    yield entry;
  }
}
function* map2(iterable, fn) {
  let i = 0;
  for (const item of iterable) {
    yield fn(item, i++);
  }
}
function* flat_map(iterable, fn) {
  let i = 0;
  for (const item of iterable) {
    yield* fn(item, i++);
  }
}
function* filter(iterable, fn) {
  let i = 0;
  for (const item of iterable) {
    if (fn(item, i++)) {
      yield item;
    }
  }
}
function every(iterable, predicate) {
  for (const item of iterable) {
    if (!predicate(item)) {
      return false;
    }
  }
  return true;
}
function some(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) {
      return true;
    }
  }
  return false;
}
function* combinations(seq, r) {
  const n = seq.length;
  if (r > n) {
    return;
  }
  const indices = range(r);
  yield indices.map((i) => seq[i]);
  while (true) {
    let k;
    for (const i of reverse(range(r))) {
      if (indices[i] != i + n - r) {
        k = i;
        break;
      }
    }
    if (k == null) {
      return;
    }
    indices[k] += 1;
    for (const j of range(k + 1, r)) {
      indices[j] = indices[j - 1] + 1;
    }
    yield indices.map((i) => seq[i]);
  }
}
function* subsets(seq) {
  for (const k of range(seq.length + 1)) {
    yield* combinations(seq, k);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/buffer.js
function buffer_to_base64(buffer) {
  const bytes = new Uint8Array(buffer);
  const chars = Array.from(bytes).map((b) => String.fromCharCode(b));
  return btoa(chars.join(""));
}
function base64_to_buffer(base64) {
  const binary_string = atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);
  for (let i = 0, end = len; i < end; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }
  return bytes.buffer;
}
function swap16(buffer) {
  const x = new Uint8Array(buffer);
  for (let i = 0, end = x.length; i < end; i += 2) {
    const t = x[i];
    x[i] = x[i + 1];
    x[i + 1] = t;
  }
}
function swap32(buffer) {
  const x = new Uint8Array(buffer);
  for (let i = 0, end = x.length; i < end; i += 4) {
    let t = x[i];
    x[i] = x[i + 3];
    x[i + 3] = t;
    t = x[i + 1];
    x[i + 1] = x[i + 2];
    x[i + 2] = t;
  }
}
function swap64(buffer) {
  const x = new Uint8Array(buffer);
  for (let i = 0, end = x.length; i < end; i += 8) {
    let t = x[i];
    x[i] = x[i + 7];
    x[i + 7] = t;
    t = x[i + 1];
    x[i + 1] = x[i + 6];
    x[i + 6] = t;
    t = x[i + 2];
    x[i + 2] = x[i + 5];
    x[i + 5] = t;
    t = x[i + 3];
    x[i + 3] = x[i + 4];
    x[i + 4] = t;
  }
}
function swap(buffer, dtype) {
  switch (dtype) {
    case "uint16":
    case "int16":
      swap16(buffer);
      break;
    case "uint32":
    case "int32":
    case "float32":
      swap32(buffer);
      break;
    case "float64":
      swap64(buffer);
      break;
    case "object":
    case "uint8":
    case "int8":
    case "bool":
      break;
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/serialization/buffer.js
var Buffer = class {
  constructor(buffer) {
    __publicField(this, "buffer");
    this.buffer = buffer;
  }
  to_base64() {
    return buffer_to_base64(this.buffer);
  }
  [equals](that, cmp) {
    return cmp.eq(this.buffer, that.buffer);
  }
};
__publicField(Buffer, "__name__", "Buffer");
var Base64Buffer = class extends Buffer {
  toJSON() {
    return this.to_base64();
  }
};
__publicField(Base64Buffer, "__name__", "Base64Buffer");

// node_modules/@bokeh/bokehjs/build/js/lib/core/serialization/serializer.js
var serialize = Symbol("serialize");
function is_Serializable(obj) {
  return isObject(obj) && serialize in obj;
}
var SerializationError = class extends Error {
};
__publicField(SerializationError, "__name__", "SerializationError");
var Serialized = class {
  constructor(value) {
    __publicField(this, "value");
    this.value = value;
  }
  to_json() {
    return JSON.stringify(this.value);
  }
};
__publicField(Serialized, "__name__", "Serialized");
var Serializer = class {
  constructor(options) {
    __publicField(this, "_references");
    __publicField(this, "binary");
    __publicField(this, "include_defaults");
    __publicField(this, "_circular", /* @__PURE__ */ new WeakSet());
    this.binary = (options == null ? void 0 : options.binary) ?? false;
    this.include_defaults = (options == null ? void 0 : options.include_defaults) ?? false;
    const references = options == null ? void 0 : options.references;
    this._references = references != null ? new Map(references) : /* @__PURE__ */ new Map();
  }
  get_ref(obj) {
    return this._references.get(obj);
  }
  add_ref(obj, ref) {
    assert(!this._references.has(obj));
    this._references.set(obj, ref);
  }
  to_serializable(obj) {
    return new Serialized(this.encode(obj));
  }
  encode(obj) {
    const ref = this.get_ref(obj);
    if (ref != null) {
      return ref;
    }
    if (!isObject(obj)) {
      return this._encode(obj);
    } else {
      if (this._circular.has(obj)) {
        this.error("circular reference");
      }
      this._circular.add(obj);
      try {
        return this._encode(obj);
      } finally {
        this._circular.delete(obj);
      }
    }
  }
  _encode(obj) {
    if (is_Serializable(obj)) {
      return obj[serialize](this);
    } else if (isArray(obj)) {
      const n = obj.length;
      const result = new Array(n);
      for (let i = 0; i < n; i++) {
        const value = obj[i];
        result[i] = this.encode(value);
      }
      return result;
    } else if (isTypedArray(obj)) {
      return this._encode_typed_array(obj);
    } else if (obj instanceof ArrayBuffer) {
      const data = this.binary ? new Buffer(obj) : new Base64Buffer(obj);
      return { type: "bytes", data };
    } else if (isPlainObject(obj)) {
      const items = entries(obj);
      if (items.length == 0) {
        return { type: "map" };
      } else {
        return { type: "map", entries: [...map2(items, ([key, val]) => [this.encode(key), this.encode(val)])] };
      }
    } else if (obj === null || isBoolean(obj) || isString(obj)) {
      return obj;
    } else if (isNumber(obj)) {
      if (isNaN(obj)) {
        return { type: "number", value: "nan" };
      } else if (!isFinite(obj)) {
        return { type: "number", value: `${obj < 0 ? "-" : "+"}inf` };
      } else {
        return obj;
      }
    } else if (obj instanceof Date) {
      const iso = obj.toISOString();
      return { type: "date", iso };
    } else if (obj instanceof Set) {
      if (obj.size == 0) {
        return { type: "set" };
      } else {
        return { type: "set", entries: [...map2(obj.values(), (val) => this.encode(val))] };
      }
    } else if (obj instanceof Map) {
      if (obj.size == 0) {
        return { type: "map" };
      } else {
        return { type: "map", entries: [...map2(obj.entries(), ([key, val]) => [this.encode(key), this.encode(val)])] };
      }
    } else if (isSymbol(obj) && obj.description != null) {
      return { type: "symbol", name: obj.description };
    } else {
      throw new SerializationError(`${Object.prototype.toString.call(obj)} is not serializable`);
    }
  }
  encode_struct(struct) {
    const result = {};
    for (const [key, val] of entries(struct)) {
      if (val !== void 0) {
        result[key] = this.encode(val);
      }
    }
    return result;
  }
  error(message) {
    throw new SerializationError(message);
  }
  _encode_typed_array(obj) {
    const array = this.encode(obj.buffer);
    const dtype = (() => {
      switch (obj.constructor) {
        case Uint8Array:
          return "uint8";
        case Int8Array:
          return "int8";
        case Uint16Array:
          return "uint16";
        case Int16Array:
          return "int16";
        case Uint32Array:
          return "uint32";
        case Int32Array:
          return "int32";
        case Float32Array:
          return "float32";
        case Float64Array:
          return "float64";
        default:
          this.error(`can't serialize typed array of type '${obj[Symbol.toStringTag]}'`);
      }
    })();
    return {
      type: "typed_array",
      array,
      order: BYTE_ORDER,
      dtype
    };
  }
};
__publicField(Serializer, "__name__", "Serializer");

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/ndarray.js
var __ndarray__ = Symbol("__ndarray__");
function encode_NDArray(array, serializer) {
  const encoded = serializer.encode(array.dtype == "object" ? Array.from(array) : array.buffer);
  return {
    type: "ndarray",
    array: encoded,
    order: BYTE_ORDER,
    dtype: array.dtype,
    shape: array.shape
  };
}
var _a2;
var _BoolNDArray = class _BoolNDArray extends Uint8Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a2, true);
    __publicField(this, "dtype", "bool");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a2 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _BoolNDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i] == 1;
  }
};
__publicField(_BoolNDArray, "__name__", "BoolNDArray");
var BoolNDArray = _BoolNDArray;
var _a3;
var _Uint8NDArray = class _Uint8NDArray extends Uint8Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a3, true);
    __publicField(this, "dtype", "uint8");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a3 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Uint8NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Uint8NDArray, "__name__", "Uint8NDArray");
var Uint8NDArray = _Uint8NDArray;
var _a4;
var _Int8NDArray = class _Int8NDArray extends Int8Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a4, true);
    __publicField(this, "dtype", "int8");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a4 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Int8NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Int8NDArray, "__name__", "Int8NDArray");
var Int8NDArray = _Int8NDArray;
var _a5;
var _Uint16NDArray = class _Uint16NDArray extends Uint16Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a5, true);
    __publicField(this, "dtype", "uint16");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a5 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Uint16NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Uint16NDArray, "__name__", "Uint16NDArray");
var Uint16NDArray = _Uint16NDArray;
var _a6;
var _Int16NDArray = class _Int16NDArray extends Int16Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a6, true);
    __publicField(this, "dtype", "int16");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a6 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Int16NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Int16NDArray, "__name__", "Int16NDArray");
var Int16NDArray = _Int16NDArray;
var _a7;
var _Uint32NDArray = class _Uint32NDArray extends Uint32Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a7, true);
    __publicField(this, "dtype", "uint32");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a7 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Uint32NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Uint32NDArray, "__name__", "Uint32NDArray");
var Uint32NDArray = _Uint32NDArray;
var _a8;
var _Int32NDArray = class _Int32NDArray extends Int32Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a8, true);
    __publicField(this, "dtype", "int32");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a8 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Int32NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Int32NDArray, "__name__", "Int32NDArray");
var Int32NDArray = _Int32NDArray;
var _a9;
var _Float32NDArray = class _Float32NDArray extends Float32Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a9, true);
    __publicField(this, "dtype", "float32");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a9 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Float32NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Float32NDArray, "__name__", "Float32NDArray");
var Float32NDArray = _Float32NDArray;
var _a10;
var _Float64NDArray = class _Float64NDArray extends Float64Array {
  constructor(init, shape) {
    super(init);
    __publicField(this, _a10, true);
    __publicField(this, "dtype", "float64");
    __publicField(this, "shape");
    __publicField(this, "dimension");
    this.shape = shape ?? (is_NDArray(init) ? init.shape : [this.length]);
    this.dimension = this.shape.length;
  }
  [(_a10 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _Float64NDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_Float64NDArray, "__name__", "Float64NDArray");
var Float64NDArray = _Float64NDArray;
var _a11;
var _ObjectNDArray = class _ObjectNDArray extends Array {
  constructor(init_, shape) {
    const init = init_ instanceof ArrayBuffer ? new Float64Array(init_) : init_;
    const size2 = isNumber(init) ? init : init.length;
    super(size2);
    __publicField(this, _a11, true);
    __publicField(this, "dtype", "object");
    __publicField(this, "_shape");
    if (!isNumber(init)) {
      for (let i = 0; i < init.length; i++) {
        this[i] = init[i];
      }
    }
    this._shape = shape ?? (is_NDArray(init) ? init.shape : void 0);
  }
  get shape() {
    return this._shape ?? [this.length];
  }
  get dimension() {
    return this.shape.length;
  }
  [(_a11 = __ndarray__, equals)](that, cmp) {
    return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);
  }
  [clone](cloner) {
    return new _ObjectNDArray(this, cloner.clone(this.shape));
  }
  [serialize](serializer) {
    return encode_NDArray(this, serializer);
  }
  get(i) {
    return this[i];
  }
};
__publicField(_ObjectNDArray, "__name__", "ObjectNDArray");
var ObjectNDArray = _ObjectNDArray;
function is_NDArray(v) {
  return isObject(v) && __ndarray__ in v;
}
function ndarray(init, { dtype, shape } = {}) {
  if (dtype == null) {
    dtype = (() => {
      switch (true) {
        case init instanceof Uint8Array:
          return "uint8";
        case init instanceof Int8Array:
          return "int8";
        case init instanceof Uint16Array:
          return "uint16";
        case init instanceof Int16Array:
          return "int16";
        case init instanceof Uint32Array:
          return "uint32";
        case init instanceof Int32Array:
          return "int32";
        case init instanceof Float32Array:
          return "float32";
        case init instanceof ArrayBuffer:
        case init instanceof Float64Array:
          return "float64";
        default:
          return "object";
      }
    })();
  }
  switch (dtype) {
    case "bool":
      return new BoolNDArray(init, shape);
    case "uint8":
      return new Uint8NDArray(init, shape);
    case "int8":
      return new Int8NDArray(init, shape);
    case "uint16":
      return new Uint16NDArray(init, shape);
    case "int16":
      return new Int16NDArray(init, shape);
    case "uint32":
      return new Uint32NDArray(init, shape);
    case "int32":
      return new Int32NDArray(init, shape);
    case "float32":
      return new Float32NDArray(init, shape);
    case "float64":
      return new Float64NDArray(init, shape);
    case "object":
      return new ObjectNDArray(init, shape);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/diagnostics.js
var Diagnostics = class {
  constructor() {
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
  }
  connect(listener) {
    this.listeners.add(listener);
  }
  disconnect(listener) {
    this.listeners.delete(listener);
  }
  report(obj) {
    for (const listener of this.listeners) {
      listener(obj);
    }
  }
};
__publicField(Diagnostics, "__name__", "Diagnostics");
var diagnostics = new Diagnostics();

// node_modules/@bokeh/bokehjs/build/js/lib/core/uniforms.js
var Uniform = class {
  is_Scalar() {
    return this.is_scalar;
  }
  is_Vector() {
    return !this.is_scalar;
  }
};
__publicField(Uniform, "__name__", "Uniform");
var _UniformScalar = class _UniformScalar extends Uniform {
  constructor(value, length) {
    super();
    __publicField(this, "value");
    __publicField(this, "length");
    __publicField(this, "is_scalar", true);
    this.value = value;
    this.length = length;
  }
  get(_i) {
    return this.value;
  }
  *[Symbol.iterator]() {
    const { length, value } = this;
    for (let i = 0; i < length; i++) {
      yield value;
    }
  }
  select(indices) {
    return new _UniformScalar(this.value, indices.count);
  }
  [equals](that, cmp) {
    return cmp.eq(this.length, that.length) && cmp.eq(this.value, that.value);
  }
  map(fn) {
    return new _UniformScalar(fn(this.value), this.length);
  }
};
__publicField(_UniformScalar, "__name__", "UniformScalar");
var UniformScalar = _UniformScalar;
var _UniformVector = class _UniformVector extends Uniform {
  constructor(array) {
    super();
    __publicField(this, "array");
    __publicField(this, "is_scalar", false);
    __publicField(this, "length");
    this.array = array;
    this.length = this.array.length;
  }
  get(i) {
    return this.array[i];
  }
  *[Symbol.iterator]() {
    yield* this.array;
  }
  select(indices) {
    const array = indices.select(this.array);
    return new this.constructor(array);
  }
  [equals](that, cmp) {
    return cmp.eq(this.length, that.length) && cmp.eq(this.array, that.array);
  }
  map(fn) {
    return new _UniformVector(map(this.array, fn));
  }
};
__publicField(_UniformVector, "__name__", "UniformVector");
var UniformVector = _UniformVector;
var ColorUniformVector = class extends UniformVector {
  constructor(array) {
    super(array);
    __publicField(this, "array");
    __publicField(this, "_view");
    this.array = array;
    this._view = new DataView(array.buffer);
  }
  get(i) {
    return this._view.getUint32(4 * i);
  }
  *[Symbol.iterator]() {
    const n = this.length;
    for (let i = 0; i < n; i++) {
      yield this.get(i);
    }
  }
};
__publicField(ColorUniformVector, "__name__", "ColorUniformVector");
function max2(u) {
  return u.is_Scalar() ? u.value : max(u.array);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/properties.js
function valueToString(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return value.toString();
  }
}
function isSpec(obj) {
  return isPlainObject(obj) && (obj.value === void 0 ? 0 : 1) + (obj.field === void 0 ? 0 : 1) + (obj.expr === void 0 ? 0 : 1) == 1;
}
var global_theme = null;
var unset = Symbol("unset");
var UnsetValueError = class extends Error {
};
__publicField(UnsetValueError, "__name__", "UnsetValueError");
var Property = class {
  constructor(obj, attr, kind, default_value, options = {}) {
    __publicField(this, "obj");
    __publicField(this, "attr");
    __publicField(this, "kind");
    __publicField(this, "default_value");
    __publicField(this, "__value__");
    __publicField(this, "_value", unset);
    __publicField(this, "_initialized", false);
    __publicField(this, "_dirty", false);
    __publicField(this, "may_have_refs");
    __publicField(this, "change");
    /*readonly*/
    __publicField(this, "internal");
    __publicField(this, "readonly");
    this.obj = obj;
    this.attr = attr;
    this.kind = kind;
    this.default_value = default_value;
    this.change = new Signal0(this.obj, "change");
    this.internal = options.internal ?? false;
    this.readonly = options.readonly ?? false;
    this.convert = options.convert;
    this.on_update = options.on_update;
    this.may_have_refs = kind.may_have_refs();
  }
  get syncable() {
    return !this.internal;
  }
  get is_unset() {
    return this._value === unset;
  }
  get initialized() {
    return this._initialized;
  }
  initialize(initial_value = unset) {
    if (this._initialized) {
      throw new Error("already initialized");
    }
    let attr_value = unset;
    if (initial_value !== unset) {
      attr_value = initial_value;
      this._dirty = true;
    } else {
      const value = this._default_override();
      if (value !== unset) {
        attr_value = value;
      } else {
        let themed = false;
        if (global_theme != null) {
          const value2 = global_theme.get(this.obj, this.attr);
          if (value2 !== void 0) {
            attr_value = value2;
            themed = true;
          }
        }
        if (!themed) {
          attr_value = this.default_value(this.obj);
        }
      }
    }
    if (attr_value !== unset) {
      if (this.kind.coerce != null) {
        attr_value = this.kind.coerce(attr_value);
      }
      this._update(attr_value);
    } else {
      this._value = unset;
    }
    this._initialized = true;
  }
  get_value() {
    if (this._value !== unset) {
      return this._value;
    } else {
      throw new UnsetValueError(`${this.obj}.${this.attr} is unset`);
    }
  }
  set_value(val) {
    if (!this._initialized) {
      this.initialize(val);
    } else {
      this._update(val);
      this._dirty = true;
    }
    diagnostics.report(this);
  }
  // abstract _intrinsic_default(): T
  _default_override() {
    return unset;
  }
  get dirty() {
    return this._dirty;
  }
  //protected abstract _update(attr_value: T): void
  _update(attr_value) {
    var _a12;
    this.validate(attr_value);
    if (this.convert != null) {
      const converted = this.convert(attr_value, this.obj);
      if (converted !== void 0) {
        attr_value = converted;
      }
    }
    this._value = attr_value;
    (_a12 = this.on_update) == null ? void 0 : _a12.call(this, attr_value, this.obj);
  }
  toString() {
    return `Prop(${this.obj}.${this.attr}, value: ${valueToString(this._value)})`;
  }
  // ----- customizable policies
  normalize(values2) {
    return values2;
  }
  validate(value) {
    if (!this.valid(value)) {
      throw new Error(`${this.obj}.${this.attr} given invalid value: ${valueToString(value)}`);
    }
  }
  valid(value) {
    return this.kind.valid(value);
  }
};
__publicField(Property, "__name__", "Property");
var PropertyAlias = class {
  constructor(attr) {
    __publicField(this, "attr");
    this.attr = attr;
  }
};
__publicField(PropertyAlias, "__name__", "PropertyAlias");
var PrimitiveProperty = class extends Property {
};
__publicField(PrimitiveProperty, "__name__", "PrimitiveProperty");
var Font2 = class extends PrimitiveProperty {
  _default_override() {
    return settings.dev ? "Bokeh" : unset;
  }
};
__publicField(Font2, "__name__", "Font");
var ScalarSpec = class extends Property {
  constructor() {
    super(...arguments);
    __publicField(this, "__scalar__");
    __publicField(this, "_value", unset);
  }
  get_value() {
    if (this._value !== unset) {
      return this._value;
    } else {
      throw new Error(`${this.obj}.${this.attr} is unset`);
    }
  }
  _update(attr_value) {
    if (isSpec(attr_value)) {
      this._value = attr_value;
    } else {
      this._value = { value: attr_value };
    }
    if (isPlainObject(this._value)) {
      const { _value } = this;
      this._value[serialize] = (serializer) => {
        const { value, field, expr, transform, units } = _value;
        return serializer.encode_struct((() => {
          if (value !== void 0) {
            return { type: "value", value, transform, units };
          } else if (field !== void 0) {
            return { type: "field", field, transform, units };
          } else {
            return { type: "expr", expr, transform, units };
          }
        })());
      };
    }
    if (isValue(this._value)) {
      this.validate(this._value.value);
    }
  }
  materialize(value) {
    return value;
  }
  scalar(value, n) {
    return new UniformScalar(value, n);
  }
  uniform(source) {
    const obj = this.get_value();
    const n = source.get_length() ?? 1;
    if (isExpr(obj)) {
      const { expr, transform } = obj;
      let result = expr.compute(source);
      if (transform != null) {
        result = transform.compute(result);
      }
      result = this.materialize(result);
      return this.scalar(result, n);
    } else {
      const { value, transform } = obj;
      let result = value;
      if (transform != null) {
        result = transform.compute(result);
      }
      result = this.materialize(result);
      return this.scalar(result, n);
    }
  }
};
__publicField(ScalarSpec, "__name__", "ScalarSpec");
var DictScalar = class extends ScalarSpec {
};
__publicField(DictScalar, "__name__", "DictScalar");
var ColorScalar = class extends ScalarSpec {
};
__publicField(ColorScalar, "__name__", "ColorScalar");
var NumberScalar = class extends ScalarSpec {
};
__publicField(NumberScalar, "__name__", "NumberScalar");
var NullStringScalar = class extends ScalarSpec {
};
__publicField(NullStringScalar, "__name__", "NullStringScalar");
var LineJoinScalar = class extends ScalarSpec {
};
__publicField(LineJoinScalar, "__name__", "LineJoinScalar");
var LineCapScalar = class extends ScalarSpec {
};
__publicField(LineCapScalar, "__name__", "LineCapScalar");
var LineDashScalar = class extends ScalarSpec {
};
__publicField(LineDashScalar, "__name__", "LineDashScalar");
var FontScalar = class extends ScalarSpec {
  _default_override() {
    return settings.dev ? "Bokeh" : unset;
  }
};
__publicField(FontScalar, "__name__", "FontScalar");
var FontSizeScalar = class extends ScalarSpec {
};
__publicField(FontSizeScalar, "__name__", "FontSizeScalar");
var FontStyleScalar = class extends ScalarSpec {
};
__publicField(FontStyleScalar, "__name__", "FontStyleScalar");
var TextAlignScalar = class extends ScalarSpec {
};
__publicField(TextAlignScalar, "__name__", "TextAlignScalar");
var TextBaselineScalar = class extends ScalarSpec {
};
__publicField(TextBaselineScalar, "__name__", "TextBaselineScalar");
var VectorSpec = class extends Property {
  constructor() {
    super(...arguments);
    __publicField(this, "__vector__");
    __publicField(this, "_value", unset);
  }
  get_value() {
    if (this._value !== unset) {
      return this._value;
    } else {
      throw new Error(`${this.obj}.${this.attr} is unset`);
    }
  }
  _update(attr_value) {
    if (isSpec(attr_value)) {
      this._value = attr_value;
    } else {
      this._value = { value: attr_value };
    }
    if (isPlainObject(this._value)) {
      const { _value } = this;
      this._value[serialize] = (serializer) => {
        const { value, field, expr, transform, units } = _value;
        return serializer.encode_struct((() => {
          if (value !== void 0) {
            return { type: "value", value, transform, units };
          } else if (field !== void 0) {
            return { type: "field", field, transform, units };
          } else {
            return { type: "expr", expr, transform, units };
          }
        })());
      };
    }
    if (isValue(this._value)) {
      this.validate(this._value.value);
    }
  }
  materialize(value) {
    return value;
  }
  v_materialize(values2) {
    return values2;
  }
  scalar(value, n) {
    return new UniformScalar(value, n);
  }
  vector(values2) {
    return new UniformVector(values2);
  }
  uniform(source) {
    const obj = this.get_value();
    const n = source.get_length() ?? 1;
    if (isField(obj)) {
      const { field, transform } = obj;
      let array = source.get_column(field);
      if (array != null) {
        if (transform != null) {
          array = transform.v_compute(array);
        }
        array = this.v_materialize(array);
        return this.vector(array);
      } else {
        const message = `attempted to retrieve property array for nonexistent field '${field}'`;
        if (settings.force_fields) {
          throw new Error(message);
        } else {
          logger.warn(message);
        }
        return this.scalar(null, n);
      }
    } else if (isExpr(obj)) {
      const { expr, transform } = obj;
      let array = expr.v_compute(source);
      if (transform != null) {
        array = transform.v_compute(array);
      }
      array = this.v_materialize(array);
      return this.vector(array);
    } else if (isValue(obj)) {
      const { value, transform } = obj;
      let result = value;
      if (transform != null) {
        result = transform.compute(result);
      }
      result = this.materialize(result);
      return this.scalar(result, n);
    } else {
      unreachable();
    }
  }
  array(source) {
    let array;
    const length = source.get_length() ?? 1;
    const obj = this.get_value();
    if (isField(obj)) {
      const { field } = obj;
      const column = source.get_column(field);
      if (column != null) {
        array = this.normalize(column);
      } else {
        const message = `attempted to retrieve property array for nonexistent field '${field}'`;
        if (settings.force_fields) {
          throw new Error(message);
        } else {
          logger.warn(message);
        }
        const missing = new Float64Array(length);
        missing.fill(NaN);
        array = missing;
      }
    } else if (isExpr(obj)) {
      const { expr } = obj;
      array = this.normalize(expr.v_compute(source));
    } else {
      const value = this.normalize([obj.value])[0];
      if (isNumber(value)) {
        const values2 = new Float64Array(length);
        values2.fill(value);
        array = values2;
      } else {
        array = repeat(value, length);
      }
    }
    const { transform } = obj;
    if (transform != null) {
      array = transform.v_compute(array);
    }
    return array;
  }
};
__publicField(VectorSpec, "__name__", "VectorSpec");
var DataSpec = class extends VectorSpec {
};
__publicField(DataSpec, "__name__", "DataSpec");
var UnitsSpec = class extends VectorSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "_value", unset);
  }
  _update(attr_value) {
    super._update(attr_value);
    if (this._value !== unset) {
      const { units } = this._value;
      if (units != null && !includes(this.valid_units, units)) {
        throw new Error(`units must be one of ${this.valid_units.join(", ")}; got: ${units}`);
      }
    }
  }
  get units() {
    return this._value !== unset ? this._value.units ?? this.default_units : this.default_units;
  }
  set units(units) {
    if (this._value !== unset) {
      if (units != this.default_units) {
        this._value.units = units;
      } else {
        delete this._value.units;
      }
    } else {
      throw new Error(`${this.obj}.${this.attr} is unset`);
    }
  }
};
__publicField(UnitsSpec, "__name__", "UnitsSpec");
var NumberUnitsSpec = class extends UnitsSpec {
  array(source) {
    return new Float64Array(super.array(source));
  }
};
__publicField(NumberUnitsSpec, "__name__", "NumberUnitsSpec");
var BaseCoordinateSpec = class extends DataSpec {
};
__publicField(BaseCoordinateSpec, "__name__", "BaseCoordinateSpec");
var CoordinateSpec = class extends BaseCoordinateSpec {
};
__publicField(CoordinateSpec, "__name__", "CoordinateSpec");
var CoordinateSeqSpec = class extends BaseCoordinateSpec {
};
__publicField(CoordinateSeqSpec, "__name__", "CoordinateSeqSpec");
var CoordinateSeqSeqSeqSpec = class extends BaseCoordinateSpec {
};
__publicField(CoordinateSeqSeqSeqSpec, "__name__", "CoordinateSeqSeqSeqSpec");
var XCoordinateSpec = class extends CoordinateSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "x");
  }
};
__publicField(XCoordinateSpec, "__name__", "XCoordinateSpec");
var YCoordinateSpec = class extends CoordinateSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "y");
  }
};
__publicField(YCoordinateSpec, "__name__", "YCoordinateSpec");
var XCoordinateSeqSpec = class extends CoordinateSeqSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "x");
  }
};
__publicField(XCoordinateSeqSpec, "__name__", "XCoordinateSeqSpec");
var YCoordinateSeqSpec = class extends CoordinateSeqSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "y");
  }
};
__publicField(YCoordinateSeqSpec, "__name__", "YCoordinateSeqSpec");
var XCoordinateSeqSeqSeqSpec = class extends CoordinateSeqSeqSeqSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "x");
  }
};
__publicField(XCoordinateSeqSeqSeqSpec, "__name__", "XCoordinateSeqSeqSeqSpec");
var YCoordinateSeqSeqSeqSpec = class extends CoordinateSeqSeqSeqSpec {
  constructor() {
    super(...arguments);
    __publicField(this, "dimension", "y");
  }
};
__publicField(YCoordinateSeqSeqSeqSpec, "__name__", "YCoordinateSeqSeqSeqSpec");
var AngleSpec = class extends NumberUnitsSpec {
  get default_units() {
    return "rad";
  }
  get valid_units() {
    return [...AngleUnits];
  }
  materialize(value) {
    const coeff = -to_radians_coeff(this.units);
    return value * coeff;
  }
  v_materialize(values2) {
    const coeff = -to_radians_coeff(this.units);
    const result = new Float32Array(values2.length);
    mul(values2, coeff, result);
    return result;
  }
  array(_source) {
    throw new Error("not supported");
  }
};
__publicField(AngleSpec, "__name__", "AngleSpec");
var DistanceSpec = class extends NumberUnitsSpec {
  get default_units() {
    return "data";
  }
  get valid_units() {
    return [...SpatialUnits];
  }
};
__publicField(DistanceSpec, "__name__", "DistanceSpec");
var NullDistanceSpec = class extends DistanceSpec {
  materialize(value) {
    return value ?? NaN;
  }
};
__publicField(NullDistanceSpec, "__name__", "NullDistanceSpec");
var NumberSpec = class extends DataSpec {
  v_materialize(values2) {
    return isTypedArray(values2) ? values2 : new Float64Array(values2);
  }
  array(source) {
    return new Float64Array(super.array(source));
  }
};
__publicField(NumberSpec, "__name__", "NumberSpec");
var ScreenSizeSpec = class extends NumberSpec {
  valid(value) {
    return isNumber(value) && value >= 0;
  }
};
__publicField(ScreenSizeSpec, "__name__", "ScreenSizeSpec");
var ColorSpec = class extends DataSpec {
  materialize(color) {
    return encode_rgba(color2rgba(color));
  }
  v_materialize(colors) {
    if (is_NDArray(colors)) {
      if (colors.dtype == "uint32" && colors.dimension == 1) {
        return to_big_endian(colors);
      } else if (colors.dtype == "uint8" && colors.dimension == 1) {
        const [n] = colors.shape;
        const array = new RGBAArray(4 * n);
        let j = 0;
        for (const gray of colors) {
          array[j++] = gray;
          array[j++] = gray;
          array[j++] = gray;
          array[j++] = 255;
        }
        return new ColorArray(array.buffer);
      } else if (colors.dtype == "uint8" && colors.dimension == 2) {
        const [n, d] = colors.shape;
        if (d == 4) {
          return new ColorArray(colors.buffer);
        } else if (d == 3) {
          const array = new RGBAArray(4 * n);
          for (let i = 0, j = 0; i < d * n; ) {
            array[j++] = colors[i++];
            array[j++] = colors[i++];
            array[j++] = colors[i++];
            array[j++] = 255;
          }
          return new ColorArray(array.buffer);
        }
      } else if ((colors.dtype == "float32" || colors.dtype == "float64") && colors.dimension == 2) {
        const [n, d] = colors.shape;
        if (d == 3 || d == 4) {
          const array = new RGBAArray(4 * n);
          for (let i = 0, j = 0; i < d * n; ) {
            array[j++] = colors[i++] * 255;
            array[j++] = colors[i++] * 255;
            array[j++] = colors[i++] * 255;
            array[j++] = (d == 3 ? 1 : colors[i++]) * 255;
          }
          return new ColorArray(array.buffer);
        }
      } else if (colors.dtype == "object" && colors.dimension == 1) {
        return this._from_css_array(colors);
      }
    } else {
      return this._from_css_array(colors);
    }
    throw new Error("invalid color array");
  }
  _from_css_array(colors) {
    const n = colors.length;
    const array = new RGBAArray(4 * n);
    let j = 0;
    for (const color of colors) {
      const [r, g, b, a] = color2rgba(color);
      array[j++] = r;
      array[j++] = g;
      array[j++] = b;
      array[j++] = a;
    }
    return new ColorArray(array.buffer);
  }
  vector(values2) {
    return new ColorUniformVector(values2);
  }
};
__publicField(ColorSpec, "__name__", "ColorSpec");
var NDArraySpec = class extends DataSpec {
};
__publicField(NDArraySpec, "__name__", "NDArraySpec");
var StringSpec = class extends DataSpec {
};
__publicField(StringSpec, "__name__", "StringSpec");
var NullStringSpec = class extends DataSpec {
};
__publicField(NullStringSpec, "__name__", "NullStringSpec");
var MarkerSpec = class extends DataSpec {
};
__publicField(MarkerSpec, "__name__", "MarkerSpec");
var LineJoinSpec = class extends DataSpec {
};
__publicField(LineJoinSpec, "__name__", "LineJoinSpec");
var LineCapSpec = class extends DataSpec {
};
__publicField(LineCapSpec, "__name__", "LineCapSpec");
var LineDashSpec = class extends DataSpec {
};
__publicField(LineDashSpec, "__name__", "LineDashSpec");
var FontSpec = class extends DataSpec {
  _default_override() {
    return settings.dev ? "Bokeh" : unset;
  }
};
__publicField(FontSpec, "__name__", "FontSpec");
var FontSizeSpec = class extends DataSpec {
};
__publicField(FontSizeSpec, "__name__", "FontSizeSpec");
var FontStyleSpec = class extends DataSpec {
};
__publicField(FontStyleSpec, "__name__", "FontStyleSpec");
var TextAlignSpec = class extends DataSpec {
};
__publicField(TextAlignSpec, "__name__", "TextAlignSpec");
var TextBaselineSpec = class extends DataSpec {
};
__publicField(TextBaselineSpec, "__name__", "TextBaselineSpec");

// node_modules/@bokeh/bokehjs/build/js/lib/core/property_mixins.js
var Line = {
  line_color: [Nullable(Color), "black"],
  line_alpha: [Alpha, 1],
  line_width: [Float, 1],
  line_join: [LineJoin, "bevel"],
  line_cap: [LineCap, "butt"],
  line_dash: [Or(LineDash, Array2(Float)), []],
  line_dash_offset: [Float, 0]
};
var Fill = {
  fill_color: [Nullable(Color), "gray"],
  fill_alpha: [Alpha, 1]
};
var Image = {
  global_alpha: [Alpha, 1]
};
var Hatch = {
  hatch_color: [Nullable(Color), "black"],
  hatch_alpha: [Alpha, 1],
  hatch_scale: [Float, 12],
  hatch_pattern: [Nullable(Or(HatchPatternType, Str)), null],
  hatch_weight: [Float, 1],
  hatch_extra: [Dict(AnyRef()), {}]
  // XXX: recursive imports
};
var Text = {
  text_color: [Nullable(Color), "#444444"],
  text_outline_color: [Nullable(Color), null],
  text_alpha: [Alpha, 1],
  text_font: [Font2, "helvetica"],
  text_font_size: [FontSize, "16px"],
  text_font_style: [FontStyle, "normal"],
  text_align: [TextAlign, "left"],
  text_baseline: [TextBaseline, "bottom"],
  text_line_height: [Float, 1.2]
};
var LineScalar = {
  line_color: [ColorScalar, "black"],
  line_alpha: [NumberScalar, 1],
  line_width: [NumberScalar, 1],
  line_join: [LineJoinScalar, "bevel"],
  line_cap: [LineCapScalar, "butt"],
  line_dash: [LineDashScalar, []],
  line_dash_offset: [NumberScalar, 0]
};
var FillScalar = {
  fill_color: [ColorScalar, "gray"],
  fill_alpha: [NumberScalar, 1]
};
var ImageScalar = {
  global_alpha: [NumberScalar, 1]
};
var HatchScalar = {
  hatch_color: [ColorScalar, "black"],
  hatch_alpha: [NumberScalar, 1],
  hatch_scale: [NumberScalar, 12],
  hatch_pattern: [NullStringScalar, null],
  hatch_weight: [NumberScalar, 1],
  hatch_extra: [DictScalar, {}]
};
var TextScalar = {
  text_color: [ColorScalar, "#444444"],
  text_outline_color: [ColorScalar, null],
  text_alpha: [NumberScalar, 1],
  text_font: [FontScalar, "helvetica"],
  text_font_size: [FontSizeScalar, "16px"],
  text_font_style: [FontStyleScalar, "normal"],
  text_align: [TextAlignScalar, "left"],
  text_baseline: [TextBaselineScalar, "bottom"],
  text_line_height: [NumberScalar, 1.2]
};
var LineVector = {
  line_color: [ColorSpec, "black"],
  line_alpha: [NumberSpec, 1],
  line_width: [NumberSpec, 1],
  line_join: [LineJoinSpec, "bevel"],
  line_cap: [LineCapSpec, "butt"],
  line_dash: [LineDashSpec, []],
  line_dash_offset: [NumberSpec, 0]
};
var FillVector = {
  fill_color: [ColorSpec, "gray"],
  fill_alpha: [NumberSpec, 1]
};
var ImageVector = {
  global_alpha: [NumberSpec, 1]
};
var HatchVector = {
  hatch_color: [ColorSpec, "black"],
  hatch_alpha: [NumberSpec, 1],
  hatch_scale: [NumberSpec, 12],
  hatch_pattern: [NullStringSpec, null],
  hatch_weight: [NumberSpec, 1],
  hatch_extra: [DictScalar, {}]
};
var TextVector = {
  text_color: [ColorSpec, "#444444"],
  text_outline_color: [ColorSpec, null],
  text_alpha: [NumberSpec, 1],
  text_font: [FontSpec, "helvetica"],
  text_font_size: [FontSizeSpec, "16px"],
  text_font_style: [FontStyleSpec, "normal"],
  text_align: [TextAlignSpec, "left"],
  text_baseline: [TextBaselineSpec, "bottom"],
  text_line_height: [NumberSpec, 1.2]
};
function attrs_of(model, prefix, mixin, new_prefix = false) {
  const attrs = {};
  for (const attr of keys(mixin)) {
    const prefixed_attr = `${prefix}${attr}`;
    const value = model[prefixed_attr];
    const new_attr = (() => {
      if (isString(new_prefix)) {
        return `${new_prefix}${attr}`;
      } else if (new_prefix) {
        return prefixed_attr;
      } else {
        return attr;
      }
    })();
    attrs[new_attr] = value;
  }
  return attrs;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/line.js
function resolve_line_dash(line_dash) {
  if (isArray(line_dash)) {
    return line_dash;
  } else {
    switch (line_dash) {
      case "solid":
        return [];
      case "dashed":
        return [6];
      case "dotted":
        return [2, 4];
      case "dotdash":
        return [2, 4, 6, 4];
      case "dashdot":
        return [6, 4, 2, 4];
      default:
        return line_dash.split(" ").map(Number).filter(isInteger);
    }
  }
}
var Line2 = class extends VisualProperties {
  get doit() {
    const color = this.get_line_color();
    const alpha = this.get_line_alpha();
    const width = this.get_line_width();
    return !(color == null || alpha == 0 || width == 0);
  }
  apply(ctx) {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.stroke();
    }
    return doit;
  }
  values() {
    return {
      color: this.get_line_color(),
      alpha: this.get_line_alpha(),
      width: this.get_line_width(),
      join: this.get_line_join(),
      cap: this.get_line_cap(),
      dash: this.get_line_dash(),
      offset: this.get_line_dash_offset()
    };
  }
  set_value(ctx) {
    const color = this.get_line_color();
    const alpha = this.get_line_alpha();
    ctx.strokeStyle = color2css(color, alpha);
    ctx.lineWidth = this.get_line_width();
    ctx.lineJoin = this.get_line_join();
    ctx.lineCap = this.get_line_cap();
    ctx.setLineDash(resolve_line_dash(this.get_line_dash()));
    ctx.lineDashOffset = this.get_line_dash_offset();
  }
  get_line_color() {
    const css_color = this._get_css_value("line-color");
    if (css_color != "") {
      return css_color;
    }
    return this.line_color.get_value();
  }
  get_line_alpha() {
    const css_alpha = this._get_css_value("line-alpha");
    if (css_alpha != "") {
      const alpha = Number(css_alpha);
      if (isFinite(alpha)) {
        return alpha;
      }
    }
    return this.line_alpha.get_value();
  }
  get_line_width() {
    const css_width = this._get_css_value("line-width");
    if (css_width != "") {
      const width = Number(css_width);
      if (isFinite(width)) {
        return width;
      }
    }
    return this.line_width.get_value();
  }
  get_line_join() {
    const css_join = this._get_css_value("line-join");
    if (LineJoin.valid(css_join)) {
      return css_join;
    }
    return this.line_join.get_value();
  }
  get_line_cap() {
    const css_cap = this._get_css_value("line-cap");
    if (LineCap.valid(css_cap)) {
      return css_cap;
    }
    return this.line_cap.get_value();
  }
  get_line_dash() {
    const css_dash = this._get_css_value("line-dash");
    if (LineDash.valid(css_dash)) {
      return css_dash;
    }
    return this.line_dash.get_value();
  }
  get_line_dash_offset() {
    const css_dash_offset = this._get_css_value("line-dash-offset");
    if (css_dash_offset != "") {
      const dash_offset = Number(css_dash_offset);
      if (isFinite(dash_offset)) {
        return dash_offset;
      }
    }
    return this.line_dash_offset.get_value();
  }
};
__publicField(Line2, "__name__", "Line");
var LineScalar2 = class extends VisualUniforms {
  get doit() {
    const color = this.line_color.value;
    const alpha = this.line_alpha.value;
    const width = this.line_width.value;
    return !(color == 0 || alpha == 0 || width == 0);
  }
  apply(ctx) {
    const { doit } = this;
    if (doit) {
      this.set_value(ctx);
      ctx.stroke();
    }
    return doit;
  }
  values() {
    return {
      color: this.line_color.value,
      alpha: this.line_alpha.value,
      width: this.line_width.value,
      join: this.line_join.value,
      cap: this.line_cap.value,
      dash: this.line_dash.value,
      offset: this.line_dash_offset.value
    };
  }
  set_value(ctx) {
    const color = this.line_color.value;
    const alpha = this.line_alpha.value;
    ctx.strokeStyle = color2css(color, alpha);
    ctx.lineWidth = this.line_width.value;
    ctx.lineJoin = this.line_join.value;
    ctx.lineCap = this.line_cap.value;
    ctx.setLineDash(resolve_line_dash(this.line_dash.value));
    ctx.lineDashOffset = this.line_dash_offset.value;
  }
};
__publicField(LineScalar2, "__name__", "LineScalar");
var LineVector2 = class extends VisualUniforms {
  get doit() {
    const { line_color } = this;
    if (line_color.is_Scalar() && line_color.value == 0) {
      return false;
    }
    const { line_alpha } = this;
    if (line_alpha.is_Scalar() && line_alpha.value == 0) {
      return false;
    }
    const { line_width } = this;
    if (line_width.is_Scalar() && line_width.value == 0) {
      return false;
    }
    return true;
  }
  v_doit(i) {
    if (this.line_color.get(i) == 0) {
      return false;
    }
    if (this.line_alpha.get(i) == 0) {
      return false;
    }
    if (this.line_width.get(i) == 0) {
      return false;
    }
    return true;
  }
  apply(ctx, i) {
    const doit = this.v_doit(i);
    if (doit) {
      this.set_vectorize(ctx, i);
      ctx.stroke();
    }
    return doit;
  }
  values(i) {
    return {
      color: this.line_color.get(i),
      alpha: this.line_alpha.get(i),
      width: this.line_width.get(i),
      join: this.line_join.get(i),
      cap: this.line_cap.get(i),
      dash: this.line_dash.get(i),
      offset: this.line_dash_offset.get(i)
    };
  }
  set_vectorize(ctx, i) {
    const color = this.line_color.get(i);
    const alpha = this.line_alpha.get(i);
    const width = this.line_width.get(i);
    const join2 = this.line_join.get(i);
    const cap = this.line_cap.get(i);
    const dash = this.line_dash.get(i);
    const offset = this.line_dash_offset.get(i);
    ctx.strokeStyle = color2css(color, alpha);
    ctx.lineWidth = width;
    ctx.lineJoin = join2;
    ctx.lineCap = cap;
    ctx.setLineDash(resolve_line_dash(dash));
    ctx.lineDashOffset = offset;
  }
};
__publicField(LineVector2, "__name__", "LineVector");
Line2.prototype.type = "line";
Line2.prototype.attrs = Object.keys(Line);
LineScalar2.prototype.type = "line";
LineScalar2.prototype.attrs = Object.keys(LineScalar);
LineVector2.prototype.type = "line";
LineVector2.prototype.attrs = Object.keys(LineVector);

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/base_line.js
var BaseLineGL = class extends BaseGLGlyph {
  constructor(regl_wrapper, glyph) {
    super(regl_wrapper, glyph);
    __publicField(this, "glyph");
    __publicField(this, "_antialias", 1.5);
    // Make this larger to test antialiasing at edges.
    __publicField(this, "_miter_limit", 10);
    // Threshold for miters to be replaced by bevels.
    // data properties
    __publicField(this, "_points");
    __publicField(this, "_show");
    // Applies to segments not points.
    // visual properties
    __publicField(this, "_linewidth", new Float32Buffer(this.regl_wrapper));
    __publicField(this, "_line_color", new NormalizedUint8Buffer(this.regl_wrapper, 4));
    __publicField(this, "_line_cap", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_line_join", new Uint8Buffer(this.regl_wrapper));
    __publicField(this, "_is_dashed", false);
    // visual properties that are only used if line is dashed.
    __publicField(this, "_length_so_far");
    // Depends on both data and visuals.
    __publicField(this, "_dash_tex", []);
    __publicField(this, "_dash_tex_info");
    __publicField(this, "_dash_scale");
    __publicField(this, "_dash_offset");
    this.glyph = glyph;
  }
  _draw_single(main_gl_glyph, transform, line_offset, point_offset, nsegments, framebuffer, show = null) {
    const solid_props = {
      scissor: this.regl_wrapper.scissor,
      viewport: this.regl_wrapper.viewport,
      canvas_size: [transform.width, transform.height],
      antialias: this._antialias / transform.pixel_ratio,
      miter_limit: this._miter_limit,
      points: main_gl_glyph._points,
      show: show ?? main_gl_glyph._show,
      nsegments,
      linewidth: this._linewidth,
      line_color: this._line_color,
      line_cap: this._line_cap,
      line_join: this._line_join,
      framebuffer,
      point_offset,
      line_offset
    };
    if (this._is_dashed && this._dash_tex[line_offset] != null) {
      const dashed_props = {
        ...solid_props,
        length_so_far: main_gl_glyph._length_so_far,
        dash_tex: this._dash_tex[line_offset],
        dash_tex_info: this._dash_tex_info,
        dash_scale: this._dash_scale,
        dash_offset: this._dash_offset
      };
      this.regl_wrapper.dashed_line()(dashed_props);
    } else {
      this.regl_wrapper.solid_line()(solid_props);
    }
  }
  _set_length_single(length_so_far, points, show) {
    const nsegments = length_so_far.length;
    let length = 0;
    for (let i = 0; i < nsegments; i++) {
      length_so_far[i] = length;
      if (show[i + 1] == 1) {
        length += Math.sqrt((points[2 * i + 4] - points[2 * i + 2]) ** 2 + (points[2 * i + 5] - points[2 * i + 3]) ** 2);
      } else {
        length = 0;
      }
    }
  }
  _set_points_single(points, sx, sy) {
    const npoints = points.length / 2 - 2;
    const is_closed = npoints > 2 && sx[0] == sx[npoints - 1] && sy[0] == sy[npoints - 1] && isFinite(sx[0] + sy[0]);
    for (let i = 1; i < npoints + 1; i++) {
      points[2 * i] = sx[i - 1];
      points[2 * i + 1] = sy[i - 1];
    }
    if (is_closed) {
      points[0] = points[2 * npoints - 2];
      points[1] = points[2 * npoints - 1];
      points[2 * npoints + 2] = points[4];
      points[2 * npoints + 3] = points[5];
    } else {
      points[0] = 0;
      points[1] = 0;
      points[2 * npoints + 2] = 0;
      points[2 * npoints + 3] = 0;
    }
  }
  _set_show_single(show, points) {
    const npoints = points.length / 2 - 2;
    let start_finite = isFinite(points[2] + points[3]);
    for (let i = 1; i < npoints; i++) {
      const end_finite = isFinite(points[2 * i + 2] + points[2 * i + 3]);
      show[i] = start_finite && end_finite ? 1 : 0;
      start_finite = end_finite;
    }
    const is_closed = npoints > 2 && points[0] == points[2 * npoints - 2] && points[1] == points[2 * npoints - 1];
    if (is_closed) {
      show[0] = show[npoints - 1];
      show[npoints] = show[1];
    } else {
      show[0] = 0;
      show[npoints] = 0;
    }
  }
  _set_visuals() {
    const line_visuals = this._get_visuals();
    this._line_color.set_from_color(line_visuals.line_color, line_visuals.line_alpha);
    this._linewidth.set_from_prop(line_visuals.line_width);
    this._line_cap.set_from_line_cap(line_visuals.line_cap);
    this._line_join.set_from_line_join(line_visuals.line_join);
    const { line_dash } = line_visuals;
    this._is_dashed = !(line_dash.is_Scalar() && line_dash.get(0).length == 0);
    if (this._is_dashed) {
      if (this._dash_offset == null) {
        this._dash_offset = new Float32Buffer(this.regl_wrapper);
      }
      this._dash_offset.set_from_prop(line_visuals.line_dash_offset);
      const n = line_dash.length;
      if (this._dash_tex_info == null) {
        this._dash_tex_info = new Float32Buffer(this.regl_wrapper, 4);
      }
      const dash_tex_info = this._dash_tex_info.get_sized_array(4 * n);
      if (this._dash_scale == null) {
        this._dash_scale = new Float32Buffer(this.regl_wrapper);
      }
      const dash_scale = this._dash_scale.get_sized_array(n);
      for (let i = 0; i < n; i++) {
        const arr = resolve_line_dash(line_dash.get(i));
        if (arr.length > 0) {
          const [tex_info, tex, scale] = this.regl_wrapper.get_dash(arr);
          this._dash_tex.push(tex);
          for (let j = 0; j < 4; j++) {
            dash_tex_info[4 * i + j] = tex_info[j];
          }
          dash_scale[i] = scale;
        } else {
          this._dash_tex.push(null);
          dash_tex_info.fill(0, 4 * i, 4 * (i + 1));
          dash_scale[i] = 0;
        }
      }
      this._dash_tex_info.update();
      this._dash_scale.update();
    }
  }
};
__publicField(BaseLineGL, "__name__", "BaseLineGL");

export {
  defer,
  Signal,
  Signal0,
  Signalable,
  receivers_for_sender,
  is_ref,
  may_have_refs,
  Kind,
  Any,
  Unknown,
  Bool,
  Float,
  Int,
  Bytes,
  Str,
  Regex,
  Null,
  Nullable,
  Opt,
  Or,
  Tuple,
  Struct,
  PartialStruct,
  Arrayable,
  List,
  Dict,
  Mapping,
  Enum,
  Ref,
  AnyRef,
  NonNegative,
  Percent,
  Color,
  Auto,
  kinds_exports,
  Align,
  HAlign,
  VAlign,
  Anchor,
  AngleUnits,
  AlternationPolicy,
  BoxOrigin,
  ButtonType,
  CalendarPosition,
  Clock,
  CoordinateUnits,
  ContextWhich,
  Dimension,
  Dimensions,
  Direction,
  Distribution,
  Face,
  FlowMode,
  FontStyle,
  HatchPatternType,
  BuiltinFormatter,
  HTTPMethod,
  HexTileOrientation,
  HoverMode,
  ImageOrigin,
  LatLon,
  LegendClickPolicy,
  LegendLocation,
  LinePolicy,
  Location,
  Logo,
  MapType,
  MarkerType,
  MutedPolicy,
  Orientation,
  OutputBackend,
  PaddingUnits,
  PanDirection,
  PointPolicy,
  RadiusDimension,
  RenderLevel,
  ResetPolicy,
  ResolutionType,
  RoundingFunction,
  ScrollbarPolicy,
  RegionSelectionMode,
  SelectionMode,
  SizingMode,
  Sort,
  StartEnd,
  StepMode,
  TapBehavior,
  TapGesture,
  TextAlign,
  TextBaseline,
  TextureRepetition,
  LabelOrientation,
  TooltipAttachment,
  UpdateMode,
  VerticalAlign,
  ToolIcon,
  equals,
  wildcard,
  EqNotImplemented,
  Comparator,
  SimilarComparator,
  is_equal,
  is_structurally_equal,
  is_similar,
  BitSet,
  GeneratorFunction,
  ColorArray,
  RGBAArray,
  infer_type,
  ScreenArray,
  to_screen,
  BYTE_ORDER,
  to_big_endian,
  isValue,
  isField,
  isExpr,
  isVectorized,
  settings,
  clone,
  Cloner,
  enumerate,
  take,
  join,
  interleave,
  map2 as map,
  flat_map,
  some,
  iterator_exports,
  base64_to_buffer,
  swap,
  Buffer,
  serialize,
  Serializer,
  is_NDArray,
  ndarray,
  diagnostics,
  UniformScalar,
  UniformVector,
  max2 as max,
  unset,
  Property,
  PropertyAlias,
  PrimitiveProperty,
  ScalarSpec,
  VectorSpec,
  DataSpec,
  UnitsSpec,
  BaseCoordinateSpec,
  CoordinateSpec,
  CoordinateSeqSpec,
  CoordinateSeqSeqSeqSpec,
  XCoordinateSpec,
  YCoordinateSpec,
  XCoordinateSeqSpec,
  YCoordinateSeqSpec,
  XCoordinateSeqSeqSeqSpec,
  YCoordinateSeqSeqSeqSpec,
  AngleSpec,
  DistanceSpec,
  NullDistanceSpec,
  NumberSpec,
  ScreenSizeSpec,
  ColorSpec,
  NDArraySpec,
  StringSpec,
  NullStringSpec,
  MarkerSpec,
  FontStyleSpec,
  TextAlignSpec,
  Line,
  Fill,
  Image,
  Hatch,
  Text,
  LineScalar,
  FillScalar,
  ImageScalar,
  HatchScalar,
  TextScalar,
  LineVector,
  FillVector,
  ImageVector,
  HatchVector,
  TextVector,
  attrs_of,
  VisualProperties,
  VisualUniforms,
  Line2,
  LineScalar2,
  LineVector2,
  BaseLineGL
};
//# sourceMappingURL=chunk-XNJJC3C4.js.map
