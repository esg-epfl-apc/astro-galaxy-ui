import {
  __publicField
} from "./chunk-EWTE5DHJ.js";

// node_modules/@bokeh/bokehjs/build/js/lib/version.js
var version = "3.6.3";

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/assert.js
var AssertionError = class extends Error {
};
__publicField(AssertionError, "__name__", "AssertionError");
var UnreachableError = class extends Error {
};
__publicField(UnreachableError, "__name__", "UnreachableError");
function assert(condition, message) {
  if (condition === true || condition !== false && condition()) {
    return;
  }
  throw new AssertionError(message ?? "Assertion failed");
}
function assert_debug(condition, message) {
  if (typeof DEBUG !== "undefined" && DEBUG) {
    assert(condition, message);
  }
}
function unreachable(msg) {
  const suffix = msg != null ? `: ${msg}` : "";
  throw new UnreachableError(`unreachable code${suffix}`);
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/types.js
var { toString } = Object.prototype;
function is_undefined(obj) {
  return typeof obj === "undefined";
}
function is_defined(obj) {
  return typeof obj !== "undefined";
}
function is_nullish(obj) {
  return obj == null;
}
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
function isNumber(obj) {
  return toString.call(obj) === "[object Number]";
}
function isInteger(obj) {
  return isNumber(obj) && Number.isInteger(obj);
}
function isString(obj) {
  return toString.call(obj) === "[object String]";
}
function isSymbol(obj) {
  return typeof obj === "symbol";
}
function isPrimitive(obj) {
  return obj === null || isBoolean(obj) || isNumber(obj) || isString(obj) || isSymbol(obj);
}
function isFunction(obj) {
  const rep = toString.call(obj);
  switch (rep) {
    case "[object Function]":
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
      return true;
    default:
      return false;
  }
}
function isArray(obj) {
  return Array.isArray(obj);
}
function isArrayOf(array, predicate) {
  for (const item of array) {
    if (!predicate(item)) {
      return false;
    }
  }
  return true;
}
function isArrayableOf(array, predicate) {
  for (const item of array) {
    if (!predicate(item)) {
      return false;
    }
  }
  return true;
}
function isTypedArray(obj) {
  return ArrayBuffer.isView(obj) && !(obj instanceof DataView);
}
function isObject(obj) {
  const tp = typeof obj;
  return tp === "function" || tp === "object" && !!obj;
}
function isBasicObject(obj) {
  return isObject(obj) && is_nullish(obj.constructor);
}
function isPlainObject(obj) {
  return isObject(obj) && (is_nullish(obj.constructor) || obj.constructor === Object);
}
function isDict(obj) {
  return obj instanceof Map || isPlainObject(obj);
}
function isIterable(obj) {
  return isObject(obj) && Symbol.iterator in obj;
}
function isArrayable(obj) {
  return isIterable(obj) && "length" in obj;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/math.js
var { PI, abs, sign, sqrt } = Math;
function angle_norm(angle) {
  if (angle == 0) {
    return 0;
  }
  while (angle <= 0) {
    angle += 2 * PI;
  }
  while (angle > 2 * PI) {
    angle -= 2 * PI;
  }
  return angle;
}
function angle_dist(lhs, rhs) {
  return angle_norm(lhs - rhs);
}
function angle_between(mid, lhs, rhs, anticlock = false) {
  const d = angle_dist(lhs, rhs);
  if (d == 0) {
    return false;
  }
  if (d == 2 * PI) {
    return true;
  }
  const norm_mid = angle_norm(mid);
  const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;
  return !anticlock ? cond : !cond;
}
function randomIn(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
function atan2(start, end) {
  return Math.atan2(end[1] - start[1], end[0] - start[0]);
}
function compute_angle(angle, units, dir = "anticlock") {
  const sign2 = dir == "anticlock" ? 1 : -1;
  return -sign2 * angle * to_radians_coeff(units);
}
function invert_angle(angle, units, dir = "anticlock") {
  const sign2 = dir == "anticlock" ? 1 : -1;
  return -sign2 * angle / to_radians_coeff(units);
}
function to_radians_coeff(units) {
  switch (units) {
    case "deg":
      return PI / 180;
    case "rad":
      return 1;
    case "grad":
      return PI / 200;
    case "turn":
      return 2 * PI;
  }
}
function minmax(v0, v1) {
  return v0 <= v1 ? [v0, v1] : [v1, v0];
}
function clamp(val, min2, max2) {
  return val < min2 ? min2 : val > max2 ? max2 : val;
}
function cycle(val, min2, max2) {
  if (val > max2) {
    return min2;
  }
  if (val < min2) {
    return max2;
  }
  return val;
}
function log(x, base = Math.E) {
  return Math.log(x) / Math.log(base);
}
function gcd(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b != 0) {
    [a, b] = [b, a % b];
  }
  return a;
}
var float = Symbol("float");
function is_Floating(obj) {
  return isObject(obj) && float in obj;
}
var Fraction = class {
  constructor(numer, denom) {
    __publicField(this, "numer");
    __publicField(this, "denom");
    assert(denom != 0, "Zero divisor");
    const div = gcd(numer, denom);
    const sgn = sign(numer) * sign(denom);
    this.numer = sgn * abs(numer) / div;
    this.denom = abs(denom) / div;
  }
  [float]() {
    return this.numer / this.denom;
  }
  toString() {
    return `${this.numer}/${this.denom}`;
  }
};
__publicField(Fraction, "__name__", "Fraction");
var float32_epsilon = 11920928955078125e-23;
function factorial(x) {
  let y = 1;
  for (let i = 2; i <= x; i++) {
    y *= i;
  }
  return y;
}
function hermite(n) {
  const poly = new Array(n + 1);
  poly.fill(0);
  const fn = factorial(n);
  for (let k = 0; k <= Math.floor(n / 2); k++) {
    const c = (-1) ** k * fn / (factorial(k) * factorial(n - 2 * k)) * 2 ** (n - 2 * k);
    poly[2 * k] = c;
  }
  return poly;
}
function eval_poly(poly, x) {
  const n = poly.length - 1;
  let y = 0;
  let x_n = 1;
  for (let i = n; i >= 0; i--) {
    y += x_n * poly[i];
    x_n *= x;
  }
  return y;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/arrayable.js
var { floor } = Math;
function is_empty(array) {
  return array.length == 0;
}
function is_sorted(array) {
  const n = array.length;
  if (n == 0) {
    return true;
  }
  let prev = array[0];
  for (let i = 1; i < n; i++) {
    const curr = array[i];
    if (prev <= curr) {
      prev = curr;
    } else {
      return false;
    }
  }
  return true;
}
function copy(array) {
  if (Array.isArray(array)) {
    return array.slice();
  } else {
    return new array.constructor(array);
  }
}
function splice(array, start, k, ...items) {
  if (Array.isArray(array)) {
    const result2 = copy(array);
    if (k === void 0) {
      result2.splice(start);
    } else {
      result2.splice(start, k, ...items);
    }
    return result2;
  }
  const len = array.length;
  if (start < 0) {
    start += len;
  }
  if (start < 0) {
    start = 0;
  } else if (start > len) {
    start = len;
  }
  if (k == null || k > len - start) {
    k = len - start;
  } else if (k < 0) {
    k = 0;
  }
  const n = len - k + items.length;
  const result = new array.constructor(n);
  let i = 0;
  for (; i < start; i++) {
    result[i] = array[i];
  }
  for (const item of items) {
    result[i++] = item;
  }
  for (let j = start + k; j < len; j++) {
    result[i++] = array[j];
  }
  return result;
}
function head(array, n) {
  return splice(array, n, array.length - n);
}
function prepend(array, item) {
  return splice(array, 0, 0, item);
}
function index_of(array, item) {
  return array.indexOf(item);
}
function includes(array, value) {
  return array.indexOf(value) !== -1;
}
var contains = includes;
function mul(array, coeff, output) {
  const n = array.length;
  const result = output ?? new array.constructor(n);
  for (let i = 0; i < n; i++) {
    result[i] = array[i] * coeff;
  }
  return result;
}
function map(array, fn) {
  const n = array.length;
  const result = new array.constructor(n);
  for (let i = 0; i < n; i++) {
    result[i] = fn(array[i], i, array);
  }
  return result;
}
function inplace_map(array, fn, output) {
  const n = array.length;
  const result = output ?? array;
  for (let i = 0; i < n; i++) {
    result[i] = fn(array[i], i);
  }
}
function filter(array, pred) {
  const n = array.length;
  const result = new array.constructor(n);
  let k = 0;
  for (let i = 0; i < n; i++) {
    const value = array[i];
    if (pred(value, i, array)) {
      result[k++] = value;
    }
  }
  return head(result, k);
}
function reduce(array, fn, initial) {
  const n = array.length;
  if (initial === void 0 && n == 0) {
    throw new Error("can't reduce an empty array without an initial value");
  }
  let value;
  let i;
  if (initial === void 0) {
    value = array[0];
    i = 1;
  } else {
    value = initial;
    i = 0;
  }
  for (; i < n; i++) {
    value = fn(value, array[i], i, array);
  }
  return value;
}
function sort_by(array, key) {
  const tmp = Array.from(array, (value, index) => {
    return { index, key: key(value) };
  });
  tmp.sort((left, right) => {
    const a = left.key;
    const b = right.key;
    if (a !== b) {
      if (a > b) {
        return 1;
      }
      if (a < b) {
        return -1;
      }
    }
    return left.index - right.index;
  });
  return map(array, (_, i) => array[tmp[i].index]);
}
function min(iterable) {
  let result = Infinity;
  for (const value of iterable) {
    if (!isNaN(value) && value < result) {
      result = value;
    }
  }
  return result;
}
function max(iterable) {
  let result = -Infinity;
  for (const value of iterable) {
    if (!isNaN(value) && value > result) {
      result = value;
    }
  }
  return result;
}
function minmax2(arr, brr) {
  let a;
  let b;
  let a_min = Infinity;
  let a_max = -Infinity;
  let b_min = Infinity;
  let b_max = -Infinity;
  const n = Math.min(arr.length, brr.length);
  for (let i = 0; i < n; i++) {
    a = arr[i];
    b = brr[i];
    if (!isNaN(a) && !isNaN(b)) {
      if (a < a_min) {
        a_min = a;
      }
      if (a > a_max) {
        a_max = a;
      }
      if (b < b_min) {
        b_min = b;
      }
      if (b > b_max) {
        b_max = b;
      }
    }
  }
  return [a_min, a_max, b_min, b_max];
}
function min_by(array, key) {
  if (array.length == 0) {
    throw new Error("min_by() called with an empty array");
  }
  let result = array[0];
  let result_computed = key(result, 0);
  for (let i = 1, length = array.length; i < length; i++) {
    const value = array[i];
    const computed = key(value, i);
    if (computed < result_computed) {
      result = value;
      result_computed = computed;
    }
  }
  return result;
}
function max_by(array, key) {
  if (array.length == 0) {
    throw new Error("max_by() called with an empty array");
  }
  let result = array[0];
  let result_computed = key(result, 0);
  for (let i = 1, length = array.length; i < length; i++) {
    const value = array[i];
    const computed = key(value, i);
    if (computed > result_computed) {
      result = value;
      result_computed = computed;
    }
  }
  return result;
}
function sum(array) {
  let result = 0;
  for (let i = 0, n = array.length; i < n; i++) {
    result += array[i];
  }
  return result;
}
function cumsum(array) {
  const result = new array.constructor(array.length);
  reduce(array, (a, b, i) => result[i] = a + b, 0);
  return result;
}
function every(iter, predicate) {
  for (const item of iter) {
    if (!predicate(item)) {
      return false;
    }
  }
  return true;
}
function some(iter, predicate) {
  for (const item of iter) {
    if (predicate(item)) {
      return true;
    }
  }
  return false;
}
function _find_index(dir) {
  return function(array, predicate) {
    const length = array.length;
    let index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index])) {
        return index;
      }
    }
    return -1;
  };
}
var find_index = _find_index(1);
var find_last_index = _find_index(-1);
function find(array, predicate) {
  const index = find_index(array, predicate);
  return index == -1 ? void 0 : array[index];
}
function find_last(array, predicate) {
  const index = find_last_index(array, predicate);
  return index == -1 ? void 0 : array[index];
}
function bisect_left_by(array, value, fn, low = 0, high = array.length) {
  assert_debug(() => is_sorted(array));
  assert(0 <= low && high <= array.length);
  while (low < high) {
    const mid = floor((low + high) / 2);
    if (fn(array[mid]) < value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function bisect_right_by(array, value, fn, low = 0, high = array.length) {
  assert_debug(() => is_sorted(array));
  assert(0 <= low && high <= array.length);
  while (low < high) {
    const mid = floor((low + high) / 2);
    if (fn(array[mid]) <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function bisect_left(array, value, low = 0, high) {
  return bisect_left_by(array, value, (item) => item, low, high);
}
function bisect_right(array, value, low = 0, high) {
  return bisect_right_by(array, value, (item) => item, low, high);
}
var sorted_index = bisect_left;
function bin_counts(data, bin_edges) {
  const nbins = bin_edges.length - 1;
  const counts = Array(nbins).fill(0);
  for (let i = 0; i < data.length; i++) {
    const sample = data[i];
    const index = sorted_index(bin_edges, sample);
    const bin = clamp(index - 1, 0, nbins - 1);
    counts[bin] += 1;
  }
  return counts;
}
function interpolate(points, x_values, y_values) {
  const n = points.length;
  const results = new Array(n);
  for (let i = 0; i < n; i++) {
    const point = points[i];
    if (isNaN(point) || x_values.length == 0) {
      results[i] = NaN;
      continue;
    }
    const index = left_edge_index(point, x_values);
    if (index == -1) {
      results[i] = y_values[0];
    } else if (index == x_values.length) {
      results[i] = y_values[y_values.length - 1];
    } else if (index == x_values.length - 1 || x_values[index] == point) {
      results[i] = y_values[index];
    } else {
      const x0 = x_values[index];
      const y0 = y_values[index];
      const x1 = x_values[index + 1];
      const y1 = y_values[index + 1];
      results[i] = lerp(point, x0, y0, x1, y1);
    }
  }
  return results;
}
function lerp(x, x0, y0, x1, y1) {
  const slope = (y1 - y0) / (x1 - x0);
  let res = slope * (x - x0) + y0;
  if (!isFinite(res)) {
    res = slope * (x - x1) + y1;
    if (!isFinite(res) && y0 == y1) {
      res = y0;
    }
  }
  return res;
}
function left_edge_index(point, intervals) {
  if (point < intervals[0]) {
    return -1;
  }
  if (point > intervals[intervals.length - 1]) {
    return intervals.length;
  }
  if (intervals.length == 1) {
    return 0;
  }
  let leftEdgeIndex = 0;
  let rightEdgeIndex = intervals.length - 1;
  while (rightEdgeIndex - leftEdgeIndex != 1) {
    const indexOfNumberToCompare = leftEdgeIndex + Math.floor((rightEdgeIndex - leftEdgeIndex) / 2);
    if (point >= intervals[indexOfNumberToCompare]) {
      leftEdgeIndex = indexOfNumberToCompare;
    } else {
      rightEdgeIndex = indexOfNumberToCompare;
    }
  }
  return leftEdgeIndex;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/array.js
var { slice } = Array.prototype;
function head2(array) {
  if (array.length != 0) {
    return array[0];
  } else {
    throw new Error("out of bounds access");
  }
}
function last(array) {
  if (array.length != 0) {
    return array[array.length - 1];
  } else {
    throw new Error("out of bounds access");
  }
}
function copy2(array) {
  return slice.call(array);
}
function concat(arrays) {
  return [].concat(...arrays);
}
function nth(array, index) {
  return array[index >= 0 ? index : array.length + index];
}
function zip(...arrays) {
  if (arrays.length == 0) {
    return [];
  }
  const n = min(arrays.map((a) => a.length));
  const k = arrays.length;
  const result = new Array(n);
  for (let i = 0; i < n; i++) {
    result[i] = new Array(k);
    for (let j = 0; j < k; j++) {
      result[i][j] = arrays[j][i];
    }
  }
  return result;
}
function unzip(array) {
  const n = array.length;
  if (n == 0) {
    return [];
  }
  const k = min(array.map((a) => a.length));
  const results = Array(k);
  for (let j = 0; j < k; j++) {
    results[j] = new Array(n);
  }
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < k; j++) {
      results[j][i] = array[i][j];
    }
  }
  return results;
}
function range(start, stop, step = 1) {
  assert(step > 0, "'step' must be a positive number");
  if (stop == null) {
    stop = start;
    start = 0;
  }
  const { max: max2, ceil, abs: abs2 } = Math;
  const delta = start <= stop ? step : -step;
  const length = max2(ceil(abs2(stop - start) / step), 0);
  const range2 = new Array(length);
  for (let i = 0; i < length; i++, start += delta) {
    range2[i] = start;
  }
  return range2;
}
function linspace(start, stop, num = 100) {
  const step = num == 1 ? 0 : (stop - start) / (num - 1);
  const array = new Array(num);
  for (let i = 0; i < num; i++) {
    array[i] = start + step * i;
  }
  return array;
}
function transpose(array) {
  const rows = array.length;
  const cols = array[0].length;
  const transposed = [];
  for (let j = 0; j < cols; j++) {
    transposed[j] = [];
    for (let i = 0; i < rows; i++) {
      transposed[j][i] = array[i][j];
    }
  }
  return transposed;
}
function argmin(array) {
  return min_by(range(array.length), (i) => array[i]);
}
function argmax(array) {
  return max_by(range(array.length), (i) => array[i]);
}
function argsort(array) {
  const indices = Array.from(array.keys());
  indices.sort((a, b) => array[a] - array[b]);
  return indices;
}
function uniq(array) {
  const result = /* @__PURE__ */ new Set();
  for (const value of array) {
    result.add(value);
  }
  return [...result];
}
function uniq_by(array, key) {
  const result = [];
  const seen = [];
  for (const value of array) {
    const computed = key(value);
    if (!includes(seen, computed)) {
      seen.push(computed);
      result.push(value);
    }
  }
  return result;
}
function _union(arrays) {
  const result = /* @__PURE__ */ new Set();
  for (const array of arrays) {
    for (const value of array) {
      result.add(value);
    }
  }
  return result;
}
function union(...arrays) {
  return [..._union(arrays)];
}
function intersection(array, ...arrays) {
  const result = [];
  top: for (const item of array) {
    if (includes(result, item)) {
      continue;
    }
    for (const other of arrays) {
      if (!includes(other, item)) {
        continue top;
      }
    }
    result.push(item);
  }
  return result;
}
function difference(array, ...arrays) {
  const rest = _union(arrays);
  return filter(array, (value) => !rest.has(value));
}
function symmetric_difference(array0, array1) {
  const set0 = new Set(array0);
  const set1 = new Set(array1);
  const result = [];
  for (const val of set0) {
    if (!set1.has(val)) {
      result.push(val);
    }
  }
  for (const val of set1) {
    if (!set0.has(val)) {
      result.push(val);
    }
  }
  return result;
}
function remove_at(array, i) {
  assert(isInteger(i) && i >= 0);
  const result = copy2(array);
  result.splice(i, 1);
  return result;
}
function remove(array, item) {
  remove_by(array, (value) => value == item);
}
function remove_by(array, key) {
  for (let i = 0; i < array.length; ) {
    if (key(array[i])) {
      array.splice(i, 1);
    } else {
      i++;
    }
  }
}
function clear(array) {
  array.splice(0, array.length);
}
function split(array, separator) {
  const chunks = [];
  const n = array.length;
  let i = 0;
  let j = 0;
  while (j < n) {
    if (array[j] === separator) {
      chunks.push(array.slice(i, j));
      i = ++j;
    } else {
      ++j;
    }
  }
  chunks.push(array.slice(i));
  return chunks;
}
function shuffle(array) {
  const length = array.length;
  const shuffled = new Array(length);
  for (let i = 0; i < length; i++) {
    const rand = randomIn(0, i);
    if (rand !== i) {
      shuffled[i] = shuffled[rand];
    }
    shuffled[rand] = array[i];
  }
  return shuffled;
}
function pairwise(array, fn) {
  const n = array.length;
  const result = new Array(n - 1);
  for (let i = 0; i < n - 1; i++) {
    result[i] = fn(array[i], array[i + 1]);
  }
  return result;
}
function elementwise(array0, array1, fn) {
  const n = Math.min(array0.length, array1.length);
  const result = Array(n);
  for (let i = 0; i < n; i++) {
    result[i] = fn(array0[i], array1[i]);
  }
  return result;
}
function reversed(array) {
  const n = array.length;
  const result = new Array(n);
  for (let i = 0; i < n; i++) {
    result[n - i - 1] = array[i];
  }
  return result;
}
function repeat(value, n) {
  const result = new Array(n).fill(value);
  return result;
}
function resize(array, new_length, fill_value) {
  if (array.length >= new_length) {
    return array.slice(0, new_length);
  } else {
    const suffix = new Array(new_length - array.length);
    if (fill_value !== void 0) {
      suffix.fill(fill_value);
    }
    return array.concat(suffix);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/object.js
var { assign } = Object;
var extend = assign;
function to_object(obj) {
  return isPlainObject(obj) ? obj : Object.fromEntries(obj);
}
function keys(obj) {
  return obj instanceof Map ? [...obj.keys()] : Object.keys(obj);
}
function values(obj) {
  return obj instanceof Map ? [...obj.values()] : Object.values(obj);
}
function entries(obj) {
  return obj instanceof Map ? [...obj.entries()] : Object.entries(obj);
}
var typed_keys = Object.keys;
var typed_values = Object.values;
var typed_entries = Object.entries;
function clone(obj) {
  return obj instanceof Map ? new Map(obj) : { ...obj };
}
function merge(obj0, obj1) {
  const result = /* @__PURE__ */ new Map();
  const keys2 = [...obj0.keys(), ...obj1.keys()];
  for (const key of keys2) {
    const v0 = obj0.get(key);
    const v1 = obj1.get(key);
    const arr0 = v0 === void 0 ? [] : v0;
    const arr1 = v1 === void 0 ? [] : v1;
    result.set(key, union(arr0, arr1));
  }
  return result;
}
function size(obj) {
  return obj instanceof Map ? obj.size : Object.keys(obj).length;
}
function is_empty2(obj) {
  return size(obj) == 0;
}
var { hasOwnProperty } = Object.prototype;
var _a;
var PlainObjectProxy = class {
  constructor(obj) {
    __publicField(this, "obj");
    __publicField(this, _a, "PlainObjectProxy");
    this.obj = obj;
  }
  clear() {
    for (const key of this.keys()) {
      delete this.obj[key];
    }
  }
  delete(key) {
    const exists = this.has(key);
    if (exists) {
      delete this.obj[key];
    }
    return exists;
  }
  has(key) {
    return hasOwnProperty.call(this.obj, key);
  }
  get(key) {
    return this.has(key) ? this.obj[key] : void 0;
  }
  set(key, value) {
    this.obj[key] = value;
    return this;
  }
  get size() {
    return size(this.obj);
  }
  [(_a = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  *keys() {
    yield* keys(this.obj);
  }
  *values() {
    yield* values(this.obj);
  }
  *entries() {
    yield* entries(this.obj);
  }
  forEach(callback, that) {
    for (const [key, value] of this.entries()) {
      callback.call(that, value, key, this);
    }
  }
};
__publicField(PlainObjectProxy, "__name__", "PlainObjectProxy");
function dict(obj) {
  return isPlainObject(obj) ? new PlainObjectProxy(obj) : obj;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/logging.js
var _loggers = {};
var LogLevel = class {
  constructor(name, level, method) {
    __publicField(this, "name");
    __publicField(this, "level");
    __publicField(this, "method");
    this.name = name;
    this.level = level;
    this.method = method;
  }
};
__publicField(LogLevel, "__name__", "LogLevel");
var _Logger = class _Logger {
  constructor(name, level = _Logger.INFO) {
    __publicField(this, "_name");
    __publicField(this, "_log_level");
    this._name = name;
    this.set_level(level);
  }
  static get levels() {
    return Object.keys(_Logger.log_levels);
  }
  static get(name, level = _Logger.INFO) {
    if (name.length > 0) {
      if (name in _loggers) {
        return _loggers[name];
      } else {
        return _loggers[name] = new _Logger(name, level);
      }
    } else {
      throw new TypeError("Logger.get() expects a non-empty string name and an optional log-level");
    }
  }
  get level() {
    return this.get_level();
  }
  get_level() {
    return this._log_level;
  }
  set_level(log_level) {
    if (log_level instanceof LogLevel) {
      this._log_level = log_level;
    } else if (_Logger.log_levels.hasOwnProperty(log_level)) {
      this._log_level = _Logger.log_levels[log_level];
    } else {
      throw new Error("Logger.set_level() expects a log-level object or a string name of a log-level");
    }
    const prefix = `[${this._name}]`;
    for (const { level, method } of values(_Logger.log_levels)) {
      if (level < this._log_level.level || this._log_level.level === _Logger.OFF.level) {
        this[method] = function() {
        };
      } else {
        this[method] = _method_factory(method, prefix);
      }
    }
    this.log = _method_factory("log", prefix);
  }
  log(..._args) {
  }
  trace(..._args) {
  }
  debug(..._args) {
  }
  info(..._args) {
  }
  warn(..._args) {
  }
  error(..._args) {
  }
};
__publicField(_Logger, "__name__", "Logger");
__publicField(_Logger, "TRACE", new LogLevel("trace", 0, "trace"));
__publicField(_Logger, "DEBUG", new LogLevel("debug", 1, "debug"));
__publicField(_Logger, "INFO", new LogLevel("info", 2, "info"));
__publicField(_Logger, "WARN", new LogLevel("warn", 6, "warn"));
__publicField(_Logger, "ERROR", new LogLevel("error", 7, "error"));
__publicField(_Logger, "FATAL", new LogLevel("fatal", 8, "error"));
__publicField(_Logger, "OFF", new LogLevel("off", 9, "log"));
__publicField(_Logger, "log_levels", {
  trace: _Logger.TRACE,
  debug: _Logger.DEBUG,
  info: _Logger.INFO,
  warn: _Logger.WARN,
  error: _Logger.ERROR,
  fatal: _Logger.FATAL,
  off: _Logger.OFF
});
var Logger = _Logger;
function _method_factory(method_name, prefix) {
  const method = console[method_name];
  const fn = typeof method != "undefined" ? method : console.log;
  return fn.bind(console, prefix);
}
var logger = Logger.get(`bokeh ${version}`);
function set_log_level(level) {
  const previous_level = logger.level;
  if (isString(level) && !(level in Logger.log_levels)) {
    logger.log(`unrecognized logging level '${level}' passed to Bokeh.set_log_level(), ignoring`);
    logger.log(`valid log levels are: ${Logger.levels.join(", ")}`);
  } else {
    logger.log(`setting log level to: '${isString(level) ? level : level.level}'`);
    logger.set_level(level);
  }
  return previous_level;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/svg_colors.js
var _named_colors = {
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var named_colors = _named_colors;
function is_named_color(color) {
  return color in named_colors;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/util/color.js
var { round, sqrt: sqrt2 } = Math;
function byte(v) {
  return clamp(round(v), 0, 255);
}
function transparent() {
  return [0, 0, 0, 0];
}
function encode_rgba([r, g, b, a]) {
  return r << 24 | g << 16 | b << 8 | a;
}
function decode_rgba(rgba) {
  const r = rgba >> 24 & 255;
  const g = rgba >> 16 & 255;
  const b = rgba >> 8 & 255;
  const a = rgba & 255;
  return [r, g, b, a];
}
function color2rgba(color, alpha = 1) {
  const [r, g, b, a] = (() => {
    if (color == null) {
      return transparent();
    } else if (isInteger(color)) {
      return decode_rgba(color);
    } else if (isString(color)) {
      const [r2, g2, b2, a2] = css4_parse(color) ?? transparent();
      return [r2, g2, b2, byte(a2 * 255)];
    } else {
      if (color.length == 2) {
        const [name, alpha2] = color;
        return color2rgba(name, alpha2);
      } else {
        const [r2, g2, b2, a2 = 1] = color;
        return [r2, g2, b2, byte(a2 * 255)];
      }
    }
  })();
  return [r, g, b, byte(alpha * a)];
}
var _hex_table = {
  0: "0",
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
  6: "6",
  7: "7",
  8: "8",
  9: "9",
  10: "a",
  11: "b",
  12: "c",
  13: "d",
  14: "e",
  15: "f"
};
function hex(v) {
  return _hex_table[v >> 4] + _hex_table[v & 15];
}
function rgba2css([r, g, b, a]) {
  const alpha = a == 255 ? "" : ` / ${a / 255}`;
  return `rgb(${r} ${g} ${b}${alpha})`;
}
function color2css(color, alpha) {
  if (isString(color) && (alpha == null || alpha == 1)) {
    return color;
  } else {
    const [r, g, b, a] = color2rgba(color, alpha);
    return rgba2css([r, g, b, a]);
  }
}
function color2hex(color, alpha) {
  const [r, g, b, a] = color2rgba(color, alpha);
  const rgb = `#${hex(r)}${hex(g)}${hex(b)}`;
  return a == 255 ? rgb : `${rgb}${hex(a)}`;
}
function color2hexrgb(color) {
  const [r, g, b] = color2rgba(color);
  return `#${hex(r)}${hex(g)}${hex(b)}`;
}
var rgb_modern = /^rgba?\(\s*(?<r>[^\s,]+?)\s+(?<g>[^\s,]+?)\s+(?<b>[^\s,]+?)(?:\s*\/\s*(?<a>[^\s,]+?))?\s*\)$/;
var rgb_legacy = /^rgba?\(\s*(?<r>[^\s,]+?)\s*,\s*(?<g>[^\s,]+?)\s*,\s*(?<b>[^\s,]+?)(?:\s*,\s*(?<a>[^\s,]+?))?\s*\)$/;
var css4_normalize = (() => {
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  const ctx = canvas.getContext("2d");
  const gradient = ctx.createLinearGradient(0, 0, 1, 1);
  return (color) => {
    ctx.fillStyle = gradient;
    ctx.fillStyle = color;
    const style = ctx.fillStyle;
    return style != gradient ? style : null;
  };
})();
function css4_parse(color) {
  color = color.trim().toLowerCase();
  if (color == "") {
    return null;
  } else if (color == "transparent") {
    return transparent();
  } else if (is_named_color(color)) {
    const [r, g, b, a] = decode_rgba(named_colors[color]);
    return [r, g, b, a / 255];
  } else if (color[0] == "#") {
    const v = Number(`0x${color.substring(1)}`);
    if (isNaN(v)) {
      return null;
    }
    switch (color.length - 1) {
      case 3: {
        const r = v >> 8 & 15;
        const g = v >> 4 & 15;
        const b = v >> 0 & 15;
        const rr = r << 4 | r;
        const gg = g << 4 | g;
        const bb = b << 4 | b;
        return [rr, gg, bb, 1];
      }
      case 4: {
        const r = v >> 12 & 15;
        const g = v >> 8 & 15;
        const b = v >> 4 & 15;
        const a = v >> 0 & 15;
        const rr = r << 4 | r;
        const gg = g << 4 | g;
        const bb = b << 4 | b;
        const aa = a << 4 | a;
        return [rr, gg, bb, aa / 255];
      }
      case 6: {
        const rr = v >> 16 & 255;
        const gg = v >> 8 & 255;
        const bb = v >> 0 & 255;
        return [rr, gg, bb, 1];
      }
      case 8: {
        const rr = v >> 24 & 255;
        const gg = v >> 16 & 255;
        const bb = v >> 8 & 255;
        const aa = v >> 0 & 255;
        return [rr, gg, bb, aa / 255];
      }
    }
  } else if (color.startsWith("rgb")) {
    const result = color.match(rgb_modern) ?? color.match(rgb_legacy);
    if ((result == null ? void 0 : result.groups) != null) {
      let { r, g, b, a = "1" } = result.groups;
      const rp = r.endsWith("%");
      const gp = g.endsWith("%");
      const bp = b.endsWith("%");
      const ap = a.endsWith("%");
      if (!(rp && gp && bp || !rp && !gp && !bp)) {
        return null;
      }
      if (rp) {
        r = r.slice(0, -1);
      }
      if (gp) {
        g = g.slice(0, -1);
      }
      if (bp) {
        b = b.slice(0, -1);
      }
      if (ap) {
        a = a.slice(0, -1);
      }
      let R = Number(r);
      let G = Number(g);
      let B = Number(b);
      let A = Number(a);
      if (isNaN(R + G + B + A)) {
        return null;
      }
      if (rp) {
        R = 255 * (R / 100);
      }
      if (gp) {
        G = 255 * (G / 100);
      }
      if (bp) {
        B = 255 * (B / 100);
      }
      A = ap ? A / 100 : A;
      R = byte(R);
      G = byte(G);
      B = byte(B);
      return [R, G, B, A];
    }
  } else {
    const style = css4_normalize(color);
    if (style != null) {
      return css4_parse(style);
    }
  }
  return null;
}
function is_Color(value) {
  if (isInteger(value)) {
    return true;
  }
  if (isString(value) && css4_parse(value) != null) {
    return true;
  }
  if (isArray(value) && (value.length == 3 || value.length == 4)) {
    return true;
  }
  return false;
}
function is_dark([r, g, b]) {
  const l = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return l >= 0.6;
}

// node_modules/@bokeh/bokehjs/build/js/lib/core/visuals/patterns.js
function _horz(ctx, h, h2) {
  ctx.moveTo(0, h2 + 0.5);
  ctx.lineTo(h, h2 + 0.5);
  ctx.stroke();
}
function _vert(ctx, h, h2) {
  ctx.moveTo(h2 + 0.5, 0);
  ctx.lineTo(h2 + 0.5, h);
  ctx.stroke();
}
function _x(ctx, h) {
  ctx.moveTo(0, h);
  ctx.lineTo(h, 0);
  ctx.stroke();
  ctx.moveTo(0, 0);
  ctx.lineTo(h, h);
  ctx.stroke();
}
var hatch_aliases = {
  " ": "blank",
  ".": "dot",
  o: "ring",
  "-": "horizontal_line",
  "|": "vertical_line",
  "+": "cross",
  '"': "horizontal_dash",
  ":": "vertical_dash",
  "@": "spiral",
  "/": "right_diagonal_line",
  "\\": "left_diagonal_line",
  x: "diagonal_cross",
  ",": "right_diagonal_dash",
  "`": "left_diagonal_dash",
  v: "horizontal_wave",
  ">": "vertical_wave",
  "*": "criss_cross"
};
function get_pattern(layer, pattern, color, alpha, scale, weight) {
  layer.resize(scale, scale);
  layer.prepare();
  create_hatch_canvas(layer.ctx, pattern, color, alpha, scale, weight);
  return layer.canvas;
}
function create_hatch_canvas(ctx, hatch_pattern, hatch_color, hatch_alpha, hatch_scale, hatch_weight) {
  const h = hatch_scale;
  const h2 = h / 2;
  const h4 = h2 / 2;
  const color = color2css(hatch_color, hatch_alpha);
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineCap = "square";
  ctx.lineWidth = hatch_weight;
  switch (hatch_aliases[hatch_pattern] ?? hatch_pattern) {
    case "blank":
      break;
    case "dot":
      ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);
      ctx.fill();
      break;
    case "ring":
      ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);
      ctx.stroke();
      break;
    case "horizontal_line":
      _horz(ctx, h, h2);
      break;
    case "vertical_line":
      _vert(ctx, h, h2);
      break;
    case "cross":
      _horz(ctx, h, h2);
      _vert(ctx, h, h2);
      break;
    case "horizontal_dash":
      _horz(ctx, h2, h2);
      break;
    case "vertical_dash":
      _vert(ctx, h2, h2);
      break;
    case "spiral": {
      const h30 = h / 30;
      ctx.moveTo(h2, h2);
      for (let i = 0; i < 360; i++) {
        const angle = 0.1 * i;
        const x = h2 + h30 * angle * Math.cos(angle);
        const y = h2 + h30 * angle * Math.sin(angle);
        ctx.lineTo(x, y);
      }
      ctx.stroke();
      break;
    }
    case "right_diagonal_line":
      ctx.moveTo(-h4 + 0.5, h);
      ctx.lineTo(h4 + 0.5, 0);
      ctx.stroke();
      ctx.moveTo(h4 + 0.5, h);
      ctx.lineTo(3 * h4 + 0.5, 0);
      ctx.stroke();
      ctx.moveTo(3 * h4 + 0.5, h);
      ctx.lineTo(5 * h4 + 0.5, 0);
      ctx.stroke();
      break;
    case "left_diagonal_line":
      ctx.moveTo(h4 + 0.5, h);
      ctx.lineTo(-h4 + 0.5, 0);
      ctx.stroke();
      ctx.moveTo(3 * h4 + 0.5, h);
      ctx.lineTo(h4 + 0.5, 0);
      ctx.stroke();
      ctx.moveTo(5 * h4 + 0.5, h);
      ctx.lineTo(3 * h4 + 0.5, 0);
      ctx.stroke();
      break;
    case "diagonal_cross":
      _x(ctx, h);
      break;
    case "right_diagonal_dash":
      ctx.moveTo(h4 + 0.5, 3 * h4 + 0.5);
      ctx.lineTo(3 * h4 + 0.5, h4 + 0.5);
      ctx.stroke();
      break;
    case "left_diagonal_dash":
      ctx.moveTo(h4 + 0.5, h4 + 0.5);
      ctx.lineTo(3 * h4 + 0.5, 3 * h4 + 0.5);
      ctx.stroke();
      break;
    case "horizontal_wave":
      ctx.moveTo(0, h4);
      ctx.lineTo(h2, 3 * h4);
      ctx.lineTo(h, h4);
      ctx.stroke();
      break;
    case "vertical_wave":
      ctx.moveTo(h4, 0);
      ctx.lineTo(3 * h4, h2);
      ctx.lineTo(h4, h);
      ctx.stroke();
      break;
    case "criss_cross":
      _x(ctx, h);
      _horz(ctx, h, h2);
      _vert(ctx, h, h2);
      break;
    default:
      logger.warn(`unknown hatch pattern: ${hatch_pattern}`);
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/webgl_utils.js
function interleave(arr0, arr1, n, alt, out) {
  for (let i = 0; i < n; i++) {
    const v0 = arr0[i];
    const v1 = arr1[i];
    if (isFinite(v0 + v1)) {
      out[2 * i] = v0;
      out[2 * i + 1] = v1;
    } else {
      out[2 * i] = alt;
      out[2 * i + 1] = alt;
    }
  }
}
var cap_lookup = { butt: 0, round: 1, square: 2 };
var join_lookup = { miter: 0, round: 1, bevel: 2 };
var hatch_pattern_lookup = {
  blank: 0,
  dot: 1,
  ring: 2,
  horizontal_line: 3,
  vertical_line: 4,
  cross: 5,
  horizontal_dash: 6,
  vertical_dash: 7,
  spiral: 8,
  right_diagonal_line: 9,
  left_diagonal_line: 10,
  diagonal_cross: 11,
  right_diagonal_dash: 12,
  left_diagonal_dash: 13,
  horizontal_wave: 14,
  vertical_wave: 15,
  criss_cross: 16
};
function hatch_pattern_to_index(pattern) {
  return hatch_pattern_lookup[hatch_aliases[pattern] ?? pattern] ?? 0;
}
function marker_type_to_size_hint(marker_type) {
  switch (marker_type) {
    case "dash":
      return 1;
    case "dot":
      return 2;
    case "diamond":
    case "diamond_cross":
    case "diamond_dot":
      return 3;
    case "hex":
    case "hex_tile":
      return 4;
    case "square_pin":
      return 5;
    case "inverted_triangle":
    case "ngon":
    case "triangle":
    case "triangle_dot":
      return 6;
    case "triangle_pin":
      return 7;
    case "star":
    case "star_dot":
      return 8;
    default:
      return 0;
  }
}

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/buffer.js
var WrappedBuffer = class {
  constructor(regl_wrapper, elements_per_primitive = 1) {
    __publicField(this, "regl_wrapper");
    __publicField(this, "buffer");
    __publicField(this, "array");
    __publicField(this, "is_scalar");
    // Number of buffer elements per rendered primitive, e.g. for RGBA buffers this is 4
    // as a single color is 4 x uint8 = 32-bit in total.
    __publicField(this, "elements_per_primitive");
    this.regl_wrapper = regl_wrapper;
    this.is_scalar = true;
    this.elements_per_primitive = elements_per_primitive;
  }
  // Return array if already know it exists and is the correct length.
  get_array() {
    assert(this.array != null, "WrappedBuffer not yet initialised");
    return this.array;
  }
  // Return array of correct size, creating it if necessary.
  // Must call update() when finished setting the array values.
  get_sized_array(length) {
    if (this.array == null || this.array.length != length) {
      this.array = this.new_array(length);
    }
    return this.array;
  }
  is_normalized() {
    return false;
  }
  get length() {
    return this.array != null ? this.array.length : 0;
  }
  set_from_array(numbers) {
    const len = numbers.length;
    const array = this.get_sized_array(len);
    for (let i = 0; i < len; i++) {
      array[i] = numbers[i];
    }
    this.update();
  }
  set_from_prop(prop) {
    const len = prop.is_Scalar() ? 1 : prop.length;
    const array = this.get_sized_array(len);
    for (let i = 0; i < len; i++) {
      array[i] = prop.get(i);
    }
    this.update(prop.is_Scalar());
  }
  set_from_scalar(scalar) {
    this.get_sized_array(1).fill(scalar);
    this.update(true);
  }
  // Return a ReGL AttributeConfig that corresponds to one value for each glyph
  // or the same value for a number of glyphs.  A buffer passed to ReGL for
  // instanced rendering can be used for multiple rendering calls and the
  // important attributes for this are the offset (in bytes) into the buffer
  // and the divisor, which is the number of instances rendered before the
  // offset is advanced to the next buffer element.
  // to_attribute_config() is used for the common case of a single render call
  // per buffer with visual properties that are either scalar or vector.
  // Visual properties of scatter markers are an good example, and scalar_divisor
  // would be the number of markers rendered.
  to_attribute_config(offset = 0, scalar_divisor = 1) {
    return {
      buffer: this.buffer,
      divisor: this.is_scalar ? scalar_divisor : 1,
      normalized: this.is_normalized(),
      offset: offset * this.bytes_per_element()
    };
  }
  // to_attribute_config_nested() is used for the more complicated case in
  // which the vectorisation is nested, such as rendering multi_lines where
  // each visual property has a single buffer that is used multiple times, once
  // for each of the constituent lines.  Vector properties are therefore
  // constant for each constituent line (composed of multiple rendered
  // instances) but change between lines.
  to_attribute_config_nested(offset_vector = 0, divisor = 1) {
    return {
      buffer: this.buffer,
      divisor: divisor * this.elements_per_primitive,
      normalized: this.is_normalized(),
      offset: this.is_scalar ? 0 : offset_vector * this.bytes_per_element() * this.elements_per_primitive
    };
  }
  // Update ReGL buffer with data contained in array in preparation for passing
  // it to the GPU.  This function must be called after get_sized_array().
  update(is_scalar = false) {
    if (this.buffer == null) {
      this.buffer = this.regl_wrapper.buffer({
        usage: "dynamic",
        data: this.array
      });
    } else {
      this.buffer({ data: this.array });
    }
    this.is_scalar = is_scalar;
  }
};
__publicField(WrappedBuffer, "__name__", "WrappedBuffer");
var Float32Buffer = class extends WrappedBuffer {
  bytes_per_element() {
    return Float32Array.BYTES_PER_ELEMENT;
  }
  new_array(len) {
    return new Float32Array(len);
  }
};
__publicField(Float32Buffer, "__name__", "Float32Buffer");
var Uint8Buffer = class extends WrappedBuffer {
  bytes_per_element() {
    return Uint8Array.BYTES_PER_ELEMENT;
  }
  new_array(len) {
    return new Uint8Array(len);
  }
  set_from_color(color_prop, alpha_prop) {
    const is_scalar = color_prop.is_Scalar() && alpha_prop.is_Scalar();
    const ncolors = is_scalar ? 1 : color_prop.length;
    const array = this.get_sized_array(4 * ncolors);
    for (let i = 0; i < ncolors; i++) {
      const [r, g, b, a] = color2rgba(color_prop.get(i), alpha_prop.get(i));
      array[4 * i] = r;
      array[4 * i + 1] = g;
      array[4 * i + 2] = b;
      array[4 * i + 3] = a;
    }
    this.update(is_scalar);
  }
  set_from_hatch_pattern(hatch_pattern_prop) {
    const len = hatch_pattern_prop.is_Scalar() ? 1 : hatch_pattern_prop.length;
    const array = this.get_sized_array(len);
    for (let i = 0; i < len; i++) {
      array[i] = hatch_pattern_to_index(hatch_pattern_prop.get(i));
    }
    this.update(hatch_pattern_prop.is_Scalar());
  }
  set_from_line_cap(line_cap_prop) {
    const len = line_cap_prop.is_Scalar() ? 1 : line_cap_prop.length;
    const array = this.get_sized_array(len);
    for (let i = 0; i < len; i++) {
      array[i] = cap_lookup[line_cap_prop.get(i)];
    }
    this.update(line_cap_prop.is_Scalar());
  }
  set_from_line_join(line_join_prop) {
    const len = line_join_prop.is_Scalar() ? 1 : line_join_prop.length;
    const array = this.get_sized_array(len);
    for (let i = 0; i < len; i++) {
      array[i] = join_lookup[line_join_prop.get(i)];
    }
    this.update(line_join_prop.is_Scalar());
  }
};
__publicField(Uint8Buffer, "__name__", "Uint8Buffer");
var NormalizedUint8Buffer = class extends Uint8Buffer {
  is_normalized() {
    return true;
  }
};
__publicField(NormalizedUint8Buffer, "__name__", "NormalizedUint8Buffer");

// node_modules/@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/base.js
var BaseGLGlyph = class {
  constructor(regl_wrapper, glyph) {
    __publicField(this, "regl_wrapper");
    __publicField(this, "glyph");
    __publicField(this, "nvertices", 0);
    __publicField(this, "size_changed", false);
    __publicField(this, "data_changed", false);
    __publicField(this, "data_mapped", false);
    __publicField(this, "visuals_changed", false);
    this.regl_wrapper = regl_wrapper;
    this.glyph = glyph;
  }
  set_data_changed() {
    const { data_size } = this.glyph;
    if (data_size != this.nvertices) {
      this.nvertices = data_size;
      this.size_changed = true;
    }
    this.data_changed = true;
  }
  set_data_mapped() {
    this.data_mapped = true;
  }
  set_visuals_changed() {
    this.visuals_changed = true;
  }
  render(_ctx, indices, mainglyph) {
    if (indices.length == 0) {
      return;
    }
    const { width, height } = this.glyph.renderer.plot_view.canvas_view.webgl.canvas;
    const { pixel_ratio } = this.glyph.renderer.plot_view.canvas_view;
    const trans = {
      pixel_ratio,
      // Needed to scale antialiasing
      width: width / pixel_ratio,
      height: height / pixel_ratio
    };
    this.draw(indices, mainglyph, trans);
  }
};
__publicField(BaseGLGlyph, "__name__", "BaseGLGlyph");

export {
  version,
  is_undefined,
  is_defined,
  is_nullish,
  isBoolean,
  isNumber,
  isInteger,
  isString,
  isSymbol,
  isPrimitive,
  isFunction,
  isArray,
  isArrayOf,
  isArrayableOf,
  isTypedArray,
  isObject,
  isBasicObject,
  isPlainObject,
  isDict,
  isIterable,
  isArrayable,
  assert,
  unreachable,
  PI,
  sqrt,
  angle_between,
  atan2,
  compute_angle,
  invert_angle,
  to_radians_coeff,
  minmax,
  clamp,
  cycle,
  log,
  float,
  is_Floating,
  float32_epsilon,
  factorial,
  hermite,
  eval_poly,
  is_empty,
  prepend,
  index_of,
  includes,
  contains,
  mul,
  map,
  inplace_map,
  filter,
  reduce,
  sort_by,
  min,
  max,
  minmax2,
  min_by,
  max_by,
  sum,
  cumsum,
  every,
  some,
  find_index,
  find_last_index,
  find,
  find_last,
  bisect_right_by,
  bisect_right,
  sorted_index,
  bin_counts,
  interpolate,
  left_edge_index,
  head2 as head,
  last,
  copy2 as copy,
  concat,
  nth,
  zip,
  unzip,
  range,
  linspace,
  transpose,
  argmin,
  argmax,
  argsort,
  uniq,
  uniq_by,
  _union,
  union,
  intersection,
  difference,
  symmetric_difference,
  remove_at,
  remove,
  remove_by,
  clear,
  split,
  shuffle,
  pairwise,
  elementwise,
  reversed,
  repeat,
  resize,
  extend,
  to_object,
  keys,
  values,
  entries,
  typed_keys,
  typed_values,
  typed_entries,
  clone,
  merge,
  size,
  is_empty2,
  PlainObjectProxy,
  dict,
  logger,
  set_log_level,
  byte,
  transparent,
  encode_rgba,
  decode_rgba,
  color2rgba,
  rgba2css,
  color2css,
  color2hex,
  color2hexrgb,
  css4_parse,
  is_Color,
  is_dark,
  get_pattern,
  interleave,
  marker_type_to_size_hint,
  Float32Buffer,
  Uint8Buffer,
  NormalizedUint8Buffer,
  BaseGLGlyph
};
//# sourceMappingURL=chunk-FHOMUG4O.js.map
