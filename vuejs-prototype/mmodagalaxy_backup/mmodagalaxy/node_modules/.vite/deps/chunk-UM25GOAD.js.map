{
  "version": 3,
  "sources": ["../../@bokeh/bokehjs/build/js/lib/models/glyphs/webgl/image.js"],
  "sourcesContent": ["import { BaseGLGlyph } from \"./base\";\nimport { Float32Buffer } from \"./buffer\";\nimport { assert } from \"../../../core/util/assert\";\nexport class ImageGL extends BaseGLGlyph {\n    glyph;\n    static __name__ = \"ImageGL\";\n    // data properties\n    _tex = [];\n    _bounds = [];\n    // image_changed is separate from data_changed as it can occur through changed colormapping.\n    _image_changed = false;\n    constructor(regl_wrapper, glyph) {\n        super(regl_wrapper, glyph);\n        this.glyph = glyph;\n    }\n    draw(indices, main_glyph, transform) {\n        const main_gl_glyph = main_glyph.glglyph;\n        // The only visual property that can change is global_alpha and that is read on every render,\n        // so ignore this.visuals_changed\n        const data_changed_or_mapped = main_gl_glyph.data_changed || main_gl_glyph.data_mapped;\n        if (data_changed_or_mapped) {\n            // Handle change of location or bounds.\n            main_gl_glyph._set_data();\n        }\n        if (main_gl_glyph._image_changed || main_gl_glyph.data_changed) {\n            // Handle change of image itself. If _image_changed then image has definitely changed such as\n            // from a change of colormapping. If data_changed then image may have changed so update just\n            // in case. If we could identify what in the CDS has changed (e.g. image or x) then we would\n            // know whether to call _set_image or not.\n            main_gl_glyph._set_image();\n        }\n        main_gl_glyph.data_changed = false;\n        main_gl_glyph.data_mapped = false;\n        main_gl_glyph._image_changed = false;\n        const { global_alpha } = this.glyph.visuals.image;\n        for (const i of indices) {\n            if (main_gl_glyph._tex[i] == null || main_gl_glyph._bounds[i] == null) {\n                continue;\n            }\n            const props = {\n                scissor: this.regl_wrapper.scissor,\n                viewport: this.regl_wrapper.viewport,\n                canvas_size: [transform.width, transform.height],\n                bounds: main_gl_glyph._bounds[i],\n                tex: main_gl_glyph._tex[i],\n                global_alpha: global_alpha.get(i),\n            };\n            this.regl_wrapper.image()(props);\n        }\n    }\n    set_image_changed() {\n        this._image_changed = true;\n    }\n    _set_data() {\n        const { image } = this.glyph;\n        const nimage = image.length;\n        if (this._bounds.length != nimage) {\n            this._bounds = Array(nimage).fill(null);\n        }\n        for (let i = 0; i < nimage; i++) {\n            const { sx, sy, sdw: sw, sdh: sh, xy_anchor, xy_scale, xy_sign } = this.glyph;\n            const sx_i = sx[i];\n            const sy_i = sy[i];\n            const sw_i = sw[i];\n            const sh_i = sh[i];\n            if (!isFinite(sx_i + sy_i + sw_i + sh_i)) {\n                this._bounds[i] = null;\n                continue;\n            }\n            if (this._bounds[i] == null) {\n                this._bounds[i] = new Float32Buffer(this.regl_wrapper);\n            }\n            const bounds_array = this._bounds[i].get_sized_array(4);\n            bounds_array[0] = sx[i] + sw[i] * (0.5 * (1 - xy_scale.x) - xy_anchor.x) * xy_sign.x;\n            bounds_array[1] = sy[i] + sh[i] * (0.5 * (1 - xy_scale.y) - xy_anchor.y) * xy_sign.y;\n            bounds_array[2] = bounds_array[0] + sw[i] * xy_scale.x * xy_sign.x;\n            bounds_array[3] = bounds_array[1] + sh[i] * xy_scale.y * xy_sign.y;\n            this._bounds[i].update();\n        }\n    }\n    _set_image() {\n        const { image, image_data } = this.glyph;\n        const nimage = image.length;\n        assert(image_data != null);\n        if (this._tex.length != nimage) {\n            this._tex = Array(nimage).fill(null);\n        }\n        for (let i = 0; i < nimage; i++) {\n            const image_data_i = image_data[i];\n            if (image_data_i == null) {\n                this._tex[i] = null;\n                continue;\n            }\n            const tex_options = {\n                width: image_data_i.width,\n                height: image_data_i.height,\n                data: image_data_i,\n                format: \"rgba\",\n                type: \"uint8\",\n            };\n            if (this._tex[i] == null) {\n                this._tex[i] = this.regl_wrapper.texture(tex_options);\n            }\n            else {\n                this._tex[i](tex_options); // Reuse existing WebGL texture\n            }\n        }\n    }\n}\n//# sourceMappingURL=image.js.map"],
  "mappings": "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",
  "names": []
}
